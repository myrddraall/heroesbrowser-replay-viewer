/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "assets/replay-worker";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/webworker/worker.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@heroesbrowser/mpq/dist/data/headers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@heroesbrowser/mpq/dist/data/headers.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MPQUserDataHeader {
    constructor(data) {
        this.magic = data.toString('utf8', 0, 4);
        this.userDataSize = data.readUInt32LE(4);
        this.mpqHeaderOffset = data.readUInt32LE(8);
        this.userDataHeaderSize = data.readUInt32LE(12);
    }
}
exports.MPQUserDataHeader = MPQUserDataHeader;
class MPQFileHeader {
    constructor(data) {
        if (data) {
            this.magic = data.toString('utf8', 0, 4);
            this.headerSize = data.readUInt32LE(4);
            this.archiveSize = data.readUInt32LE(8);
            this.formatVersion = data.readUInt16LE(12);
            this.sectorSizeShift = data.readUInt16LE(14);
            this.hashTableOffset = data.readUInt32LE(16);
            this.blockTableOffset = data.readUInt32LE(20);
            this.hashTableEntries = data.readUInt32LE(24);
            this.blockTableEntries = data.readUInt32LE(28);
        }
    }
}
exports.MPQFileHeader = MPQFileHeader;
class MPQFileHeaderExt extends MPQFileHeader {
    constructor(data) {
        super(null);
        this.extendedBlockTableOffset = data.readIntLE(0, 8);
        this.hashTableOffsetHigh = data.readInt8(8);
        this.blockTableOffsetHigh = data.readInt8(10);
    }
}
exports.MPQFileHeaderExt = MPQFileHeaderExt;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGEvaGVhZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0lBT0ksWUFBbUIsSUFBWTtRQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7Q0FFSjtBQWRELDhDQWNDO0FBRUQ7SUFZSSxZQUFtQixJQUFZO1FBQzNCLElBQUksSUFBSSxFQUFFO1lBQ04sSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNsRDtJQUNMLENBQUM7Q0FDSjtBQXpCRCxzQ0F5QkM7QUFFRCxzQkFBOEIsU0FBUSxhQUFhO0lBSy9DLFlBQW1CLElBQVk7UUFDM0IsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELENBQUM7Q0FDSjtBQVhELDRDQVdDIiwiZmlsZSI6ImRhdGEvaGVhZGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgTVBRVXNlckRhdGFIZWFkZXIge1xyXG4gICAgcHVibGljIG1hZ2ljOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgdXNlckRhdGFTaXplOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgbXBxSGVhZGVyT2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdXNlckRhdGFIZWFkZXJTaXplOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgY29udGVudDogQnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLm1hZ2ljID0gZGF0YS50b1N0cmluZygndXRmOCcsIDAsIDQpO1xyXG4gICAgICAgIHRoaXMudXNlckRhdGFTaXplID0gZGF0YS5yZWFkVUludDMyTEUoNCk7XHJcbiAgICAgICAgdGhpcy5tcHFIZWFkZXJPZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRSg4KTtcclxuICAgICAgICB0aGlzLnVzZXJEYXRhSGVhZGVyU2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKDEyKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNUFFGaWxlSGVhZGVyIHtcclxuICAgIHB1YmxpYyBtYWdpYzogc3RyaW5nO1xyXG4gICAgcHVibGljIGhlYWRlclNpemU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhcmNoaXZlU2l6ZTogbnVtYmVyO1xyXG4gICAgcHVibGljIHNlY3RvclNpemVTaGlmdDogbnVtYmVyO1xyXG4gICAgcHVibGljIGhhc2hUYWJsZU9mZnNldDogbnVtYmVyO1xyXG4gICAgcHVibGljIGJsb2NrVGFibGVPZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBoYXNoVGFibGVFbnRyaWVzOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYmxvY2tUYWJsZUVudHJpZXM6IG51bWJlcjtcclxuICAgIHB1YmxpYyBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBmb3JtYXRWZXJzaW9uOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdXNlckRhdGFIZWFkZXI6IE1QUVVzZXJEYXRhSGVhZGVyO1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFnaWMgPSBkYXRhLnRvU3RyaW5nKCd1dGY4JywgMCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyU2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKDQpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY2hpdmVTaXplID0gZGF0YS5yZWFkVUludDMyTEUoOCk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0VmVyc2lvbiA9IGRhdGEucmVhZFVJbnQxNkxFKDEyKTtcclxuICAgICAgICAgICAgdGhpcy5zZWN0b3JTaXplU2hpZnQgPSBkYXRhLnJlYWRVSW50MTZMRSgxNCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzaFRhYmxlT2Zmc2V0ID0gZGF0YS5yZWFkVUludDMyTEUoMTYpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrVGFibGVPZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRSgyMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzaFRhYmxlRW50cmllcyA9IGRhdGEucmVhZFVJbnQzMkxFKDI0KTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja1RhYmxlRW50cmllcyA9IGRhdGEucmVhZFVJbnQzMkxFKDI4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNUFFGaWxlSGVhZGVyRXh0IGV4dGVuZHMgTVBRRmlsZUhlYWRlciB7XHJcbiAgICBwdWJsaWMgZXh0ZW5kZWRCbG9ja1RhYmxlT2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaGFzaFRhYmxlT2Zmc2V0SGlnaDogbnVtYmVyO1xyXG4gICAgcHVibGljIGJsb2NrVGFibGVPZmZzZXRIaWdoOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xyXG4gICAgICAgIHN1cGVyKG51bGwpO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kZWRCbG9ja1RhYmxlT2Zmc2V0ID0gZGF0YS5yZWFkSW50TEUoMCwgOCk7XHJcbiAgICAgICAgdGhpcy5oYXNoVGFibGVPZmZzZXRIaWdoID0gZGF0YS5yZWFkSW50OCg4KTtcclxuICAgICAgICB0aGlzLmJsb2NrVGFibGVPZmZzZXRIaWdoID0gZGF0YS5yZWFkSW50OCgxMCk7XHJcbiAgICB9XHJcbn1cclxuIl19


/***/ }),

/***/ "./node_modules/@heroesbrowser/mpq/dist/data/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@heroesbrowser/mpq/dist/data/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./headers */ "./node_modules/@heroesbrowser/mpq/dist/data/headers.js"));
__export(__webpack_require__(/*! ./tables */ "./node_modules/@heroesbrowser/mpq/dist/data/tables.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGEvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBMEI7QUFDMUIsOEJBQXlCIiwiZmlsZSI6ImRhdGEvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2hlYWRlcnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3RhYmxlcyc7XHJcbiJdfQ==


/***/ }),

/***/ "./node_modules/@heroesbrowser/mpq/dist/data/tables.js":
/*!*************************************************************!*\
  !*** ./node_modules/@heroesbrowser/mpq/dist/data/tables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MPQHashTableEntry {
    constructor(data) {
        this.hashA = data.readUInt32BE(0);
        this.hashB = data.readUInt32BE(4);
        this.locale = data.readUInt16BE(8);
        this.platform = data.readUInt16BE(10);
        this.blockTableIndex = data.readUInt32BE(12);
    }
}
exports.MPQHashTableEntry = MPQHashTableEntry;
class MPQBlockTableEntry {
    constructor(data) {
        this.offset = data.readUInt32BE(0);
        this.archivedSize = data.readUInt32BE(4);
        this.size = data.readUInt32BE(8);
        this.flags = data.readUInt32BE(12);
    }
}
exports.MPQBlockTableEntry = MPQBlockTableEntry;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGEvdGFibGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7SUFPSSxZQUFtQixJQUFZO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakQsQ0FBQztDQUNKO0FBZEQsOENBY0M7QUFFRDtJQUtJLFlBQW1CLElBQVk7UUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Q0FDSjtBQVhELGdEQVdDIiwiZmlsZSI6ImRhdGEvdGFibGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBNUFFIYXNoVGFibGVFbnRyeSB7XHJcbiAgICBwdWJsaWMgaGFzaEE6IG51bWJlcjtcclxuICAgIHB1YmxpYyBoYXNoQjogbnVtYmVyO1xyXG4gICAgcHVibGljIGxvY2FsZTogbnVtYmVyO1xyXG4gICAgcHVibGljIHBsYXRmb3JtOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYmxvY2tUYWJsZUluZGV4OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuaGFzaEEgPSBkYXRhLnJlYWRVSW50MzJCRSgwKTtcclxuICAgICAgICB0aGlzLmhhc2hCID0gZGF0YS5yZWFkVUludDMyQkUoNCk7XHJcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBkYXRhLnJlYWRVSW50MTZCRSg4KTtcclxuICAgICAgICB0aGlzLnBsYXRmb3JtID0gZGF0YS5yZWFkVUludDE2QkUoMTApO1xyXG4gICAgICAgIHRoaXMuYmxvY2tUYWJsZUluZGV4ID0gZGF0YS5yZWFkVUludDMyQkUoMTIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTVBRQmxvY2tUYWJsZUVudHJ5IHtcclxuICAgIHB1YmxpYyBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhcmNoaXZlZFNpemU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBzaXplOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgZmxhZ3M6IG51bWJlcjtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IGRhdGEucmVhZFVJbnQzMkJFKDApO1xyXG4gICAgICAgIHRoaXMuYXJjaGl2ZWRTaXplID0gZGF0YS5yZWFkVUludDMyQkUoNCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5yZWFkVUludDMyQkUoOCk7XHJcbiAgICAgICAgdGhpcy5mbGFncyA9IGRhdGEucmVhZFVJbnQzMkJFKDEyKTtcclxuICAgIH1cclxufVxyXG4iXX0=


/***/ }),

/***/ "./node_modules/@heroesbrowser/mpq/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@heroesbrowser/mpq/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./data */ "./node_modules/@heroesbrowser/mpq/dist/data/index.js"));
__export(__webpack_require__(/*! ./mpq */ "./node_modules/@heroesbrowser/mpq/dist/mpq.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsNEJBQXVCO0FBQ3ZCLDJCQUFzQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZGF0YSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vbXBxJzsiXX0=


/***/ }),

/***/ "./node_modules/@heroesbrowser/mpq/dist/mpq.js":
/*!*****************************************************!*\
  !*** ./node_modules/@heroesbrowser/mpq/dist/mpq.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**************************************************************
    This is a port of
    https://github.com/nexus-devtools/empeeku
    to typescript and modifies it to run in the browser

    https://github.com/nexus-devtools/empeeku is a fork of
    https://github.com/Farof/mpyqjs which is a port of
    https://github.com/eagleflo/mpyq
  
 ***************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-bitwise
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js");
const Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
const data_1 = __webpack_require__(/*! ./data */ "./node_modules/@heroesbrowser/mpq/dist/data/index.js");
const compress = __webpack_require__(/*! keybase-compressjs */ "./node_modules/keybase-compressjs/main2.js");
const hashTypes = {
    'TABLE_OFFSET': 0,
    'HASH_A': 1,
    'HASH_B': 2,
    'TABLE': 3
};
const MPQ_FILE_IMPLODE = 0x00000100;
const MPQ_FILE_COMPRESS = 0x00000200;
const MPQ_FILE_ENCRYPTED = 0x00010000;
const MPQ_FILE_FIX_KEY = 0x00020000;
const MPQ_FILE_SINGLE_UNIT = 0x01000000;
const MPQ_FILE_DELETE_MARKER = 0x02000000;
const MPQ_FILE_SECTOR_CRC = 0x04000000;
const MPQ_FILE_EXISTS = 0x80000000;
class MPQArchive {
    constructor(mpqData, listFiles = true) {
        this._encryptionTable = (function () {
            const table = {};
            let index;
            let seed = new Long.fromValue(0x00100001, true);
            for (let i = 0; i < 256; i++) {
                index = i;
                for (let j = 0; j < 5; j++) {
                    seed = seed.mul(125).add(3).mod(0x2AAAAB);
                    const t1 = seed.and(0xFFFF).shiftLeft(0x10);
                    seed = seed.mul(125).add(3).mod(0x2AAAAB);
                    const t2 = seed.and(0xFFFF);
                    table[index] = t1.or(t2).toNumber();
                    index += 0x100;
                }
            }
            return table;
        })();
        this._data = new buffer_1.Buffer(mpqData);
        this._header = this._readHeader();
        this._hashTable = this._readTable('hash');
        this._blockTable = this._readTable('block');
        if (listFiles) {
            const listFile = this.readFile('(listfile)');
            if (listFile) {
                this._files = listFile.toString('utf-8').trim().split('\r\n');
            }
        }
    }
    get files() {
        return this._files;
    }
    get header() {
        return this._header;
    }
    printHeaders() {
        console.info('MPQ archive header');
        console.info('------------------');
        for (const key in this._header) {
            if (key === 'userDataHeader') {
                continue;
            }
            console.info(key + ' - ' + this._header[key]);
        }
        if (this._header.userDataHeader) {
            console.info();
            console.info('MPQ user data header');
            console.info('--------------------');
            console.info();
            // tslint:disable-next-line:forin
            for (const key in this._header.userDataHeader) {
                console.info(key + ' - ' + this._header.userDataHeader[key]);
            }
            console.info();
        }
    }
    printHashTable() {
        console.info('MPQ archive hash table');
        console.info('----------------------');
        console.info('Hash A\t\tHash B\t\tLocl\tPlat\tBlockIdx');
        const format = [8, 8, 4, 4, 8];
        this._hashTable.forEach(entry => {
            console.info(Object.keys(entry).map((key, i) => {
                return this._formatWord(entry[key], format[i]);
            }).join('\t'));
        });
        console.info();
    }
    ;
    printBlockTable() {
        console.info('MPQ archive block table');
        console.info('-----------------------');
        console.info('Offset\t\tArchSize\tRealSize\tFlags');
        this._blockTable.forEach(entry => {
            console.info([
                this._formatWord(entry.offset, 8),
                this._leadingChar(entry.archivedSize, ' ', 8),
                this._leadingChar(entry.size, ' ', 8),
                this._formatWord(entry.flags, 8)
            ].join('\t'));
        });
        console.info();
    }
    ;
    readFile(filename, forceDecompress = false) {
        function decompress(data) {
            const compressionType = data.readUInt8(0);
            if (compressionType === 0) {
                return data;
            }
            else if (compressionType === 2) {
                throw new Error('Unsupported compression type "zlib".');
            }
            else if (compressionType === 16) {
                return new buffer_1.Buffer(compress.Bzip2.decompressFile(data.slice(1)));
            }
            else {
                throw new Error('Unsupported compression type.');
            }
        }
        const hashEntry = this._getHashTableEntry(filename);
        if (!hashEntry) {
            return null;
        }
        const blockEntry = this._blockTable[hashEntry.blockTableIndex];
        if (blockEntry.flags & MPQ_FILE_EXISTS) {
            if (blockEntry.archivedSize === 0) {
                return null;
            }
            const offset = blockEntry.offset + this._header.offset;
            let fileData = this._data.slice(offset, offset + blockEntry.archivedSize);
            if (blockEntry.flags & MPQ_FILE_ENCRYPTED) {
                throw new Error('Encryption is not supported yet');
            }
            if (!(blockEntry.flags & MPQ_FILE_SINGLE_UNIT)) {
                const sectorSize = 512 << this._header.sectorSizeShift;
                let sectors = Math.trunc(blockEntry.size / sectorSize) + 1;
                let crc;
                if (blockEntry.flags & MPQ_FILE_SECTOR_CRC) {
                    crc = true;
                    sectors += 1;
                }
                else {
                    crc = false;
                }
                const positions = [];
                for (let i = 0; i < (sectors + 1); i++) {
                    positions[i] = fileData.readUInt32LE(4 * i);
                }
                const ln = positions.length - (crc ? 2 : 1);
                let result = new buffer_1.Buffer(0);
                let sectorBytesLeft = blockEntry.size;
                for (let i = 0; i < ln; i++) {
                    let sector = fileData.slice(positions[i], positions[i + 1]);
                    if ((blockEntry.flags & MPQ_FILE_COMPRESS) && (forceDecompress || (sectorBytesLeft > sector.length))) {
                        sector = decompress(sector);
                    }
                    sectorBytesLeft -= sector.length;
                    result = buffer_1.Buffer.concat([result, sector]);
                }
                fileData = result;
            }
            else {
                if ((blockEntry.flags & MPQ_FILE_COMPRESS) && (forceDecompress || (blockEntry.size > blockEntry.archivedSize))) {
                    fileData = decompress(fileData);
                }
            }
            return fileData;
        }
    }
    _leadingChar(str, ch, ln, after = false) {
        str = '' + str;
        while (str.length < ln) {
            str = after ? str + ch : ch + str;
        }
        return str;
    }
    _formatWord(data, ln) {
        return this._leadingChar(data.toString(16).toUpperCase(), '0', ln);
    }
    _getHashTableEntry(filename) {
        const hashA = this._hash(filename, 'HASH_A');
        const hashB = this._hash(filename, 'HASH_B');
        for (const entry of this._hashTable) {
            if (entry.hashA === hashA && entry.hashB === hashB) {
                return entry;
            }
            ;
        }
        return undefined;
    }
    _readHeader() {
        let header;
        const head = this._data.toString('utf-8', 0, 4);
        if (head === 'MPQ\x1a') {
            header = this._readMPQHeader();
            header.offset = 0;
        }
        else if (head === 'MPQ\x1b') {
            const userDataHeader = this._readMPQUserDataHeader();
            header = this._readMPQHeader(userDataHeader.mpqHeaderOffset);
            header.offset = userDataHeader.mpqHeaderOffset;
            header.userDataHeader = userDataHeader;
        }
        else {
            throw new Error('Invalid MPQ file header');
        }
        return header;
    }
    _readMPQUserDataHeader() {
        const data = this._data.slice(0, 16);
        const header = new data_1.MPQUserDataHeader(data);
        header.content = this._data.slice(16, 16 + header.userDataHeaderSize);
        return header;
    }
    _readMPQHeader(offset = 0) {
        let data = this._data.slice(offset, offset + 32);
        let header = new data_1.MPQFileHeader(data);
        if (header.formatVersion === 1) {
            data = this._data.slice(offset + 32, offset + 32 + 12);
            header = Object.assign(new data_1.MPQFileHeaderExt(data), header);
        }
        return header;
    }
    _readTable(tableType) {
        let type;
        switch (tableType) {
            case 'hash':
                type = data_1.MPQHashTableEntry;
                break;
            case 'block':
                type = type = data_1.MPQBlockTableEntry;
                break;
        }
        const tableOffset = this._header[tableType + 'TableOffset'];
        const tableEntries = this._header[tableType + 'TableEntries'];
        const key = this._hash('(' + tableType + ' table)', 'TABLE');
        let data = this._data.slice(tableOffset + this._header.offset, tableOffset + this._header.offset + tableEntries * 16);
        data = this._decrypt(data, key);
        const entries = [];
        for (let i = 0; i < tableEntries; i++) {
            entries[i] = new type(data.slice(i * 16, i * 16 + 16));
        }
        return entries;
    }
    _hash(value, hashType) {
        let seed1 = new Long.fromValue(0x7FED7FED, true);
        let seed2 = new Long.fromValue(0xEEEEEEEE, true);
        let result;
        let ch;
        for (ch of value.toUpperCase()) {
            if (isNaN(parseInt(ch, 10))) {
                ch = ch.codePointAt(0);
            }
            result = new Long.fromValue(this._encryptionTable[(hashTypes[hashType] << 8) + ch], true);
            seed1 = result.xor(seed1.add(seed2)).and(0xFFFFFFFF);
            seed2 = seed1.add(seed2).add(ch).add(seed2.shiftLeft(5)).add(3).and(0xFFFFFFFF);
        }
        return seed1.toNumber();
    }
    _decrypt(data, key) {
        const result = new buffer_1.Buffer(data.length);
        const ln = data.length / 4;
        let seed1 = new Long.fromValue(key, true);
        let seed2 = new Long.fromValue(0xEEEEEEEE, true);
        for (let i = 0; i < ln; i++) {
            // tslint:disable-next-line:no-bitwise
            seed2 = seed2.add(this._encryptionTable[0x400 + (seed1 & 0xFF)]);
            seed2 = seed2.and(0xFFFFFFFF);
            let value = new Long.fromValue(data.readUInt32LE(i * 4), true);
            value = value.xor(seed1.add(seed2)).and(0xFFFFFFFF);
            seed1 = seed1.xor(-1).shiftLeft(0x15).add(0x11111111).or(seed1.shiftRight(0x0B));
            seed1 = seed1.and(0xFFFFFFFF);
            seed2 = value.add(seed2).add(seed2.shiftLeft(5)).add(3).and(0xFFFFFFFF);
            result.writeUInt32BE(value.toNumber(), i * 4);
        }
        return result;
    }
}
exports.MPQArchive = MPQArchive;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2pGLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzlCLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN4RSxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDakQ7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0NBQ0o7QUF0UkQsZ0NBc1JDIiwiZmlsZSI6Im1wcS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgVGhpcyBpcyBhIHBvcnQgb2YgIFxyXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL25leHVzLWRldnRvb2xzL2VtcGVla3UgXHJcbiAgICB0byB0eXBlc2NyaXB0IGFuZCBtb2RpZmllcyBpdCB0byBydW4gaW4gdGhlIGJyb3dzZXJcclxuXHJcbiAgICBodHRwczovL2dpdGh1Yi5jb20vbmV4dXMtZGV2dG9vbHMvZW1wZWVrdSBpcyBhIGZvcmsgb2YgXHJcbiAgICBodHRwczovL2dpdGh1Yi5jb20vRmFyb2YvbXB5cWpzIHdoaWNoIGlzIGEgcG9ydCBvZlxyXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2VhZ2xlZmxvL21weXFcclxuICBcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcclxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcclxuaW1wb3J0ICogYXMgTG9uZyBmcm9tICdsb25nJztcclxuaW1wb3J0IHsgTVBRVXNlckRhdGFIZWFkZXIsIE1QUUZpbGVIZWFkZXIsIE1QUUZpbGVIZWFkZXJFeHQsIE1QUUJsb2NrVGFibGVFbnRyeSwgTVBRSGFzaFRhYmxlRW50cnkgfSBmcm9tICcuL2RhdGEnO1xyXG5pbXBvcnQgKiBhcyBjb21wcmVzcyBmcm9tICdrZXliYXNlLWNvbXByZXNzanMnO1xyXG5cclxuY29uc3QgaGFzaFR5cGVzID0ge1xyXG4gICAgJ1RBQkxFX09GRlNFVCc6IDAsXHJcbiAgICAnSEFTSF9BJzogMSxcclxuICAgICdIQVNIX0InOiAyLFxyXG4gICAgJ1RBQkxFJzogM1xyXG59O1xyXG5cclxuY29uc3QgTVBRX0ZJTEVfSU1QTE9ERSA9IDB4MDAwMDAxMDA7XHJcbmNvbnN0IE1QUV9GSUxFX0NPTVBSRVNTID0gMHgwMDAwMDIwMDtcclxuY29uc3QgTVBRX0ZJTEVfRU5DUllQVEVEID0gMHgwMDAxMDAwMDtcclxuY29uc3QgTVBRX0ZJTEVfRklYX0tFWSA9IDB4MDAwMjAwMDA7XHJcbmNvbnN0IE1QUV9GSUxFX1NJTkdMRV9VTklUID0gMHgwMTAwMDAwMDtcclxuY29uc3QgTVBRX0ZJTEVfREVMRVRFX01BUktFUiA9IDB4MDIwMDAwMDA7XHJcbmNvbnN0IE1QUV9GSUxFX1NFQ1RPUl9DUkMgPSAweDA0MDAwMDAwO1xyXG5jb25zdCBNUFFfRklMRV9FWElTVFMgPSAweDgwMDAwMDAwO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1QUUFyY2hpdmUge1xyXG5cclxuICAgIHByaXZhdGUgX2RhdGE6IEJ1ZmZlcjtcclxuICAgIHByaXZhdGUgX2hlYWRlcjogTVBRRmlsZUhlYWRlcjtcclxuXHJcbiAgICBwcml2YXRlIF9oYXNoVGFibGU6IE1QUUhhc2hUYWJsZUVudHJ5W107XHJcbiAgICBwcml2YXRlIF9ibG9ja1RhYmxlOiBNUFFCbG9ja1RhYmxlRW50cnlbXTtcclxuXHJcbiAgICBwcml2YXRlIF9maWxlczogc3RyaW5nW107XHJcblxyXG4gICAgcHJpdmF0ZSBfZW5jcnlwdGlvblRhYmxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCB0YWJsZSA9IHt9O1xyXG4gICAgICAgIGxldCBpbmRleDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBzZWVkID0gbmV3IExvbmcuZnJvbVZhbHVlKDB4MDAxMDAwMDEsIHRydWUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgc2VlZCA9IHNlZWQubXVsKDEyNSkuYWRkKDMpLm1vZCgweDJBQUFBQik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0MSA9IHNlZWQuYW5kKDB4RkZGRikuc2hpZnRMZWZ0KDB4MTApO1xyXG4gICAgICAgICAgICAgICAgc2VlZCA9IHNlZWQubXVsKDEyNSkuYWRkKDMpLm1vZCgweDJBQUFBQik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0MiA9IHNlZWQuYW5kKDB4RkZGRik7XHJcbiAgICAgICAgICAgICAgICB0YWJsZVtpbmRleF0gPSB0MS5vcih0MikudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDB4MTAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFibGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHB1YmxpYyBnZXQgZmlsZXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGhlYWRlcigpOiBNUFFGaWxlSGVhZGVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihtcHFEYXRhOiBBcnJheUJ1ZmZlciwgbGlzdEZpbGVzID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgQnVmZmVyKG1wcURhdGEpO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHRoaXMuX3JlYWRIZWFkZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFzaFRhYmxlID0gdGhpcy5fcmVhZFRhYmxlKCdoYXNoJyk7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tUYWJsZSA9IHRoaXMuX3JlYWRUYWJsZSgnYmxvY2snKTtcclxuXHJcbiAgICAgICAgaWYgKGxpc3RGaWxlcykge1xyXG4gICAgICAgICAgICBjb25zdCBsaXN0RmlsZSA9IHRoaXMucmVhZEZpbGUoJyhsaXN0ZmlsZSknKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlcyA9IGxpc3RGaWxlLnRvU3RyaW5nKCd1dGYtOCcpLnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHByaW50SGVhZGVycygpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oJ01QUSBhcmNoaXZlIGhlYWRlcicpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tJyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5faGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd1c2VyRGF0YUhlYWRlcicpIHsgY29udGludWU7IH1cclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKGtleSArICcgLSAnICsgdGhpcy5faGVhZGVyW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5faGVhZGVyLnVzZXJEYXRhSGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ01QUSB1c2VyIGRhdGEgaGVhZGVyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKCk7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9oZWFkZXIudXNlckRhdGFIZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhrZXkgKyAnIC0gJyArIHRoaXMuX2hlYWRlci51c2VyRGF0YUhlYWRlcltrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHByaW50SGFzaFRhYmxlKCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnTVBRIGFyY2hpdmUgaGFzaCB0YWJsZScpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnSGFzaCBBXFx0XFx0SGFzaCBCXFx0XFx0TG9jbFxcdFBsYXRcXHRCbG9ja0lkeCcpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IFs4LCA4LCA0LCA0LCA4XTtcclxuICAgICAgICB0aGlzLl9oYXNoVGFibGUuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhPYmplY3Qua2V5cyhlbnRyeSkubWFwKChrZXksIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRXb3JkKGVudHJ5W2tleV0sIGZvcm1hdFtpXSk7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcdCcpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmluZm8oKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHByaW50QmxvY2tUYWJsZSgpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oJ01QUSBhcmNoaXZlIGJsb2NrIHRhYmxlJyk7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnT2Zmc2V0XFx0XFx0QXJjaFNpemVcXHRSZWFsU2l6ZVxcdEZsYWdzJyk7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tUYWJsZS5mb3JFYWNoKGVudHJ5ID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdFdvcmQoZW50cnkub2Zmc2V0LCA4KSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlYWRpbmdDaGFyKGVudHJ5LmFyY2hpdmVkU2l6ZSwgJyAnLCA4KSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlYWRpbmdDaGFyKGVudHJ5LnNpemUsICcgJywgOCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtYXRXb3JkKGVudHJ5LmZsYWdzLCA4KVxyXG4gICAgICAgICAgICBdLmpvaW4oJ1xcdCcpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmluZm8oKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlYWRGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGZvcmNlRGVjb21wcmVzcyA9IGZhbHNlKTogQnVmZmVyIHtcclxuICAgICAgICBmdW5jdGlvbiBkZWNvbXByZXNzKGRhdGE6IEJ1ZmZlcik6IEJ1ZmZlciB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzaW9uVHlwZSA9IGRhdGEucmVhZFVJbnQ4KDApO1xyXG4gICAgICAgICAgICBpZiAoY29tcHJlc3Npb25UeXBlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wcmVzc2lvblR5cGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gdHlwZSBcInpsaWJcIi4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wcmVzc2lvblR5cGUgPT09IDE2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihjb21wcmVzcy5CemlwMi5kZWNvbXByZXNzRmlsZShkYXRhLnNsaWNlKDEpKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbXByZXNzaW9uIHR5cGUuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGhhc2hFbnRyeSA9IHRoaXMuX2dldEhhc2hUYWJsZUVudHJ5KGZpbGVuYW1lKTtcclxuICAgICAgICBpZiAoIWhhc2hFbnRyeSkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgIGNvbnN0IGJsb2NrRW50cnkgPSB0aGlzLl9ibG9ja1RhYmxlW2hhc2hFbnRyeS5ibG9ja1RhYmxlSW5kZXhdO1xyXG4gICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfRVhJU1RTKSB7XHJcbiAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmFyY2hpdmVkU2l6ZSA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBibG9ja0VudHJ5Lm9mZnNldCArIHRoaXMuX2hlYWRlci5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMuX2RhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja0VudHJ5LmFyY2hpdmVkU2l6ZSk7XHJcbiAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfRU5DUllQVEVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfU0lOR0xFX1VOSVQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0b3JTaXplID0gNTEyIDw8IHRoaXMuX2hlYWRlci5zZWN0b3JTaXplU2hpZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdG9ycyA9IE1hdGgudHJ1bmMoYmxvY2tFbnRyeS5zaXplIC8gc2VjdG9yU2l6ZSkgKyAxO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNyYzogYm9vbGVhbjtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfU0VDVE9SX0NSQykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdG9ycyArPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjcmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc2VjdG9ycyArIDEpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaV0gPSBmaWxlRGF0YS5yZWFkVUludDMyTEUoNCAqIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbG4gPSBwb3NpdGlvbnMubGVuZ3RoIC0gKGNyYyA/IDIgOiAxKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgQnVmZmVyKDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3RvckJ5dGVzTGVmdCA9IGJsb2NrRW50cnkuc2l6ZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWN0b3IgPSBmaWxlRGF0YS5zbGljZShwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tFbnRyeS5mbGFncyAmIE1QUV9GSUxFX0NPTVBSRVNTKSAmJiAoZm9yY2VEZWNvbXByZXNzIHx8IChzZWN0b3JCeXRlc0xlZnQgPiBzZWN0b3IubGVuZ3RoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdG9yID0gZGVjb21wcmVzcyhzZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWN0b3JCeXRlc0xlZnQgLT0gc2VjdG9yLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtyZXN1bHQsIHNlY3Rvcl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsZURhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGJsb2NrRW50cnkuZmxhZ3MgJiBNUFFfRklMRV9DT01QUkVTUykgJiYgKGZvcmNlRGVjb21wcmVzcyB8fCAoYmxvY2tFbnRyeS5zaXplID4gYmxvY2tFbnRyeS5hcmNoaXZlZFNpemUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVEYXRhID0gZGVjb21wcmVzcyhmaWxlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sZWFkaW5nQ2hhcihzdHI6IHN0cmluZyB8IG51bWJlciwgY2g6IHN0cmluZywgbG46IG51bWJlciwgYWZ0ZXIgPSBmYWxzZSk6IHN0cmluZyB7XHJcbiAgICAgICAgc3RyID0gJycgKyBzdHI7XHJcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsbikge1xyXG4gICAgICAgICAgICBzdHIgPSBhZnRlciA/IHN0ciArIGNoIDogY2ggKyBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZm9ybWF0V29yZChkYXRhOiBudW1iZXIsIGxuOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFkaW5nQ2hhcihkYXRhLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0SGFzaFRhYmxlRW50cnkoZmlsZW5hbWU6IHN0cmluZyk6IE1QUUhhc2hUYWJsZUVudHJ5IHtcclxuICAgICAgICBjb25zdCBoYXNoQSA9IHRoaXMuX2hhc2goZmlsZW5hbWUsICdIQVNIX0EnKTtcclxuICAgICAgICBjb25zdCBoYXNoQiA9IHRoaXMuX2hhc2goZmlsZW5hbWUsICdIQVNIX0InKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuX2hhc2hUYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnkuaGFzaEEgPT09IGhhc2hBICYmIGVudHJ5Lmhhc2hCID09PSBoYXNoQikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3JlYWRIZWFkZXIoKTogTVBRRmlsZUhlYWRlciB7XHJcbiAgICAgICAgbGV0IGhlYWRlcjogTVBRRmlsZUhlYWRlcjtcclxuXHJcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2RhdGEudG9TdHJpbmcoJ3V0Zi04JywgMCwgNCk7XHJcbiAgICAgICAgaWYgKGhlYWQgPT09ICdNUFFcXHgxYScpIHtcclxuICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5fcmVhZE1QUUhlYWRlcigpO1xyXG4gICAgICAgICAgICBoZWFkZXIub2Zmc2V0ID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYgKGhlYWQgPT09ICdNUFFcXHgxYicpIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlckRhdGFIZWFkZXIgPSB0aGlzLl9yZWFkTVBRVXNlckRhdGFIZWFkZXIoKTtcclxuICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5fcmVhZE1QUUhlYWRlcih1c2VyRGF0YUhlYWRlci5tcHFIZWFkZXJPZmZzZXQpO1xyXG4gICAgICAgICAgICBoZWFkZXIub2Zmc2V0ID0gdXNlckRhdGFIZWFkZXIubXBxSGVhZGVyT2Zmc2V0O1xyXG4gICAgICAgICAgICBoZWFkZXIudXNlckRhdGFIZWFkZXIgPSB1c2VyRGF0YUhlYWRlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTVBRIGZpbGUgaGVhZGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcmVhZE1QUVVzZXJEYXRhSGVhZGVyKCk6IE1QUVVzZXJEYXRhSGVhZGVyIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZSgwLCAxNik7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IE1QUVVzZXJEYXRhSGVhZGVyKGRhdGEpO1xyXG4gICAgICAgIGhlYWRlci5jb250ZW50ID0gdGhpcy5fZGF0YS5zbGljZSgxNiwgMTYgKyBoZWFkZXIudXNlckRhdGFIZWFkZXJTaXplKTtcclxuICAgICAgICByZXR1cm4gaGVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3JlYWRNUFFIZWFkZXIob2Zmc2V0ID0gMCk6IE1QUUZpbGVIZWFkZXIge1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKTtcclxuICAgICAgICBsZXQgaGVhZGVyID0gbmV3IE1QUUZpbGVIZWFkZXIoZGF0YSk7XHJcbiAgICAgICAgaWYgKGhlYWRlci5mb3JtYXRWZXJzaW9uID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLnNsaWNlKG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIDEyKTtcclxuICAgICAgICAgICAgaGVhZGVyID0gPE1QUUZpbGVIZWFkZXI+T2JqZWN0LmFzc2lnbihuZXcgTVBRRmlsZUhlYWRlckV4dChkYXRhKSwgaGVhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9yZWFkVGFibGUodGFibGVUeXBlOiAnaGFzaCcpOiBNUFFIYXNoVGFibGVFbnRyeVtdO1xyXG4gICAgcHJpdmF0ZSBfcmVhZFRhYmxlKHRhYmxlVHlwZTogJ2Jsb2NrJyk6IE1QUUJsb2NrVGFibGVFbnRyeVtdO1xyXG4gICAgcHJpdmF0ZSBfcmVhZFRhYmxlKHRhYmxlVHlwZTogJ2hhc2gnIHwgJ2Jsb2NrJykge1xyXG4gICAgICAgIGxldCB0eXBlOiBhbnk7XHJcbiAgICAgICAgc3dpdGNoICh0YWJsZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnaGFzaCc6XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gTVBRSGFzaFRhYmxlRW50cnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgPSBNUFFCbG9ja1RhYmxlRW50cnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFibGVPZmZzZXQgPSB0aGlzLl9oZWFkZXJbdGFibGVUeXBlICsgJ1RhYmxlT2Zmc2V0J107XHJcbiAgICAgICAgY29uc3QgdGFibGVFbnRyaWVzID0gdGhpcy5faGVhZGVyW3RhYmxlVHlwZSArICdUYWJsZUVudHJpZXMnXTtcclxuXHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5faGFzaCgnKCcgKyB0YWJsZVR5cGUgKyAnIHRhYmxlKScsICdUQUJMRScpO1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZSh0YWJsZU9mZnNldCArIHRoaXMuX2hlYWRlci5vZmZzZXQsIHRhYmxlT2Zmc2V0ICsgdGhpcy5faGVhZGVyLm9mZnNldCArIHRhYmxlRW50cmllcyAqIDE2KTtcclxuICAgICAgICBkYXRhID0gdGhpcy5fZGVjcnlwdChkYXRhLCBrZXkpO1xyXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlRW50cmllczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBuZXcgdHlwZShkYXRhLnNsaWNlKGkgKiAxNiwgaSAqIDE2ICsgMTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfaGFzaCh2YWx1ZTogc3RyaW5nLCBoYXNoVHlwZTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgc2VlZDEgPSBuZXcgTG9uZy5mcm9tVmFsdWUoMHg3RkVEN0ZFRCwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IHNlZWQyID0gbmV3IExvbmcuZnJvbVZhbHVlKDB4RUVFRUVFRUUsIHRydWUpO1xyXG4gICAgICAgIGxldCByZXN1bHQ6IGFueTtcclxuICAgICAgICBsZXQgY2g6IGFueTtcclxuICAgICAgICBmb3IgKGNoIG9mIHZhbHVlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlSW50KGNoLCAxMCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjaCA9IGNoLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBMb25nLmZyb21WYWx1ZSh0aGlzLl9lbmNyeXB0aW9uVGFibGVbKGhhc2hUeXBlc1toYXNoVHlwZV0gPDwgOCkgKyBjaF0sIHRydWUpO1xyXG4gICAgICAgICAgICBzZWVkMSA9IHJlc3VsdC54b3Ioc2VlZDEuYWRkKHNlZWQyKSkuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICBzZWVkMiA9IHNlZWQxLmFkZChzZWVkMikuYWRkKGNoKS5hZGQoc2VlZDIuc2hpZnRMZWZ0KDUpKS5hZGQoMykuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlZWQxLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZGVjcnlwdChkYXRhOiBCdWZmZXIsIGtleTogbnVtYmVyKTogQnVmZmVyIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQnVmZmVyKGRhdGEubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBsbiA9IGRhdGEubGVuZ3RoIC8gNDtcclxuICAgICAgICBsZXQgc2VlZDEgPSBuZXcgTG9uZy5mcm9tVmFsdWUoa2V5LCB0cnVlKTtcclxuICAgICAgICBsZXQgc2VlZDIgPSBuZXcgTG9uZy5mcm9tVmFsdWUoMHhFRUVFRUVFRSwgdHJ1ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIHNlZWQyID0gc2VlZDIuYWRkKHRoaXMuX2VuY3J5cHRpb25UYWJsZVsweDQwMCArIChzZWVkMSAmIDB4RkYpXSk7XHJcbiAgICAgICAgICAgIHNlZWQyID0gc2VlZDIuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXcgTG9uZy5mcm9tVmFsdWUoZGF0YS5yZWFkVUludDMyTEUoaSAqIDQpLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS54b3Ioc2VlZDEuYWRkKHNlZWQyKSkuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICBzZWVkMSA9IHNlZWQxLnhvcigtMSkuc2hpZnRMZWZ0KDB4MTUpLmFkZCgweDExMTExMTExKS5vcihzZWVkMS5zaGlmdFJpZ2h0KDB4MEIpKTtcclxuICAgICAgICAgICAgc2VlZDEgPSBzZWVkMS5hbmQoMHhGRkZGRkZGRik7XHJcbiAgICAgICAgICAgIHNlZWQyID0gdmFsdWUuYWRkKHNlZWQyKS5hZGQoc2VlZDIuc2hpZnRMZWZ0KDUpKS5hZGQoMykuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICByZXN1bHQud3JpdGVVSW50MzJCRSh2YWx1ZS50b051bWJlcigpLCBpICogNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuIl19


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/charenc/charenc.js":
/*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),

/***/ "./node_modules/crypt/crypt.js":
/*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/keybase-compressjs/main2.js":
/*!**************************************************!*\
  !*** ./node_modules/keybase-compressjs/main2.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (typeof console.assert !== "function") { console.assert = function () {} };
exports.BWT = __webpack_require__(/*! ./outlib/BWT */ "./node_modules/keybase-compressjs/outlib/BWT.js");
exports.BWTC = __webpack_require__(/*! ./outlib/BWTC */ "./node_modules/keybase-compressjs/outlib/BWTC.js");
exports.BitStream = __webpack_require__(/*! ./outlib/BitStream */ "./node_modules/keybase-compressjs/outlib/BitStream.js");
exports.Bzip2 = __webpack_require__(/*! ./outlib/Bzip2 */ "./node_modules/keybase-compressjs/outlib/Bzip2.js");
exports.CRC32 = __webpack_require__(/*! ./outlib/CRC32 */ "./node_modules/keybase-compressjs/outlib/CRC32.js");
exports.Context1Model = __webpack_require__(/*! ./outlib/Context1Model */ "./node_modules/keybase-compressjs/outlib/Context1Model.js");
exports.DefSumModel = __webpack_require__(/*! ./outlib/DefSumModel */ "./node_modules/keybase-compressjs/outlib/DefSumModel.js");
exports.DeflateDistanceModel = __webpack_require__(/*! ./outlib/DeflateDistanceModel */ "./node_modules/keybase-compressjs/outlib/DeflateDistanceModel.js");
exports.Dmc = __webpack_require__(/*! ./outlib/Dmc */ "./node_modules/keybase-compressjs/outlib/Dmc.js");
exports.DummyRangeCoder = __webpack_require__(/*! ./outlib/DummyRangeCoder */ "./node_modules/keybase-compressjs/outlib/DummyRangeCoder.js");
exports.FenwickModel = __webpack_require__(/*! ./outlib/FenwickModel */ "./node_modules/keybase-compressjs/outlib/FenwickModel.js");
exports.Huffman = __webpack_require__(/*! ./outlib/Huffman */ "./node_modules/keybase-compressjs/outlib/Huffman.js");
exports.HuffmanAllocator = __webpack_require__(/*! ./outlib/HuffmanAllocator */ "./node_modules/keybase-compressjs/outlib/HuffmanAllocator.js");
exports.LogDistanceModel = __webpack_require__(/*! ./outlib/LogDistanceModel */ "./node_modules/keybase-compressjs/outlib/LogDistanceModel.js");
exports.Lzjb = __webpack_require__(/*! ./outlib/Lzjb */ "./node_modules/keybase-compressjs/outlib/Lzjb.js");
exports.LzjbR = __webpack_require__(/*! ./outlib/LzjbR */ "./node_modules/keybase-compressjs/outlib/LzjbR.js");
exports.Lzp3 = __webpack_require__(/*! ./outlib/Lzp3 */ "./node_modules/keybase-compressjs/outlib/Lzp3.js");
exports.MTFModel = __webpack_require__(/*! ./outlib/MTFModel */ "./node_modules/keybase-compressjs/outlib/MTFModel.js");
exports.NoModel = __webpack_require__(/*! ./outlib/NoModel */ "./node_modules/keybase-compressjs/outlib/NoModel.js");
exports.PPM = __webpack_require__(/*! ./outlib/PPM */ "./node_modules/keybase-compressjs/outlib/PPM.js");
exports.RangeCoder = __webpack_require__(/*! ./outlib/RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js");
exports.Simple = __webpack_require__(/*! ./outlib/Simple */ "./node_modules/keybase-compressjs/outlib/Simple.js");
exports.Stream = __webpack_require__(/*! ./outlib/Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js");
exports.Util = __webpack_require__(/*! ./outlib/Util */ "./node_modules/keybase-compressjs/outlib/Util.js");
exports.freeze = __webpack_require__(/*! ./outlib/freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js");


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/BWT.js":
/*!*******************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/BWT.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Burrows-Wheeler transform, computed with the Induced Sorting Suffix Array
 *  construction mechanism (sais).  Code is a port of:
 *    https://sites.google.com/site/yuta256/sais
 *  which is:
 *    Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.
 *  and licensed under an MIT/X11 license.  I generally looked at both
 *  the C and the Java implementations to guide my work.
 *
 * This JavaScript port is:
 *    Copyright (c) 2013 C. Scott Ananian
 * and licensed under GPLv2; see the README at the top level of this package.
 */
var libs = [
	__webpack_require__(/*! ./freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, Util) {
    var ASSERT = console.assert.bind(console);

    // we're dispensing with the "arbitrary alphabet" stuff of the source
    // and just using Uint8Arrays.

    /** Find the start or end of each bucket. */
    var getCounts = function(T, C, n, k) {
        var i;
        for (i = 0; i < k; i++) { C[i] = 0; }
        for (i = 0; i < n; i++) { C[T[i]]++; }
    };
    var getBuckets = function(C, B, k, end) {
        var i, sum = 0;
        if (end) {
            for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum; }
        } else {
            for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum - C[i]; }
        }
    };

    /** Sort all type LMS suffixes */
    var LMSsort = function(T, SA, C, B, n, k) {
        var b, i, j;
        var c0, c1;
        /* compute SAl */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, false); /* find starts of buckets */
        j = n - 1;
        b = B[c1 = T[j]];
        j--;
        SA[b++] = (T[j] < c1) ? ~j : j;
        for (i = 0; i < n; i++) {
            if ((j = SA[i]) > 0) {
                ASSERT(T[j] >= T[j+1]);
                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT(i < b);
                j--;
                SA[b++] = (T[j] < c1) ? ~j : j;
                SA[i] = 0;
            } else if (j < 0) {
                SA[i] = ~j;
            }
        }
        /* compute SAs */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, 1); /* find ends of buckets */
        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
            if ((j = SA[i]) > 0) {
                ASSERT(T[j] <= T[j+1]);
                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT(b <= i);
                j--;
                SA[--b] = (T[j] > c1) ? ~(j+1) : j;
                SA[i] = 0;
            }
        }
    };

    var LMSpostproc = function(T, SA, n, m) {
        var i, j, p, q, plen, qlen, name;
        var c0, c1;
        var diff;

        /* compact all the sorted substrings into the first m items of SA
         * 2*m must not be larger than n (provable) */
        ASSERT(n > 0);
        for (i = 0; (p = SA[i]) < 0; i++) { SA[i] = ~p; ASSERT((i+1) < n); }
        if (i < m) {
            for (j = i, i++; ; i++) {
                ASSERT(i < n);
                if ((p = SA[i]) < 0) {
                    SA[j++] = ~p; SA[i] = 0;
                    if (j === m) { break; }
                }
            }
        }

        /* store the length of all substrings */
        c0 = T[i = j = n - 1];
        do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );
        for (; i >= 0; ) {
            do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) <= c1) );
            if (i >= 0) {
                SA[m + ((i + 1) >>> 1)] = j - i; j = i + 1;
                do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );
            }
        }

        /* find the lexicographic names of all substrings */
        for (i = 0, name = 0, q = n, qlen = 0; i < m; i++) {
            p = SA[i]; plen = SA[m + (p >>> 1)]; diff = true;
            if ((plen === qlen) && ((q + plen) < n)) {
                for (j = 0; (j < plen) && (T[p + j] === T[q + j]); ) { j++; }
                if (j === plen) { diff = false; }
            }
            if (diff) { name++; q = p; qlen = plen; }
            SA[m + (p >>> 1)] = name;
        }

        return name;
    };

    /* compute SA and BWT */
    var induceSA = function(T, SA, C, B, n, k) {
        var b, i, j;
        var c0, c1;
        /* compute SAl */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, false); /* find starts of buckets */
        j = n - 1;
        b = B[c1 = T[j]];
        SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;
        for (i = 0; i < n; i++) {
            j = SA[i]; SA[i] = ~j;
            if (j > 0) {
                j--;
                ASSERT( T[j] >= T[j + 1] );
                if ((c0 = T[j]) !== c1) { B[c1]  = b; b = B[c1=c0]; }
                ASSERT( i < b );
                SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;
            }
        }
        /* compute SAs */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, true); /* find ends of buckets */
        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
            if ((j = SA[i]) > 0) {
                j--;
                ASSERT( T[j] <= T[j + 1] );
                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT( b <= i );
                SA[--b] = ((j === 0) || (T[j - 1] > c1)) ? ~j : j;
            } else {
                SA[i] = ~j;
            }
        }
    };

    var computeBWT = function(T, SA, C, B, n, k) {
        var b, i, j, pidx = -1;
        var c0, c1;
        /* compute SAl */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, false); /* find starts of buckets */
        j = n - 1;
        b = B[c1 = T[j]];
        SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;
        for (i = 0; i < n; i++) {
            if ((j=SA[i]) > 0) {
                j--;
                ASSERT( T[j] >= T[j+1] );
                SA[i] = ~(c0 = T[j]);
                if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT( i < b );
                SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;
            } else if (j !== 0) {
                SA[i] = ~j;
            }
        }
        /* compute SAs */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, true); /* find ends of buckets */
        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
            if ((j = SA[i]) > 0) {
                j--;
                ASSERT( T[j] <= T[j+1] );
                SA[i] = c0 = T[j];
                if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT( b <= i );
                SA[--b] = ((j > 0) && (T[j-1] > c1)) ? (~T[j-1]) : j;
            } else if (j !== 0) {
                SA[i] = ~j;
            } else {
                pidx = i;
            }
        }
        return pidx;
    };

    /* find the suffix array SA of T[0..n-1] in {0..k-1}^n
       use a working space (excluding T and SA) of at most 2n+O(1) for a
       constant alphabet */
    var SA_IS = function(T, SA, fs, n, k, isbwt) {
        var C, B, RA;
        var i, j, b, c, m, p, q, name, pidx = 0, newfs;
        var c0, c1;
        var flags = 0;

        // allocate temporary storage [CSA]
        if (k <= 256) {
            C = Util.makeS32Buffer(k);
            if (k <= fs) { B = SA.subarray(n + fs - k); flags = 1; }
            else { B = Util.makeS32Buffer(k); flags = 3; }
        } else if (k <= fs) {
            C = SA.subarray(n + fs - k);
            if (k <= (fs - k)) { B = SA.subarray(n + fs - k * 2); flags = 0; }
            else if (k <= 1024) { B = Util.makeS32Buffer(k); flags = 2; }
            else { B = C; flags = 8; }
        } else {
            C = B = Util.makeS32Buffer(k);
            flags = 4 | 8;
        }

        /* stage 1: reduce the problem by at least 1/2
           sort all the LMS-substrings */
        getCounts(T, C, n, k);
        getBuckets(C, B, k, true); /* find ends of buckets */
        for (i = 0; i < n; i++) { SA[i] = 0; }
        b = -1; i = n - 1; j = n; m = 0; c0 = T[n - 1];
        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
        for (; i >= 0 ;) {
            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));
            if ( i >= 0 ) {
                if ( b >= 0 ) { SA[b] = j; }
                b = --B[c1];
                j = i;
                ++m;
                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
            }
        }

        if (m > 1) {
            LMSsort(T, SA, C, B, n, k);
            name = LMSpostproc(T, SA, n, m);
        } else if (m === 1) {
            SA[b] = j + 1;
            name = 1;
        } else {
            name = 0;
        }

        /* stage 2: solve the reduced problem
           recurse if names are not yet unique */
        if(name < m) {
            if((flags & 4) !== 0) { C = null; B = null; }
            if((flags & 2) !== 0) { B = null; }
            newfs = (n + fs) - (m * 2);
            if((flags & (1 | 4 | 8)) === 0) {
                if((k + name) <= newfs) { newfs -= k; }
                else { flags |= 8; }
            }
            ASSERT( (n >>> 1) <= (newfs + m) );
            for (i = m + (n >>> 1) - 1, j = m * 2 + newfs - 1; m <= i; i--) {
                if(SA[i] !== 0) { SA[j--] = SA[i] - 1; }
            }
            RA = SA.subarray(m + newfs);
            SA_IS(RA, SA, newfs, m, name, false);
            RA = null;

            i = n - 1; j = m * 2 - 1; c0 = T[n - 1];
            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
            for (; i >= 0 ;) {
                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));
                if ( i >= 0 ) {
                    SA[j--] = i + 1;
                    do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
                }
            }

            for (i = 0; i < m; i++) { SA[i] = SA[m + SA[i]]; }
            if((flags & 4) !== 0) { C = B = Util.makeS32Buffer(k); }
            if((flags & 2) !== 0) { B = Util.makeS32Buffer(k); }
        }

        /* stage 3: induce the result for the original problem */
        if((flags & 8) !== 0) { getCounts(T, C, n, k); }
        /* put all left-most S characters into their buckets */
        if (m > 1) {
            getBuckets(C, B, k, true); /* find ends of buckets */
            i = m - 1; j = n; p = SA[m - 1]; c1 = T[p];
            do {
                q = B[c0 = c1];
                while (q < j) { SA[--j] = 0; }
                do {
                    SA[--j] = p;
                    if(--i < 0) { break; }
                    p = SA[i];
                } while((c1 = T[p]) === c0);
            } while (i >= 0 );
            while ( j > 0 ) { SA[--j] = 0; }
        }
        if (!isbwt) { induceSA(T, SA, C, B, n, k); }
        else { pidx = computeBWT(T, SA, C, B, n, k); }
        C = null; B = null;
        return pidx;
    };

    var BWT = Object.create(null);
    /** SA should be a Int32Array (signed!); T can be any typed array.
     *  alphabetSize is optional if T is an Uint8Array or Uint16Array. */
    BWT.suffixsort = function(T, SA, n, alphabetSize) {
        ASSERT( T && SA && T.length >= n && SA.length >= n );
        if (n <= 1) {
            if (n === 1) { SA[0] = 0; }
            return 0;
        }
        if (!alphabetSize) {
            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
            else throw new Error('Need to specify alphabetSize');
        }
        ASSERT( alphabetSize > 0 );
        if (T.BYTES_PER_ELEMENT) {
            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
        }
        return SA_IS(T, SA, 0, n, alphabetSize, false);
    };
    /** Burrows-Wheeler Transform.
        A should be Int32Array (signed!); T can be any typed array.
        U is the same type as T (it is used for output).
        alphabetSize is optional if T is an Uint8Array or Uint16Array.
        ASSUMES STRING IS TERMINATED WITH AN EOF CHARACTER.
    */
    BWT.bwtransform = function(T, U, A, n, alphabetSize) {
        var i, pidx;
        ASSERT( T && U && A );
        ASSERT( T.length >= n && U.length >= n && A.length >= n );
        if (n <= 1) {
            if (n === 1) { U[0] = T[0]; }
            return n;
        }
        if (!alphabetSize) {
            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
            else throw new Error('Need to specify alphabetSize');
        }
        ASSERT( alphabetSize > 0 );
        if (T.BYTES_PER_ELEMENT) {
            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
        }
        pidx = SA_IS(T, A, 0, n, alphabetSize, true);
        U[0] = T[n - 1];
        for (i = 0; i < pidx ; i++) { U[i + 1] = A[i]; }
        for (i += 1; i < n; i++) { U[i] = A[i]; }
        return pidx + 1;
    };
    /** Reverses transform above. (ASSUMED STRING IS TERMINATED WITH EOF.) */
    BWT.unbwtransform = function(T, U, LF, n, pidx) {
        var C = Util.makeU32Buffer(256);
        var i, t;
        for (i=0; i<256; i++) { C[i] = 0; }
        for (i=0; i<n; i++) { LF[i] = C[T[i]]++; }
        for (i=0, t=0; i<256; i++) { t += C[i]; C[i] = t - C[i]; }
        for (i=n-1, t=0; i>=0; i--) {
            t = LF[t] + C[U[i]=T[t]];
            t += (t<pidx) ? 1 : 0;
        }
        C = null;
    };

    /** Burrows-Wheeler Transform.
        A should be Int32Array (signed!); T can be any typed array.
        U is the same type as T (it is used for output).
        alphabetSize is optional if T is an Uint8Array or Uint16Array.
        ASSUMES STRING IS CYCLIC.
        (XXX: this is twice as inefficient as I'd like! [CSA])
    */
    BWT.bwtransform2 = function(T, U, n, alphabetSize) {
        var i, j, pidx = 0;
        ASSERT( T && U );
        ASSERT( T.length >= n && U.length >= n );
        if (n <= 1) {
            if (n === 1) { U[0] = T[0]; }
            return 0;
        }
        if (!alphabetSize) {
            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
            else throw new Error('Need to specify alphabetSize');
        }
        ASSERT( alphabetSize > 0 );
        if (T.BYTES_PER_ELEMENT) {
            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
        }
        // double length of T
        var TT;
        if (T.length >= n*2) {
            TT = T; // do it in place if possible
        } else if (alphabetSize <= 256) {
            TT = Util.makeU8Buffer(n*2);
        } else if (alphabetSize <= 65536) {
            TT = Util.makeU16Buffer(n*2);
        } else {
            TT = Util.makeU32Buffer(n*2);
        }
        if (TT!==T) {
            for (i=0; i<n; i++) { TT[i] = T[i]; }
        }
        for (i=0; i<n; i++) { TT[n+i] = TT[i]; }
        // sort doubled string
        var A = Util.makeS32Buffer(n*2);
        SA_IS(TT, A, 0, n*2, alphabetSize, false);
        for (i=0, j=0; i<2*n; i++) {
            var s = A[i];
            if (s < n) {
                if (s === 0) { pidx = j; }
                if (--s < 0) { s = n-1; }
                U[j++] = T[s];
            }
        }
        ASSERT(j===n);
        return pidx;
    };

    return freeze(BWT);
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/BWTC.js":
/*!********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/BWTC.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* A simple bzip-like BWT compressor with a range encoder; written as a
 * self-test of the BWT package. */
var libs = [
	__webpack_require__(/*! ./freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__(/*! ./BWT */ "./node_modules/keybase-compressjs/outlib/BWT.js"),
	__webpack_require__(/*! ./DefSumModel */ "./node_modules/keybase-compressjs/outlib/DefSumModel.js"),
	__webpack_require__(/*! ./FenwickModel */ "./node_modules/keybase-compressjs/outlib/FenwickModel.js"),
	__webpack_require__(/*! ./LogDistanceModel */ "./node_modules/keybase-compressjs/outlib/LogDistanceModel.js"),
	__webpack_require__(/*! ./NoModel */ "./node_modules/keybase-compressjs/outlib/NoModel.js"),
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, BWT, DefSumModel, FenwickModel, LogDistanceModel, NoModel, RangeCoder, Stream, Util) {
    var EOF = Stream.EOF;

    var F_PROB_MAX  = 0xFF00;
    var F_PROB_INCR = 0x0100;

    BWTC = Object.create(null);
    BWTC.MAGIC = "bwtc";
    BWTC.compressFile = Util.compressFileHelper(BWTC.MAGIC, function(input, output, size, props, finalByte) {
        var encoder = new RangeCoder(output);
        encoder.encodeStart(finalByte, 1);

        var blockSize = 9;
        if (typeof(props)==='number' && props >= 1 && props <= 9) {
            blockSize = props;
        }
        encoder.encodeByte(blockSize);
        var fast = (blockSize <= 5);
        blockSize *= 100000;

        var block = Util.makeU8Buffer(blockSize);
        var readBlock = function() {
            var pos;
            for (pos=0; pos < blockSize; ) {
                var ch = input.readByte();
                if (ch < 0) { break; }
                block[pos++] = ch;
            }
            return pos;
        };
        var U = Util.makeU8Buffer(blockSize);
        var A = Util.makeS32Buffer(blockSize);
        var M = Util.makeU8Buffer(256); // move to front array
        var bitModelFactory = NoModel.factory(encoder);
        var lenModel = new LogDistanceModel(blockSize, 0,
                                            bitModelFactory,
                                            bitModelFactory);
        var length, b, c, pidx, i, j;
        do {
            length = readBlock();
            if (length === 0) { break; }
            // indicate that there's another block comin'
            // and encode the length of the block if necessary
            if (length === block.length) {
                encoder.encodeFreq(1, 0, 3); // "full size block"
                b = block;
            } else {
                encoder.encodeFreq(1, 1, 3); // "short block"
                lenModel.encode(length);
                b = block.subarray(0, length);
            }
            pidx = BWT.bwtransform(b, U, A, length, 256);
            lenModel.encode(pidx); // starting index
            // encode the alphabet subset used
            var useTree = Util.makeU16Buffer(512);
            for (i=0; i<length; i++) {
                c = U[i];
                useTree[256+c] = 1;
            }
            for (i=255; i>0; i--) { // sum all the way up the tree
                useTree[i] = useTree[2*i] + useTree[2*i + 1];
            }
            useTree[0] = 1; // sentinel
            for (i=1; i<512; i++) {
                var parent = i>>>1;
                var full = 1 << (9-Util.fls(i));
                if (useTree[parent] === 0 || useTree[parent] === (full*2)) {
                    /* already known full/empty */
                } else if (i >= 256) {
                    encoder.encodeBit(useTree[i]); // leaf node
                } else {
                    var v = useTree[i];
                    v = (v===0) ? 0 : (v===full) ? 2 : 1;
                    encoder.encodeFreq(1, v, 3);
                }
            }
            // remap symbols to this subset
            var alphabetSize = 0;
            for (i=0; i<256; i++) {
                if (useTree[256+i]) { // symbol in use
                    M[alphabetSize++] = i;
                }
            }
            useTree = null;
            // MTF encoding of U
            for (i=0; i<length; i++) {
                c = U[i];
                for (j=0; j<alphabetSize; j++) {
                    if (M[j] === c) {
                        break;
                    }
                }
                console.assert(j<alphabetSize);
                U[i] = j;
                // move to front
                for (; j>0; j--) {
                    M[j] = M[j-1];
                }
                M[0] = c;
            }
            // RLE/range encoding
            var model = new FenwickModel(encoder, alphabetSize+1,
                                         F_PROB_MAX, F_PROB_INCR);
            if (fast) { model = new DefSumModel(encoder, alphabetSize+1); }
            var runLength = 0;
            var emitLastRun = function() {
                // binary encode runs of zeros
                while (runLength !== 0) {
                    if (runLength&1) {
                        model.encode(0); // RUNA
                        runLength-=1;
                    } else {
                        model.encode(1); // RUNB
                        runLength-=2;
                    }
                    runLength >>>= 1;
                }
            };
            for (i=0; i<length; i++) {
                c = U[i];
                if (c === 0) {
                    runLength++;
                } else {
                    emitLastRun();
                    model.encode(c+1);
                    // reset for next
                    runLength = 0;
                }
            }
            emitLastRun();
            // done with this block!
        } while (length === block.length);

        encoder.encodeFreq(1, 2, 3); // "no more blocks"
        encoder.encodeFinish();
    }, true);

    BWTC.decompressFile = Util.decompressFileHelper(BWTC.MAGIC, function(input, output, size) {
        var decoder = new RangeCoder(input);
        decoder.decodeStart(true/* already read the extra byte */);
        var blockSize = decoder.decodeByte();
        console.assert(blockSize >= 1 && blockSize <= 9);
        var fast = (blockSize <= 5);
        blockSize *= 100000;

        var block = Util.makeU8Buffer(blockSize);
        var U = Util.makeU8Buffer(blockSize);
        var A = Util.makeS32Buffer(blockSize);
        var M = Util.makeU8Buffer(256); // move to front array
        var bitModelFactory = NoModel.factory(decoder);
        var lenModel = new LogDistanceModel(blockSize, 0,
                                            bitModelFactory,
                                            bitModelFactory);
        var b, length, i, j, c;
        while (true) {
            var blockIndicator = decoder.decodeCulFreq(3);
            decoder.decodeUpdate(1, blockIndicator, 3);
            if (blockIndicator === 0) { // full-length block
                length = blockSize;
                b = block;
            } else if (blockIndicator === 1) { // short block
                length = lenModel.decode();
                b = block.subarray(0, length);
            } else if (blockIndicator === 2) { // all done, no more blocks
                break;
            }
            // read starting index for unBWT
            var pidx = lenModel.decode();
            // decode the alphabet subset used
            var useTree = Util.makeU16Buffer(512);
            useTree[0] = 1; // sentinel
            for (i=1; i<512; i++) {
                var parent = i>>>1;
                var full = 1 << (9-Util.fls(i));
                if (useTree[parent] === 0 || useTree[parent] === (full*2)) {
                    /* already known full/empty */
                    useTree[i] = useTree[parent] >>> 1;
                } else if (i >= 256) {
                    useTree[i] = decoder.decodeBit(); // leaf node
                } else {
                    var v = decoder.decodeCulFreq(3);
                    decoder.decodeUpdate(1, v, 3);
                    useTree[i] = (v===2) ? full : v;
                }
            }
            // remap symbols to this subset
            var alphabetSize = 0;
            for (i=0; i<256; i++) {
                if (useTree[256+i]) { // symbol in use
                    M[alphabetSize++] = i;
                }
            }
            useTree = null;
            // RLE/range decoding
            var model = new FenwickModel(decoder, alphabetSize+1,
                                         F_PROB_MAX, F_PROB_INCR);
            if (fast) { model = new DefSumModel(decoder, alphabetSize+1, true);}
            var val = 1; // repeat count
            for (i=0; i<length; ) {
                c = model.decode();
                if (c===0) {
                    for (j=0; j<val; j++) { b[i++] = 0; }
                    val *= 2;
                } else if (c===1) {
                    for (j=0; j<val; j++) { b[i++] = 0; b[i++] = 0; }
                    val *= 2;
                } else {
                    val = 1;
                    b[i++] = c-1;
                }
            }
            // MTF decode
            for (i=0; i<length; i++) {
                j = b[i];
                b[i] = c = M[j];
                // move to front
                for (; j>0; j--) {
                    M[j] = M[j-1];
                }
                M[0] = c;
            }
            // unBWT
            BWT.unbwtransform(block, U, A, length, pidx);
            // emit!
            output.write(U, 0, length);
        }
        decoder.decodeFinish();
    });

    return BWTC;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/BitStream.js":
/*!*************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/BitStream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. */
var libs = [
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js")
];
var body_fn = function (Stream) {

    var BitStream = function(stream) {
        (function() {
            var bufferByte = 0x100; // private var for readers
            this.readBit = function() {
                if ((bufferByte & 0xFF) === 0) {
                    var ch = stream.readByte();
                    if (ch === Stream.EOF) {
                        this._eof = true;
                        return ch; /* !!! */
                    }
                    bufferByte = (ch << 1) | 1;
                }
                var bit = (bufferByte & 0x100) ? 1 : 0;
                bufferByte <<= 1;
                return bit;
            };
            // seekable iff the provided stream is
            this.seekBit = function(pos) {
                var n_byte = pos >>> 3;
                var n_bit = pos - (n_byte*8);
                this.seek(n_byte);
                this._eof = false;
                this.readBits(n_bit);
            };
            this.tellBit = function() {
                var pos = stream.tell() * 8;
                var b = bufferByte;
                while ((b & 0xFF) !== 0) {
                    pos--;
                    b <<= 1;
                }
                return pos;
            };
            // implement byte stream interface as well.
            this.readByte = function() {
                if ((bufferByte & 0xFF) === 0) {
                    return stream.readByte();
                }
                return this.readBits(8);
            };
            this.seek = function(pos) {
                stream.seek(pos);
                bufferByte = 0x100;
            };
        }).call(this);
        (function() {
            var bufferByte = 1; // private var for writers
            this.writeBit = function(b) {
                bufferByte <<= 1;
                if (b) { bufferByte |= 1; }
                if (bufferByte & 0x100) {
                    stream.writeByte(bufferByte & 0xFF);
                    bufferByte = 1;
                }
            };
            // implement byte stream interface as well
            this.writeByte = function(_byte) {
                if (bufferByte===1) {
                    stream.writeByte(_byte);
                } else {
                    stream.writeBits(8, _byte);
                }
            };
            this.flush = function() {
                while (bufferByte !== 1) {
                    this.writeBit(0);
                }
                if (stream.flush) { stream.flush(); }
            };
        }).call(this);
    };
    // inherit read/write methods from Stream.
    BitStream.EOF = Stream.EOF;
    BitStream.prototype = Object.create(Stream.prototype);
    // bit chunk read/write
    BitStream.prototype.readBits = function(n) {
        var i, r = 0, b;
        if (n > 31) {
            r = this.readBits(n-16)*0x10000; // fp multiply, not shift
            return r + this.readBits(16);
        }
        for (i = 0; i < n; i++) {
            r <<= 1; // this could make a negative value if n>31
            // bits read past EOF are all zeros!
            if (this.readBit() > 0) { r++; }
        }
        return r;
    };
    BitStream.prototype.writeBits = function(n, value) {
        if (n > 32) {
            var low = (value & 0xFFFF);
            var high = (value - low) / (0x10000); // fp division, not shift
            this.writeBits(n-16, high);
            this.writeBits(16, low);
            return;
        }
        var i;
        for (i = n-1; i >= 0; i--) {
            this.writeBit( (value >>> i) & 1 );
        }
    };

    return BitStream;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Bzip2.js":
/*!*********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Bzip2.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
An implementation of Bzip2 de/compression, including the ability to
seek within bzip2 data.

Copyright (C) 2013 C. Scott Ananian
Copyright (C) 2012 Eli Skeggs
Copyright (C) 2011 Kevin Kwok

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, see
http://www.gnu.org/licenses/lgpl-2.1.html

Adapted from node-bzip, copyright 2012 Eli Skeggs.
Adapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.

BWT implementation based on work by Yuta Mori; see BWT.js for details.

bzip2 compression code inspired by https://code.google.com/p/jbzip2
*/
var libs = [
	__webpack_require__(/*! ./freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__(/*! ./BitStream */ "./node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__(/*! ./BWT */ "./node_modules/keybase-compressjs/outlib/BWT.js"),
	__webpack_require__(/*! ./CRC32 */ "./node_modules/keybase-compressjs/outlib/CRC32.js"),
	__webpack_require__(/*! ./HuffmanAllocator */ "./node_modules/keybase-compressjs/outlib/HuffmanAllocator.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, BitStream, BWT, CRC32, HuffmanAllocator, Stream, Util) {

var MAX_HUFCODE_BITS = 20;
var MAX_SYMBOLS = 258;
var SYMBOL_RUNA = 0;
var SYMBOL_RUNB = 1;
var MIN_GROUPS = 2;
var MAX_GROUPS = 6;
var GROUP_SIZE = 50;

var WHOLEPI = 0x314159265359; // 48-bit integer
var SQRTPI =  0x177245385090; // 48-bit integer

var EOF = Stream.EOF;

var mtf = function(array, index) {
  var src = array[index], i;
  for (i = index; i > 0; i--) {
    array[i] = array[i-1];
  }
  array[0] = src;
  return src;
};

var Err = {
  OK: 0,
  LAST_BLOCK: -1,
  NOT_BZIP_DATA: -2,
  UNEXPECTED_INPUT_EOF: -3,
  UNEXPECTED_OUTPUT_EOF: -4,
  DATA_ERROR: -5,
  OUT_OF_MEMORY: -6,
  OBSOLETE_INPUT: -7,
  END_OF_BLOCK: -8
};
var ErrorMessages = {};
ErrorMessages[Err.LAST_BLOCK] =            "Bad file checksum";
ErrorMessages[Err.NOT_BZIP_DATA] =         "Not bzip data";
ErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  "Unexpected input EOF";
ErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
ErrorMessages[Err.DATA_ERROR] =            "Data error";
ErrorMessages[Err.OUT_OF_MEMORY] =         "Out of memory";
ErrorMessages[Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";

var _throw = function(status, optDetail) {
  var msg = ErrorMessages[status] || 'unknown error';
  if (optDetail) { msg += ': '+optDetail; }
  var e = new TypeError(msg);
  e.errorCode = status;
  throw e;
};

var Bunzip = function(inputStream, outputStream) {
  this.writePos = this.writeCurrent = this.writeCount = 0;

  this._start_bunzip(inputStream, outputStream);
};
Bunzip.prototype._init_block = function() {
  var moreBlocks = this._get_next_block();
  if ( !moreBlocks ) {
    this.writeCount = -1;
    return false; /* no more blocks */
  }
  this.blockCRC = new CRC32();
  return true;
};
/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */
Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
  /* Ensure that file starts with "BZh['1'-'9']." */
  var buf = Util.makeU8Buffer(4);
  if (inputStream.read(buf, 0, 4) !== 4 ||
      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')
    _throw(Err.NOT_BZIP_DATA, 'bad magic');

  var level = buf[3] - 0x30;
  if (level < 1 || level > 9)
    _throw(Err.NOT_BZIP_DATA, 'level out of range');

  this.reader = new BitStream(inputStream);

  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of
     uncompressed data.  Allocate intermediate buffer for block. */
  this.dbufSize = 100000 * level;
  this.nextoutput = 0;
  this.outputStream = outputStream;
  this.streamCRC = 0;
};
Bunzip.prototype._get_next_block = function() {
  var i, j, k;
  var reader = this.reader;
  // this is get_next_block() function from micro-bunzip:
  /* Read in header signature and CRC, then validate signature.
     (last block signature means CRC is for whole file, return now) */
  var h = reader.readBits(48);
  if (h === SQRTPI) { // last block
    return false; /* no more blocks */
  }
  if (h !== WHOLEPI)
    _throw(Err.NOT_BZIP_DATA);
  this.targetBlockCRC = reader.readBits(32);
  this.streamCRC = (this.targetBlockCRC ^
                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;
  /* We can add support for blockRandomised if anybody complains.  There was
     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that
     it didn't actually work. */
  if (reader.readBits(1))
    _throw(Err.OBSOLETE_INPUT);
  var origPointer = reader.readBits(24);
  if (origPointer > this.dbufSize)
    _throw(Err.DATA_ERROR, 'initial position out of bounds');
  /* mapping table: if some byte values are never used (encoding things
     like ASCII text), the compression code removes the gaps to have fewer
     symbols to deal with, and writes a sparse bitfield indicating which
     values were present.  We make a translation table to convert the symbols
     back to the corresponding bytes. */
  var t = reader.readBits(16);
  var symToByte = Util.makeU8Buffer(256), symTotal = 0;
  for (i = 0; i < 16; i++) {
    if (t & (1 << (0xF - i))) {
      var o = i * 16;
      k = reader.readBits(16);
      for (j = 0; j < 16; j++)
        if (k & (1 << (0xF - j)))
          symToByte[symTotal++] = o + j;
    }
  }

  /* How many different Huffman coding groups does this block use? */
  var groupCount = reader.readBits(3);
  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)
    _throw(Err.DATA_ERROR);
  /* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding
     group.  Read in the group selector list, which is stored as MTF encoded
     bit runs.  (MTF=Move To Front, as each value is used it's moved to the
     start of the list.) */
  var nSelectors = reader.readBits(15);
  if (nSelectors === 0)
    _throw(Err.DATA_ERROR);

  var mtfSymbol = Util.makeU8Buffer(256);
  for (i = 0; i < groupCount; i++)
    mtfSymbol[i] = i;

  var selectors = Util.makeU8Buffer(nSelectors); // was 32768...

  for (i = 0; i < nSelectors; i++) {
    /* Get next value */
    for (j = 0; reader.readBits(1); j++)
      if (j >= groupCount) _throw(Err.DATA_ERROR);
    /* Decode MTF to get the next selector */
    selectors[i] = mtf(mtfSymbol, j);
  }

  /* Read the Huffman coding tables for each group, which code for symTotal
     literal symbols, plus two run symbols (RUNA, RUNB) */
  var symCount = symTotal + 2;
  var groups = [], hufGroup;
  for (j = 0; j < groupCount; j++) {
    var length = Util.makeU8Buffer(symCount), temp = Util.makeU8Buffer(MAX_HUFCODE_BITS + 1);
    /* Read Huffman code lengths for each symbol.  They're stored in
       a way similar to MTF; record a starting value for the first symbol,
       and an offset from the previous value for every symbol after that. */
    t = reader.readBits(5); // lengths
    for (i = 0; i < symCount; i++) {
      for (;;) {
        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);
        /* If first bit is 0, stop.  Else second bit indicates whether
           to increment or decrement the value. */
        if(!reader.readBits(1))
          break;
        if(!reader.readBits(1))
          t++;
        else
          t--;
      }
      length[i] = t;
    }

    /* Find largest and smallest lengths in this group */
    var minLen,  maxLen;
    minLen = maxLen = length[0];
    for (i = 1; i < symCount; i++) {
      if (length[i] > maxLen)
        maxLen = length[i];
      else if (length[i] < minLen)
        minLen = length[i];
    }

    /* Calculate permute[], base[], and limit[] tables from length[].
     *
     * permute[] is the lookup table for converting Huffman coded symbols
     * into decoded symbols.  base[] is the amount to subtract from the
     * value of a Huffman symbol of a given length when using permute[].
     *
     * limit[] indicates the largest numerical value a symbol with a given
     * number of bits can have.  This is how the Huffman codes can vary in
     * length: each code with a value>limit[length] needs another bit.
     */
    hufGroup = {};
    groups.push(hufGroup);
    hufGroup.permute = Util.makeU16Buffer(MAX_SYMBOLS);
    hufGroup.limit = Util.makeU32Buffer(MAX_HUFCODE_BITS + 2);
    hufGroup.base = Util.makeU32Buffer(MAX_HUFCODE_BITS + 1);
    hufGroup.minLen = minLen;
    hufGroup.maxLen = maxLen;
    /* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */
    var pp = 0;
    for (i = minLen; i <= maxLen; i++) {
      temp[i] = hufGroup.limit[i] = 0;
      for (t = 0; t < symCount; t++)
        if (length[t] === i)
          hufGroup.permute[pp++] = t;
    }
    /* Count symbols coded for at each bit length */
    for (i = 0; i < symCount; i++)
      temp[length[i]]++;
    /* Calculate limit[] (the largest symbol-coding value at each bit
     * length, which is (previous limit<<1)+symbols at this level), and
     * base[] (number of symbols to ignore at each bit length, which is
     * limit minus the cumulative count of symbols coded for already). */
    pp = t = 0;
    for (i = minLen; i < maxLen; i++) {
      pp += temp[i];
      /* We read the largest possible symbol size and then unget bits
         after determining how many we need, and those extra bits could
         be set to anything.  (They're noise from future symbols.)  At
         each level we're really only interested in the first few bits,
         so here we set all the trailing to-be-ignored bits to 1 so they
         don't affect the value>limit[length] comparison. */
      hufGroup.limit[i] = pp - 1;
      pp <<= 1;
      t += temp[i];
      hufGroup.base[i + 1] = pp - t;
    }
    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinel value for reading next sym. */
    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
    hufGroup.base[minLen] = 0;
  }
  /* We've finished reading and digesting the block header.  Now read this
     block's Huffman coded symbols from the file and undo the Huffman coding
     and run length encoding, saving the result into dbuf[dbufCount++]=uc */

  /* Initialize symbol occurrence counters and symbol Move To Front table */
  var byteCount = Util.makeU32Buffer(256);
  for (i = 0; i < 256; i++)
    mtfSymbol[i] = i;
  /* Loop through compressed symbols. */
  var runPos = 0, dbufCount = 0, selector = 0, uc;
  var dbuf = this.dbuf = Util.makeU32Buffer(this.dbufSize);
  symCount = 0;
  for (;;) {
    /* Determine which Huffman coding group to use. */
    if (!(symCount--)) {
      symCount = GROUP_SIZE - 1;
      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }
      hufGroup = groups[selectors[selector++]];
    }
    /* Read next Huffman-coded symbol. */
    i = hufGroup.minLen;
    j = reader.readBits(i);
    for (;;i++) {
      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }
      if (j <= hufGroup.limit[i])
        break;
      j = (j << 1) | reader.readBits(1);
    }
    /* Huffman decode value to get nextSym (with bounds checking) */
    j -= hufGroup.base[i];
    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }
    var nextSym = hufGroup.permute[j];
    /* We have now decoded the symbol, which indicates either a new literal
       byte, or a repeated run of the most recent literal byte.  First,
       check if nextSym indicates a repeated run, and if so loop collecting
       how many times to repeat the last literal. */
    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {
      /* If this is the start of a new run, zero out counter */
      if (!runPos){
        runPos = 1;
        t = 0;
      }
      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at
         each bit position, add 1 or 2 instead.  For example,
         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.
         You can make any bit pattern that way using 1 less symbol than
         the basic or 0/1 method (except all bits 0, which would use no
         symbols, but a run of length 0 doesn't mean anything in this
         context).  Thus space is saved. */
      if (nextSym === SYMBOL_RUNA)
        t += runPos;
      else
        t += 2 * runPos;
      runPos <<= 1;
      continue;
    }
    /* When we hit the first non-run symbol after a run, we now know
       how many times to repeat the last literal, so append that many
       copies to our buffer of decoded symbols (dbuf) now.  (The last
       literal used is the one at the head of the mtfSymbol array.) */
    if (runPos){
      runPos = 0;
      if (dbufCount + t >= this.dbufSize) { _throw(Err.DATA_ERROR); }
      uc = symToByte[mtfSymbol[0]];
      byteCount[uc] += t;
      while (t--)
        dbuf[dbufCount++] = uc;
    }
    /* Is this the terminating symbol? */
    if (nextSym > symTotal)
      break;
    /* At this point, nextSym indicates a new literal character.  Subtract
       one to get the position in the MTF array at which this literal is
       currently to be found.  (Note that the result can't be -1 or 0,
       because 0 and 1 are RUNA and RUNB.  But another instance of the
       first symbol in the MTF array, position 0, would have been handled
       as part of a run above.  Therefore 1 unused MTF position minus
       2 non-literal nextSym values equals -1.) */
    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }
    i = nextSym - 1;
    uc = mtf(mtfSymbol, i);
    uc = symToByte[uc];
    /* We have our literal byte.  Save it into dbuf. */
    byteCount[uc]++;
    dbuf[dbufCount++] = uc;
  }
  /* At this point, we've read all the Huffman-coded symbols (and repeated
     runs) for this block from the input stream, and decoded them into the
     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].
     Now undo the Burrows-Wheeler transform on dbuf.
     See http://dogma.net/markn/articles/bwt/bwt.htm
  */
  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }
  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */
  j = 0;
  for (i = 0; i < 256; i++) {
    k = j + byteCount[i];
    byteCount[i] = j;
    j = k;
  }
  /* Figure out what order dbuf would be in if we sorted it. */
  for (i = 0; i < dbufCount; i++) {
    uc = dbuf[i] & 0xff;
    dbuf[byteCount[uc]] |= (i << 8);
    byteCount[uc]++;
  }
  /* Decode first byte by hand to initialize "previous" byte.  Note that it
     doesn't get output, and if the first three characters are identical
     it doesn't qualify as a run (hence writeRunCountdown=5). */
  var pos = 0, current = 0, run = 0;
  if (dbufCount) {
    pos = dbuf[origPointer];
    current = (pos & 0xff);
    pos >>= 8;
    run = -1;
  }
  this.writePos = pos;
  this.writeCurrent = current;
  this.writeCount = dbufCount;
  this.writeRun = run;

  return true; /* more blocks to come */
};
/* Undo burrows-wheeler transform on intermediate buffer to produce output.
   If start_bunzip was initialized with out_fd=-1, then up to len bytes of
   data are written to outbuf.  Return value is number of bytes written or
   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len
   are ignored, data is written to out_fd and return is RETVAL_OK or error.
*/
Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
    var copies, previous, outbyte;
    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully
       decoded, which results in this returning RETVAL_LAST_BLOCK, also
       equal to -1... Confusing, I'm returning 0 here to indicate no
       bytes written into the buffer */
  if (this.writeCount < 0) { return 0; }

  var gotcount = 0;
  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
  var dbufCount = this.writeCount, outputsize = this.outputsize;
  var run = this.writeRun;

  while (dbufCount) {
    dbufCount--;
    previous = current;
    pos = dbuf[pos];
    current = pos & 0xff;
    pos >>= 8;
    if (run++ === 3){
      copies = current;
      outbyte = previous;
      current = -1;
    } else {
      copies = 1;
      outbyte = current;
    }
    this.blockCRC.updateCRCRun(outbyte, copies);
    while (copies--) {
      this.outputStream.writeByte(outbyte);
      this.nextoutput++;
    }
    if (current != previous)
      run = 0;
  }
  this.writeCount = dbufCount;
  // check CRC
  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {
    _throw(Err.DATA_ERROR, "Bad block CRC "+
           "(got "+this.blockCRC.getCRC().toString(16)+
           " expected "+this.targetBlockCRC.toString(16)+")");
  }
  return this.nextoutput;
};

/* Static helper functions */
Bunzip.Err = Err;
// 'input' can be a stream or a buffer
// 'output' can be a stream or a buffer or a number (buffer size)
Bunzip.decode = function(input, output, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;

  var bz = new Bunzip(inputStream, outputStream);
  while (true) {
    if ('eof' in inputStream && inputStream.eof()) break;
    if (bz._init_block()) {
      bz._read_bunzip();
    } else {
      var targetStreamCRC = bz.reader.readBits(32);
      if (targetStreamCRC !== bz.streamCRC) {
        _throw(Err.DATA_ERROR, "Bad stream CRC "+
               "(got "+bz.streamCRC.toString(16)+
               " expected "+targetStreamCRC.toString(16)+")");
      }
      if (multistream &&
          'eof' in inputStream &&
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
      } else break;
    }
  }
  return o.retval;
};
Bunzip.decodeBlock = function(input, pos, output) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;
  var bz = new Bunzip(inputStream, outputStream);
  bz.reader.seekBit(pos);
  /* Fill the decode buffer for the block */
  var moreBlocks = bz._get_next_block();
  if (moreBlocks) {
    /* Init the CRC for writing */
    bz.blockCRC = new CRC32();

    /* Zero this so the current byte from before the seek is not written */
    bz.writeCopies = 0;

    /* Decompress the block and write to stdout */
    bz._read_bunzip();
    // XXX keep writing?
  }
  return o.retval;
};
/* Reads bzip2 file from stream or buffer `input`, and invoke
 * `callback(position, size)` once for each bzip2 block,
 * where position gives the starting position (in *bits*)
 * and size gives uncompressed size of the block (in *bytes*). */
Bunzip.table = function(input, callback, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = new Stream();
  inputStream.delegate = Util.coerceInputStream(input);
  inputStream.pos = 0;
  inputStream.readByte = function() {
    this.pos++;
    return this.delegate.readByte();
  };
  inputStream.tell = function() { return this.pos; };
  if (inputStream.delegate.eof) {
    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
  }
  var outputStream = new Stream();
  outputStream.pos = 0;
  outputStream.writeByte = function() { this.pos++; };

  var bz = new Bunzip(inputStream, outputStream);
  var blockSize = bz.dbufSize;
  while (true) {
    if ('eof' in inputStream && inputStream.eof()) break;

    var position = bz.reader.tellBit();

    if (bz._init_block()) {
      var start = outputStream.pos;
      bz._read_bunzip();
      callback(position, outputStream.pos - start);
    } else {
      var crc = bz.reader.readBits(32); // (but we ignore the crc)
      if (multistream &&
          'eof' in inputStream &&
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
        console.assert(bz.dbufSize === blockSize,
                       "shouldn't change block size within multistream file");
      } else break;
    }
  }
};

// create a Huffman tree from the table of frequencies
var StaticHuffman = function(freq, alphabetSize) {
  // As in BZip2HuffmanStageEncoder.java (from jbzip2):
  // The Huffman allocator needs its input symbol frequencies to be
  // sorted, but we need to return code lengths in the same order as
  // the corresponding frequencies are passed in.
  // The symbol frequency and index are merged into a single array of
  // integers - frequency in the high 23 bits, index in the low 9
  // bits.
  //     2^23 = 8,388,608 which is higher than the maximum possible
  //            frequency for one symbol in a block
  //     2^9 = 512 which is higher than the maximum possible
  //            alphabet size (== 258)
  // Sorting this array simultaneously sorts the frequencies and
  // leaves a lookup that can be used to cheaply invert the sort
  var i, mergedFreq = [];
  for (i=0; i<alphabetSize; i++) {
    mergedFreq[i] = (freq[i] << 9) | i;
  }
  mergedFreq.sort(function(a,b) { return a-b; });
  var sortedFreq = mergedFreq.map(function(v) { return v>>>9; });
  // allocate code lengths in place. (result in sortedFreq array)
  HuffmanAllocator.allocateHuffmanCodeLengths(sortedFreq, MAX_HUFCODE_BITS);
  // reverse the sort to put codes & code lengths in order of input symbols
  this.codeLengths = Util.makeU8Buffer(alphabetSize);
  for (i=0; i<alphabetSize; i++) {
    var sym = mergedFreq[i] & 0x1FF;
    this.codeLengths[sym] = sortedFreq[i];
  }
};
// compute canonical Huffman codes, given code lengths
StaticHuffman.prototype.computeCanonical = function() {
  var alphabetSize = this.codeLengths.length;
  // merge arrays; sort first by length then by symbol.
  var i, merged = [];
  for (i=0; i<alphabetSize; i++) {
    merged[i] = (this.codeLengths[i] << 9) | i;
  }
  merged.sort(function(a,b) { return a-b; });
  // use sorted lengths to assign codes
  this.code = Util.makeU32Buffer(alphabetSize);
  var code = 0, prevLen = 0;
  for (i=0; i<alphabetSize; i++) {
    var curLen = merged[i] >>> 9;
    var sym = merged[i] & 0x1FF;
    console.assert(prevLen <= curLen);
    code <<= (curLen - prevLen);
    this.code[sym] = code++;
    prevLen = curLen;
  }
};
// compute the cost of encoding the given range of symbols w/ this Huffman code
StaticHuffman.prototype.cost = function(array, offset, length) {
  var i, cost = 0;
  for (i=0; i<length; i++) {
    cost += this.codeLengths[array[offset+i]];
  }
  return cost;
};
// emit the bit lengths used by this Huffman code
StaticHuffman.prototype.emit = function(outStream) {
  // write the starting length
  var i, currentLength = this.codeLengths[0];
  outStream.writeBits(5, currentLength);
  for (i=0; i<this.codeLengths.length; i++) {
    var codeLength = this.codeLengths[i];
    var value, delta;
    console.assert(codeLength > 0 && codeLength <= MAX_HUFCODE_BITS);
    if (currentLength < codeLength) {
      value = 2; delta = codeLength - currentLength;
    } else {
      value = 3; delta = currentLength - codeLength;
    }
    while (delta-- > 0) {
      outStream.writeBits(2, value);
    }
    outStream.writeBit(0);
    currentLength = codeLength;
  }
};
// encode the given symbol with this Huffman code
StaticHuffman.prototype.encode = function(outStream, symbol) {
  outStream.writeBits(this.codeLengths[symbol], this.code[symbol]);
};

// read a block for bzip2 compression.
var readBlock = function(inStream, block, length, crc) {
  var pos = 0;
  var lastChar = -1;
  var runLength = 0;
  while (pos < length) {
    if (runLength===4) {
      block[pos++] = 0;
      if (pos >= length) { break; }
    }
    var ch = inStream.readByte();
    if (ch === EOF) {
      break;
    }
    crc.updateCRC(ch);
    if (ch !== lastChar) {
      lastChar = ch;
      runLength = 1;
    } else {
      runLength++;
      if (runLength > 4) {
        if (runLength < 256) {
          block[pos-1]++;
          continue;
        } else {
          runLength = 1;
        }
      }
    }
    block[pos++] = ch;
  }
  return pos;
};

// divide the input into groups at most GROUP_SIZE symbols long.
// assign each group to the Huffman table which compresses it best.
var assignSelectors = function(selectors, groups, input) {
  var i, j, k;
  for (i=0, k=0; i<input.length; i+=GROUP_SIZE) {
    var groupSize = Math.min(GROUP_SIZE, input.length - i);
    var best = 0, bestCost = groups[0].cost(input, i, groupSize);
    for (j=1; j<groups.length; j++) {
      var groupCost = groups[j].cost(input, i, groupSize);
      if (groupCost < bestCost) {
        best = j; bestCost = groupCost;
      }
    }
    selectors[k++] = best;
  }
};
var optimizeHuffmanGroups = function(groups, targetGroups, input,
                                     selectors, alphabetSize) {
  // until we've got "targetGroups" Huffman codes, pick the Huffman code which
  // matches the largest # of groups and split it by picking the groups
  // which require more than the median number of bits to encode.
  // then recompute frequencies and reassign Huffman codes.
  var i, j, k, groupCounts = [];
  while (groups.length < targetGroups) {
    assignSelectors(selectors, groups, input);
    // which code gets used the most?
    for (i=0; i<groups.length; i++) { groupCounts[i] = 0; }
    for (i=0; i<selectors.length; i++) {
      groupCounts[selectors[i]]++;
    }
    var which = groupCounts.indexOf(Math.max.apply(Math, groupCounts));
    // ok, let's look at the size of those blocks
    var splits = [];
    for (i=0, j=0; i<selectors.length; i++) {
      if (selectors[i] !== which) { continue; }
      var start = i*GROUP_SIZE;
      var end = Math.min(start + GROUP_SIZE, input.length);
      splits.push({index: i, cost:groups[which].cost(input, start, end-start)});
    }
    // find the median.  there are O(n) algorithms to do this, but we'll
    // be lazy and use a full O(n ln n) sort.
    splits.sort(function(s1, s2) { return s1.cost - s2.cost; });
    // assign the groups in the top half to the "new" selector
    for (i=(splits.length>>>1); i<splits.length; i++) {
      selectors[splits[i].index] = groups.length;
    }
    groups.push(null);
    // recompute frequencies
    var freq = [], f;
    for (i=0; i<groups.length; i++) {
      f = freq[i] = [];
      for (j=0; j<alphabetSize; j++) { f[j] = 0; }
    }
    for (i=0, j=0; i<input.length; ) {
      f = freq[selectors[j++]];
      for (k=0; k<GROUP_SIZE && i<input.length; k++) {
        f[input[i++]]++;
      }
    }
    // reconstruct Huffman codes
    for (i=0; i<groups.length; i++) {
      groups[i] = new StaticHuffman(freq[i], alphabetSize);
    }
  }
};

var compressBlock = function(block, length, outStream) {
  var c, i, j, k;
  // do BWT transform
  var U = Util.makeU8Buffer(length);
  var pidx = BWT.bwtransform2(block, U, length, 256);
  outStream.writeBit(0); // not randomized
  outStream.writeBits(24, pidx);
  // track values used; write bitmap
  var used = [], compact = [];
  for (i=0; i<length; i++) {
    c = block[i];
    used[c] = true;
    compact[c>>>4] = true;
  }
  for (i=0; i<16; i++) {
    outStream.writeBit(!!compact[i]);
  }
  for (i=0; i<16; i++) {
    if (compact[i]) {
      for (j=0; j<16; j++) {
        outStream.writeBit(!!used[(i<<4)|j]);
      }
    }
  }
  var alphabetSize = 0;
  for (i=0; i<256; i++) {
    if (used[i]) {
      alphabetSize++;
    }
  }
  // now MTF and RLE/2 encoding, while tracking symbol statistics.
  // output can be one longer than length, because we include the
  // end-of-block character at the end. Similarly, we need a U16
  // array because the end-of-block character can be 256.
  var A = Util.makeU16Buffer(length+1);
  var endOfBlock = alphabetSize + 1;
  var freq = [];
  for (i=0; i<=endOfBlock; i++) { freq[i] = 0; }
  var M = Util.makeU8Buffer(alphabetSize);
  for (i=0, j=0; i<256; i++) {
    if (used[i]) { M[j++] = i; }
  }
  used = null; compact = null;
  var pos = 0, runLength = 0;
  var emit = function(c) {
    A[pos++] = c;
    freq[c]++;
  };
  var emitLastRun = function() {
    while (runLength !== 0) {
      if (runLength & 1) {
        emit(0); // RUNA
        runLength -= 1;
      } else {
        emit(1); // RUNB
        runLength -= 2;
      }
      runLength >>>= 1;
    }
  };
  for (i=0; i<U.length; i++) {
    c = U[i];
    // look for C in M
    for (j=0; j<alphabetSize; j++) {
      if (M[j]===c) { break; }
    }
    console.assert(j!==alphabetSize);
    // shift MTF array
    mtf(M, j);
    // emit j
    if (j===0) {
      runLength++;
    } else {
      emitLastRun();
      emit(j+1);
      runLength = 0;
    }
  }
  emitLastRun();
  emit(endOfBlock); // end of block symbol
  A = A.subarray(0, pos);
  // now A[0...pos) has the encoded output, and freq[0-alphabetSize] has the
  // frequencies.  Use these to construct Huffman tables.
  // the canonical bzip2 encoder does some complicated optimization
  // to attempt to select the best tables.  We're going to simplify things:
  // (unless the block is very short) we're always going to create MAX_GROUPS
  // tables; 1 based on global frequencies, and the rest based on dividing the
  // block into MAX_GROUPS-1 pieces.
  var groups = [];
  var targetGroups; // how many Huffman groups should we create?
  // look at length of MTF-encoded block to pick a good number of groups
  if (pos >= 2400) { targetGroups = 6; }
  else if (pos >= 1200) { targetGroups = 5; }
  else if (pos >= 600) { targetGroups = 4; }
  else if (pos >= 200) { targetGroups = 3; }
  else { targetGroups = 2; }
  // start with two Huffman groups: one with the global frequencies, and
  // a second with a flat frequency distribution (which is also the smallest
  // possible Huffman table to encode, which is handy to prevent excessive
  // bloat if the input file size is very small)
  groups.push(new StaticHuffman(freq, endOfBlock+1));
  for (i=0; i<=endOfBlock; i++) { freq[i] = 1; }
  groups.push(new StaticHuffman(freq, endOfBlock+1));
  freq = null;
  // Now optimize the Huffman groups!  this is a black art.
  // we probably don't want to waste too much time on it, though.
  var selectors = Util.makeU8Buffer(Math.ceil(pos / GROUP_SIZE));
  optimizeHuffmanGroups(groups, targetGroups, A, selectors, endOfBlock+1);
  assignSelectors(selectors, groups, A);

  // okay, let's start writing out our Huffman tables
  console.assert(groups.length >= MIN_GROUPS && groups.length <= MAX_GROUPS);
  outStream.writeBits(3, groups.length);
  // and write out the best selector for each group
  outStream.writeBits(15, selectors.length);
  for (i=0; i<groups.length; i++) { M[i] = i; } // initialize MTF table.
  for (i=0; i<selectors.length; i++) {
    var s = selectors[i];
    // find selector in MTF list
    for (j=0; j<groups.length; j++) { if (M[j]===s) { break; } }
    console.assert(j<groups.length);
    mtf(M, j);
    // emit 'j' as a unary number
    for (;j>0; j--) {
      outStream.writeBit(1);
    }
    outStream.writeBit(0);
  }
  // okay, now emit the Huffman tables in order.
  for (i=0; i<groups.length; i++) {
    groups[i].emit(outStream);
    groups[i].computeCanonical(); // get ready for next step while we're at it
  }
  // okay, now (finally!) emit the actual data!
  for (i=0, k=0; i<pos; ) {
    var huff = groups[selectors[k++]];
    for (j=0; j<GROUP_SIZE && i<pos; j++) {
      huff.encode(outStream, A[i++]);
    }
  }
  // done.
};

var Bzip2 = Object.create(null);
Bzip2.compressFile = function(inStream, outStream, props) {
  inStream = Util.coerceInputStream(inStream);
  var o = Util.coerceOutputStream(outStream, outStream);
  outStream = new BitStream(o.stream);

  var blockSizeMultiplier = 9;
  if (typeof(props)==='number') {
    blockSizeMultiplier = props;
  }
  if (blockSizeMultiplier < 1 || blockSizeMultiplier > 9) {
    throw new Error('Invalid block size multiplier');
  }

  var blockSize = blockSizeMultiplier * 100000;
  // the C implementation always writes at least length-19 characters,
  // but it reads ahead enough that if the last character written was part
  // of a run, it writes out the full run.
  // That's really annoying to implement.
  // So instead just subtract 19 from the blockSize; in most cases (unless
  // there's a run at the end of the block) this will yield block divisions
  // matching the C implementation.
  blockSize -= 19;

  // write file magic
  outStream.writeByte('B'.charCodeAt(0));
  outStream.writeByte('Z'.charCodeAt(0));
  outStream.writeByte('h'.charCodeAt(0)); // Huffman-coded bzip
  outStream.writeByte('0'.charCodeAt(0) + blockSizeMultiplier);

  // allocate a buffer for the block
  var block = Util.makeU8Buffer(blockSize);
  var streamCRC = 0;
  var length;

  do {
    var crc = new CRC32();
    length = readBlock(inStream, block, blockSize, crc);
    if (length > 0) {
      streamCRC = (((streamCRC << 1) | (streamCRC>>>31)) ^ crc.getCRC()) >>> 0;
      outStream.writeBits(48, WHOLEPI);
      outStream.writeBits(32, crc.getCRC());
      compressBlock(block, length, outStream);
    }
  } while (length === blockSize);

  // finish up
  outStream.writeBits(48, SQRTPI);
  outStream.writeBits(32, streamCRC);
  outStream.flush(); // get the last bits flushed out
  return o.retval;
};

Bzip2.decompressFile = Bunzip.decode;
Bzip2.decompressBlock = Bunzip.decodeBlock;
Bzip2.table = Bunzip.table;

return Bzip2;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/CRC32.js":
/*!*********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/CRC32.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* CRC32, used in Bzip2 implementation.
 * This is a port of CRC32.java from the jbzip2 implementation at
 *   https://code.google.com/p/jbzip2
 * which is:
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */
var libs = [
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Util) {

  /**
   * A static CRC lookup table
   */
    var crc32Lookup = Util.arraycopy(Util.makeU32Buffer(256), [
    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
  ]);

  var CRC32 = function() {
    /**
     * The current CRC
     */
    var crc = 0xffffffff;

    /**
     * @return The current CRC
     */
    this.getCRC = function() {
      return (~crc) >>> 0; // return an unsigned value
    };

    /**
     * Update the CRC with a single byte
     * @param value The value to update the CRC with
     */
    this.updateCRC = function(value) {
      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
    };

    /**
     * Update the CRC with a sequence of identical bytes
     * @param value The value to update the CRC with
     * @param count The number of bytes
     */
    this.updateCRCRun = function(value, count) {
      while (count-- > 0) {
        crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
      }
    };
  };
  return CRC32;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Context1Model.js":
/*!*****************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Context1Model.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** A simple context-1 model. */
var libs = [
	__webpack_require__(/*! ./BitStream */ "./node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__(/*! ./Huffman */ "./node_modules/keybase-compressjs/outlib/Huffman.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream,Huffman,Util) {

var Context1Model = function(modelFactory, contextSize, alphabetSize) {
  var i;
  this.literalModel = [];
  // even if there's an EOF symbol, we don't need a context for it!
  for (i=0; i<contextSize; i++) {
    this.literalModel[i] = modelFactory(alphabetSize);
  }
};
Context1Model.prototype.encode = function(ch, context) {
  this.literalModel[context].encode(ch);
};
Context1Model.prototype.decode = function(context) {
  return this.literalModel[context].decode();
};

/** Simple self-test. */
Context1Model.MAGIC='ctx1';
Context1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {
  var bitstream = new BitStream(outStream);
  var alphabetSize = 256;
  if (fileSize < 0) { alphabetSize++; }
  var coder = Huffman.factory(bitstream, 8191);
  var model = new Context1Model(coder, 256, alphabetSize);
  var lastchar = 0x20;
  var modelp = {
    encode: function(symbol) {
      model.encode(symbol, lastchar);
      lastchar = symbol;
    }
  };
  Util.compressWithModel(inStream, fileSize, modelp);
  bitstream.flush();
});
Context1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {
  var bitstream = new BitStream(inStream);
  var alphabetSize = 256;
  if (fileSize < 0) { alphabetSize++; }
  var coder = Huffman.factory(bitstream, 8191);
  var model = new Context1Model(coder, 256, alphabetSize);
  var lastchar = 0x20;
  var modelp = {
    decode: function() {
      var symbol = model.decode(lastchar);
      lastchar = symbol;
      return symbol;
    }
  };
  Util.decompressWithModel(outStream, fileSize, modelp);
});

return Context1Model;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/DefSumModel.js":
/*!***************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/DefSumModel.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Deferred-sum model, suitable for small ( ~ 256 ) ranges. */
var libs = [
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){

var LOG_PROB_TOTAL = 8;
var PROB_TOTAL = 1 << LOG_PROB_TOTAL;
var MAX_ESCAPE_COUNT = 40;

var DefSumModel = function(coder, size, isDecoder) {
  var i;
  console.assert(size < 300); // not meant for sparse
  var ESCAPE = this.numSyms = size;
  this.coder = coder;
  this.prob = Util.makeU16Buffer(size+2); /* size + ESC + 1 */
  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/
  this.update = Util.makeU16Buffer(size+1); /* size + ESC */
  this.prob[ESCAPE+1] = PROB_TOTAL;
  for (i=0; i<=this.numSyms; i++) {
    this.escape[i] = i;
  }
  this.updateCount = 0;
  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);
  if (!isDecoder) { return; }
  // extra tables for fast decoding
  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);
  this.escProbToSym = Util.makeU16Buffer(this.numSyms);
  for (i=0; i<PROB_TOTAL; i++) {
    this.probToSym[i] = ESCAPE;
  }
  for (i=0; i<this.numSyms; i++) {
    this.escProbToSym[i] = i;
  }
};
DefSumModel.factory = function(coder, isDecoder) {
  return function(size) { return new DefSumModel(coder, size, isDecoder); };
};
DefSumModel.prototype._update = function(symbol, isDecoder) {
  if (symbol === this.numSyms) {
    // some special cases for the escape character
    if (this.update[symbol] >= MAX_ESCAPE_COUNT) { return; } // hard limit
    // don't let an escape character trigger an update, because then the
    // escaped character might find itself unescaped after the tables have
    // been updated!
    if (this.updateCount >= (this.updateThresh - 1)) { return; }
  }
  this.update[symbol]++;
  this.updateCount++;
  // is it time to transfer the updated probabilities?
  if (this.updateCount < this.updateThresh) {
    return; //defer update
  }
  var cumProb, cumEscProb, odd, i, j, k;
  this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;
  for (i=0; i < this.numSyms+1; i++) {
    var newProb = ((this.prob[i+1]-this.prob[i]) >>> 1) + this.update[i];
    if (newProb) {
      // live 'un
      this.prob[i] = cumProb;
      cumProb += newProb;
      if (newProb & 1) { odd++; }
      this.escape[i] = cumEscProb;
    } else {
      // this symbol will escape
      this.prob[i] = cumProb;
      this.escape[i] = cumEscProb;
      cumEscProb++;
    }
  }
  this.prob[i] = cumProb;
  console.assert(cumProb === PROB_TOTAL);
  /* how many updates will be required after current probs are halved? */
  this.updateThresh = PROB_TOTAL - Math.floor((cumProb-odd) / 2);
  /* reset the update table */
  for (i=0; i < (this.numSyms + 1); i++) {
    this.update[i] = 0;
  }
  this.update[this.numSyms] = 1; // ensure that escape never goes away
  this.updateCount = 1;
  /* compute decode table, if this is a decoder */
  if (!isDecoder) { return; }
  for (i=0, j=0, k=0; i<(this.numSyms+1); i++) {
    var probLimit = this.prob[i+1];
    for (; j<probLimit; j++) {
      this.probToSym[j] = i;
    }
    var escProbLimit = this.escape[i+1];
    for (; k<escProbLimit; k++) {
      this.escProbToSym[k] = i;
    }
  }
};
DefSumModel.prototype.encode = function(symbol) {
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  console.assert(this.prob[this.numSyms+1] === PROB_TOTAL);
  if (sy_f) {
    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);
    return this._update(symbol);
  }
  // escape!
  console.assert(symbol !== this.numSyms); // catch infinite recursion
  this.encode(this.numSyms); // guaranteed non-zero probability
  // code symbol as literal, taking advantage of reduced escape range.
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  var tot_f = this.escape[this.numSyms];
  this.coder.encodeFreq(sy_f, lt_f, tot_f);
  return this._update(symbol);
};
DefSumModel.prototype.decode = function() {
  var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);
  var symbol = this.probToSym[prob];
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);
  this._update(symbol, true);
  if (symbol !== this.numSyms) {
    return symbol;
  }
  // escape!
  var tot_f = this.escape[this.numSyms];
  prob = this.coder.decodeCulFreq(tot_f);
  symbol = this.escProbToSym[prob];
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, tot_f);
  this._update(symbol, true);
  return symbol;
};

DefSumModel.MAGIC='dfsm';
/** Simple order-0 compressor, as self-test. */
DefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
},true);
/** Simple order-0 decompresser, as self-test. */
DefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*already read the final byte*/);
  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256, true);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

return DefSumModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/DeflateDistanceModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/DeflateDistanceModel.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Distance model used by gzip/deflate.
 *  Encodes distances starting at 0 (for deflate compatibility, subtract
 *  one from distance to encode).
 *  Uses ~32-entry model to predict ln2(distance) (more-or-less) and then
 *  encodes a few more bits for the actual distance. */
var libs = [
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Util){

    // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
    // and must return an appropriate model or coder.
    var DeflateDistanceModel = function(size, extraStates,
                                        lgDistanceModelFactory,
                                        lengthBitsModelFactory) {
        var i;
        var bits = Util.fls(size-1);
        this.extraStates = +extraStates || 0;
        this.lgDistanceModel = lgDistanceModelFactory(2*bits + extraStates);
        // this.distanceModel[n] used for distances which are n-bits long,
        // but only n-2 bits are encoded: the top bit is known to be one,
        // and the next bit is encoded by the lgDistanceModel.
        this.distanceModel = [];
        for (i=3 ; i <= bits; i++) {
            var numBits = i - 2;
            this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);
        }
    };
    /* you can give this model arguments between 0 and (size-1), or else
       a negative argument which is one of the 'extra states'. */
    DeflateDistanceModel.prototype.encode = function(distance) {
        if (distance < 4) { // small distance or an 'extra state'
            this.lgDistanceModel.encode(distance + this.extraStates);
            return;
        }
        var lgDistance = Util.fls(distance);
        console.assert(distance & (1<<(lgDistance-1))); // top bit is set
        console.assert(lgDistance >= 3);
        var nextBit = (distance & (1 << (lgDistance-2))) ? 1 : 0;
        var l = 4 + ((lgDistance-3)*2) + nextBit;
        this.lgDistanceModel.encode(l + this.extraStates);
        // now encode the rest of the bits.
        var rest = distance & ((1 << (lgDistance-2)) - 1);
        this.distanceModel[lgDistance].encode(rest);
    };
    DeflateDistanceModel.prototype.decode = function() {
        var l = this.lgDistanceModel.decode() - this.extraStates;
        if (l < 4) {
            return l; // this is a small distance or an 'extra state'
        }
        var nextBit = (l&1);
        var lgDistance = ((l-4) >>> 1) + 3;
        var rest = this.distanceModel[lgDistance].decode();
        return ((2+nextBit) << (lgDistance-2)) + rest;
    };
    return DeflateDistanceModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Dmc.js":
/*!*******************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Dmc.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Implementation of Dynamic Markov Compression, using byte-oriented
 * nodes/transitions.
 *
 * Currently no model-shrinking is done, so be careful trying to use
 * this on large inputs!
 *
 * Notes for the future / TO DO:
 *
 * Add node merging to Dmc:
 *  - once (total states traversed / total node count) exceeds a certain value
 *    - find the median node w/rt total visits
 *    - combine all nodes w/ less visits into a single node, with transitions
 *      to node[0] - node[255] (initial context-1 states)
 *      - initially transition counts are zero?  or summed from components?
 *        needs to be summed so kirchoff principle holds
 *    - halve the edge counts of all nodes, to provide for adaptation
 *      - enforce property that all nodes point "higher" except for
 *        links to nodes 0-255.  So we can resum all nodes in one pass,
 *        after resetting all node.sum to zero. X YES because we know
 *        what the total sum must be, so we can arrange to scale to maintain
 *        proper sum. XXX what about node 0-255? XXX maybe just clear all
 *        edge counts XXX
 *
 * Fix buglet: ensure that kirchoff principle *exactly* holds by
 * paying attention to rounding when we distribute edge counts.  track
 * highest edge and give (desiredSum - newSum) extra counts to that
 * outgoing edge? add one to each nonzero edge until all gone?
 *
 * Split 'to' nodes when to.sum grows too high -- only if we're
 * highest incoming edge?  Fix bug again here with saturating counts;
 * we can't ignore counts w/o violating kirchoff principle, so we need
 * to clone it.  Maybe start trying to clone early (before our counter
 * saturates) so we have a better chance of cloning on the high
 * incoming edge? XXX we don't track incoming edges.  XXX so just
 * clone when we visit.
 */
var libs = [
	__webpack_require__(/*! ./MTFModel */ "./node_modules/keybase-compressjs/outlib/MTFModel.js"),
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (MTFModel, RangeCoder, Stream, Util){

// nm = no model cloning, MAX_TRANS_CNT=0xFF, MAX_MODEL_PROB=0xFFFF
// nm2 = "                            0xFFFF                 0xFFFF
// nm3 = "                             0xFFF                 0x0FFF
// nm4 = "                            0xFFFF                   0xFF
// cl1 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFF
// cl2 = model cloning, MAX_TRANS_CNT=  0xFF  MAX_MODEL_PROB=0xFF
// cl3 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFFFF
var MAX_TRANS_CNT = 0xFFFF;
var DEFAULT_MIN_CNT1 = 8;
var DEFAULT_MIN_CNT2 = 128;
var MODEL_PROB_MAX = 0xFF00;
var MODEL_PROB_INCR= 0x0100;
var CLONE_MODELS=false;
var PRINT_STATS=false; // for quick benchmarking

// XXX need to limit growth of model (throw away and retrain if model
//     gets too large)

var Dmc = Object.create(null);
Dmc.MAGIC = 'dmc!';

var MarkovNode = function(coder, size, optModel) {
  this.out = [];
  this.model = optModel ? optModel.clone() :
    new MTFModel(coder, size, MODEL_PROB_MAX, MODEL_PROB_INCR);
  this.count = Util.makeU16Buffer(size);
  this.sum = 0;
};
MarkovNode.prototype.clone = function(coder, size) {
  var i;
  var newNode = new MarkovNode(coder, size, CLONE_MODELS ? this.model : null);
  for (i=0; i<size; i++) {
    newNode.out[i] = this.out[i];
  }
  return newNode;
};

var MarkovModel = function(coder, size, MIN_CNT1, MIN_CNT2) {
  var i, j;
  // initial model is 'size' states, completely linked.
  this.coder = coder;
  this.size = size;
  this.MIN_CNT1 = MIN_CNT1 || DEFAULT_MIN_CNT1;
  this.MIN_CNT2 = MIN_CNT2 || DEFAULT_MIN_CNT2;
  this.nodes = [];
  for (i=0; i<size; i++) {
    this.nodes[i] = new MarkovNode(coder, size);
  }
  // now link nodes
  for (i=0; i<size; i++) {
    for (j=0; j<size; j++) {
      this.nodes[i].out[j] = this.nodes[j];
    }
  }
  // select an arbitrary node as the start state.
  this.current = this.nodes[0];
};
MarkovModel.prototype.maybeSplit = function(from, symbol, to) {
  var trans_cnt = from.count[symbol];
  var next_cnt = to.sum;
  var i;
  if ( (trans_cnt <= this.MIN_CNT1) ||
       (next_cnt - trans_cnt <= this.MIN_CNT2) ) {
    return to; // no split
  }

  // split this guy!
  var newNode = to.clone(this.coder, this.size);
  this.nodes.push(newNode);
  from.out[symbol] = newNode;
  // distribute transition counts among new and cloned node
  newNode.sum = to.sum = 0;
  for (i=0; i<this.size; i++) {
    newNode.count[i] = to.count[i] * trans_cnt / next_cnt;
    newNode.sum += newNode.count[i];
    to.count[i] -= newNode.count[i];
    to.sum += to.count[i];
  }

  return newNode;
};
MarkovModel.prototype.encode = function(symbol) {
  var from = this.current;
  from.model.encode(symbol);
  var to = from.out[symbol];
  if (from.count[symbol] !== MAX_TRANS_CNT) {
      from.count[symbol]++;
      from.sum++;
  }
  this.current = this.maybeSplit(from, symbol, to);
};
MarkovModel.prototype.decode = function() {
  var from = this.current;
  var symbol = from.model.decode();
  var to = from.out[symbol];
  if (from.count[symbol] !== MAX_TRANS_CNT) {
      from.count[symbol]++;
      from.sum++;
  }
  this.current = this.maybeSplit(from, symbol, to);
  return symbol;
};

Dmc.compressFile = Util.compressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize, props) {

  props = props || {};
  var MIN_CNT1 = (+props.m) || DEFAULT_MIN_CNT1;
  var MIN_CNT2 = (+props.n) || DEFAULT_MIN_CNT2;
  Util.writeUnsignedNumber(outStream, MIN_CNT1);
  Util.writeUnsignedNumber(outStream, MIN_CNT2);

  var range = new RangeCoder(outStream);
  range.encodeStart(0xCA, 0);

  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,
                           MIN_CNT1, MIN_CNT2);
  var inSize = 0;
  while (inSize !== fileSize) {
    var ch = inStream.readByte();
    if (ch===Stream.EOF) {
      mm.encode(256); // end of stream
      break;
    }
    mm.encode(ch);
    inSize++;
  }
  var outSize = range.encodeFinish();
  if (PRINT_STATS) {
    console.log('M1', mm.MIN_CNT1, 'M2', mm.MIN_CNT2,
                'states', mm.nodes.length, 'size', outSize);
  }
});

Dmc.decompressFile = Util.decompressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize) {

  var MIN_CNT1 = Util.readUnsignedNumber(inStream);
  var MIN_CNT2 = Util.readUnsignedNumber(inStream);

  var range = new RangeCoder(inStream);
  range.decodeStart();

  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,
                           MIN_CNT1, MIN_CNT2);
  var outSize = 0;
  while (outSize !== fileSize) {
    var ch = mm.decode();
    if (ch===256) {
      break; // EOF
    }
    outStream.writeByte(ch);
    outSize++;
  }
  range.decodeFinish();
});

return Dmc;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/DummyRangeCoder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/DummyRangeCoder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Dummy Range Coder, for debugging.
 * This has the same interface as RangeCoder, but just dumps the frequency
 * parameters given to the file.  This helps debug problems with the model
 * driving the range coder.
 */
var libs = [
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Util){
    var Dummy = function(stream) {
        RangeCoder.call(this, stream);
    };
    Dummy.prototype = Object.create(RangeCoder.prototype);
    Dummy.prototype._write8 = function(b) {
        Util.writeUnsignedNumber(this.stream, b);
        this.stream.writeByte(b);
    };
    Dummy.prototype._write16 = function(s) {
        this.stream.writeByte((s >>> 8) & 0xFF);
        this.stream.writeByte(s & 0xFF);
    };
    Dummy.prototype._read8 = function() {
        return this.stream.readByte();
    };
    Dummy.prototype._read16 = function() {
        var hi = this.stream.readByte();
        var lo = this.stream.readByte();
        return (hi<<8) | lo;
    };
    Dummy.prototype.encodeStart = function(c, initlength) {
        this.stream.writeByte(c);
    };
    Dummy.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {
        console.assert(sy_f > 0);
        console.assert(tot_f > 0);
        console.assert(tot_f <= (1<<23));
        if ((sy_f + lt_f) > tot_f) {
            console.error('dummy coder: lt_f + sy_f > tot_f',
                          sy_f, lt_f, tot_f);
        }
        Util.writeUnsignedNumber(this.stream, sy_f);
        Util.writeUnsignedNumber(this.stream, lt_f);
        Util.writeUnsignedNumber(this.stream, tot_f);
    };
    Dummy.prototype.encodeShift = function(sy_f, lt_f, shift) {
        this.encodeFreq(sy_f, lt_f, 1 << shift);
    };
    Dummy.prototype.encodeFinish = function() {
        return 0;
    };
    Dummy.prototype.decodeStart = function(skipInitialRead) {
        return skipInitialRead ? 0 : this.stream.readByte();
    };
    Dummy.prototype.decodeCulFreq = function(tot_f) {
        console.assert(tot_f > 0);
        this.sy_f = Util.readUnsignedNumber(this.stream);
        this.lt_f = Util.readUnsignedNumber(this.stream);
        this.tot_f= Util.readUnsignedNumber(this.stream);
        if (tot_f !== this.tot_f) {
            console.error('decodeCul* wrong total: got', tot_f,
                          'expected', this.tot_f);
        }
        return (this.sy_f>>>1) + this.lt_f;
    };
    Dummy.prototype.decodeCulShift = function(shift) {
        return this.decodeCulFreq(1<<shift);
    };
    Dummy.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
        console.assert(sy_f > 0);
        console.assert(tot_f > 0);
        if (sy_f !== this.sy_f ||
            lt_f !== this.lt_f ||
            tot_f!== this.tot_f) {
            console.error('decodeUpdate wrong parameters; got',
                          sy_f, lt_f, tot_f, 'expected',
                          this.sy_f, this.lt_f, this.tot_f);
        }
    };
    Dummy.prototype.decodeFinish = function() {
    };

    return Dummy;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/FenwickModel.js":
/*!****************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/FenwickModel.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Range coding model based on Fenwick trees for O(ln N) query/update. */
var libs = [
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){

/** We store two probabilities in a U32, so max prob is going to be 0xFFFF */
var DEFAULT_MAX_PROB = 0xFF00;
var DEFAULT_INCREMENT= 0x0100;

var ESC_MASK = 0x0000FFFF, ESC_SHIFT = 0;
var SYM_MASK = 0xFFFF0000, SYM_SHIFT = 16;
var SCALE_MASK=0xFFFEFFFE;

var FenwickModel = function(coder, size, max_prob, increment) {
    this.coder = coder;
    this.numSyms = size + 1; // save space for an escape symbol
    this.tree = Util.makeU32Buffer(this.numSyms*2);
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    // sanity-check to prevent overflow.
    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);
    console.assert(size <= 0xFFFF);
    // record escape probability as 1.
    var i;
    for (i=0; i<size; i++) {
        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0
            (1 << ESC_SHIFT) | (0 << SYM_SHIFT);
    }
    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1
        (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);
    this._sumTree();
    // probability sums are in this.tree[1].  this.tree[0] is unused.
};
FenwickModel.factory = function(coder, max_prob, increment) {
    return function(size) {
        return new FenwickModel(coder, size, max_prob, increment);
    };
};
FenwickModel.prototype.clone = function() {
    var newModel = new FenwickModel(this.coder, this.size,
                                    this.max_prob, this.increment);
    var i;
    for (i=1; i<this.tree.length; i++) {
        newModel.tree[i] = this.tree[i];
    }
    return newModel;
};
FenwickModel.prototype.encode = function(symbol) {
    var i = this.numSyms + symbol;
    var sy_f = this.tree[i];
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment << SYM_SHIFT);

    if ((sy_f & SYM_MASK) === 0) { // escape!
        this.encode(this.numSyms-1);
        mask = ESC_MASK;
        update -= (1<<ESC_SHIFT); // not going to escape no mo'
        shift = ESC_SHIFT;
    } else if (symbol === (this.numSyms-1) &&
               ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
        // this is the last escape, zero it out
        update = -this.tree[i];
    }
    // sum up the proper lt_f
    var lt_f = 0;
    while (i > 1) {
        var isRight = (i & 1);
        var parent = (i >>> 1);
        // if we're the right child, we need to
        // add the prob from the left child
        if (isRight) {
            lt_f += this.tree[2*parent];
        }
        // update sums
        this.tree[i] += update; // increase sym / decrease esc
        i = parent;
    }
    var tot_f = this.tree[1];
    this.tree[1] += update; // update prob in root
    sy_f = (sy_f & mask) >>> shift;
    lt_f = (lt_f & mask) >>> shift;
    tot_f =(tot_f& mask) >>> shift;
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // rescale?
    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {
        this._rescale();
    }
};
FenwickModel.prototype._decode = function(isEscape) {
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment << SYM_SHIFT);
    if (isEscape) {
        mask = ESC_MASK;
        update -= (1 << ESC_SHIFT);
        shift = ESC_SHIFT;
    }
    var tot_f = (this.tree[1] & mask) >>> shift;
    var prob = this.coder.decodeCulFreq(tot_f);
    // travel down the tree looking for this
    var i = 1, lt_f = 0;
    while (i < this.numSyms) {
        this.tree[i] += update;
        // look at probability in left child.
        var leftProb = (this.tree[2*i] & mask) >>> shift;
        i *= 2;
        if ((prob-lt_f) >= leftProb) {
            lt_f += leftProb;
            i++; // take the right child.
        }
    }
    var symbol = i - this.numSyms;
    var sy_f = (this.tree[i] & mask) >>> shift;
    this.tree[i] += update;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    // was this the last escape?
    if (symbol === (this.numSyms-1) &&
        ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
        update = -this.tree[i]; // zero it out
        while (i >= 1) {
            this.tree[i] += update;
            i = (i >>> 1); // parent
        }
    }
    // rescale?
    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {
        this._rescale();
    }
    return symbol;
};
FenwickModel.prototype.decode = function() {
    var symbol = this._decode(false); // not escape
    if (symbol === (this.numSyms-1)) {
        // this was an escape!
        symbol = this._decode(true); // an escape!
    }
    return symbol;
};
FenwickModel.prototype._rescale = function() {
    var i, prob, noEscape = true;
    // scale symbols (possible causing them to escape)
    for (i=0; i < this.numSyms-1; i++) {
        prob = this.tree[this.numSyms + i];
        if ((prob & ESC_MASK) !== 0) {
            // this symbol escapes
            noEscape = false;
            continue;
        }
        prob = (prob & SCALE_MASK) >>> 1;
        if (prob === 0) {
            // this symbol newly escapes
            prob = (1 << ESC_SHIFT);
            noEscape = false;
        }
        this.tree[this.numSyms + i] = prob;
    }
    // scale the escape symbol
    prob = this.tree[this.numSyms + i];
    prob = (prob & SCALE_MASK) >>> 1;
    // prob should be zero if there are no escaping symbols, otherwise
    // it must be at least 1.
    if (noEscape) { prob = 0; }
    else if (prob === 0) { prob = (1 << SYM_SHIFT); }
    this.tree[this.numSyms + i] = prob;
    // sum it all up afresh
    this._sumTree();
};
FenwickModel.prototype._sumTree = function() {
    var i;
    // sum it all. (we know we won't overflow)
    for (i=this.numSyms - 1; i > 0; i--) {
        this.tree[i] = this.tree[2*i] + this.tree[2*i + 1];
    }
};

FenwickModel.MAGIC = 'fenw';
/** Simple order-0 compressor, as self-test. */
FenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var range = new RangeCoder(outStream);
    range.encodeStart(finalByte, 1);
    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    range.encodeFinish();
}, true);

/** Simple order-0 decompresser, as self-test. */
FenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {
    var range = new RangeCoder(inStream);
    range.decodeStart(true/*already read the final byte*/);
    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
    range.decodeFinish();
});

return FenwickModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Huffman.js":
/*!***********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Huffman.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Adaptive Huffman code, using Vitter's algorithm ported from
 * vitter.c at http://code.google.com/p/compression-code/downloads/list
 * The original code was placed in the public domain, and so I
 * also place this JavaScript port in the public domain.
 *   -- C. Scott Ananian <cscott@cscott.net>, 2013
 * ps. some truly grotty C code in the originally, faithfully ported to
 *     evil comma-operator-using, assignment-in-if-condition JavaScript.
 */
var libs = [
	__webpack_require__(/*! ./BitStream */ "./node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream,Util) {
//  This code is adapted from Professor Vitter's
//  article, Design and Analysis of Dynamic Huffman Codes,
//  which appeared in JACM October 1987

//  A design trade-off has been made to simplify the
//  code:  a node's block is determined dynamically,
//  and the implicit tree structure is maintained,
//  e.g. explicit node numbers are also implicit.

//  Dynamic Huffman table weight ranking
//  is maintained per Professor Vitter's
//  invariant (*) for algorithm FGK:

//  leaves precede internal nodes of the
//  same weight in a non-decreasing ranking
//  of weights using implicit node numbers:

//  1) leaves slide over internal nodes, internal nodes
//  swap over groups of leaves, leaves are swapped
//  into group leader position, but two internal
//  nodes never change positions relative
//  to one another.

//  2) weights are incremented by 2:
//  leaves always have even weight values;
//  internal nodes always have odd values.

//  3) even node numbers are always right children;
//  odd numbers are left children in the tree.

//  node 2 * HuffSize - 1 is always the tree root;
//  node HuffEsc is the escape node;

//  the tree is initialized by creating an
//  escape node as the root.

//  each new leaf symbol is paired with a new escape
//  node into the previous escape node in the tree,
//  until the last symbol which takes over the
//  tree position of the escape node, and
//  HuffEsc is left at zero.

//  overall table size: 2 * HuffSize

//  huff_init(alphabet_size, potential symbols used)
//  huff_encode(next_symbol)
//  next_symbol = huff_decode()

//  huff_scale(by_bits) -- scale weights and re-balance tree

var HTable = function(up, down, symbol, weight) {
    this.up = up; // next node up the tree
    this.down = down; // pair of down nodes
    this.symbol = symbol;       // node symbol value
    this.weight = weight;       // node weight
};
HTable.prototype.clone = function() {
  return new HTable(this.up, this.down, this.symbol, this.weight);
};
HTable.prototype.set = function(htable) {
  this.up = htable.up;
  this.down = htable.down;
  this.symbol = htable.symbol;
  this.weight = htable.weight;
};

//  initialize an adaptive coder
//  for alphabet size, and count
//  of nodes to be used
var Huffman = function(size, root, bitstream, max_weight) {
  var i;
  //  default: all alphabet symbols are used

  console.assert(size && typeof(size)==='number');
  if( !root || root > size )
      root = size;

  //  create the initial escape node
  //  at the tree root

  if ( root <<= 1 ) {
      root--;
  }

  // create root+1 htables (coding table)
  // XXX this could be views on a backing Uint32 array?
  this.table = [];
  for (i=0; i<=root; i++) {
    this.table[i] = new HTable(0,0,0,0);
  }

  // this.map => mapping for symbols to nodes
  this.map = [];
  // this.size => the alphabet size
  if( this.size = size ) {
    for (i=0; i<size; i++) {
      this.map[i] = 0;
    }
  }

  // this.esc  => the current tree height
  // this.root => the root of the tree
  this.esc = this.root = root;

  if (bitstream) {
    this.readBit = bitstream.readBit.bind(bitstream);
    this.writeBit = bitstream.writeBit.bind(bitstream);
  }
  this.max_weight = max_weight; // may be null or undefined
}
// factory interface
Huffman.factory = function(bitstream, max_weight) {
  return function(size) {
    return new Huffman(size, size, bitstream, max_weight);
  };
};


// split escape node to incorporate new symbol

Huffman.prototype.split = function(symbol) {
  var pair, node;

  //  is the tree already full???

  if( pair = this.esc ) {
    this.esc--;
  } else {
    console.assert(false);
    return 0;
  }

  //  if this is the last symbol, it moves into
  //  the escape node's old position, and
  //  this.esc is set to zero.

  //  otherwise, the escape node is promoted to
  //  parent a new escape node and the new symbol.

  if( node = this.esc ) {
    this.table[pair].down = node;
    this.table[pair].weight = 1;
    this.table[node].up = pair;
    this.esc--;
  } else {
    pair = 0;
    node = 1;
  }

  //  initialize the new symbol node

  this.table[node].symbol = symbol;
  this.table[node].weight = 0;
  this.table[node].down = 0;
  this.map[symbol] = node;

  //  initialize a new escape node.

  this.table[this.esc].weight = 0;
  this.table[this.esc].down = 0;
  this.table[this.esc].up = pair;
  return node;
};

//  swap leaf to group leader position
//  return symbol's new node

Huffman.prototype.leader = function(node) {
  var weight = this.table[node].weight;
  var leader = node, prev, symbol;

  while( weight === this.table[leader + 1].weight ) {
    leader++;
  }

  if( leader === node ) {
    return node;
  }

  // swap the leaf nodes

  symbol = this.table[node].symbol;
  prev = this.table[leader].symbol;

  this.table[leader].symbol = symbol;
  this.table[node].symbol = prev;
  this.map[symbol] = leader;
  this.map[prev] = node;
  return leader;
};

//  slide internal node up over all leaves of equal weight;
//  or exchange leaf with next smaller weight internal node

//  return node's new position

Huffman.prototype.slide = function(node) {
  var next = node;
  var swap;

  swap = this.table[next++].clone();

  // if we're sliding an internal node, find the
  // highest possible leaf to exchange with

  if( swap.weight & 1 ) {
    while( swap.weight > this.table[next + 1].weight ) {
      next++;
    }
  }

  //  swap the two nodes

  this.table[node].set(this.table[next]);
  this.table[next].set(swap);

  this.table[next].up = this.table[node].up;
  this.table[node].up = swap.up;

  //  repair the symbol map and tree structure

  if( swap.weight & 1 ) {
    this.table[swap.down].up = next;
    this.table[swap.down - 1].up = next;
    this.map[this.table[node].symbol] = node;
  } else {
    this.table[this.table[node].down - 1].up = node;
    this.table[this.table[node].down].up = node;
    this.map[swap.symbol] = next;
  }

  return next;
};

//  increment symbol weight and re balance the tree.

Huffman.prototype.increment = function(node) {
  var up;

  //  obviate swapping a parent with its child:
  //    increment the leaf and proceed
  //    directly to its parent.

  //  otherwise, promote leaf to group leader position in the tree

  if( this.table[node].up === node + 1 ) {
    this.table[node].weight += 2;
    node++;
  } else {
    node = this.leader (node);
  }

  //  increase the weight of each node and slide
  //  over any smaller weights ahead of it
  //  until reaching the root

  //  internal nodes work upwards from
  //  their initial positions; while
  //  symbol nodes slide over first,
  //  then work up from their final
  //  positions.

  while( this.table[node].weight += 2, up = this.table[node].up ) {
    while( this.table[node].weight > this.table[node + 1].weight ) {
        node = this.slide (node);
    }

    if( this.table[node].weight & 1 ) {
        node = up;
    } else {
        node = this.table[node].up;
    }
  }

  /* Re-scale if necessary. */
  if (this.max_weight) {
    if (this.table[this.root].weight >= this.max_weight) {
      this.scale(1);
    }
  }
};

//  scale all weights and re-balance the tree

//  zero weight nodes are removed from the tree
//  by sliding them out the left of the rank list

Huffman.prototype.scale = function(bits) {
  var node = this.esc, weight, prev;

  //  work up the tree from the escape node
  //  scaling weights by the value of bits

  while( ++node <= this.root ) {
    //  recompute the weight of internal nodes;
    //  slide down and out any unused ones

    if( this.table[node].weight & 1 ) {
      if( weight = this.table[this.table[node].down].weight & ~1 ) {
        weight += this.table[this.table[node].down - 1].weight | 1;
      }

      //  remove zero weight leaves by incrementing HuffEsc
      //  and removing them from the symbol map.  take care

    } else if( !(weight = this.table[node].weight >> bits & ~1) ) {
      if( this.map[this.table[node].symbol] = 0, this.esc++ ) {
        this.esc++;
      }
    }

    // slide the scaled node back down over any
    // previous nodes with larger weights

    this.table[node].weight = weight;
    prev = node;

    while( weight < this.table[--prev].weight ) {
      this.slide(prev);
    }
  }

  // prepare a new escape node

  this.table[this.esc].down = 0;
};

//  send the bits for an escaped symbol

Huffman.prototype.sendid = function(symbol) {
  var empty = 0, max;

  //  count the number of empty symbols
  //  before the symbol in the table

  while( symbol-- ) {
    if( !this.map[symbol] ) {
      empty++;
    }
  }

  //  send LSB of this count first, using
  //  as many bits as are required for
  //  the maximum possible count

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      this.writeBit(empty & 1);
      empty >>= 1;
    } while( max >>= 1 );
  }
};

//  encode the next symbol

Huffman.prototype.encode = function(symbol) {
  var emit = 1, bit;
  var up, idx, node;

  if( symbol < this.size ) {
    node = this.map[symbol];
  } else {
    console.assert(false);
    return;
  }

  //  for a new symbol, direct the receiver to the escape node
  //  but refuse input if table is already full.

  if( !(idx = node) ) {
    if( !(idx = this.esc) ) {
      return;
    }
  }

  //  accumulate the code bits by
  //  working up the tree from
  //  the node to the root

  while( up = this.table[idx].up ) {
    emit <<= 1; emit |= idx & 1; idx = up;
  }

  //  send the code, root selector bit first

  while( bit = emit & 1, emit >>= 1 ) {
    this.writeBit(bit);
  }

  //  send identification and incorporate
  //  new symbols into the tree

  if( !node ) {
    this.sendid(symbol);
    node = this.split(symbol);
  }

  //  adjust and re-balance the tree

  this.increment(node);
};

//  read the identification bits
//  for an escaped symbol

Huffman.prototype.readid = function() {
  var empty = 0, bit = 1, max, symbol;

  //  receive the symbol, LSB first, reading
  //  only the number of bits necessary to
  //  transmit the maximum possible symbol value

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      empty |= this.readBit() ? bit : 0;
      bit <<= 1;
    } while( max >>= 1 );
  }

  //  the count is of unmapped symbols
  //  in the table before the new one

  for( symbol = 0; symbol < this.size; symbol++ ) {
    if( !this.map[symbol] ) {
      if( !empty-- ) {
        return symbol;
      }
    }
  }

  //  oops!  our count is too big, either due
  //  to a bit error, or a short node count
  //  given to huff_init.

  console.assert(false);
  return 0;
};

//  decode the next symbol

Huffman.prototype.decode = function() {
  var node = this.root;
  var symbol, down;

  //  work down the tree from the root
  //  until reaching either a leaf
  //  or the escape node.  A one
  //  bit means go left, a zero
  //  means go right.

  while( down = this.table[node].down ) {
    if( this.readBit() ) {
      node = down - 1;  // the left child precedes the right child
    } else {
      node = down;
    }
  }

  //  sent to the escape node???
  //  refuse to add to a full tree

  if( node === this.esc ) {
    if( this.esc ) {
      symbol = this.readid ();
      node = this.split (symbol);
    } else {
      console.assert(false);
      return 0;
    }
  } else {
    symbol = this.table[node].symbol;
  }

  //  increment weights and re-balance
  //  the coding tree

  this.increment (node);
  return symbol;
};

// stand alone compressor, mostly for testing
Huffman.MAGIC = 'huff';
Huffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {
  var bitstream = new BitStream(output);

  var alphabetSize = 256;
  if (size < 0) { alphabetSize++; }
  var huff = new Huffman(257, alphabetSize, bitstream, 8191);
  Util.compressWithModel(input, size, huff);
  bitstream.flush();
});

// stand alone decompresser, again for testing
Huffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {
  var bitstream = new BitStream(input);

  var alphabetSize = 256;
  if (size < 0) { alphabetSize++; }
  var huff = new Huffman(257, alphabetSize, bitstream, 8191);
  Util.decompressWithModel(output, size, huff);
});

return Huffman;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/HuffmanAllocator.js":
/*!********************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/HuffmanAllocator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * An in-place, length restricted Canonical Huffman code length allocator
 *
 * Based on the algorithm proposed by R. L. Milidi, A. A. Pessoa and
 * E. S. Laber in "In-place Length-Restricted Prefix Coding" (see:
 * http://www-di.inf.puc-rio.br/~laber/public/spire98.ps) and
 * incorporating additional ideas from the implementation of "shcodec"
 * by Simakov Alexander (see: http://webcenter.ru/~xander/)
 *
 * This JavaScript implementation ported from HuffmanAllocator.java from
 *   https://code.google.com/p/jbzip2
 * which is:
 *
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 *
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */
var libs = [
	__webpack_require__(/*! ./freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, Util) {

  /**
   * FIRST() function
   * @param array The code length array
   * @param i The input position
   * @param nodesToMove The number of internal nodes to be relocated
   * @return The smallest {@code k} such that {@code nodesToMove <= k <= i} and
   *         {@code i <= (array[k] % array.length)}
   */
  var first = function(array, i, nodesToMove) {
    var length = array.length;
    var limit = i;
    var k = array.length - 2;

    while ((i >= nodesToMove) && ((array[i] % length) > limit)) {
      k = i;
      i -= (limit - i + 1);
    }
    i = Math.max (nodesToMove - 1, i);

    while (k > (i + 1)) {
      var temp = (i + k) >> 1;
      if ((array[temp] % length) > limit) {
        k = temp;
      } else {
        i = temp;
      }
    }

    return k;
  };

  /**
   * Fills the code array with extended parent pointers
   * @param array The code length array
   */
  var setExtendedParentPointers = function(array) {
    var length = array.length;

    array[0] += array[1];

    var headNode, tailNode, topNode, temp;
    for (headNode = 0, tailNode = 1, topNode = 2;
         tailNode < (length - 1);
         tailNode++) {
      if ((topNode >= length) || (array[headNode] < array[topNode])) {
        temp = array[headNode];
        array[headNode++] = tailNode;
      } else {
        temp = array[topNode++];
      }

      if ((topNode >= length) ||
          ((headNode < tailNode) && (array[headNode] < array[topNode]))) {
        temp += array[headNode];
        array[headNode++] = tailNode + length;
      } else {
        temp += array[topNode++];
      }

      array[tailNode] = temp;
    }
  };

  /**
   * Finds the number of nodes to relocate in order to achieve a given code
   * length limit
   * @param array The code length array
   * @param maximumLength The maximum bit length for the generated codes
   * @return The number of nodes to relocate
   */
  var findNodesToRelocate = function(array, maximumLength) {
    var currentNode = array.length - 2;
    var currentDepth;
    for (currentDepth = 1;
         (currentDepth < (maximumLength - 1)) && (currentNode > 1);
         currentDepth++) {
      currentNode =  first (array, currentNode - 1, 0);
    }

    return currentNode;
  };


  /**
   * A final allocation pass with no code length limit
   * @param array The code length array
   */
  var allocateNodeLengths = function(array) {
    var firstNode = array.length - 2;
    var nextNode = array.length - 1;
    var currentDepth, availableNodes, lastNode, i;

    for (currentDepth = 1, availableNodes = 2;
         availableNodes > 0;
         currentDepth++) {
      lastNode = firstNode;
      firstNode = first (array, lastNode - 1, 0);

      for (i = availableNodes - (lastNode - firstNode); i > 0; i--) {
        array[nextNode--] = currentDepth;
      }

      availableNodes = (lastNode - firstNode) << 1;
    }
  };

  /**
   * A final allocation pass that relocates nodes in order to achieve a
   * maximum code length limit
   * @param array The code length array
   * @param nodesToMove The number of internal nodes to be relocated
   * @param insertDepth The depth at which to insert relocated nodes
   */
  var allocateNodeLengthsWithRelocation = function(array, nodesToMove,
                                                   insertDepth) {
    var firstNode = array.length - 2;
    var nextNode = array.length - 1;
    var currentDepth = (insertDepth == 1) ? 2 : 1;
    var nodesLeftToMove = (insertDepth == 1) ? nodesToMove - 2 : nodesToMove;
    var availableNodes, lastNode, offset, i;

    for (availableNodes = currentDepth << 1;
         availableNodes > 0;
         currentDepth++) {
      lastNode = firstNode;
      firstNode = (firstNode <= nodesToMove) ? firstNode : first (array, lastNode - 1, nodesToMove);

      offset = 0;
      if (currentDepth >= insertDepth) {
        offset = Math.min (nodesLeftToMove, 1 << (currentDepth - insertDepth));
      } else if (currentDepth == (insertDepth - 1)) {
        offset = 1;
        if ((array[firstNode]) == lastNode) {
          firstNode++;
        }
      }

      for (i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {
        array[nextNode--] = currentDepth;
      }

      nodesLeftToMove -= offset;
      availableNodes = (lastNode - firstNode + offset) << 1;
    }
  };

  /**
   * Allocates Canonical Huffman code lengths in place based on a sorted
   * frequency array
   * @param array On input, a sorted array of symbol frequencies; On output,
   *              an array of Canonical Huffman code lengths
   * @param maximumLength The maximum code length. Must be at least
   *                      {@code ceil(log2(array.length))}
   */
  // public
  var allocateHuffmanCodeLengths = function(array, maximumLength) {
    switch (array.length) {
    case 2:
      array[1] = 1;
    case 1:
      array[0] = 1;
      return;
    }

    /* Pass 1 : Set extended parent pointers */
    setExtendedParentPointers (array);

    /* Pass 2 : Find number of nodes to relocate in order to achieve
     *          maximum code length */
    var nodesToRelocate = findNodesToRelocate (array, maximumLength);

    /* Pass 3 : Generate code lengths */
    if ((array[0] % array.length) >= nodesToRelocate) {
      allocateNodeLengths (array);
    } else {
      var insertDepth = maximumLength - (Util.fls(nodesToRelocate - 1));
      allocateNodeLengthsWithRelocation (array, nodesToRelocate, insertDepth);
    }
  };

  return freeze({
    allocateHuffmanCodeLengths: allocateHuffmanCodeLengths
  });
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/LogDistanceModel.js":
/*!********************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/LogDistanceModel.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Simple (log n)(n) distance model. */
var libs = [
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Util){

    // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
    // and must return an appropriate model or coder.
    var LogDistanceModel = function(size, extraStates,
                                    lgDistanceModelFactory,
                                    lengthBitsModelFactory) {
        var i;
        var bits = Util.fls(size-1);
        this.extraStates = +extraStates || 0;
        this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);
        // this.distanceModel[n] used for distances which are n-bits long,
        // but only n-1 bits are encoded: the top bit is known to be one.
        this.distanceModel = [];
        for (i=2 ; i <= bits; i++) {
            var numBits = i - 1;
            this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);
        }
    };
    /* you can give this model arguments between 0 and (size-1), or else
       a negative argument which is one of the 'extra states'. */
    LogDistanceModel.prototype.encode = function(distance) {
        if (distance < 2) { // small distance or an 'extra state'
            this.lgDistanceModel.encode(distance + this.extraStates);
            return;
        }
        var lgDistance = Util.fls(distance);
        console.assert(distance & (1<<(lgDistance-1))); // top bit is set
        console.assert(lgDistance >= 2);
        this.lgDistanceModel.encode(lgDistance + this.extraStates);
        // now encode the rest of the bits.
        var rest = distance & ((1 << (lgDistance-1)) - 1);
        this.distanceModel[lgDistance].encode(rest);
    };
    LogDistanceModel.prototype.decode = function() {
        var lgDistance = this.lgDistanceModel.decode() - this.extraStates;
        if (lgDistance < 2) {
            return lgDistance; // this is a small distance or an 'extra state'
        }
        var rest = this.distanceModel[lgDistance].decode();
        return (1 << (lgDistance-1)) + rest;
    };
    return LogDistanceModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Lzjb.js":
/*!********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Lzjb.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* LZJB compression: http://en.wikipedia.org/wiki/LZJB */
var libs = [
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Stream,Util) {
/**
$Id: Iuppiter.js 3026 2010-06-23 10:03:13Z Bear $

Copyright (c) 2010 Nuwa Information Co., Ltd, and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  3. Neither the name of Nuwa Information nor the names of its contributors
     may be used to endorse or promote products derived from this software
     without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

$Author: Bear $
$Date: 2010-06-23 18:03:13 +0800 (, 23  2010) $
$Revision: 3026 $
*/

var Lzjb = Object.create(null);
Lzjb.MAGIC = 'lzjb';

// Constants was used for compress/decompress function.
var NBBY = 8,
    MATCH_BITS = 6,
    MATCH_MIN = 3,
    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),
    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),
    LEMPEL_SIZE_BASE = 1024;
var EOF = Stream.EOF;

// set C_COMPAT to true if you need to decompress with the (untweaked) C lzjb
// implementation, which breaks if offset==0; the javascript
// implementation uses 0 to indicate an offset of OFFSET_MASK+1.
var C_COMPAT = true;

/**
 * Compress string or byte array using fast and efficient algorithm.
 *
 * Because of weak of javascript's natural, many compression algorithm
 * become useless in javascript implementation. The main problem is
 * performance, even the simple Huffman, LZ77/78 algorithm will take many
 * many time to operate. We use LZJB algorithm to do that, it suprisingly
 * fulfills our requirement to compress string fastly and efficiently.
 *
 * Our implementation is based on
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c
 * and
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c
 * It is licensed under CDDL.
 *
 * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array
 *        that you want to compress.
 * @param {stream} output Optional output stream.
 * @return {Array|Uint8Array|Buffer} Compressed byte array, or 'output'
 */
Lzjb.compressFile = Util.compressFileHelper(Lzjb.MAGIC, function(inStream, outStream, fileSize, props) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        hash, hp,
        lempel,
        i, j;
    var retval;

    // in an improvement over the original C implementation, we expand
    // the hash table to track a number of potential matches, not just the
    // most recent.  This doesn't require any changes to the decoder.
    // Sample impact on compression size (on wikipedia data):
    //  EXPAND  Time     Size      Option
    //    1   0m20.321s  50185613    -1
    //    2   0m22.437s  46503301    -2
    //    3   0m23.773s  45744564    -3
    //    4   0m25.666s  45199866    -4
    //    5   0m35.810s  44821413    -5
    //    6   0m40.947s  44666638    -6
    //    8   0m49.639s  44413865    -7
    //   12   0m49.927s  44124825    -8
    //   16   1m01.180s  43972515    -9
    //   32   1m30.530s  43554099
    //   64   2m14.504s  43005530
    //  128   3m43.570s  42361718
    //  256   6m38.681s  41684853
    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;
    var EXPAND = 1; // default to original C impl
    if (typeof(props)==='number') {
        LEMPEL_SIZE *= 2;
        props = Math.max(1, Math.min(9, props)) - 1;
        EXPAND = 1<<Math.floor(props/2);
        if (props&1) EXPAND = Math.round(EXPAND * 1.5);
        if (props >=2 && props <= 4) EXPAND++;
    }

    // use Uint16Array if available (zero-filled)
    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;
    var winput = function(_byte) {
        window[windowpos++] = _byte;
        if (windowpos >= window.length) {
            windowpos = 0;
        }
        return _byte;
    };

    var outwindow = Util.makeU8Buffer(17);
    var outpos = 0;
    var dumpout = function() {
        var i;
        for (i=0; i<outpos; i++) {
            outStream.writeByte(outwindow[i]);
        }
        outpos = 0;
    };

    var unbuffer = [];
    var get = function() {
        if (unbuffer.length)
            return unbuffer.pop();
        return inStream.readByte();
    };
    var unget = function(_byte) {
        unbuffer.push(_byte);
    };

    var copymask = 1 << (NBBY - 1);
    var matchpossibility = [];
    while (true) {
        var c1 = get();
        if (c1 === EOF) break;

        if ((copymask <<= 1) == (1 << NBBY)) {
            dumpout();
            copymask = 1;
            outwindow[0] = 0;
            outpos = 1;
        }

        var c2 = get();
        if (c2 === EOF) {
            outwindow[outpos++] = winput(c1);
            break;
        }
        var c3 = get();
        if (c3 === EOF) {
            outwindow[outpos++] = winput(c1);
            unget(c2);
            continue;
        }

        hash = (c1 << 16) + (c2 << 8) + c3;
        hash ^= (hash >> 9);
        hash += (hash >> 5);
        hash ^= c1;
        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;
        matchpossibility.length = 0;
        for (j=0; j<EXPAND; j++) {
            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;
            cpy = window.length + windowpos - offset;
            var w1 = window[cpy & OFFSET_MASK];
            var w2 = window[(cpy+1) & OFFSET_MASK];
            var w3 = window[(cpy+2) & OFFSET_MASK];
            // if offset is small, we might not have copied the tentative
            // bytes into the window yet.  (Note that offset=0 really means
            // offset=(OFFSET_MASK+1).)
            if (C_COMPAT && offset===0) {
                w1 = c1 ^ 1; // ensure match will fail
            } else if (offset==1) { w2 = c1; w3 = c2; }
            else if (offset==2) { w3 = c1; }
            if (c1 === w1 && c2 === w2 && c3 === w3) {
                matchpossibility.push(offset);
            }
        }
        // store this location in the hash, move the others over to make room
        // oldest match drops off
        for (j=EXPAND-1; j>0; j--)
            lempel[hp+j] = lempel[hp+j-1];
        lempel[hp] = windowpos;
        // did we find any matches?
        if (matchpossibility.length === 0) {
            outwindow[outpos++] = winput(c1);
            unget(c3);
            unget(c2);
        } else {
            // find the longest of the possible matches
            outwindow[0] |= copymask;
            winput(c1); winput(c2); winput(c3);
            var c4 = get(), last = matchpossibility[0];
            var base = window.length + windowpos;
            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {
                if (c4 === EOF) break;
                for (j=0; j < matchpossibility.length; ) {
                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];
                    if (c4 !== w4) {
                        last = matchpossibility[j];
                        matchpossibility.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (matchpossibility.length===0) break; // no more matches
                winput(c4);
                c4 = get();
            }
            if (matchpossibility.length !== 0) {
                // maximum length match, rock on!
                last = matchpossibility[0];
            }
            unget(c4);

            outwindow[outpos++] = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |
                (last >> NBBY);
            outwindow[outpos++] = last & 0xFF;
        }
    }
    dumpout();
});

/**
 * Decompress string or byte array using fast and efficient algorithm.
 *
 * Our implementation is based on
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c
 * and
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c
 * It is licensed under CDDL.
 *
 * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array
 *        that you want to decompress.
 * @param {stream} output Optional output stream.
 * @return {Array|Uint8Array|Buffer} Decompressed byte array, or 'output'
 */
Lzjb.decompressFile = Util.decompressFileHelper(Lzjb.MAGIC, function(inStream, outStream, outSize) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        i, c;
    var retval;

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;

    var copymask = 1 << (NBBY - 1);

    while (outSize !== 0) {
        c = inStream.readByte();
        if (c === EOF) break;

        if ((copymask <<= 1) == (1 << NBBY)) {
            copymask = 1;
            copymap = c;
            c = inStream.readByte();
        }
        if (copymap & copymask) {
            mlen = (c >> (NBBY - MATCH_BITS)) + MATCH_MIN;
            offset = ((c << NBBY) | inStream.readByte()) & OFFSET_MASK;
            cpy = windowpos - offset;
            if (cpy < 0) cpy += window.length;
            if (outSize >= 0) outSize -= mlen;
            while (--mlen >= 0) {
                c = window[windowpos++] = window[cpy++];
                outStream.writeByte(c);
                if (windowpos >= window.length) { windowpos=0; }
                if (cpy >= window.length) { cpy = 0; }
            }
        } else {
            outStream.writeByte(c);
            window[windowpos++] = c;
            if (windowpos >= window.length) { windowpos=0; }
            if (outSize >= 0) outSize--;
        }
    }
});


return Lzjb;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/LzjbR.js":
/*!*********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/LzjbR.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Tweaked version of LZJB, using range coder. */
var libs = [
	__webpack_require__(/*! ./Context1Model */ "./node_modules/keybase-compressjs/outlib/Context1Model.js"),
	__webpack_require__(/*! ./FenwickModel */ "./node_modules/keybase-compressjs/outlib/FenwickModel.js"),
	__webpack_require__(/*! ./LogDistanceModel */ "./node_modules/keybase-compressjs/outlib/LogDistanceModel.js"),
	__webpack_require__(/*! ./NoModel */ "./node_modules/keybase-compressjs/outlib/NoModel.js"),
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Context1Model,FenwickModel,LogDistanceModel,NoModel,RangeCoder,Stream,Util){

var LzjbR = Object.create(null);
LzjbR.MAGIC = 'lzjR';

// Constants was used for compress/decompress function.
var NBBY = 8,
    MATCH_BITS = 6,
    MATCH_MIN = 3,
    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),
    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),
    LEMPEL_SIZE_BASE = 1024;
var LENGTH_MODEL_CUTOFF = 32;


/**
 * Compress using modified LZJB algorithm.  Instead of using the simple
 * 9-bit literal / 17-bit match format of the original, use a range
 * coder for the literal/match bit and for the offset and length.
 */
LzjbR.compressFile = Util.compressFileHelper(LzjbR.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        hash, hp,
        lempel,
        i, j;

    // in an improvement over the original C implementation of LZJB, we expand
    // the hash table to track a number of potential matches, not just the
    // most recent.  This doesn't require any changes to the decoder.
    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;
    var EXPAND = 1; // default to original C impl
    if (typeof(props)==='number') {
        LEMPEL_SIZE *= 2;
        props = Math.max(1, Math.min(9, props)) - 1;
        EXPAND = 1<<Math.floor(props/2);
        if (props&1) EXPAND = Math.round(EXPAND * 1.5);
        if (props >=2 && props <= 4) EXPAND++;
    }

    var encoder = new RangeCoder(outStream);
    encoder.encodeStart(finalByte, 1);

    // use Uint16Array if available (zero-filled)
    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;
    var winput = function(_byte) {
        window[windowpos++] = _byte;
        if (windowpos >= window.length) {
            windowpos = 0;
        }
        return _byte;
    };

    var unbuffer = [];
    var get = function() {
        if (unbuffer.length)
            return unbuffer.pop();
        return inStream.readByte();
    };
    var unget = function(_byte) {
        unbuffer.push(_byte);
    };

    var matchpossibility = [];
    var MATCH = 256;
    var EOF_SYM = 257;
    var noModelFactory = NoModel.factory(encoder);
    var modelFactory = FenwickModel.factory(encoder, 0xFF00, 0x100);
    var literalModel = new Context1Model(modelFactory, 256,
                                         ((fileSize<0) ? EOF_SYM : MATCH) + 1);
    var sparseModelFactory = function(size) {
        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }
        return noModelFactory(size);
    };
    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,
                                        modelFactory, sparseModelFactory);
    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,
                                        modelFactory, sparseModelFactory);
    var lastChar = 0x20, lastOffset = 0;
    while (true) {
        var initialPos = windowpos;
        var c1 = get();
        if (c1 === Stream.EOF) break;

        var c2 = get();
        if (c2 === Stream.EOF) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            break;
        }
        var c3 = get();
        if (c3 === Stream.EOF) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            unget(c2); lastChar = c1;
            continue;
        }

        hash = (c1 << 16) + (c2 << 8) + c3;
        hash ^= (hash >> 9);
        hash += (hash >> 5);
        hash ^= c1;
        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;
        matchpossibility.length = 0;
        for (j=0; j<EXPAND; j++) {
            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;
            cpy = window.length + windowpos - offset;
            var w1 = window[cpy & OFFSET_MASK];
            var w2 = window[(cpy+1) & OFFSET_MASK];
            var w3 = window[(cpy+2) & OFFSET_MASK];
            // if offset is small, we might not have copied the tentative
            // bytes into the window yet.  (Note that offset=0 really means
            // offset=(OFFSET_MASK+1).)
            if (offset==1) { w2 = c1; w3 = c2; }
            else if (offset==2) { w3 = c1; }
            if (c1 === w1 && c2 === w2 && c3 === w3) {
                matchpossibility.push(offset);
            }
        }
        // store this location in the hash, move the others over to make room
        // oldest match drops off
        for (j=EXPAND-1; j>0; j--)
            lempel[hp+j] = lempel[hp+j-1];
        lempel[hp] = windowpos;
        // did we find any matches?
        if (matchpossibility.length === 0) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            unget(c3);
            unget(c2);
            lastChar = c1;
        } else {
            literalModel.encode(MATCH, lastChar); // a match!
            // find the longest of the possible matches
            winput(c1); winput(c2); winput(c3); lastChar = c3;
            var c4 = get(), last = matchpossibility[0];
            var base = window.length + windowpos;
            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {
                if (c4 === Stream.EOF) break;
                for (j=0; j < matchpossibility.length; ) {
                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];
                    if (c4 !== w4) {
                        last = matchpossibility[j];
                        matchpossibility.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (matchpossibility.length===0) break; // no more matches
                winput(c4); lastChar = c4;
                c4 = get();
            }
            if (matchpossibility.length !== 0) {
                // maximum length match, rock on!
                last = matchpossibility[0];
            }
            unget(c4);

            // encode match length
            // XXX we could get a bit more compression if we allowed
            // the length to predict the offset (or vice-versa)
            lenModel.encode(mlen - MATCH_MIN);
            offset = (initialPos - last) & OFFSET_MASK;
            if (offset === lastOffset) {
                posModel.encode(-1); // common case!
            } else {
                posModel.encode(offset);
                lastOffset = offset;
            }
        }
    }
    if (fileSize < 0) {
        literalModel.encode(EOF_SYM, lastChar); // end of file (streaming)
    }
    encoder.encodeFinish();
}, true);

/**
 * Decompress using modified LZJB algorithm.
 */
LzjbR.decompressFile = Util.decompressFileHelper(LzjbR.MAGIC, function(inStream, outStream, outSize) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        i, c;

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;

    var decoder = new RangeCoder(inStream);
    decoder.decodeStart(true/* we already read the 'free' byte*/);

    var MATCH = 256;
    var EOF_SYM = 257;
    var noModelFactory = NoModel.factory(decoder);
    var modelFactory = FenwickModel.factory(decoder, 0xFF00, 0x100);
    var literalModel = new Context1Model(modelFactory, 256,
                                         ((outSize<0) ? EOF_SYM : MATCH) + 1);
    var sparseModelFactory = function(size) {
        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }
        return noModelFactory(size);
    };
    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,
                                        modelFactory, sparseModelFactory);
    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,
                                        modelFactory, sparseModelFactory);
    var lastChar = 0x20, lastOffset = 0;
    while (outSize !== 0) {
        c = literalModel.decode(lastChar);
        if (c === EOF_SYM) {
            break;
        } else if (c === MATCH) {
            mlen = lenModel.decode() + MATCH_MIN;
            cpy = posModel.decode();
            if (cpy<0) { cpy = lastOffset; }
            else       { lastOffset = cpy; }
            if (outSize >= 0) outSize -= mlen;
            while (--mlen >= 0) {
                c = lastChar = window[windowpos++] = window[cpy++];
                outStream.writeByte(c);
                if (windowpos >= window.length) { windowpos=0; }
                if (cpy >= window.length) { cpy = 0; }
            }
        } else {
            outStream.writeByte(c);
            window[windowpos++] = lastChar = c;
            if (windowpos >= window.length) { windowpos=0; }
            if (outSize >= 0) outSize--;
        }
    }
    decoder.decodeFinish();
});


return LzjbR;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Lzp3.js":
/*!********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Lzp3.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Implementation of LZP3(ish), with an adaptive Huffman code or a range
 * coder (instead of LZP3's original static Huffman code).
 * See: http://www.cbloom.com/papers/lzp.pdf
 */
var libs = [
	__webpack_require__(/*! ./BitStream */ "./node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__(/*! ./Context1Model */ "./node_modules/keybase-compressjs/outlib/Context1Model.js"),
	__webpack_require__(/*! ./DefSumModel */ "./node_modules/keybase-compressjs/outlib/DefSumModel.js"),
	__webpack_require__(/*! ./FenwickModel */ "./node_modules/keybase-compressjs/outlib/FenwickModel.js"),
	__webpack_require__(/*! ./Huffman */ "./node_modules/keybase-compressjs/outlib/Huffman.js"),
	__webpack_require__(/*! ./LogDistanceModel */ "./node_modules/keybase-compressjs/outlib/LogDistanceModel.js"),
	__webpack_require__(/*! ./NoModel */ "./node_modules/keybase-compressjs/outlib/NoModel.js"),
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream, Context1Model, DefSumModel, FenwickModel, Huffman, LogDistanceModel, NoModel, RangeCoder, Stream, Util){

var Lzp3 = Object.create(null);
Lzp3.MAGIC = 'lzp3';

// use Huffman coder (fast) or else use range coder (slow)
var USE_HUFFMAN_CODE = false;
// use deferred-sum model, which is supposed to be faster (but compresses worse)
var USE_DEFSUM = false;
// when to give up attempting to model the length
var LENGTH_MODEL_CUTOFF = 256;
var MODEL_MAX_PROB = 0xFF00;
var MODEL_INCREMENT = 0x100;

// Constants was used for compress/decompress function.
var CTXT4_TABLE_SIZE = 1 << 16;
var CTXT3_TABLE_SIZE = 1 << 12;
var CTXT2_TABLE_SIZE = 1 << 16;
var CONTEXT_LEN = 4;
var LOG_WINDOW_SIZE = 20;
var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;
var MAX_MATCH_LEN = WINDOW_SIZE-1;
var MATCH_LEN_CONTEXTS = 16;

var MAX32 = 0xFFFFFFFF;
var MAX24 = 0x00FFFFFF;
var MAX16 = 0x0000FFFF;
var MAX8  = 0x000000FF;


var Window = function(maxSize) {
  this.buffer = Util.makeU8Buffer(Math.min(maxSize+4, WINDOW_SIZE));
  this.pos = 0;
  // context-4 hash table.
  this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);
  // context-3 hash table
  this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);
  // context-2 table (not really a hash any more)
  this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);
  // initial context
  this.put(0x63); this.put(0x53); this.put(0x61); this.put(0x20);
};
Window.prototype.put = function(_byte) {
  this.buffer[this.pos++] = _byte;
  if (this.pos >= WINDOW_SIZE) { this.pos = 0; }
  return _byte;
};
Window.prototype.get = function(pos) {
  return this.buffer[pos & (WINDOW_SIZE-1)];
};
Window.prototype.context = function(pos, n) {
  var c = 0, i;
  pos = (pos - n) & (WINDOW_SIZE-1);
  for (i=0; i<n; i++) {
    c = (c << 8) | this.buffer[pos++];
    if (pos >= WINDOW_SIZE) { pos = 0; }
  }
  return c;
};
// if matchLen !== 0, update the index; otherwise get index value.
Window.prototype.getIndex = function(s, matchLen) {
  var c = this.context(s, 4);
  // compute context hashes
  var h4 = ((c>>>15) ^ c) & (CTXT4_TABLE_SIZE-1);
  var h3 = ((c>>>11) ^ c) & (CTXT3_TABLE_SIZE-1);
  var h2 = c & MAX16;
  // check order-4 context
  var p = 0, checkc;
  // only do context confirmation if matchLen==0 (that is, if we're not just
  // doing an update)
  if (matchLen===0) {
    p = this.ctxt4[h4];
    if (p !== 0 && c !== this.context(p-1, 4)) {
      p = 0; // context confirmation failed
    }
    if (p === 0) {
      // check order-3 context
      p = this.ctxt3[h3];
      if (p !== 0 && (c & MAX24) !== this.context(p-1, 3)) {
        p = 0; // context confirmation failed
      }
      if (p === 0) {
        // check order-2 context
        p = this.ctxt2[h2];
        if (p !== 0 && (c && MAX16) !== this.context(p-1, 2)) {
          p = 0; // context confirmation failed
        }
      }
    }
  }
  // update context index
  if (matchLen) { matchLen--; }
  this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =
    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;
  // return lookup result.
  return p;
};

/**
 * Compress using modified LZP3 algorithm.  Instead of using static
 * Huffman coding, we use an adaptive Huffman code or range encoding.
 */
Lzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {
  // sliding window & hash table
  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );

  var coderFactory, sparseCoderFactory, flush;

  if (USE_HUFFMAN_CODE) {
    // Huffman contexts
    outStream.writeByte(0x80); // mark that this is Huffman coded.
    var bitstream = new BitStream(outStream);
    flush = bitstream.flush.bind(bitstream);
    coderFactory = Huffman.factory(bitstream, MAX16);
    sparseCoderFactory = NoModel.factory(bitstream);

  } else { // range encoder
    var range = new RangeCoder(outStream);
    range.encodeStart(0x00, 0); // 0x00 == range encoded

    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
    if (USE_DEFSUM) {
      coderFactory = DefSumModel.factory(range, false /* encoder */);
    }
    // switch sparseCoderFactory to a NoModel when size > cutoff
    var noCoderFactory = NoModel.factory(range);
    sparseCoderFactory = function(size) {
      if (size > LENGTH_MODEL_CUTOFF) {
        return noCoderFactory(size);
      }
      return coderFactory(size);
    };
    flush = function() { range.encodeFinish(); };
  }

  var huffLiteral= new Context1Model(coderFactory, 256,
                                     (fileSize<0) ? 257 : 256);
  var huffLen = [], i;
  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {
    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,
                                      coderFactory, sparseCoderFactory);
  }

  var inSize = 0, s, matchContext = 0;
  while (inSize !== fileSize) {
    var ch = inStream.readByte();
    s = window.pos;
    var p = window.getIndex(s, 0);
    if (p !== 0) {
      // great, a match! how long is it?
      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
      var matchLen = 0;
      while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {
        matchLen++;
        window.put(ch);
        ch = inStream.readByte();
      }
      // code match length; match len = 0 means "literal"
      // use "extra state" -1 to mean "same as previous match length"
      if (prevMatchLen===matchLen) {
        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(-1);
      } else {
        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(matchLen);
      }
      // update hash with this match
      window.getIndex(s, matchLen);
      inSize += matchLen;
      matchContext <<= 1;
      if (matchLen > 0) { matchContext |= 1; }
      // XXX: LZMA uses a special "delta match" context here if matchLen==0
      // XXX: it also uses the offset as context for the length (or vice-versa)
    }
    // always encode a literal after a match
    var context1 = window.get(window.pos-1);
    if (ch===Stream.EOF) {
      if (fileSize < 0) {
        huffLiteral.encode(256, context1);
      }
      break;
    }
    huffLiteral.encode(ch, context1);
    window.put(ch);
    inSize++;
  }
  if (flush) flush();
});

/**
 * Decompress using modified LZP3 algorithm.
 */
Lzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {
  var flags = inStream.readByte();
  var use_huffman_code = !!(flags & 0x80);

  // sliding window & hash table
  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );

  var coderFactory, sparseCoderFactory, finish;

  if (use_huffman_code) {
    // Huffman contexts
    var bitstream = new BitStream(inStream);
    coderFactory = Huffman.factory(bitstream, MAX16);
    sparseCoderFactory = NoModel.factory(bitstream);
  } else { // range encoder
    var range = new RangeCoder(inStream);
    range.decodeStart(true/* skip initial read */);
    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
    if (USE_DEFSUM) {
      coderFactory = DefSumModel.factory(range, true /* decoder */);
    }
    // switch sparseCoderFactory to a NoModel when size > cutoff
    var noCoderFactory = NoModel.factory(range);
    sparseCoderFactory = function(size) {
      if (size > LENGTH_MODEL_CUTOFF) {
        return noCoderFactory(size);
      }
      return coderFactory(size);
    };
    finish = function() { range.decodeFinish(); };
  }

  var huffLiteral= new Context1Model(coderFactory, 256,
                                     (fileSize<0) ? 257 : 256);
  var huffLen = [], i;
  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {
    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,
                                      coderFactory, sparseCoderFactory);
  }

  var s, ch, outSize = 0, matchContext = 0;
  while (outSize !== fileSize) {
    s = window.pos;
    var p = window.getIndex(s, 0);
    if (p !== 0) {
      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
      var matchLen = huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].decode();
      if (matchLen < 0) { matchLen = prevMatchLen; }
      // copy characters!
      for (i=0; i<matchLen; i++) {
        ch = window.get(p + i);
        outStream.writeByte(window.put(ch));
      }
      window.getIndex(s, matchLen);
      outSize += matchLen;
      matchContext <<= 1;
      if (matchLen > 0) matchContext |= 1;
    }
    // literal always follows match (or failed match)
    if (outSize === fileSize) {
      break; // EOF
    }
    var context1 = window.get(window.pos-1);
    ch = huffLiteral.decode(context1);
    if (ch === 256) {
      break; // EOF
    }
    outStream.writeByte(window.put(ch));
    outSize++;
  }
  if (finish) finish();
});


return Lzp3;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/MTFModel.js":
/*!************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/MTFModel.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Simple range coding model w/ escape, suitable for sparse symbol sets.
 *  Uses a move-to-front list, which is simple and relatively performant,
 *  but slows down a lot if you want to try to model escapes more precisely
 *  (which is why this feature is disabled by default).
 */
var libs = [
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){

var DEFAULT_MAX_PROB = 0xFF00;
var DEFAULT_INCREMENT= 0x0100;

var NUMERIC_SORT = function(a, b) { return a - b; };

var MTFModel = function(coder, size, max_prob, increment, betterEscape) {
    this.coder = coder;
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);
    this.sym = Util.makeU16Buffer(size+1);
    this.prob= Util.makeU16Buffer(size+2);
    this.sym[0] = size; // escape code
    this.prob[0]= 0;
    this.seenSyms = 1;
    // total probability always found in this.prob[this.seenSyms]
    this.prob[this.seenSyms] = this.increment;
    this.numSyms = size;
    if (betterEscape) {
        this.sortedSeen = [size];
    }
};
MTFModel.factory = function(coder, max_prob, increment, betterEscape) {
    return function(size) {
        return new MTFModel(coder, size, max_prob, increment, betterEscape);
    };
};
MTFModel.prototype.clone = function() {
    var newModel = new MTFModel(this.coder, this.numSyms, this.max_prob,
                                this.increment, !!this.sortedSeen);
    var i;
    for (i=0; i<this.seenSyms; i++) {
        newModel.sym[i] = this.sym[i];
        newModel.prob[i] = this.prob[i];
    }
    newModel.prob[i] = this.prob[i]; // total probability
    newModel.seenSyms = this.seenSyms;
    if (this.sortedSeen) {
        newModel.sortedSeen = this.sortedSeen.slice(0);
    }
    return newModel;
};
MTFModel.prototype._update = function(symbol, index, sy_f) {
    var j, tot_f;
    // move this symbol to the end
    for (j=index; j<this.seenSyms-1; j++) {
        this.sym[j] = this.sym[j+1];
        this.prob[j] = this.prob[j+1] - sy_f;
    }
    if (index < this.seenSyms) {
        this.sym[j] = symbol;
        this.prob[j] = this.prob[j+1] - sy_f;
        // increase frequency for this symbol, and total freq at same time
        this.prob[this.seenSyms] = tot_f =
            this.prob[this.seenSyms] + this.increment;
        if (symbol === this.numSyms && this.seenSyms >= this.numSyms) {
            // this is the last time we'll see an escape! remove it.
            tot_f = this.prob[--this.seenSyms];
            if (this.sortedSeen) { this.sortedSeen.length--; }
        }
    } else { // add to the end
        tot_f = this.prob[this.seenSyms];
        this.sym[index] = symbol;
        this.prob[index] = tot_f;
        tot_f += this.increment;
        this.prob[++this.seenSyms] = tot_f;
        if (this.sortedSeen) {
            this.sortedSeen.push(symbol);
            // hopefully sort is very fast on a mostly-sorted array
            this.sortedSeen.sort(NUMERIC_SORT);
        }
    }
    if (tot_f >= this.max_prob) { this._rescale(); }
    return;
};
MTFModel.prototype._rescale = function() {
    var i, j, total=0;
    var noEscape = true;
    if (this.sortedSeen) { this.sortedSeen.length = 0; }
    for(i=0, j=0; i<this.seenSyms; i++) {
        var sym = this.sym[i];
        var sy_f = this.prob[i+1] - this.prob[i];
        sy_f >>>= 1;
        if (sy_f > 0) {
            if (sym === this.numSyms) {
                noEscape = false;
            }
            this.sym[j] = sym;
            this.prob[j++] = total;
            total += sy_f;
            if (this.sortedSeen) { this.sortedSeen.push(sym); }
        }
    }
    this.prob[j] = total;
    this.seenSyms = j;
    if (this.sortedSeen) {
        this.sortedSeen.sort(NUMERIC_SORT);
    }
    // don't allow escape to go to zero prob if we still need it
    if (noEscape && this.seenSyms < this.numSyms) {
        // NOTE this adds this.increment to escape freq; the FenwickModel
        //      just adds one.
        this._update(this.numSyms/*escape*/, this.seenSyms/*at end*/);
    }
};
MTFModel.prototype.decode = function() {
    var tot_f = this.prob[this.seenSyms];
    var prob = this.coder.decodeCulFreq(tot_f);
    // we're expecting to find the probability near the "most recent" side
    // of our array
    var i;
    for (i=this.seenSyms-1; i>=0; i--) {
        if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)
            break;
    }
    console.assert(i>=0);
    var symbol = this.sym[i];
    var lt_f = this.prob[i];
    var sy_f = this.prob[i + 1] - lt_f;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    this._update(symbol, i, sy_f);
    if (symbol === this.numSyms) {
        /* this is an escape */
        /* decode the literal */
        sy_f = 1;
        tot_f = this.numSyms;
        if (this.sortedSeen) {
            // do a slower, but more precise decoding of the literal
            // by excluding the already-seen symbols.
            var seen = this.sortedSeen;
            tot_f = this.numSyms - this.seenSyms;
            if (seen[seen.length-1] === this.numSyms) { tot_f++; }
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
            for (i=0; i < seen.length && seen[i] <= symbol ; i++) {
                symbol++;
            }
        } else {
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
        }
        this.coder.decodeUpdate(sy_f, lt_f, tot_f);
        this._update(symbol, this.seenSyms);
    }
    return symbol;
};
MTFModel.prototype.encode = function(symbol) {
    // look for symbol, from most-recent to oldest
    var i, sy_f, lt_f, tot_f;
    for (i=this.seenSyms-1; i>=0; i--) {
        if (symbol === this.sym[i]) {
            // ok, found it.
            lt_f = this.prob[i];
            sy_f = this.prob[i + 1] - lt_f;
            tot_f = this.prob[this.seenSyms];
            this.coder.encodeFreq(sy_f, lt_f, tot_f);
            return this._update(symbol, i, sy_f);
        }
    }
    // couldn't find this symbol.  encode as escape.
    console.assert(symbol !== this.numSyms); // catch infinite recursion
    this.encode(this.numSyms); // guaranteed to be found in the table.
    // code symbol as literal
    sy_f = 1;
    lt_f = symbol;
    tot_f = this.numSyms;
    if (this.sortedSeen) {
        // do a slower, but more precise encoding of the literal
        // by excluding the already-seen symbols.
        var seen = this.sortedSeen;
        tot_f -= this.seenSyms;
        if (seen[seen.length-1] === this.numSyms) { tot_f++; }
        for (i=0; i < seen.length && seen[i] < symbol; i++) {
            lt_f--;
        }
    }
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // now add symbol to the end.
    return this._update(symbol, this.seenSyms);
};

MTFModel.MAGIC = 'mtfm';
/** Simple order-0 compressor, as self-test. */
MTFModel.compressFile = Util.compressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
}, true);

/** Simple order-0 decompresser, as self-test. */
MTFModel.decompressFile = Util.decompressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*we already read the 'free' byte*/);
  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

return MTFModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/NoModel.js":
/*!***********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/NoModel.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Simple "lack of model" -- just encode the bits directly.
 *  Useful especially with sparse spaces or Huffman coders where there's
 *  no obvious prediction to be made that will pay for itself.
 */
var libs = [
	__webpack_require__(/*! ./BitStream */ "./node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream,Util) {

var NoModel = function(bitstream, size) {
  this.bitstream = bitstream;
  this.bits = Util.fls(size-1);
};
NoModel.factory = function(bitstream) {
  return function(size) { return new NoModel(bitstream, size); };
};
NoModel.prototype.encode = function(symbol) {
  var i;
  for (i=this.bits-1; i>=0; i--) {
    var b = (symbol >>> i) & 1;
    this.bitstream.writeBit(b);
  }
};
NoModel.prototype.decode = function() {
  var i, r = 0;
  for (i=this.bits-1; i>=0; i--) {
    r <<= 1;
    if (this.bitstream.readBit()) r++;
  }
  return r;
};

/** Brain-dead self-test. */
NoModel.MAGIC = 'nomo';
NoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {
    var bitstream = new BitStream(outStream);
    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    bitstream.flush();
});
NoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {
    var bitstream = new BitStream(inStream);
    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
});

return NoModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/PPM.js":
/*!*******************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/PPM.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Particularly simple-minded implementation of PPM compression. */
var libs = [
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Util) {

  var MAX_CONTEXT = 5;
  var LOG_WINDOW_SIZE = 18;
  var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;

  var Window = function() {
    this.buffer = Util.makeU8Buffer(WINDOW_SIZE);
    this.pos = 0;
    this.firstPass = true;
    for (var i=0; i<MAX_CONTEXT; i++) {
      this.put('cSaCsA'.charCodeAt(i%6));
    }
  };
  Window.prototype.put = function(_byte) {
    this.buffer[this.pos++] = _byte;
    if (this.pos >= WINDOW_SIZE) { this.pos = 0; this.firstPass = false; }
    return _byte;
  };
  Window.prototype.get = function(pos) {
    return this.buffer[pos & (WINDOW_SIZE-1)];
  };
  // the context ending just before 'pos'
  Window.prototype.context = function(pos, n) {
    var c = [], i;
    pos = (pos - n) & (WINDOW_SIZE-1);
    for (i=0; i<n; i++) {
      c.push(this.buffer[pos++]);
      if (pos >= WINDOW_SIZE) { pos = 0; }
    }
    return String.fromCharCode.apply(String, c);
  };

  var DMM_INCREMENT = 0x100, DMM_MAX_PROB = 0xFF00;

  var PPM = function(coder, size) {
    this.window = new Window();
    this.contexts = Object.create(null);
    // brain-dead '-1' context, using full exclusion
    var Cm1Context = function() { };
    Cm1Context.prototype.encode = function(symbol, exclude) {
      var i, lt_f = 0;
      for (i=0; i<symbol; i++) {
        if (!exclude[i]) {
          lt_f++;
        }
      }
      var tot_f = size - exclude.total;
      coder.encodeFreq(1, lt_f, tot_f);
    };
    Cm1Context.prototype.decode = function(exclude) {
      var i, symbol, lt_f;
      var tot_f = size - exclude.total;
      symbol = lt_f = coder.decodeCulFreq(tot_f);
      for (i=0; i<=symbol; i++) {
        if (exclude[i]) {
          symbol++;
        }
      }
      coder.decodeUpdate(1, lt_f, tot_f);
      return symbol;
    };
    this.cm1coder = new Cm1Context();

    var DenseMTFModel = function() {
      this.sym = [size];
      this.prob= [0, DMM_INCREMENT];
      this.refcount = 0;
    };
    DenseMTFModel.prototype._rescale = function() {
      var seenSyms = this.sym.length;
      var i, j, total=0;
      var noEscape = true;
      for(i=0, j=0; i<seenSyms; i++) {
        var sym = this.sym[i];
        var sy_f = this.prob[i+1] - this.prob[i];
        sy_f >>>= 1;
        if (sy_f > 0) {
          if (sym === size) {
            noEscape = false;
          }
          this.sym[j] = sym;
          this.prob[j++] = total;
          total += sy_f;
        }
      }
      this.prob[j] = total;
      seenSyms = this.sym.length = j;
      this.prob.length = seenSyms + 1;
      // don't allow escape to go to zero prob if we still need it
      if (noEscape && seenSyms < size) {
        total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);
      }
      return total;
    };
    DenseMTFModel.prototype.update = function(symbol, incr) {
      // find symbol
      var i=0;
      for (i=0; i<this.sym.length; i++) {
        if (this.sym[i] === symbol) {
          return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);
        }
      }
      // symbol escaped
      return this._update(symbol, i, 0, incr);
    };
    DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {
      var seenSyms = this.sym.length;
      var i, j, tot_f;
      // move this symbol to the end
      for (j=index; j<seenSyms-1; j++) {
        this.sym[j] = this.sym[j+1];
        this.prob[j] = this.prob[j+1] - sy_f;
      }
      // "method D" -- if we add a new escaped symbol, escape & the symbol
      // both increase by 1/2.
      if (index < seenSyms) {
        this.sym[j] = symbol;
        this.prob[j] = this.prob[j+1] - sy_f;
        // increase frequency for this symbol, and total freq at same time
        this.prob[seenSyms] = tot_f =
          this.prob[seenSyms] + incr;
      } else { // add to the end
        tot_f = this.prob[seenSyms];
        this.sym[index] = symbol;
        this.prob[index] = tot_f;
        tot_f += incr;
        this.prob[++seenSyms] = tot_f;
        // remove probability of escape if table just filled up
        if (this.sym.length > size) {
          for (i=0; i<seenSyms; i++) {
            if (size === this.sym[i]) {
              // found it.
              this._update(size, i, this.prob[i+1] - this.prob[i], -1);
              this.sym.length--;
              this.prob.length--;
              tot_f = this.prob[this.prob.length-1];
            }
          }
        }
      }
      if (tot_f >= DMM_MAX_PROB) { tot_f = this._rescale(); }
      return tot_f;
    };
    DenseMTFModel.prototype.encode = function(symbol, exclude) {
      // look for symbol, from most-recent to oldest
      var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;
      var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
      for (i=seenSyms-1; i>=0; i--) {
        lt_f = this.prob[i];
        sy_f = this.prob[i + 1] - lt_f;
        if (symbol === this.sym[i]) {
          // ok, found it.
          // count up the rest of the probabilities
          for (j=i-1; j>=0 && ex_seen < exclude.total; j--) {
            if (exclude[this.sym[j]]) {
              ex_seen += 1;
              ex_sy_f = this.prob[j+1] - this.prob[j];
              ex_lt_f += ex_sy_f;
              ex_tot_f += ex_sy_f;
            }
          }
          tot_f = this.prob[seenSyms];
          // adjust by excluded symbols
          lt_f -= ex_lt_f;
          tot_f -= ex_tot_f;
          coder.encodeFreq(sy_f, lt_f, tot_f);
          if (symbol === size) { // only update table for escapes
            this._update(symbol, i, sy_f, DMM_INCREMENT/2);
            return false; // escape.
          } // otherwise we'll do update later
          return true; // encoded character!
        } else if (exclude[this.sym[i]]) {
          ex_seen += 1;
          ex_tot_f += sy_f;
        }
      }
      // couldn't find this symbol.  encode as escape.
      this.encode(size, exclude);
      // add symbols to exclusion table
      console.assert(this.sym[this.sym.length-1] === size);//escape
      for (i=0; i<this.sym.length-1; i++) {
        if (!exclude[this.sym[i]]) {
          exclude[this.sym[i]] = true;
          exclude.total++;
        }
      }
    };
    DenseMTFModel.prototype.decode = function(exclude) {
      var seenSyms = this.sym.length;
      var tot_f = this.prob[seenSyms];
      var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
      var i;
      for (i=seenSyms-1; i>=0 && ex_seen < exclude.total; i--) {
        if (exclude[this.sym[i]]) {
          ex_seen += 1;
          ex_tot_f += this.prob[i+1] - this.prob[i];
        }
      }
      var prob = coder.decodeCulFreq(tot_f - ex_tot_f) + ex_tot_f;
      // we're expecting to find the probability near the "most recent" side
      // of our array
      ex_lt_f = ex_tot_f;
      for (i=seenSyms-1; i>=0; i--) {
        if (exclude[this.sym[i]]) {
          ex_sy_f = this.prob[i+1] - this.prob[i];
          ex_lt_f -= ex_sy_f;
          prob -= ex_sy_f;
        } else if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)
          break;
      }
      console.assert(i>=0);
      var symbol = this.sym[i];
      var lt_f = this.prob[i];
      var sy_f = this.prob[i + 1] - lt_f;
      coder.decodeUpdate(sy_f, lt_f - ex_lt_f, tot_f - ex_tot_f);
      // defer update
      if (symbol < size) { return symbol; }
      // an escape
      this._update(symbol, i, sy_f, DMM_INCREMENT/2);
      // add symbols to exclusion table
      console.assert(this.sym[this.sym.length-1] === size);//escape
      for (i=0; i<this.sym.length-1; i++) {
        if (!exclude[this.sym[i]]) {
          exclude[this.sym[i]] = true;
          exclude.total++;
        }
      }
      return -1;
    };
    this.newContext = function(initialSymbol) {
      return new DenseMTFModel();
    };
    this.newExclude = function() {
      var result = Object.create(null);
      result.total = 0; // no excluded symbols (yet)
      return result;
    };
    // set up some initial contexts
    (function() {
      var i, j;
      for (i=0; i<MAX_CONTEXT; i++) {
        for (j=0; j<=i; j++) {
          var cc = this.window.context(j+((MAX_CONTEXT-1)-i), j);
          if (!this.contexts[cc]) { this.contexts[cc] = this.newContext(); }
          this.contexts[cc].refcount++;
        }
      }
    }).call(this);
  };
  PPM.prototype.update = function(symbol, contextString, matchLevel) {
    // slide up the contexts, updating them
    var model, c, cc;
    for (c=0; c <= MAX_CONTEXT; c++) {
      cc = contextString.slice(MAX_CONTEXT - c);
      model = this.contexts[cc];
      if (!model) {
        model = this.contexts[cc] = this.newContext();
      }
      if (c >= matchLevel) {
        // only update useful contexts
        model.update(symbol, DMM_INCREMENT / 2);
      }
      // refcount all contexts, whether used/updated or not
      model.refcount++;
    }
    // now garbage-collect old contexts
    contextString = this.window.context(this.window.pos + MAX_CONTEXT,
                                        MAX_CONTEXT);
    var firstPass = this.window.firstPass;
    for (c=MAX_CONTEXT; c>=0 && !firstPass; c--) {
      cc = contextString.slice(0, c);
      model = this.contexts[cc];
      console.assert(model);
      if ((--model.refcount) <= 0) {
        console.assert(cc !== ''); // don't allow context-0 to be gc'ed!
        delete this.contexts[cc];
      }
    }
    // ok, advance window.
    this.window.put(symbol);
  };
  PPM.prototype.decode = function() {
    var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
    var exclude = this.newExclude();
    var model, c, cc, symbol;
    for (c=MAX_CONTEXT; c>=0; c--) {
      cc = contextString.slice(MAX_CONTEXT - c);
      model = this.contexts[cc];
      if (model) {
        symbol = model.decode(exclude);
        if (symbol >= 0) {
          this.update(symbol, contextString, c);
          return symbol;
        }
      }
    }
    // still no match, fall back to context -1
    symbol = this.cm1coder.decode(exclude);
    this.update(symbol, contextString, c);
    return symbol;
  };
  PPM.prototype.encode = function(symbol) {
    var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
    var exclude = this.newExclude();
    var c;
    for (c=MAX_CONTEXT; c>=0; c--) {
      var cc = contextString.slice(MAX_CONTEXT - c);
      var model = this.contexts[cc];
      if (model) {
        var success = model.encode(symbol, exclude);
        if (success) {
          this.update(symbol, contextString, c);
          return;
        }
      }
    }
    // fall back to context -1 (but still use exclusion table)
    this.cm1coder.encode(symbol, exclude);
    this.update(symbol, contextString, c);
    return;
  };

  PPM.MAGIC = 'ppm2';
  PPM.compressFile = Util.compressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var range = new RangeCoder(outStream);
    range.encodeStart(finalByte, 1);
    var model = new PPM(range, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    range.encodeFinish();
  }, true);
  PPM.decompressFile = Util.decompressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize) {
    var range = new RangeCoder(inStream);
    range.decodeStart(true/*we already read the 'free' byte*/);
    var model = new PPM(range, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
    range.decodeFinish();
  });

  return PPM;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/RangeCoder.js":
/*!**************************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/RangeCoder.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Range Coder.  Inspired by rangecod.c from rngcod13.zip from
 *    http://www.compressconsult.com/rangecoder/
 * This JavaScript version is:
 *    Copyright (c) 2013 C. Scott Ananian.
 */
var libs = [
];
var body_fn = function (){

    // Uses 32-bit integer math.  Hopefully the JavaScript runtime figures
    // that out. ;)
    // see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript
    // for some hints on doing 32-bit unsigned match in JavaScript.
    // One key is the use of ">>>0" to change a signed result to unsigned.
    var CODE_BITS = 32;
    var Top_value = Math.pow(2, CODE_BITS-1);
    var SHIFT_BITS = (CODE_BITS - 9);
    var EXTRA_BITS = ((CODE_BITS-2) % 8 + 1);
    var Bottom_value = (Top_value >>> 8);

    var MAX_INT = Math.pow(2, CODE_BITS) - 1;

    /* it is highly recommended that the total frequency count is less  */
    /* than 1 << 19 to minimize rounding effects.                       */
    /* the total frequency count MUST be less than 1<<23                */


    var RangeCoder = function(stream) {
        this.low = 0; /* low end of interval */
        this.range = Top_value; /* length of interval */
        this.buffer = 0; /* buffer for input/output */
        this.help = 0; /* bytes_to_follow / intermediate value */
        this.bytecount = 0; /* counter for output bytes */
        this.stream = stream;
    };

    /* Do the normalization before we need a defined state, instead of
     * after messing it up.  This simplifies starting and ending. */
    var enc_normalize = function(rc, outputStream) {
        while (rc.range <= Bottom_value) { /* do we need renormalization? */
            if (rc.low < (0xFF << SHIFT_BITS)) {//no carry possible, so output
                outputStream.writeByte(rc.buffer);
                for (; rc.help; rc.help--)
                    outputStream.writeByte(0xFF);
                rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
            } else if (rc.low & Top_value) { /* carry now, no future carry */
                outputStream.writeByte(rc.buffer+1);
                for (; rc.help; rc.help--)
                    outputStream.writeByte(0x00);
                rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
            } else {
                rc.help++;
                if (rc.help > MAX_INT)
                    throw new Error("Too many bytes outstanding, "+
                                    "file too large!");
            }
            rc.range = (rc.range << 8) >>> 0;/*ensure result remains positive*/
            rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned */
            rc.bytecount++;
        }
    };

    /* Start the encoder                                         */
    /* c is written as the first byte in the datastream.
     * one could do w/o, but then you have an additional if per output byte */
    RangeCoder.prototype.encodeStart = function(c, initlength) {
        this.low = 0;
        this.range = Top_value;
        this.buffer = c;
        this.help = 0;
        this.bytecount = initlength;
    };

   /* Encode a symbol using frequencies                         */
    /* rc is the range coder to be used                          */
    /* sy_f is the interval length (frequency of the symbol)     */
    /* lt_f is the lower end (frequency sum of < symbols)        */
    /* tot_f is the total interval length (total frequency sum)  */
    /* or (faster): tot_f = (code_value)1<<shift                             */
    RangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {
        enc_normalize(this, this.stream);
        var r = (this.range / tot_f) >>> 0; // note coercion to integer
        var tmp = r * lt_f;
        this.low += tmp;
        if ((lt_f + sy_f) < tot_f) {
            this.range = r * sy_f;
        } else {
            this.range -= tmp;
        }
    };
    RangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {
        enc_normalize(this, this.stream);
        var r = this.range >>> shift;
        var tmp = r * lt_f;
        this.low += tmp;
        if ((lt_f + sy_f) >>> shift) {
            this.range -= tmp;
        } else {
            this.range = r * sy_f;
        }
    };
    /* Encode a bit w/o modelling. */
    RangeCoder.prototype.encodeBit = function(b) {
        this.encodeShift(1, b?1:0, 1);
    };
    /* Encode a byte w/o modelling. */
    RangeCoder.prototype.encodeByte = function(b) {
        this.encodeShift(1, b, 8);
    };
    /* Encode a short w/o modelling. */
    RangeCoder.prototype.encodeShort = function(s) {
        this.encodeShift(1, s, 16);
    };

    /* Finish encoding                                           */
    /* returns number of bytes written                           */
    RangeCoder.prototype.encodeFinish = function() {
        var outputStream = this.stream;
        enc_normalize(this, outputStream);
        this.bytecount += 5;
        var tmp = this.low >>> SHIFT_BITS;
        if ((this.low & (Bottom_value-1)) >= ((this.bytecount&0xFFFFFF)>>>1)) {
            tmp++;
        }
        if (tmp > 0xFF) { /* we have a carry */
            outputStream.writeByte(this.buffer + 1);
            for (; this.help; this.help--)
                outputStream.writeByte(0x00);
        } else { /* no carry */
            outputStream.writeByte(this.buffer);
            for (; this.help; this.help--)
                outputStream.writeByte(0xFF);
        }
        outputStream.writeByte(tmp & 0xFF);
        // XXX: i'm pretty sure these could be three arbitrary bytes
        //      they are consumed by the decoder at the end
        outputStream.writeByte((this.bytecount >>> 16) & 0xFF);
        outputStream.writeByte((this.bytecount >>>  8) & 0xFF);
        outputStream.writeByte((this.bytecount       ) & 0xFF);
        return this.bytecount;
    };

    /* Start the decoder; you need to provide the *second* byte from the
     * datastream. (The first byte was provided to startEncoding and is
     * ignored by the decoder.)
     */
    RangeCoder.prototype.decodeStart = function(skipInitialRead) {
        var c = skipInitialRead ? 0 : this.stream.readByte();
        if (typeof(c) !== 'number' || c < 0) {
            return c; // EOF
        }
        this.buffer = this.stream.readByte();
        this.low = this.buffer >>> (8 - EXTRA_BITS);
        this.range = 1 << EXTRA_BITS;
        return c;
    };

    var dec_normalize = function(rc, inputStream) {
        while (rc.range <= Bottom_value) {
            rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);
            /* rc.low could be negative here; don't fix it quite yet */
            rc.buffer = inputStream.readByte();
            rc.low |= rc.buffer >>> (8-EXTRA_BITS);
            rc.low = rc.low >>> 0; /* fix it now */
            rc.range = (rc.range << 8) >>> 0; /* ensure stays positive */
        }
    };

    /* Calculate cumulative frequency for next symbol. Does NO update!*/
    /* rc is the range coder to be used                          */
    /* tot_f is the total frequency                              */
    /* or: totf is (code_value)1<<shift                                      */
    /* returns the <= cumulative frequency                         */
    RangeCoder.prototype.decodeCulFreq = function(tot_f) {
        dec_normalize(this, this.stream);
        this.help = (this.range / tot_f) >>> 0; // note coercion to integer
        var tmp = (this.low / this.help) >>> 0; // again
        return (tmp >= tot_f ? tot_f-1 : tmp);
    };
    RangeCoder.prototype.decodeCulShift = function(shift) {
        dec_normalize(this, this.stream);
        this.help = this.range >>> shift;
        var tmp = (this.low / this.help) >>> 0; // coercion to unsigned
        // shift is less than 31, so shift below will remain positive
        return ((tmp>>>shift) ? (1<<shift)-1 : tmp);
    };

    /* Update decoding state                                     */
    /* rc is the range coder to be used                          */
    /* sy_f is the interval length (frequency of the symbol)     */
    /* lt_f is the lower end (frequency sum of < symbols)        */
    /* tot_f is the total interval length (total frequency sum)  */
    RangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
        var tmp = this.help * lt_f; // should not overflow!
        this.low -= tmp;
        if (lt_f + sy_f < tot_f) {
            this.range = (this.help * sy_f);
        } else {
            this.range -= tmp;
        }
    };

    /* Decode a bit w/o modelling. */
    RangeCoder.prototype.decodeBit = function() {
        var tmp = this.decodeCulShift(1);
        this.decodeUpdate(1, tmp, 1<<1);
        return tmp;
    };
    /* decode a byte w/o modelling */
    RangeCoder.prototype.decodeByte = function() {
        var tmp = this.decodeCulShift(8);
        this.decodeUpdate(1, tmp, 1<<8);
        return tmp;
    };
    /* decode a short w/o modelling */
    RangeCoder.prototype.decodeShort = function() {
        var tmp = this.decodeCulShift(16);
        this.decodeUpdate(1, tmp, 1<<16);
        return tmp;
    };

    /* Finish decoding */
    RangeCoder.prototype.decodeFinish = function() {
        /* normalize to use up all bytes */
        dec_normalize(this, this.stream);
    };

    /** Utility functions */

    // bitstream interface
    RangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;
    RangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;

    // stream interface
    RangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;
    RangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;

    return RangeCoder;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Simple.js":
/*!**********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Simple.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* *Very* simple de/compression utility, based on simple_c and simple_d from
 * rngcod13.zip at http://www.compressconsult.com/rangecoder/
 * Really just a demonstration/test of the rangecoder.
 */
var libs = [
	__webpack_require__(/*! ./RangeCoder */ "./node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__(/*! ./Util */ "./node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){
    var MAX_BLOCK_SIZE = 1<<17;

    var Simple = Object.create(null);
    Simple.MAGIC = 'smpl';
    Simple.compressFile = Util.compressFileHelper(Simple.MAGIC, function(input, output, size, props, finalByte) {
        var encoder = new RangeCoder(output);
        encoder.encodeStart(finalByte, 1);

        // read a block
        var block = Util.makeU8Buffer(MAX_BLOCK_SIZE);
        var counts = [];
        var blockLength = 0, sawEOF = false;

        var readBlock = function() {
            var pos = 0;
            // initialize counts
            for (pos=0; pos < 256; pos++) {
                counts[pos] = 0;
            }
            if (sawEOF) {
                blockLength = 0;
                return;
            }
            for (pos=0; pos < MAX_BLOCK_SIZE; ) {
                var c = input.readByte();
                if (c===Stream.EOF) {
                    sawEOF = true;
                    break;
                }
                block[pos++] = c;
                counts[c]++;
                // bail if some count reaches maximum
                if (counts[c]===0xFFFF) {
                    break;
                }
            }
            blockLength = pos;
        };

        while (true) {
            var i;
            readBlock();
            if (sawEOF && blockLength===0) {
                break;
            }
            // indicate that there's another block comin'
            encoder.encodeBit(true);
            // write all the statistics
            for (i=0; i<256; i++) {
                encoder.encodeShort(counts[i]);
            }
            // convert counts to cumulative counts
            counts[256] = blockLength;
            for (i=256; i; i--) {
                counts[i-1] = counts[i] - counts[i-1];
            }
            // encode the symbols using the probability table.
            for (i=0; i<blockLength; i++) {
                var ch = block[i];
                encoder.encodeFreq(counts[ch+1]-counts[ch], counts[ch],
                                   counts[256]);
            }
        }
        // write a stop bit
        encoder.encodeBit(false);
        // done!
        encoder.encodeFinish();
    }, true);
    Simple.decompressFile = Util.decompressFileHelper(Simple.MAGIC, function(input, output, size) {
        var decoder = new RangeCoder(input);
        decoder.decodeStart(true/*we already read the 'free' byte*/);
        while (decoder.decodeBit()) {
            var i, counts = [];
            // read all the statistics
            for (i=0; i<256; i++) {
                counts[i] = decoder.decodeShort();
            }
            // compute cumulative stats & total block size
            var blocksize = 0;
            for (i=0; i<256; i++) {
                var tmp = counts[i];
                counts[i] = blocksize;
                blocksize += tmp;
            }
            counts[256] = blocksize;

            for (i=0; i<blocksize; i++) {
                var cf = decoder.decodeCulFreq(blocksize);
                // inefficient way to look up the symbol.
                var symbol;
                for (symbol=0; symbol<256; symbol++)
                    // careful, there are length-0 ranges
                    // (where counts[symbol]===counts[symbol+1])
                    if (counts[symbol]<=cf && cf < counts[symbol+1])
                        break;
                var ch = symbol;
                decoder.decodeUpdate(counts[symbol+1] - counts[symbol],
                                     counts[symbol], blocksize);
                output.writeByte(symbol);
            }
        }
        decoder.decodeFinish();
    });
    return Simple;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Stream.js":
/*!**********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Stream.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** Abstract Stream interface, for byte-oriented i/o. */
var libs = [
	__webpack_require__(/*! ./freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js")
];
var body_fn = function (freeze) {
    var EOF = -1;

    var Stream = function() {
        /* ABSTRACT */
    };
    // you must define one of read / readByte for a readable stream
    Stream.prototype.readByte = function() {
        var buf = [ 0 ];
        var len = this.read(buf, 0, 1);
        if (len===0) { this._eof = true; return EOF; }
        return buf[0];
    };
    Stream.prototype.read = function(buf, bufOffset, length) {
        var ch, bytesRead = 0;
        while (bytesRead < length) {
            ch = this.readByte();
            if (ch === EOF) { this._eof = true; break; }
            buf[bufOffset+(bytesRead++)] = ch;
        }
        return bytesRead;
    };
    // reasonable default implementation of 'eof'
    Stream.prototype.eof = function() { return !!this._eof; };
    // not all readable streams are seekable
    Stream.prototype.seek = function(pos) {
        throw new Error('Stream is not seekable.');
    };
    Stream.prototype.tell = function() {
        throw new Error('Stream is not seekable.');
    };
    // you must define one of write / writeByte for a writable stream
    Stream.prototype.writeByte = function(_byte) {
        var buf = [ _byte ];
        this.write(buf, 0, 1);
    };
    Stream.prototype.write = function(buf, bufOffset, length) {
        var i;
        for (i=0; i<length; i++) {
            this.writeByte(buf[bufOffset + i]);
        }
        return length;
    };
    // flush will happily do nothing if you don't override it.
    Stream.prototype.flush = function() { };

    // export EOF as a constant.
    Stream.EOF = EOF;

    return freeze(Stream);
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/Util.js":
/*!********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/Util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {/* Some basic utilities, used in a number of places. */
var libs = [
	__webpack_require__(/*! ./freeze */ "./node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__(/*! ./Stream */ "./node_modules/keybase-compressjs/outlib/Stream.js")
];
var body_fn = function (freeze, Stream) {
    var Util = Object.create(null);

    var EOF = Stream.EOF;

    /* Take a buffer, array, or stream, and return an input stream. */
    Util.coerceInputStream = function(input, forceRead) {
        if (!('readByte' in input)) {
            var buffer = input;
            input = new Stream();
            input.size = buffer.length;
            input.pos = 0;
            input.readByte = function() {
                if (this.pos >= this.size) { return EOF; }
                return buffer[this.pos++];
            };
            input.read = function(buf, bufOffset, length) {
                var bytesRead = 0;
                while (bytesRead < length && this.pos < buffer.length) {
                    buf[bufOffset++] = buffer[this.pos++];
                    bytesRead++;
                }
                return bytesRead;
            };
            input.seek = function(pos) { this.pos = pos; };
            input.tell = function() { return this.pos; };
            input.eof = function() { return this.pos >= buffer.length; };
        } else if (forceRead && !('read' in input)) {
            // wrap input if it doesn't implement read
            var s = input;
            input = new Stream();
            input.readByte = function() {
                var ch = s.readByte();
                if (ch === EOF) { this._eof = true; }
                return ch;
            };
            if ('size' in s) { input.size = s.size; }
            if ('seek' in s) {
                input.seek = function(pos) {
                    s.seek(pos); // may throw if s doesn't implement seek
                    this._eof = false;
                };
            }
            if ('tell' in s) {
                input.tell = s.tell.bind(s);
            }
        }
        return input;
    };

    var BufferStream = function(buffer, resizeOk) {
        this.buffer = buffer;
        this.resizeOk = resizeOk;
        this.pos = 0;
    };
    BufferStream.prototype = Object.create(Stream.prototype);
    BufferStream.prototype.writeByte = function(_byte) {
        if (this.resizeOk && this.pos >= this.buffer.length) {
            var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);
            newBuffer.set(this.buffer);
            this.buffer = newBuffer;
        }
        this.buffer[this.pos++] = _byte;
    };
    BufferStream.prototype.getBuffer = function() {
        // trim buffer if needed
        if (this.pos !== this.buffer.length) {
            if (!this.resizeOk)
                throw new TypeError('outputsize does not match decoded input');
            var newBuffer = Util.makeU8Buffer(this.pos);
            newBuffer.set(this.buffer.subarray(0, this.pos));
            this.buffer = newBuffer;
        }
        return this.buffer;
    };

    /* Take a stream (or not) and an (optional) size, and return an
     * output stream.  Return an object with a 'retval' field equal to
     * the output stream (if that was given) or else a pointer at the
     * internal Uint8Array/buffer/array; and a 'stream' field equal to
     * an output stream to use.
     */
    Util.coerceOutputStream = function(output, size) {
        var r = { stream: output, retval: output };
        if (output) {
            if (typeof(output)==='object' && 'writeByte' in output) {
                return r; /* leave output alone */
            } else if (typeof(size) === 'number') {
                console.assert(size >= 0);
                r.stream = new BufferStream(Util.makeU8Buffer(size), false);
            } else { // output is a buffer
                r.stream = new BufferStream(output, false);
            }
        } else {
            r.stream = new BufferStream(Util.makeU8Buffer(16384), true);
        }
        Object.defineProperty(r, 'retval', {
            get: r.stream.getBuffer.bind(r.stream)
        });
        return r;
    };

    Util.compressFileHelper = function(magic, guts, suppressFinalByte) {
        return function(inStream, outStream, props) {
            inStream = Util.coerceInputStream(inStream);
            var o = Util.coerceOutputStream(outStream, outStream);
            outStream = o.stream;

            // write the magic number to identify this file type
            // (it better be ASCII, we're not doing utf-8 conversion)
            var i;
            for (i=0; i<magic.length; i++) {
                outStream.writeByte(magic.charCodeAt(i));
            }

            // if we know the size, write it
            var fileSize;
            if ('size' in inStream && inStream.size >= 0) {
                fileSize = inStream.size;
            } else {
                fileSize = -1; // size unknown
            }
            if (suppressFinalByte) {
                var tmpOutput = Util.coerceOutputStream([]);
                Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
                tmpOutput = tmpOutput.retval;
                for (i=0; i<tmpOutput.length-1; i++) {
                    outStream.writeByte(tmpOutput[i]);
                }
                suppressFinalByte = tmpOutput[tmpOutput.length-1];
            } else {
                Util.writeUnsignedNumber(outStream, fileSize + 1);
            }

            // call the guts to do the real compression
            guts(inStream, outStream, fileSize, props, suppressFinalByte);

            return o.retval;
        };
    };
    Util.decompressFileHelper = function(magic, guts) {
        return function(inStream, outStream) {
            inStream = Util.coerceInputStream(inStream);

            // read the magic number to confirm this file type
            // (it better be ASCII, we're not doing utf-8 conversion)
            var i;
            for (i=0; i<magic.length; i++) {
                if (magic.charCodeAt(i) !== inStream.readByte()) {
                    throw new Error("Bad magic");
                }
            }

            // read the file size & create an appropriate output stream/buffer
            var fileSize = Util.readUnsignedNumber(inStream) - 1;
            var o = Util.coerceOutputStream(outStream, fileSize);
            outStream = o.stream;

            // call the guts to do the real decompression
            guts(inStream, outStream, fileSize);

            return o.retval;
        };
    };
    // a helper for simple self-test of model encode
    Util.compressWithModel = function(inStream, fileSize, model) {
        var inSize = 0;
        while (inSize !== fileSize) {
            var ch = inStream.readByte();
            if (ch === EOF) {
                model.encode(256); // end of stream;
                break;
            }
            model.encode(ch);
            inSize++;
        }
    };
    // a helper for simple self-test of model decode
    Util.decompressWithModel = function(outStream, fileSize, model) {
        var outSize = 0;
        while (outSize !== fileSize) {
            var ch = model.decode();
            if (ch === 256) {
                break; // end of stream;
            }
            outStream.writeByte(ch);
            outSize++;
        }
    };

    /** Write a number using a self-delimiting big-endian encoding. */
    Util.writeUnsignedNumber = function(output, n) {
        console.assert(n >= 0);
        var bytes = [], i;
        do {
            bytes.push(n & 0x7F);
            // use division instead of shift to allow encoding numbers up to
            // 2^53
            n = Math.floor( n / 128 );
        } while (n !== 0);
        bytes[0] |= 0x80; // mark end of encoding.
        for (i=bytes.length-1; i>=0; i--) {
            output.writeByte(bytes[i]); // write in big-endian order
        }
        return output;
    };

    /** Read a number using a self-delimiting big-endian encoding. */
    Util.readUnsignedNumber = function(input) {
        var n = 0, c;
        while (true) {
            c = input.readByte();
            if (c&0x80) { n += (c&0x7F); break; }
            // using + and * instead of << allows decoding numbers up to 2^53
            n = (n + c) * 128;
        }
        return n;
    };

    // Compatibility thunks for Buffer/TypedArray constructors.

    var zerofill = function(a) {
        for (var i = 0, len = a.length; i < len; i++) {
            a[i] = 0;
        }
        return a;
    };

    var fallbackarray = function(size) {
        return zerofill(new Array(size));
    };

    // Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.
    // See https://github.com/joyent/node/issues/6664
    // Try to detect and workaround the bug.
    var ensureZeroed = function id(a) { return a; };
    if ((typeof(process) !== 'undefined') &&
        Array.prototype.some.call(new Uint32Array(128), function(x) {
            return x !== 0;
        })) {
        //console.warn('Working around broken TypedArray');
        ensureZeroed = zerofill;
    }

    /** Portable 8-bit unsigned buffer. */
    Util.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {
        // Uint8Array ought to be  automatically zero-filled
        return ensureZeroed(new Uint8Array(size));
    } : (typeof(Buffer) !== 'undefined') ? function(size) {
        var b = new Buffer(size);
        b.fill(0);
        return b;
    } : fallbackarray;

    /** Portable 16-bit unsigned buffer. */
    Util.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {
        // Uint16Array ought to be  automatically zero-filled
        return ensureZeroed(new Uint16Array(size));
    } : fallbackarray;

    /** Portable 32-bit unsigned buffer. */
    Util.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {
        // Uint32Array ought to be  automatically zero-filled
        return ensureZeroed(new Uint32Array(size));
    } : fallbackarray;

    /** Portable 32-bit signed buffer. */
    Util.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {
        // Int32Array ought to be  automatically zero-filled
        return ensureZeroed(new Int32Array(size));
    } : fallbackarray;

    Util.arraycopy = function(dst, src) {
        console.assert(dst.length >= src.length);
        for (var i = 0, len = src.length; i < len ; i++) {
            dst[i] = src[i];
        }
        return dst;
    };

    /** Highest bit set in a byte. */
    var bytemsb = [
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 */
    ];
    console.assert(bytemsb.length===0x100);
    /** Find last set (most significant bit).
     *  @return the last bit set in the argument.
     *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. */
    var fls = Util.fls = function(v) {
        console.assert(v>=0);
        if (v > 0xFFFFFFFF) { // use floating-point mojo
            return 32 + fls(Math.floor(v / 0x100000000));
        }
        if ( (v & 0xFFFF0000) !== 0) {
            if ( (v & 0xFF000000) !== 0) {
                return 24 + bytemsb[(v>>>24) & 0xFF];
            } else {
                return 16 + bytemsb[v>>>16];
            }
        } else if ( (v & 0x0000FF00) !== 0) {
            return 8 + bytemsb[v>>>8];
        } else {
            return bytemsb[v];
        }
    };
    /** Returns ceil(log2(n)) */
    Util.log2c = function(v) {
        return (v===0)?-1:fls(v-1);
    };

    return freeze(Util); // ensure constants are recognized as such.
};
module.exports = body_fn.apply(null, libs);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/keybase-compressjs/outlib/freeze.js":
/*!**********************************************************!*\
  !*** ./node_modules/keybase-compressjs/outlib/freeze.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var libs = [
];
var body_fn = function (){
  'use strict';

  // Object.freeze(), or a thunk if that method is not present in this
  // JavaScript environment.

  if (Object.freeze) {
    return Object.freeze;
  } else {
    return function(o) { return o; };
  }

};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "./node_modules/linq/linq.js":
/*!***********************************!*\
  !*** ./node_modules/linq/linq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*--------------------------------------------------------------------------
 * linq.js - LINQ for JavaScript
 * licensed under MIT License
 *------------------------------------------------------------------------*/

(function (root, undefined) {
    // ReadOnly Function
    var Functions = {
        Identity: function (x) { return x; },
        True: function () { return true; },
        Blank: function () { }
    };

    // const Type
    var Types = {
        Boolean: typeof true,
        Number: typeof 0,
        String: typeof "",
        Object: typeof {},
        Undefined: typeof undefined,
        Function: typeof function () { }
    };

    // createLambda cache
    var funcCache = { "": Functions.Identity };

    // private utility methods
    var Utils = {
        // Create anonymous function from lambda expression string
        createLambda: function (expression) {
            if (expression == null) return Functions.Identity;
            if (typeof expression === Types.String) {
                // get from cache
                var f = funcCache[expression];
                if (f != null) {
                    return f;
                }

                if (expression.indexOf("=>") === -1) {
                    var regexp = new RegExp("[$]+", "g");

                    var maxLength = 0;
                    var match;
                    while ((match = regexp.exec(expression)) != null) {
                        var paramNumber = match[0].length;
                        if (paramNumber > maxLength) {
                            maxLength = paramNumber;
                        }
                    }

                    var argArray = [];
                    for (var i = 1; i <= maxLength; i++) {
                        var dollar = "";
                        for (var j = 0; j < i; j++) {
                            dollar += "$";
                        }
                        argArray.push(dollar);
                    }

                    var args = Array.prototype.join.call(argArray, ",");

                    f = new Function(args, "return " + expression);
                    funcCache[expression] = f;
                    return f;
                }
                else {
                    var expr = expression.match(/^[(\s]*([^()]*?)[)\s]*=>(.*)/);
                    f = new Function(expr[1], "return " + expr[2]);
                    funcCache[expression] = f;
                    return f;
                }
            }
            return expression;
        },

        isIEnumerable: function (obj) {
            if (typeof Enumerator !== Types.Undefined) {
                try {
                    new Enumerator(obj); // check JScript(IE)'s Enumerator
                    return true;
                }
                catch (e) { }
            }

            return false;
        },

        // IE8's defineProperty is defined but cannot use, therefore check defineProperties
        defineProperty: (Object.defineProperties != null)
            ? function (target, methodName, value) {
                Object.defineProperty(target, methodName, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                    value: value
                })
            }
            : function (target, methodName, value) {
                target[methodName] = value;
            },

        compare: function (a, b) {
            return (a === b) ? 0
                 : (a > b) ? 1
                 : -1;
        },

        dispose: function (obj) {
            if (obj != null) obj.dispose();
        }
    };

    // IEnumerator State
    var State = { Before: 0, Running: 1, After: 2 };

    // "Enumerator" is conflict JScript's "Enumerator"
    var IEnumerator = function (initialize, tryGetNext, dispose) {
        var yielder = new Yielder();
        var state = State.Before;

        this.current = yielder.current;

        this.moveNext = function () {
            try {
                switch (state) {
                    case State.Before:
                        state = State.Running;
                        initialize();
                        // fall through
                    case State.Running:
                        if (tryGetNext.apply(yielder)) {
                            return true;
                        }
                        else {
                            this.dispose();
                            return false;
                        }
                    case State.After:
                        return false;
                }
            }
            catch (e) {
                this.dispose();
                throw e;
            }
        };

        this.dispose = function () {
            if (state != State.Running) return;

            try {
                dispose();
            }
            finally {
                state = State.After;
            }
        };
    };

    // for tryGetNext
    var Yielder = function () {
        var current = null;
        this.current = function () { return current; };
        this.yieldReturn = function (value) {
            current = value;
            return true;
        };
        this.yieldBreak = function () {
            return false;
        };
    };

    // Enumerable constuctor
    var Enumerable = function (getEnumerator) {
        this.getEnumerator = getEnumerator;
    };

    // Utility

    Enumerable.Utils = {}; // container

    Enumerable.Utils.createLambda = function (expression) {
        return Utils.createLambda(expression);
    };

    Enumerable.Utils.createEnumerable = function (getEnumerator) {
        return new Enumerable(getEnumerator);
    };

    Enumerable.Utils.createEnumerator = function (initialize, tryGetNext, dispose) {
        return new IEnumerator(initialize, tryGetNext, dispose);
    };

    Enumerable.Utils.extendTo = function (type) {
        var typeProto = type.prototype;
        var enumerableProto;

        if (type === Array) {
            enumerableProto = ArrayEnumerable.prototype;
            Utils.defineProperty(typeProto, "getSource", function () {
                return this;
            });
        }
        else {
            enumerableProto = Enumerable.prototype;
            Utils.defineProperty(typeProto, "getEnumerator", function () {
                return Enumerable.from(this).getEnumerator();
            });
        }

        for (var methodName in enumerableProto) {
            var func = enumerableProto[methodName];

            // already extended
            if (typeProto[methodName] == func) continue;

            // already defined(example Array#reverse/join/forEach...)
            if (typeProto[methodName] != null) {
                methodName = methodName + "ByLinq";
                if (typeProto[methodName] == func) continue; // recheck
            }

            if (func instanceof Function) {
                Utils.defineProperty(typeProto, methodName, func);
            }
        }
    };

    // Generator

    Enumerable.choice = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].getEnumerator != null) ? args[0].toArray()
                        : args;
                },
                function () {
                    return this.yieldReturn(args[Math.floor(Math.random() * args.length)]);
                },
                Functions.Blank);
        });
    };

    Enumerable.cycle = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            var index = 0;
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].getEnumerator != null) ? args[0].toArray()
                        : args;
                },
                function () {
                    if (index >= args.length) index = 0;
                    return this.yieldReturn(args[index++]);
                },
                Functions.Blank);
        });
    };

    Enumerable.empty = function () {
        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return false; },
                Functions.Blank);
        });
    };

    Enumerable.from = function (obj) {
        if (obj == null) {
            return Enumerable.empty();
        }
        if (obj instanceof Enumerable) {
            return obj;
        }
        if (typeof obj == Types.Number || typeof obj == Types.Boolean) {
            return Enumerable.repeat(obj, 1);
        }
        if (typeof obj == Types.String) {
            return new Enumerable(function () {
                var index = 0;
                return new IEnumerator(
                    Functions.Blank,
                    function () {
                        return (index < obj.length) ? this.yieldReturn(obj.charAt(index++)) : false;
                    },
                    Functions.Blank);
            });
        }
        if (typeof obj != Types.Function) {
            // array or array like object
            if (typeof obj.length == Types.Number) {
                return new ArrayEnumerable(obj);
            }

            // JScript's IEnumerable
            if (!(obj instanceof Object) && Utils.isIEnumerable(obj)) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = new Enumerator(obj); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.atEnd()) ? false : this.yieldReturn(enumerator.item());
                        },
                        Functions.Blank);
                });
            }

            // WinMD IIterable<T>
            if (typeof Windows === Types.Object && typeof obj.first === Types.Function) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = obj.first(); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.hasCurrent) ? this.yieldReturn(enumerator.current) : this.yieldBreak();
                        },
                        Functions.Blank);
                });
            }
        }

        // case function/object : Create keyValuePair[]
        return new Enumerable(function () {
            var array = [];
            var index = 0;

            return new IEnumerator(
                function () {
                    for (var key in obj) {
                        var value = obj[key];
                        if (!(value instanceof Function) && Object.prototype.hasOwnProperty.call(obj, key)) {
                            array.push({ key: key, value: value });
                        }
                    }
                },
                function () {
                    return (index < array.length)
                        ? this.yieldReturn(array[index++])
                        : false;
                },
                Functions.Blank);
        });
    },

    Enumerable.make = function (element) {
        return Enumerable.repeat(element, 1);
    };

    // Overload:function(input, pattern)
    // Overload:function(input, pattern, flags)
    Enumerable.matches = function (input, pattern, flags) {
        if (flags == null) flags = "";
        if (pattern instanceof RegExp) {
            flags += (pattern.ignoreCase) ? "i" : "";
            flags += (pattern.multiline) ? "m" : "";
            pattern = pattern.source;
        }
        if (flags.indexOf("g") === -1) flags += "g";

        return new Enumerable(function () {
            var regex;
            return new IEnumerator(
                function () { regex = new RegExp(pattern, flags); },
                function () {
                    var match = regex.exec(input);
                    return (match) ? this.yieldReturn(match) : false;
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, count)
    // Overload:function(start, count, step)
    Enumerable.range = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start - step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value += step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, count)
    // Overload:function(start, count, step)
    Enumerable.rangeDown = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start + step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value -= step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, to)
    // Overload:function(start, to, step)
    Enumerable.rangeTo = function (start, to, step) {
        if (step == null) step = 1;

        if (start < to) {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start - step; },
                function () {
                    var next = value += step;
                    return (next <= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
        else {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start + step; },
                function () {
                    var next = value -= step;
                    return (next >= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
    };

    // Overload:function(element)
    // Overload:function(element, count)
    Enumerable.repeat = function (element, count) {
        if (count != null) return Enumerable.repeat(element).take(count);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(element); },
                Functions.Blank);
        });
    };

    Enumerable.repeatWithFinalize = function (initializer, finalizer) {
        initializer = Utils.createLambda(initializer);
        finalizer = Utils.createLambda(finalizer);

        return new Enumerable(function () {
            var element;
            return new IEnumerator(
                function () { element = initializer(); },
                function () { return this.yieldReturn(element); },
                function () {
                    if (element != null) {
                        finalizer(element);
                        element = null;
                    }
                });
        });
    };

    // Overload:function(func)
    // Overload:function(func, count)
    Enumerable.generate = function (func, count) {
        if (count != null) return Enumerable.generate(func).take(count);
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(func()); },
                Functions.Blank);
        });
    };

    // Overload:function()
    // Overload:function(start)
    // Overload:function(start, step)
    Enumerable.toInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start - step; },
                function () { return this.yieldReturn(value += step); },
                Functions.Blank);
        });
    };

    // Overload:function()
    // Overload:function(start)
    // Overload:function(start, step)
    Enumerable.toNegativeInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start + step; },
                function () { return this.yieldReturn(value -= step); },
                Functions.Blank);
        });
    };

    Enumerable.unfold = function (seed, func) {
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            var isFirst = true;
            var value;
            return new IEnumerator(
                Functions.Blank,
                function () {
                    if (isFirst) {
                        isFirst = false;
                        value = seed;
                        return this.yieldReturn(value);
                    }
                    value = func(value);
                    return this.yieldReturn(value);
                },
                Functions.Blank);
        });
    };

    Enumerable.defer = function (enumerableFactory) {

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = Enumerable.from(enumerableFactory()).getEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : this.yieldBreak();
                },
                function () {
                    Utils.dispose(enumerator);
                });
        });
    };

    // Extension Methods

    /* Projection and Filtering Methods */

    // Overload:function(func)
    // Overload:function(func, resultSelector<element>)
    // Overload:function(func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseBreadthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var nestLevel = 0;
            var buffer = [];

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            buffer.push(enumerator.current());
                            return this.yieldReturn(resultSelector(enumerator.current(), nestLevel));
                        }

                        var next = Enumerable.from(buffer).selectMany(function (x) { return func(x); });
                        if (!next.any()) {
                            return false;
                        }
                        else {
                            nestLevel++;
                            buffer = [];
                            Utils.dispose(enumerator);
                            enumerator = next.getEnumerator();
                        }
                    }
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(func)
    // Overload:function(func, resultSelector<element>)
    // Overload:function(func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseDepthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumeratorStack = [];
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            var value = resultSelector(enumerator.current(), enumeratorStack.length);
                            enumeratorStack.push(enumerator);
                            enumerator = Enumerable.from(func(enumerator.current())).getEnumerator();
                            return this.yieldReturn(value);
                        }

                        if (enumeratorStack.length <= 0) return false;
                        Utils.dispose(enumerator);
                        enumerator = enumeratorStack.pop();
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Enumerable.from(enumeratorStack).forEach(function (s) { s.dispose(); });
                    }
                });
        });
    };

    Enumerable.prototype.flatten = function () {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = null;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (middleEnumerator != null) {
                            if (middleEnumerator.moveNext()) {
                                return this.yieldReturn(middleEnumerator.current());
                            }
                            else {
                                middleEnumerator = null;
                            }
                        }

                        if (enumerator.moveNext()) {
                            if (enumerator.current() instanceof Array) {
                                Utils.dispose(middleEnumerator);
                                middleEnumerator = Enumerable.from(enumerator.current())
                                    .selectMany(Functions.Identity)
                                    .flatten()
                                    .getEnumerator();
                                continue;
                            }
                            else {
                                return this.yieldReturn(enumerator.current());
                            }
                        }

                        return false;
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(middleEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.pairwise = function (selector) {
        var source = this;
        selector = Utils.createLambda(selector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    enumerator.moveNext();
                },
                function () {
                    var prev = enumerator.current();
                    return (enumerator.moveNext())
                        ? this.yieldReturn(selector(prev, enumerator.current()))
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(func)
    // Overload:function(seed,func<value,element>)
    Enumerable.prototype.scan = function (seed, func) {
        var isUseSeed;
        if (func == null) {
            func = Utils.createLambda(seed); // arguments[0]
            isUseSeed = false;
        } else {
            func = Utils.createLambda(func);
            isUseSeed = true;
        }
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var value;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (isFirst) {
                        isFirst = false;
                        if (!isUseSeed) {
                            if (enumerator.moveNext()) {
                                return this.yieldReturn(value = enumerator.current());
                            }
                        }
                        else {
                            return this.yieldReturn(value = seed);
                        }
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(value = func(value, enumerator.current()))
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(selector<element>)
    // Overload:function(selector<element,index>)
    Enumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            return new WhereSelectEnumerable(this, null, selector);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.getEnumerator(); },
                    function () {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(selector(enumerator.current(), index++))
                            : false;
                    },
                    function () { Utils.dispose(enumerator); });
            });
        }
    };

    // Overload:function(collectionSelector<element>)
    // Overload:function(collectionSelector<element,index>)
    // Overload:function(collectionSelector<element>,resultSelector)
    // Overload:function(collectionSelector<element,index>,resultSelector)
    Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {
        var source = this;
        collectionSelector = Utils.createLambda(collectionSelector);
        if (resultSelector == null) resultSelector = function (a, b) { return b; };
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = undefined;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (middleEnumerator === undefined) {
                        if (!enumerator.moveNext()) return false;
                    }
                    do {
                        if (middleEnumerator == null) {
                            var middleSeq = collectionSelector(enumerator.current(), index++);
                            middleEnumerator = Enumerable.from(middleSeq).getEnumerator();
                        }
                        if (middleEnumerator.moveNext()) {
                            return this.yieldReturn(resultSelector(enumerator.current(), middleEnumerator.current()));
                        }
                        Utils.dispose(middleEnumerator);
                        middleEnumerator = null;
                    } while (enumerator.moveNext());
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(middleEnumerator);
                    }
                });
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            return new WhereEnumerable(this, predicate);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.getEnumerator(); },
                    function () {
                        while (enumerator.moveNext()) {
                            if (predicate(enumerator.current(), index++)) {
                                return this.yieldReturn(enumerator.current());
                            }
                        }
                        return false;
                    },
                    function () { Utils.dispose(enumerator); });
            });
        }
    };


    // Overload:function(selector<element>)
    // Overload:function(selector<element,index>)
    Enumerable.prototype.choose = function (selector) {
        selector = Utils.createLambda(selector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        var result = selector(enumerator.current(), index++);
                        if (result != null) {
                            return this.yieldReturn(result);
                        }
                    }
                    return this.yieldBreak();
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.ofType = function (type) {
        var typeName;
        switch (type) {
            case Number:
                typeName = Types.Number;
                break;
            case String:
                typeName = Types.String;
                break;
            case Boolean:
                typeName = Types.Boolean;
                break;
            case Function:
                typeName = Types.Function;
                break;
            default:
                typeName = null;
                break;
        }
        return (typeName === null)
            ? this.where(function (x) { return x instanceof type; })
            : this.where(function (x) { return typeof x === typeName; });
    };

    // mutiple arguments, last one is selector, others are enumerable
    Enumerable.prototype.zip = function () {
        var args = arguments;
        var selector = Utils.createLambda(arguments[arguments.length - 1]);

        var source = this;
        // optimized case:argument is 2
        if (arguments.length == 2) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;
                var index = 0;

                return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    secondEnumerator = Enumerable.from(second).getEnumerator();
                },
                function () {
                    if (firstEnumerator.moveNext() && secondEnumerator.moveNext()) {
                        return this.yieldReturn(selector(firstEnumerator.current(), secondEnumerator.current(), index++));
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    } finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            return new Enumerable(function () {
                var enumerators;
                var index = 0;

                return new IEnumerator(
                function () {
                    var array = Enumerable.make(source)
                        .concat(Enumerable.from(args).takeExceptLast().select(Enumerable.from))
                        .select(function (x) { return x.getEnumerator() })
                        .toArray();
                    enumerators = Enumerable.from(array);
                },
                function () {
                    if (enumerators.all(function (x) { return x.moveNext() })) {
                        var array = enumerators
                            .select(function (x) { return x.current() })
                            .toArray();
                        array.push(index++);
                        return this.yieldReturn(selector.apply(null, array));
                    }
                    else {
                        return this.yieldBreak();
                    }
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.dispose);
                });
            });
        }
    };

    // mutiple arguments
    Enumerable.prototype.merge = function () {
        var args = arguments;
        var source = this;

        return new Enumerable(function () {
            var enumerators;
            var index = -1;

            return new IEnumerator(
                function () {
                    enumerators = Enumerable.make(source)
                        .concat(Enumerable.from(args).select(Enumerable.from))
                        .select(function (x) { return x.getEnumerator() })
                        .toArray();
                },
                function () {
                    while (enumerators.length > 0) {
                        index = (index >= enumerators.length - 1) ? 0 : index + 1;
                        var enumerator = enumerators[index];

                        if (enumerator.moveNext()) {
                            return this.yieldReturn(enumerator.current());
                        }
                        else {
                            enumerator.dispose();
                            enumerators.splice(index--, 1);
                        }
                    }
                    return this.yieldBreak();
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.dispose);
                });
        });
    };

    /* Join Methods */

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var outerEnumerator;
            var lookup;
            var innerElements = null;
            var innerCount = 0;

            return new IEnumerator(
                function () {
                    outerEnumerator = source.getEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);
                },
                function () {
                    while (true) {
                        if (innerElements != null) {
                            var innerElement = innerElements[innerCount++];
                            if (innerElement !== undefined) {
                                return this.yieldReturn(resultSelector(outerEnumerator.current(), innerElement));
                            }

                            innerElement = null;
                            innerCount = 0;
                        }

                        if (outerEnumerator.moveNext()) {
                            var key = outerKeySelector(outerEnumerator.current());
                            innerElements = lookup.get(key).toArray();
                        } else {
                            return false;
                        }
                    }
                },
                function () { Utils.dispose(outerEnumerator); });
        });
    };

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator = source.getEnumerator();
            var lookup = null;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);
                },
                function () {
                    if (enumerator.moveNext()) {
                        var innerElement = lookup.get(outerKeySelector(enumerator.current()));
                        return this.yieldReturn(resultSelector(enumerator.current(), innerElement));
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    /* Set Methods */

    Enumerable.prototype.all = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var result = true;
        this.forEach(function (x) {
            if (!predicate(x)) {
                result = false;
                return false; // break
            }
        });
        return result;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.any = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var enumerator = this.getEnumerator();
        try {
            if (arguments.length == 0) return enumerator.moveNext(); // case:function()

            while (enumerator.moveNext()) // case:function(predicate)
            {
                if (predicate(enumerator.current())) return true;
            }
            return false;
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    Enumerable.prototype.isEmpty = function () {
        return !this.any();
    };

    // multiple arguments
    Enumerable.prototype.concat = function () {
        var source = this;

        if (arguments.length == 1) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;

                return new IEnumerator(
                function () { firstEnumerator = source.getEnumerator(); },
                function () {
                    if (secondEnumerator == null) {
                        if (firstEnumerator.moveNext()) return this.yieldReturn(firstEnumerator.current());
                        secondEnumerator = Enumerable.from(second).getEnumerator();
                    }
                    if (secondEnumerator.moveNext()) return this.yieldReturn(secondEnumerator.current());
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            var args = arguments;

            return new Enumerable(function () {
                var enumerators;

                return new IEnumerator(
                    function () {
                        enumerators = Enumerable.make(source)
                            .concat(Enumerable.from(args).select(Enumerable.from))
                            .select(function (x) { return x.getEnumerator() })
                            .toArray();
                    },
                    function () {
                        while (enumerators.length > 0) {
                            var enumerator = enumerators[0];

                            if (enumerator.moveNext()) {
                                return this.yieldReturn(enumerator.current());
                            }
                            else {
                                enumerator.dispose();
                                enumerators.splice(0, 1);
                            }
                        }
                        return this.yieldBreak();
                    },
                    function () {
                        Enumerable.from(enumerators).forEach(Utils.dispose);
                    });
            });
        }
    };

    Enumerable.prototype.insert = function (index, second) {
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var count = 0;
            var isEnumerated = false;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    secondEnumerator = Enumerable.from(second).getEnumerator();
                },
                function () {
                    if (count == index && secondEnumerator.moveNext()) {
                        isEnumerated = true;
                        return this.yieldReturn(secondEnumerator.current());
                    }
                    if (firstEnumerator.moveNext()) {
                        count++;
                        return this.yieldReturn(firstEnumerator.current());
                    }
                    if (!isEnumerated && secondEnumerator.moveNext()) {
                        return this.yieldReturn(secondEnumerator.current());
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.alternate = function (alternateValueOrSequence) {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var enumerator;
            var alternateSequence;
            var alternateEnumerator;

            return new IEnumerator(
                function () {
                    if (alternateValueOrSequence instanceof Array || alternateValueOrSequence.getEnumerator != null) {
                        alternateSequence = Enumerable.from(Enumerable.from(alternateValueOrSequence).toArray()); // freeze
                    }
                    else {
                        alternateSequence = Enumerable.make(alternateValueOrSequence);
                    }
                    enumerator = source.getEnumerator();
                    if (enumerator.moveNext()) buffer = enumerator.current();
                },
                function () {
                    while (true) {
                        if (alternateEnumerator != null) {
                            if (alternateEnumerator.moveNext()) {
                                return this.yieldReturn(alternateEnumerator.current());
                            }
                            else {
                                alternateEnumerator = null;
                            }
                        }

                        if (buffer == null && enumerator.moveNext()) {
                            buffer = enumerator.current(); // hasNext
                            alternateEnumerator = alternateSequence.getEnumerator();
                            continue; // GOTO
                        }
                        else if (buffer != null) {
                            var retVal = buffer;
                            buffer = null;
                            return this.yieldReturn(retVal);
                        }

                        return this.yieldBreak();
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(alternateEnumerator);
                    }
                });
        });
    };

    // Overload:function(value)
    // Overload:function(value, compareSelector)
    Enumerable.prototype.contains = function (value, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var enumerator = this.getEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (compareSelector(enumerator.current()) === value) return true;
            }
            return false;
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    Enumerable.prototype.defaultIfEmpty = function (defaultValue) {
        var source = this;
        if (defaultValue === undefined) defaultValue = null;

        return new Enumerable(function () {
            var enumerator;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        isFirst = false;
                        return this.yieldReturn(enumerator.current());
                    }
                    else if (isFirst) {
                        isFirst = false;
                        return this.yieldReturn(defaultValue);
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function()
    // Overload:function(compareSelector)
    Enumerable.prototype.distinct = function (compareSelector) {
        return this.except(Enumerable.empty(), compareSelector);
    };

    Enumerable.prototype.distinctUntilChanged = function (compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var compareKey;
            var initial;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        var key = compareSelector(enumerator.current());

                        if (initial) {
                            initial = false;
                            compareKey = key;
                            return this.yieldReturn(enumerator.current());
                        }

                        if (compareKey === key) {
                            continue;
                        }

                        compareKey = key;
                        return this.yieldReturn(enumerator.current());
                    }
                    return this.yieldBreak();
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.except = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    keys = new Dictionary(compareSelector);
                    Enumerable.from(second).forEach(function (key) { keys.add(key); });
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.current();
                        if (!keys.contains(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.intersect = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;
            var outs;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();

                    keys = new Dictionary(compareSelector);
                    Enumerable.from(second).forEach(function (key) { keys.add(key); });
                    outs = new Dictionary(compareSelector);
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.current();
                        if (!outs.contains(current) && keys.contains(current)) {
                            outs.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.sequenceEqual = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);

        var firstEnumerator = this.getEnumerator();
        try {
            var secondEnumerator = Enumerable.from(second).getEnumerator();
            try {
                while (firstEnumerator.moveNext()) {
                    if (!secondEnumerator.moveNext()
                    || compareSelector(firstEnumerator.current()) !== compareSelector(secondEnumerator.current())) {
                        return false;
                    }
                }

                if (secondEnumerator.moveNext()) return false;
                return true;
            }
            finally {
                Utils.dispose(secondEnumerator);
            }
        }
        finally {
            Utils.dispose(firstEnumerator);
        }
    };

    Enumerable.prototype.union = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var keys;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    keys = new Dictionary(compareSelector);
                },
                function () {
                    var current;
                    if (secondEnumerator === undefined) {
                        while (firstEnumerator.moveNext()) {
                            current = firstEnumerator.current();
                            if (!keys.contains(current)) {
                                keys.add(current);
                                return this.yieldReturn(current);
                            }
                        }
                        secondEnumerator = Enumerable.from(second).getEnumerator();
                    }
                    while (secondEnumerator.moveNext()) {
                        current = secondEnumerator.current();
                        if (!keys.contains(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
        });
    };

    /* Ordering Methods */

    Enumerable.prototype.orderBy = function (keySelector) {
        return new OrderedEnumerable(this, keySelector, false);
    };

    Enumerable.prototype.orderByDescending = function (keySelector) {
        return new OrderedEnumerable(this, keySelector, true);
    };

    Enumerable.prototype.reverse = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var index;

            return new IEnumerator(
                function () {
                    buffer = source.toArray();
                    index = buffer.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(buffer[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.shuffle = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;

            return new IEnumerator(
                function () { buffer = source.toArray(); },
                function () {
                    if (buffer.length > 0) {
                        var i = Math.floor(Math.random() * buffer.length);
                        return this.yieldReturn(buffer.splice(i, 1)[0]);
                    }
                    return false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.weightedSample = function (weightSelector) {
        weightSelector = Utils.createLambda(weightSelector);
        var source = this;

        return new Enumerable(function () {
            var sortedByBound;
            var totalWeight = 0;

            return new IEnumerator(
                function () {
                    sortedByBound = source
                        .choose(function (x) {
                            var weight = weightSelector(x);
                            if (weight <= 0) return null; // ignore 0

                            totalWeight += weight;
                            return { value: x, bound: totalWeight };
                        })
                        .toArray();
                },
                function () {
                    if (sortedByBound.length > 0) {
                        var draw = Math.floor(Math.random() * totalWeight) + 1;

                        var lower = -1;
                        var upper = sortedByBound.length;
                        while (upper - lower > 1) {
                            var index = Math.floor((lower + upper) / 2);
                            if (sortedByBound[index].bound >= draw) {
                                upper = index;
                            }
                            else {
                                lower = index;
                            }
                        }

                        return this.yieldReturn(sortedByBound[upper].value);
                    }

                    return this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    /* Grouping Methods */

    // Overload:function(keySelector)
    // Overload:function(keySelector,elementSelector)
    // Overload:function(keySelector,elementSelector,resultSelector)
    // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.groupBy = function (keySelector, elementSelector, resultSelector, compareSelector) {
        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        if (resultSelector != null) resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.toLookup(keySelector, elementSelector, compareSelector)
                        .toEnumerable()
                        .getEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        return (resultSelector == null)
                            ? this.yieldReturn(enumerator.current())
                            : this.yieldReturn(resultSelector(enumerator.current().key(), enumerator.current()));
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(keySelector)
    // Overload:function(keySelector,elementSelector)
    // Overload:function(keySelector,elementSelector,resultSelector)
    // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, compareSelector) {

        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var hasResultSelector;
        if (resultSelector == null) {
            hasResultSelector = false;
            resultSelector = function (key, group) { return new Grouping(key, group); };
        }
        else {
            hasResultSelector = true;
            resultSelector = Utils.createLambda(resultSelector);
        }

        return new Enumerable(function () {
            var enumerator;
            var key;
            var compareKey;
            var group = [];

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    if (enumerator.moveNext()) {
                        key = keySelector(enumerator.current());
                        compareKey = compareSelector(key);
                        group.push(elementSelector(enumerator.current()));
                    }
                },
                function () {
                    var hasNext;
                    while ((hasNext = enumerator.moveNext()) == true) {
                        if (compareKey === compareSelector(keySelector(enumerator.current()))) {
                            group.push(elementSelector(enumerator.current()));
                        }
                        else break;
                    }

                    if (group.length > 0) {
                        var result = (hasResultSelector)
                            ? resultSelector(key, Enumerable.from(group))
                            : resultSelector(key, group);
                        if (hasNext) {
                            key = keySelector(enumerator.current());
                            compareKey = compareSelector(key);
                            group = [elementSelector(enumerator.current())];
                        }
                        else group = [];

                        return this.yieldReturn(result);
                    }

                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.buffer = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    var array = [];
                    var index = 0;
                    while (enumerator.moveNext()) {
                        array.push(enumerator.current());
                        if (++index >= count) return this.yieldReturn(array);
                    }
                    if (array.length > 0) return this.yieldReturn(array);
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    /* Aggregate Methods */

    // Overload:function(func)
    // Overload:function(seed,func)
    // Overload:function(seed,func,resultSelector)
    Enumerable.prototype.aggregate = function (seed, func, resultSelector) {
        resultSelector = Utils.createLambda(resultSelector);
        return resultSelector(this.scan(seed, func, resultSelector).last());
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.average = function (selector) {
        selector = Utils.createLambda(selector);

        var sum = 0;
        var count = 0;
        this.forEach(function (x) {
            sum += selector(x);
            ++count;
        });

        return sum / count;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.count = function (predicate) {
        predicate = (predicate == null) ? Functions.True : Utils.createLambda(predicate);

        var count = 0;
        this.forEach(function (x, i) {
            if (predicate(x, i))++count;
        });
        return count;
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.max = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) { return (a > b) ? a : b; });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.min = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) { return (a < b) ? a : b; });
    };

    Enumerable.prototype.maxBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) { return (keySelector(a) > keySelector(b)) ? a : b; });
    };

    Enumerable.prototype.minBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) { return (keySelector(a) < keySelector(b)) ? a : b; });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.sum = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(0, function (a, b) { return a + b; });
    };

    /* Paging Methods */

    Enumerable.prototype.elementAt = function (index) {
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        if (!found) throw new Error("index is less than 0 or greater than or equal to the number of elements in source.");
        return value;
    };

    Enumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.first = function (predicate) {
        if (predicate != null) return this.where(predicate).first();

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });

        if (!found) throw new Error("first:No element satisfies the condition.");
        return value;
    };

    Enumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            if (typeof predicate === Types.Function || typeof Utils.createLambda(predicate) === Types.Function) {
                return this.where(predicate).firstOrDefault(undefined, defaultValue);
            }
            defaultValue = predicate;
        }

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.last = function (predicate) {
        if (predicate != null) return this.where(predicate).last();

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });

        if (!found) throw new Error("last:No element satisfies the condition.");
        return value;
    };

    Enumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            if (typeof predicate === Types.Function || typeof Utils.createLambda(predicate) === Types.Function) {
                return this.where(predicate).lastOrDefault(undefined, defaultValue);
            }
            defaultValue = predicate;
        }

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.single = function (predicate) {
        if (predicate != null) return this.where(predicate).single();

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        if (!found) throw new Error("single:No element satisfies the condition.");
        return value;
    };

    // Overload:function(defaultValue)
    // Overload:function(defaultValue,predicate)
    Enumerable.prototype.singleOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).singleOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        return (!found) ? defaultValue : value;
    };

    Enumerable.prototype.skip = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    while (index++ < count && enumerator.moveNext()) {
                    }
                    ;
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.skipWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;
            var isSkipEnd = false;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (!isSkipEnd) {
                        if (enumerator.moveNext()) {
                            if (!predicate(enumerator.current(), index++)) {
                                isSkipEnd = true;
                                return this.yieldReturn(enumerator.current());
                            }
                            continue;
                        } else return false;
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;

                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.take = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (index++ < count && enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); }
            );
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.takeWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (enumerator.moveNext() && predicate(enumerator.current(), index++))
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function()
    // Overload:function(count)
    Enumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        var source = this;

        return new Enumerable(function () {
            if (count <= 0) return source.getEnumerator(); // do nothing

            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        if (q.length == count) {
                            q.push(enumerator.current());
                            return this.yieldReturn(q.shift());
                        }
                        q.push(enumerator.current());
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.takeFromLast = function (count) {
        if (count <= 0 || count == null) return Enumerable.empty();
        var source = this;

        return new Enumerable(function () {
            var sourceEnumerator;
            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { sourceEnumerator = source.getEnumerator(); },
                function () {
                    while (sourceEnumerator.moveNext()) {
                        if (q.length == count) q.shift();
                        q.push(sourceEnumerator.current());
                    }
                    if (enumerator == null) {
                        enumerator = Enumerable.from(q).getEnumerator();
                    }
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(item)
    // Overload:function(predicate)
    Enumerable.prototype.indexOf = function (item) {
        var found = null;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) {
                    found = i;
                    return false;
                }
            });
        }
        else {
            this.forEach(function (x, i) {
                if (x === item) {
                    found = i;
                    return false;
                }
            });
        }

        return (found !== null) ? found : -1;
    };

    // Overload:function(item)
    // Overload:function(predicate)
    Enumerable.prototype.lastIndexOf = function (item) {
        var result = -1;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) result = i;
            });
        }
        else {
            this.forEach(function (x, i) {
                if (x === item) result = i;
            });
        }

        return result;
    };

    /* Convert Methods */

    Enumerable.prototype.cast = function () {
        return this;
    };

    Enumerable.prototype.asEnumerable = function () {
        return Enumerable.from(this);
    };

    Enumerable.prototype.toArray = function () {
        var array = [];
        this.forEach(function (x) { array.push(x); });
        return array;
    };

    // Overload:function(keySelector)
    // Overload:function(keySelector, elementSelector)
    // Overload:function(keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toLookup = function (keySelector, elementSelector, compareSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);

        var dict = new Dictionary(compareSelector);
        this.forEach(function (x) {
            var key = keySelector(x);
            var element = elementSelector(x);

            var array = dict.get(key);
            if (array !== undefined) array.push(element);
            else dict.add(key, [element]);
        });
        return new Lookup(dict);
    };

    Enumerable.prototype.toObject = function (keySelector, elementSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);

        var obj = {};
        this.forEach(function (x) {
            obj[keySelector(x)] = elementSelector(x);
        });
        return obj;
    };

    // Overload:function(keySelector, elementSelector)
    // Overload:function(keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toDictionary = function (keySelector, elementSelector, compareSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);

        var dict = new Dictionary(compareSelector);
        this.forEach(function (x) {
            dict.add(keySelector(x), elementSelector(x));
        });
        return dict;
    };

    // Overload:function()
    // Overload:function(replacer)
    // Overload:function(replacer, space)
    Enumerable.prototype.toJSONString = function (replacer, space) {
        if (typeof JSON === Types.Undefined || JSON.stringify == null) {
            throw new Error("toJSONString can't find JSON.stringify. This works native JSON support Browser or include json2.js");
        }
        return JSON.stringify(this.toArray(), replacer, space);
    };

    // Overload:function()
    // Overload:function(separator)
    // Overload:function(separator,selector)
    Enumerable.prototype.toJoinedString = function (separator, selector) {
        if (separator == null) separator = "";
        if (selector == null) selector = Functions.Identity;

        return this.select(selector).toArray().join(separator);
    };


    /* Action Methods */

    // Overload:function(action<element>)
    // Overload:function(action<element,index>)
    Enumerable.prototype.doAction = function (action) {
        var source = this;
        action = Utils.createLambda(action);

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        action(enumerator.current(), index++);
                        return this.yieldReturn(enumerator.current());
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(action<element>)
    // Overload:function(action<element,index>)
    // Overload:function(func<element,bool>)
    // Overload:function(func<element,index,bool>)
    Enumerable.prototype.forEach = function (action) {
        action = Utils.createLambda(action);

        var index = 0;
        var enumerator = this.getEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (action(enumerator.current(), index++) === false) break;
            }
        } finally {
            Utils.dispose(enumerator);
        }
    };

    // Overload:function()
    // Overload:function(separator)
    // Overload:function(separator,selector)
    Enumerable.prototype.write = function (separator, selector) {
        if (separator == null) separator = "";
        selector = Utils.createLambda(selector);

        var isFirst = true;
        this.forEach(function (item) {
            if (isFirst) isFirst = false;
            else document.write(separator);
            document.write(selector(item));
        });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.writeLine = function (selector) {
        selector = Utils.createLambda(selector);

        this.forEach(function (item) {
            document.writeln(selector(item) + "<br />");
        });
    };

    Enumerable.prototype.force = function () {
        var enumerator = this.getEnumerator();

        try {
            while (enumerator.moveNext()) {
            }
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    /* Functional Methods */

    Enumerable.prototype.letBind = function (func) {
        func = Utils.createLambda(func);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = Enumerable.from(func(source)).getEnumerator();
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.share = function () {
        var source = this;
        var sharedEnumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            return new IEnumerator(
                function () {
                    if (sharedEnumerator == null) {
                        sharedEnumerator = source.getEnumerator();
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    return (sharedEnumerator.moveNext())
                        ? this.yieldReturn(sharedEnumerator.current())
                        : false;
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.dispose(sharedEnumerator);
        });
    };

    Enumerable.prototype.memoize = function () {
        var source = this;
        var cache;
        var enumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            var index = -1;

            return new IEnumerator(
                function () {
                    if (enumerator == null) {
                        enumerator = source.getEnumerator();
                        cache = [];
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    index++;
                    if (cache.length <= index) {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(cache[index] = enumerator.current())
                            : false;
                    }

                    return this.yieldReturn(cache[index]);
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.dispose(enumerator);
            cache = null;
        });
    };

    /* Error Handling Methods */

    Enumerable.prototype.catchError = function (handler) {
        handler = Utils.createLambda(handler);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    try {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(enumerator.current())
                            : false;
                    } catch (e) {
                        handler(e);
                        return false;
                    }
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.finallyAction = function (finallyAction) {
        finallyAction = Utils.createLambda(finallyAction);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    } finally {
                        finallyAction();
                    }
                });
        });
    };

    /* For Debug Methods */

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.log = function (selector) {
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(selector(item));
            }
        });
    };

    // Overload:function()
    // Overload:function(message)
    // Overload:function(message,selector)
    Enumerable.prototype.trace = function (message, selector) {
        if (message == null) message = "Trace";
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(message, selector(item));
            }
        });
    };

    // private

    var OrderedEnumerable = function (source, keySelector, descending, parent) {
        this.source = source;
        this.keySelector = Utils.createLambda(keySelector);
        this.descending = descending;
        this.parent = parent;
    };
    OrderedEnumerable.prototype = new Enumerable();

    OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, descending) {
        return new OrderedEnumerable(this.source, keySelector, descending, this);
    };

    OrderedEnumerable.prototype.thenBy = function (keySelector) {
        return this.createOrderedEnumerable(keySelector, false);
    };

    OrderedEnumerable.prototype.thenByDescending = function (keySelector) {
        return this.createOrderedEnumerable(keySelector, true);
    };

    OrderedEnumerable.prototype.getEnumerator = function () {
        var self = this;
        var buffer;
        var indexes;
        var index = 0;

        return new IEnumerator(
            function () {
                buffer = [];
                indexes = [];
                self.source.forEach(function (item, index) {
                    buffer.push(item);
                    indexes.push(index);
                });
                var sortContext = SortContext.create(self, null);
                sortContext.GenerateKeys(buffer);

                indexes.sort(function (a, b) { return sortContext.compare(a, b); });
            },
            function () {
                return (index < indexes.length)
                    ? this.yieldReturn(buffer[indexes[index++]])
                    : false;
            },
            Functions.Blank
        );
    };

    var SortContext = function (keySelector, descending, child) {
        this.keySelector = keySelector;
        this.descending = descending;
        this.child = child;
        this.keys = null;
    };

    SortContext.create = function (orderedEnumerable, currentContext) {
        var context = new SortContext(orderedEnumerable.keySelector, orderedEnumerable.descending, currentContext);
        if (orderedEnumerable.parent != null) return SortContext.create(orderedEnumerable.parent, context);
        return context;
    };

    SortContext.prototype.GenerateKeys = function (source) {
        var len = source.length;
        var keySelector = this.keySelector;
        var keys = new Array(len);
        for (var i = 0; i < len; i++) keys[i] = keySelector(source[i]);
        this.keys = keys;

        if (this.child != null) this.child.GenerateKeys(source);
    };

    SortContext.prototype.compare = function (index1, index2) {
        var comparison = Utils.compare(this.keys[index1], this.keys[index2]);

        if (comparison == 0) {
            if (this.child != null) return this.child.compare(index1, index2);
            return Utils.compare(index1, index2);
        }

        return (this.descending) ? -comparison : comparison;
    };

    var DisposableEnumerable = function (getEnumerator, dispose) {
        this.dispose = dispose;
        Enumerable.call(this, getEnumerator);
    };
    DisposableEnumerable.prototype = new Enumerable();

    // optimize array or arraylike object

    var ArrayEnumerable = function (source) {
        this.getSource = function () { return source; };
    };
    ArrayEnumerable.prototype = new Enumerable();

    ArrayEnumerable.prototype.any = function (predicate) {
        return (predicate == null)
            ? (this.getSource().length > 0)
            : Enumerable.prototype.any.apply(this, arguments);
    };

    ArrayEnumerable.prototype.count = function (predicate) {
        return (predicate == null)
            ? this.getSource().length
            : Enumerable.prototype.count.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAt = function (index) {
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : Enumerable.prototype.elementAt.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : defaultValue;
    };

    ArrayEnumerable.prototype.first = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[0]
            : Enumerable.prototype.first.apply(this, arguments);
    };

    ArrayEnumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            return Enumerable.prototype.firstOrDefault.apply(this, arguments);
        }
        defaultValue = predicate;

        var source = this.getSource();
        return source.length > 0 ? source[0] : defaultValue;
    };

    ArrayEnumerable.prototype.last = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[source.length - 1]
            : Enumerable.prototype.last.apply(this, arguments);
    };

    ArrayEnumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            return Enumerable.prototype.lastOrDefault.apply(this, arguments);
        }
        defaultValue = predicate;

        var source = this.getSource();
        return source.length > 0 ? source[source.length - 1] : defaultValue;
    };

    ArrayEnumerable.prototype.skip = function (count) {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () { index = (count < 0) ? 0 : count; },
                function () {
                    return (index < source.length)
                        ? this.yieldReturn(source[index++])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        return this.take(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.takeFromLast = function (count) {
        return this.skip(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.reverse = function () {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () {
                    index = source.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(source[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.sequenceEqual = function (second, compareSelector) {
        if ((second instanceof ArrayEnumerable || second instanceof Array)
            && compareSelector == null
            && Enumerable.from(second).count() != this.count()) {
            return false;
        }

        return Enumerable.prototype.sequenceEqual.apply(this, arguments);
    };

    ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {
        var source = this.getSource();
        if (selector != null || !(source instanceof Array)) {
            return Enumerable.prototype.toJoinedString.apply(this, arguments);
        }

        if (separator == null) separator = "";
        return source.join(separator);
    };

    ArrayEnumerable.prototype.getEnumerator = function () {
        var source = this.getSource();
        var index = -1;

        // fast and simple enumerator
        return {
            current: function () { return source[index]; },
            moveNext: function () {
                return ++index < source.length;
            },
            dispose: Functions.Blank
        };
    };

    // optimization for multiple where and multiple select and whereselect

    var WhereEnumerable = function (source, predicate) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1
    };
    WhereEnumerable.prototype = new Enumerable();

    WhereEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            var prevPredicate = this.prevPredicate;
            var composedPredicate = function (x) { return prevPredicate(x) && predicate(x); };
            return new WhereEnumerable(this.prevSource, composedPredicate);
        }
        else {
            // if predicate use index, can't compose
            return Enumerable.prototype.where.call(this, predicate);
        }
    };

    WhereEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        return (selector.length <= 1)
            ? new WhereSelectEnumerable(this.prevSource, this.prevPredicate, selector)
            : Enumerable.prototype.select.call(this, selector);
    };

    WhereEnumerable.prototype.getEnumerator = function () {
        var predicate = this.prevPredicate;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.getEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate(enumerator.current())) {
                        return this.yieldReturn(enumerator.current());
                    }
                }
                return false;
            },
            function () { Utils.dispose(enumerator); });
    };

    var WhereSelectEnumerable = function (source, predicate, selector) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1 or null
        this.prevSelector = selector; // selector.length always <= 1
    };
    WhereSelectEnumerable.prototype = new Enumerable();

    WhereSelectEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        return (predicate.length <= 1)
            ? new WhereEnumerable(this, predicate)
            : Enumerable.prototype.where.call(this, predicate);
    };

    WhereSelectEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            var prevSelector = this.prevSelector;
            var composedSelector = function (x) { return selector(prevSelector(x)); };
            return new WhereSelectEnumerable(this.prevSource, this.prevPredicate, composedSelector);
        }
        else {
            // if selector use index, can't compose
            return Enumerable.prototype.select.call(this, selector);
        }
    };

    WhereSelectEnumerable.prototype.getEnumerator = function () {
        var predicate = this.prevPredicate;
        var selector = this.prevSelector;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.getEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate == null || predicate(enumerator.current())) {
                        return this.yieldReturn(selector(enumerator.current()));
                    }
                }
                return false;
            },
            function () { Utils.dispose(enumerator); });
    };

    // Collections

    var Dictionary = (function () {
        // static utility methods
        var callHasOwnProperty = function (target, key) {
            return Object.prototype.hasOwnProperty.call(target, key);
        };

        var computeHashCode = function (obj) {
            if (obj === null) return "null";
            if (obj === undefined) return "undefined";

            return (typeof obj.toString === Types.Function)
                ? obj.toString()
                : Object.prototype.toString.call(obj);
        };

        // LinkedList for Dictionary
        var HashEntry = function (key, value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        };

        var EntryList = function () {
            this.first = null;
            this.last = null;
        };
        EntryList.prototype =
        {
            addLast: function (entry) {
                if (this.last != null) {
                    this.last.next = entry;
                    entry.prev = this.last;
                    this.last = entry;
                } else this.first = this.last = entry;
            },

            replace: function (entry, newEntry) {
                if (entry.prev != null) {
                    entry.prev.next = newEntry;
                    newEntry.prev = entry.prev;
                } else this.first = newEntry;

                if (entry.next != null) {
                    entry.next.prev = newEntry;
                    newEntry.next = entry.next;
                } else this.last = newEntry;

            },

            remove: function (entry) {
                if (entry.prev != null) entry.prev.next = entry.next;
                else this.first = entry.next;

                if (entry.next != null) entry.next.prev = entry.prev;
                else this.last = entry.prev;
            }
        };

        // Overload:function()
        // Overload:function(compareSelector)
        var Dictionary = function (compareSelector) {
            this.countField = 0;
            this.entryList = new EntryList();
            this.buckets = {}; // as Dictionary<string,List<object>>
            this.compareSelector = (compareSelector == null) ? Functions.Identity : compareSelector;
        };
        Dictionary.prototype =
        {
            add: function (key, value) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                var entry = new HashEntry(key, value);
                if (callHasOwnProperty(this.buckets, hash)) {
                    var array = this.buckets[hash];
                    for (var i = 0; i < array.length; i++) {
                        if (this.compareSelector(array[i].key) === compareKey) {
                            this.entryList.replace(array[i], entry);
                            array[i] = entry;
                            return;
                        }
                    }
                    array.push(entry);
                } else {
                    this.buckets[hash] = [entry];
                }
                this.countField++;
                this.entryList.addLast(entry);
            },

            get: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return undefined;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    var entry = array[i];
                    if (this.compareSelector(entry.key) === compareKey) return entry.value;
                }
                return undefined;
            },

            set: function (key, value) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (callHasOwnProperty(this.buckets, hash)) {
                    var array = this.buckets[hash];
                    for (var i = 0; i < array.length; i++) {
                        if (this.compareSelector(array[i].key) === compareKey) {
                            var newEntry = new HashEntry(key, value);
                            this.entryList.replace(array[i], newEntry);
                            array[i] = newEntry;
                            return true;
                        }
                    }
                }
                return false;
            },

            contains: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return false;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    if (this.compareSelector(array[i].key) === compareKey) return true;
                }
                return false;
            },

            clear: function () {
                this.countField = 0;
                this.buckets = {};
                this.entryList = new EntryList();
            },

            remove: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    if (this.compareSelector(array[i].key) === compareKey) {
                        this.entryList.remove(array[i]);
                        array.splice(i, 1);
                        if (array.length == 0) delete this.buckets[hash];
                        this.countField--;
                        return;
                    }
                }
            },

            count: function () {
                return this.countField;
            },

            toEnumerable: function () {
                var self = this;
                return new Enumerable(function () {
                    var currentEntry;

                    return new IEnumerator(
                        function () { currentEntry = self.entryList.first; },
                        function () {
                            if (currentEntry != null) {
                                var result = { key: currentEntry.key, value: currentEntry.value };
                                currentEntry = currentEntry.next;
                                return this.yieldReturn(result);
                            }
                            return false;
                        },
                        Functions.Blank);
                });
            }
        };

        return Dictionary;
    })();

    // dictionary = Dictionary<TKey, TValue[]>
    var Lookup = function (dictionary) {
        this.count = function () {
            return dictionary.count();
        };
        this.get = function (key) {
            return Enumerable.from(dictionary.get(key));
        };
        this.contains = function (key) {
            return dictionary.contains(key);
        };
        this.toEnumerable = function () {
            return dictionary.toEnumerable().select(function (kvp) {
                return new Grouping(kvp.key, kvp.value);
            });
        };
    };

    var Grouping = function (groupKey, elements) {
        this.key = function () {
            return groupKey;
        };
        ArrayEnumerable.call(this, elements);
    };
    Grouping.prototype = new ArrayEnumerable();

    // module export
    if ("function" === Types.Function && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) { // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Enumerable; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else if (typeof module !== Types.Undefined && module.exports) { // Node
        module.exports = Enumerable;
    }
    else {
        root.Enumerable = Enumerable;
    }
})(this);


/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/node-libs-browser/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/isarray/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/isarray/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/rxjs/AsyncSubject.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/AsyncSubject.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/Subject.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/Subscription.js");
/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        _super.apply(this, arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;
//# sourceMappingURL=AsyncSubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/BehaviorSubject.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/BehaviorSubject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/Subject.js");
var ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/util/ObjectUnsubscribedError.js");
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;
//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/InnerSubscriber.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/InnerSubscriber.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/Notification.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/Notification.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(/*! ./Observable */ "./node_modules/rxjs/Observable.js");
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),

/***/ "./node_modules/rxjs/Observable.js":
/*!*****************************************!*\
  !*** ./node_modules/rxjs/Observable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ./util/root */ "./node_modules/rxjs/util/root.js");
var toSubscriber_1 = __webpack_require__(/*! ./util/toSubscriber */ "./node_modules/rxjs/util/toSubscriber.js");
var observable_1 = __webpack_require__(/*! ./symbol/observable */ "./node_modules/rxjs/symbol/observable.js");
var pipe_1 = __webpack_require__(/*! ./util/pipe */ "./node_modules/rxjs/util/pipe.js");
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/Observer.js":
/*!***************************************!*\
  !*** ./node_modules/rxjs/Observer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),

/***/ "./node_modules/rxjs/OuterSubscriber.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/OuterSubscriber.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/ReplaySubject.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/ReplaySubject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ./Subject */ "./node_modules/rxjs/Subject.js");
var queue_1 = __webpack_require__(/*! ./scheduler/queue */ "./node_modules/rxjs/scheduler/queue.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/Subscription.js");
var observeOn_1 = __webpack_require__(/*! ./operators/observeOn */ "./node_modules/rxjs/operators/observeOn.js");
var ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/util/ObjectUnsubscribedError.js");
var SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ "./node_modules/rxjs/SubjectSubscription.js");
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),

/***/ "./node_modules/rxjs/Scheduler.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/Scheduler.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/Subject.js":
/*!**************************************!*\
  !*** ./node_modules/rxjs/Subject.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(/*! ./Observable */ "./node_modules/rxjs/Observable.js");
var Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/Subscription.js");
var ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/rxjs/util/ObjectUnsubscribedError.js");
var SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ "./node_modules/rxjs/SubjectSubscription.js");
var rxSubscriber_1 = __webpack_require__(/*! ./symbol/rxSubscriber */ "./node_modules/rxjs/symbol/rxSubscriber.js");
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),

/***/ "./node_modules/rxjs/SubjectSubscription.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/SubjectSubscription.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/Subscription.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/Subscriber.js":
/*!*****************************************!*\
  !*** ./node_modules/rxjs/Subscriber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/util/isFunction.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/rxjs/Subscription.js");
var Observer_1 = __webpack_require__(/*! ./Observer */ "./node_modules/rxjs/Observer.js");
var rxSubscriber_1 = __webpack_require__(/*! ./symbol/rxSubscriber */ "./node_modules/rxjs/symbol/rxSubscriber.js");
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    // HACK(benlesh): To resolve an issue where Node users may have multiple
                    // copies of rxjs in their node_modules directory.
                    if (isTrustedSubscriber(destinationOrNext)) {
                        var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                        this.destination = trustedSubscriber;
                        trustedSubscriber.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
function isTrustedSubscriber(obj) {
    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber]);
}
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/Subscription.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/Subscription.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(/*! ./util/isArray */ "./node_modules/rxjs/util/isArray.js");
var isObject_1 = __webpack_require__(/*! ./util/isObject */ "./node_modules/rxjs/util/isObject.js");
var isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/rxjs/util/isFunction.js");
var tryCatch_1 = __webpack_require__(/*! ./util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ./util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ "./node_modules/rxjs/util/UnsubscriptionError.js");
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/ArrayLikeObservable.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/observable/ArrayLikeObservable.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var ScalarObservable_1 = __webpack_require__(/*! ./ScalarObservable */ "./node_modules/rxjs/observable/ScalarObservable.js");
var EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ "./node_modules/rxjs/observable/EmptyObservable.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/ArrayObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/ArrayObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var ScalarObservable_1 = __webpack_require__(/*! ./ScalarObservable */ "./node_modules/rxjs/observable/ScalarObservable.js");
var EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ "./node_modules/rxjs/observable/EmptyObservable.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/ConnectableObservable.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/observable/ConnectableObservable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
var refCount_1 = __webpack_require__(/*! ../operators/refCount */ "./node_modules/rxjs/operators/refCount.js");
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/EmptyObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/EmptyObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/FromObservable.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/observable/FromObservable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
var isArrayLike_1 = __webpack_require__(/*! ../util/isArrayLike */ "./node_modules/rxjs/util/isArrayLike.js");
var isPromise_1 = __webpack_require__(/*! ../util/isPromise */ "./node_modules/rxjs/util/isPromise.js");
var PromiseObservable_1 = __webpack_require__(/*! ./PromiseObservable */ "./node_modules/rxjs/observable/PromiseObservable.js");
var IteratorObservable_1 = __webpack_require__(/*! ./IteratorObservable */ "./node_modules/rxjs/observable/IteratorObservable.js");
var ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
var ArrayLikeObservable_1 = __webpack_require__(/*! ./ArrayLikeObservable */ "./node_modules/rxjs/observable/ArrayLikeObservable.js");
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/symbol/iterator.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var observeOn_1 = __webpack_require__(/*! ../operators/observeOn */ "./node_modules/rxjs/operators/observeOn.js");
var observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/symbol/observable.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/IteratorObservable.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/observable/IteratorObservable.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/rxjs/util/root.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/symbol/iterator.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
exports.IteratorObservable = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/PromiseObservable.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/observable/PromiseObservable.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/rxjs/util/root.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/ScalarObservable.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/observable/ScalarObservable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/TimerObservable.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/observable/TimerObservable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(/*! ../util/isNumeric */ "./node_modules/rxjs/util/isNumeric.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
var isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/rxjs/util/isDate.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));
exports.TimerObservable = TimerObservable;
//# sourceMappingURL=TimerObservable.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/concat.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/observable/concat.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
var of_1 = __webpack_require__(/*! ./of */ "./node_modules/rxjs/observable/of.js");
var from_1 = __webpack_require__(/*! ./from */ "./node_modules/rxjs/observable/from.js");
var concatAll_1 = __webpack_require__(/*! ../operators/concatAll */ "./node_modules/rxjs/operators/concatAll.js");
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/from.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/observable/from.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromObservable_1 = __webpack_require__(/*! ./FromObservable */ "./node_modules/rxjs/observable/FromObservable.js");
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/merge.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/merge.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
var mergeAll_1 = __webpack_require__(/*! ../operators/mergeAll */ "./node_modules/rxjs/operators/mergeAll.js");
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/of.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/observable/of.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(/*! ./ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
exports.of = ArrayObservable_1.ArrayObservable.of;
//# sourceMappingURL=of.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/race.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/observable/race.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
var ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `race([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;
//# sourceMappingURL=race.js.map

/***/ }),

/***/ "./node_modules/rxjs/observable/timer.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/observable/timer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TimerObservable_1 = __webpack_require__(/*! ./TimerObservable */ "./node_modules/rxjs/observable/TimerObservable.js");
exports.timer = TimerObservable_1.TimerObservable.create;
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/operators.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var audit_1 = __webpack_require__(/*! ./operators/audit */ "./node_modules/rxjs/operators/audit.js");
exports.audit = audit_1.audit;
var auditTime_1 = __webpack_require__(/*! ./operators/auditTime */ "./node_modules/rxjs/operators/auditTime.js");
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = __webpack_require__(/*! ./operators/buffer */ "./node_modules/rxjs/operators/buffer.js");
exports.buffer = buffer_1.buffer;
var bufferCount_1 = __webpack_require__(/*! ./operators/bufferCount */ "./node_modules/rxjs/operators/bufferCount.js");
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = __webpack_require__(/*! ./operators/bufferTime */ "./node_modules/rxjs/operators/bufferTime.js");
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = __webpack_require__(/*! ./operators/bufferToggle */ "./node_modules/rxjs/operators/bufferToggle.js");
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = __webpack_require__(/*! ./operators/bufferWhen */ "./node_modules/rxjs/operators/bufferWhen.js");
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = __webpack_require__(/*! ./operators/catchError */ "./node_modules/rxjs/operators/catchError.js");
exports.catchError = catchError_1.catchError;
var combineAll_1 = __webpack_require__(/*! ./operators/combineAll */ "./node_modules/rxjs/operators/combineAll.js");
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = __webpack_require__(/*! ./operators/combineLatest */ "./node_modules/rxjs/operators/combineLatest.js");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = __webpack_require__(/*! ./operators/concat */ "./node_modules/rxjs/operators/concat.js");
exports.concat = concat_1.concat;
var concatAll_1 = __webpack_require__(/*! ./operators/concatAll */ "./node_modules/rxjs/operators/concatAll.js");
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = __webpack_require__(/*! ./operators/concatMap */ "./node_modules/rxjs/operators/concatMap.js");
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = __webpack_require__(/*! ./operators/concatMapTo */ "./node_modules/rxjs/operators/concatMapTo.js");
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = __webpack_require__(/*! ./operators/count */ "./node_modules/rxjs/operators/count.js");
exports.count = count_1.count;
var debounce_1 = __webpack_require__(/*! ./operators/debounce */ "./node_modules/rxjs/operators/debounce.js");
exports.debounce = debounce_1.debounce;
var debounceTime_1 = __webpack_require__(/*! ./operators/debounceTime */ "./node_modules/rxjs/operators/debounceTime.js");
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = __webpack_require__(/*! ./operators/defaultIfEmpty */ "./node_modules/rxjs/operators/defaultIfEmpty.js");
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = __webpack_require__(/*! ./operators/delay */ "./node_modules/rxjs/operators/delay.js");
exports.delay = delay_1.delay;
var delayWhen_1 = __webpack_require__(/*! ./operators/delayWhen */ "./node_modules/rxjs/operators/delayWhen.js");
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = __webpack_require__(/*! ./operators/dematerialize */ "./node_modules/rxjs/operators/dematerialize.js");
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = __webpack_require__(/*! ./operators/distinct */ "./node_modules/rxjs/operators/distinct.js");
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = __webpack_require__(/*! ./operators/distinctUntilChanged */ "./node_modules/rxjs/operators/distinctUntilChanged.js");
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = __webpack_require__(/*! ./operators/distinctUntilKeyChanged */ "./node_modules/rxjs/operators/distinctUntilKeyChanged.js");
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = __webpack_require__(/*! ./operators/elementAt */ "./node_modules/rxjs/operators/elementAt.js");
exports.elementAt = elementAt_1.elementAt;
var every_1 = __webpack_require__(/*! ./operators/every */ "./node_modules/rxjs/operators/every.js");
exports.every = every_1.every;
var exhaust_1 = __webpack_require__(/*! ./operators/exhaust */ "./node_modules/rxjs/operators/exhaust.js");
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = __webpack_require__(/*! ./operators/exhaustMap */ "./node_modules/rxjs/operators/exhaustMap.js");
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = __webpack_require__(/*! ./operators/expand */ "./node_modules/rxjs/operators/expand.js");
exports.expand = expand_1.expand;
var filter_1 = __webpack_require__(/*! ./operators/filter */ "./node_modules/rxjs/operators/filter.js");
exports.filter = filter_1.filter;
var finalize_1 = __webpack_require__(/*! ./operators/finalize */ "./node_modules/rxjs/operators/finalize.js");
exports.finalize = finalize_1.finalize;
var find_1 = __webpack_require__(/*! ./operators/find */ "./node_modules/rxjs/operators/find.js");
exports.find = find_1.find;
var findIndex_1 = __webpack_require__(/*! ./operators/findIndex */ "./node_modules/rxjs/operators/findIndex.js");
exports.findIndex = findIndex_1.findIndex;
var first_1 = __webpack_require__(/*! ./operators/first */ "./node_modules/rxjs/operators/first.js");
exports.first = first_1.first;
var groupBy_1 = __webpack_require__(/*! ./operators/groupBy */ "./node_modules/rxjs/operators/groupBy.js");
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = __webpack_require__(/*! ./operators/ignoreElements */ "./node_modules/rxjs/operators/ignoreElements.js");
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = __webpack_require__(/*! ./operators/isEmpty */ "./node_modules/rxjs/operators/isEmpty.js");
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = __webpack_require__(/*! ./operators/last */ "./node_modules/rxjs/operators/last.js");
exports.last = last_1.last;
var map_1 = __webpack_require__(/*! ./operators/map */ "./node_modules/rxjs/operators/map.js");
exports.map = map_1.map;
var mapTo_1 = __webpack_require__(/*! ./operators/mapTo */ "./node_modules/rxjs/operators/mapTo.js");
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = __webpack_require__(/*! ./operators/materialize */ "./node_modules/rxjs/operators/materialize.js");
exports.materialize = materialize_1.materialize;
var max_1 = __webpack_require__(/*! ./operators/max */ "./node_modules/rxjs/operators/max.js");
exports.max = max_1.max;
var merge_1 = __webpack_require__(/*! ./operators/merge */ "./node_modules/rxjs/operators/merge.js");
exports.merge = merge_1.merge;
var mergeAll_1 = __webpack_require__(/*! ./operators/mergeAll */ "./node_modules/rxjs/operators/mergeAll.js");
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = __webpack_require__(/*! ./operators/mergeMap */ "./node_modules/rxjs/operators/mergeMap.js");
exports.mergeMap = mergeMap_1.mergeMap;
var mergeMap_2 = __webpack_require__(/*! ./operators/mergeMap */ "./node_modules/rxjs/operators/mergeMap.js");
exports.flatMap = mergeMap_2.mergeMap;
var mergeMapTo_1 = __webpack_require__(/*! ./operators/mergeMapTo */ "./node_modules/rxjs/operators/mergeMapTo.js");
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = __webpack_require__(/*! ./operators/mergeScan */ "./node_modules/rxjs/operators/mergeScan.js");
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = __webpack_require__(/*! ./operators/min */ "./node_modules/rxjs/operators/min.js");
exports.min = min_1.min;
var multicast_1 = __webpack_require__(/*! ./operators/multicast */ "./node_modules/rxjs/operators/multicast.js");
exports.multicast = multicast_1.multicast;
var observeOn_1 = __webpack_require__(/*! ./operators/observeOn */ "./node_modules/rxjs/operators/observeOn.js");
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = __webpack_require__(/*! ./operators/onErrorResumeNext */ "./node_modules/rxjs/operators/onErrorResumeNext.js");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = __webpack_require__(/*! ./operators/pairwise */ "./node_modules/rxjs/operators/pairwise.js");
exports.pairwise = pairwise_1.pairwise;
var partition_1 = __webpack_require__(/*! ./operators/partition */ "./node_modules/rxjs/operators/partition.js");
exports.partition = partition_1.partition;
var pluck_1 = __webpack_require__(/*! ./operators/pluck */ "./node_modules/rxjs/operators/pluck.js");
exports.pluck = pluck_1.pluck;
var publish_1 = __webpack_require__(/*! ./operators/publish */ "./node_modules/rxjs/operators/publish.js");
exports.publish = publish_1.publish;
var publishBehavior_1 = __webpack_require__(/*! ./operators/publishBehavior */ "./node_modules/rxjs/operators/publishBehavior.js");
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = __webpack_require__(/*! ./operators/publishLast */ "./node_modules/rxjs/operators/publishLast.js");
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = __webpack_require__(/*! ./operators/publishReplay */ "./node_modules/rxjs/operators/publishReplay.js");
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = __webpack_require__(/*! ./operators/race */ "./node_modules/rxjs/operators/race.js");
exports.race = race_1.race;
var reduce_1 = __webpack_require__(/*! ./operators/reduce */ "./node_modules/rxjs/operators/reduce.js");
exports.reduce = reduce_1.reduce;
var repeat_1 = __webpack_require__(/*! ./operators/repeat */ "./node_modules/rxjs/operators/repeat.js");
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = __webpack_require__(/*! ./operators/repeatWhen */ "./node_modules/rxjs/operators/repeatWhen.js");
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = __webpack_require__(/*! ./operators/retry */ "./node_modules/rxjs/operators/retry.js");
exports.retry = retry_1.retry;
var retryWhen_1 = __webpack_require__(/*! ./operators/retryWhen */ "./node_modules/rxjs/operators/retryWhen.js");
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = __webpack_require__(/*! ./operators/refCount */ "./node_modules/rxjs/operators/refCount.js");
exports.refCount = refCount_1.refCount;
var sample_1 = __webpack_require__(/*! ./operators/sample */ "./node_modules/rxjs/operators/sample.js");
exports.sample = sample_1.sample;
var sampleTime_1 = __webpack_require__(/*! ./operators/sampleTime */ "./node_modules/rxjs/operators/sampleTime.js");
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = __webpack_require__(/*! ./operators/scan */ "./node_modules/rxjs/operators/scan.js");
exports.scan = scan_1.scan;
var sequenceEqual_1 = __webpack_require__(/*! ./operators/sequenceEqual */ "./node_modules/rxjs/operators/sequenceEqual.js");
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = __webpack_require__(/*! ./operators/share */ "./node_modules/rxjs/operators/share.js");
exports.share = share_1.share;
var shareReplay_1 = __webpack_require__(/*! ./operators/shareReplay */ "./node_modules/rxjs/operators/shareReplay.js");
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = __webpack_require__(/*! ./operators/single */ "./node_modules/rxjs/operators/single.js");
exports.single = single_1.single;
var skip_1 = __webpack_require__(/*! ./operators/skip */ "./node_modules/rxjs/operators/skip.js");
exports.skip = skip_1.skip;
var skipLast_1 = __webpack_require__(/*! ./operators/skipLast */ "./node_modules/rxjs/operators/skipLast.js");
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = __webpack_require__(/*! ./operators/skipUntil */ "./node_modules/rxjs/operators/skipUntil.js");
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = __webpack_require__(/*! ./operators/skipWhile */ "./node_modules/rxjs/operators/skipWhile.js");
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = __webpack_require__(/*! ./operators/startWith */ "./node_modules/rxjs/operators/startWith.js");
exports.startWith = startWith_1.startWith;
/**
 * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be
 * treeshaken. Currently if this export is added back, it
 * forces apps to bring in asap scheduler along with
 * Immediate, root, and other supporting code.
 */
// export { subscribeOn } from './operators/subscribeOn';
var switchAll_1 = __webpack_require__(/*! ./operators/switchAll */ "./node_modules/rxjs/operators/switchAll.js");
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = __webpack_require__(/*! ./operators/switchMap */ "./node_modules/rxjs/operators/switchMap.js");
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = __webpack_require__(/*! ./operators/switchMapTo */ "./node_modules/rxjs/operators/switchMapTo.js");
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = __webpack_require__(/*! ./operators/take */ "./node_modules/rxjs/operators/take.js");
exports.take = take_1.take;
var takeLast_1 = __webpack_require__(/*! ./operators/takeLast */ "./node_modules/rxjs/operators/takeLast.js");
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = __webpack_require__(/*! ./operators/takeUntil */ "./node_modules/rxjs/operators/takeUntil.js");
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = __webpack_require__(/*! ./operators/takeWhile */ "./node_modules/rxjs/operators/takeWhile.js");
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = __webpack_require__(/*! ./operators/tap */ "./node_modules/rxjs/operators/tap.js");
exports.tap = tap_1.tap;
var throttle_1 = __webpack_require__(/*! ./operators/throttle */ "./node_modules/rxjs/operators/throttle.js");
exports.throttle = throttle_1.throttle;
var throttleTime_1 = __webpack_require__(/*! ./operators/throttleTime */ "./node_modules/rxjs/operators/throttleTime.js");
exports.throttleTime = throttleTime_1.throttleTime;
var timeInterval_1 = __webpack_require__(/*! ./operators/timeInterval */ "./node_modules/rxjs/operators/timeInterval.js");
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = __webpack_require__(/*! ./operators/timeout */ "./node_modules/rxjs/operators/timeout.js");
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = __webpack_require__(/*! ./operators/timeoutWith */ "./node_modules/rxjs/operators/timeoutWith.js");
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = __webpack_require__(/*! ./operators/timestamp */ "./node_modules/rxjs/operators/timestamp.js");
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = __webpack_require__(/*! ./operators/toArray */ "./node_modules/rxjs/operators/toArray.js");
exports.toArray = toArray_1.toArray;
var window_1 = __webpack_require__(/*! ./operators/window */ "./node_modules/rxjs/operators/window.js");
exports.window = window_1.window;
var windowCount_1 = __webpack_require__(/*! ./operators/windowCount */ "./node_modules/rxjs/operators/windowCount.js");
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = __webpack_require__(/*! ./operators/windowTime */ "./node_modules/rxjs/operators/windowTime.js");
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = __webpack_require__(/*! ./operators/windowToggle */ "./node_modules/rxjs/operators/windowToggle.js");
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = __webpack_require__(/*! ./operators/windowWhen */ "./node_modules/rxjs/operators/windowWhen.js");
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = __webpack_require__(/*! ./operators/withLatestFrom */ "./node_modules/rxjs/operators/withLatestFrom.js");
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = __webpack_require__(/*! ./operators/zip */ "./node_modules/rxjs/operators/zip.js");
exports.zip = zip_1.zip;
var zipAll_1 = __webpack_require__(/*! ./operators/zipAll */ "./node_modules/rxjs/operators/zipAll.js");
exports.zipAll = zipAll_1.zipAll;
//# sourceMappingURL=operators.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/audit.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/audit.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
            if (duration === errorObject_1.errorObject) {
                this.destination.error(errorObject_1.errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
                if (innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=audit.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/auditTime.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/auditTime.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var audit_1 = __webpack_require__(/*! ./audit */ "./node_modules/rxjs/operators/audit.js");
var timer_1 = __webpack_require__(/*! ../observable/timer */ "./node_modules/rxjs/observable/timer.js");
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;
//# sourceMappingURL=auditTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/buffer.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/buffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=buffer.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/bufferCount.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/bufferCount.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.buffer = [];
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=bufferCount.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/bufferTime.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/bufferTime.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
/* tslint:enable:max-line-length */
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _super.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        var context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/bufferToggle.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/operators/bufferToggle.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(subscribeToResult_1.subscribeToResult(this, openings));
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=bufferToggle.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/bufferWhen.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/bufferWhen.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        }
        else {
            closingSubscription = new Subscription_1.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=bufferWhen.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/catchError.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/catchError.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @name catchError
 */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=catchError.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/combineAll.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/combineAll.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var combineLatest_1 = __webpack_require__(/*! ../operators/combineLatest */ "./node_modules/rxjs/operators/combineLatest.js");
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;
//# sourceMappingURL=combineAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/combineLatest.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operators/combineLatest.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/concat.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/concat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(/*! ../observable/concat */ "./node_modules/rxjs/observable/concat.js");
var concat_2 = __webpack_require__(/*! ../observable/concat */ "./node_modules/rxjs/observable/concat.js");
exports.concatStatic = concat_2.concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/concatAll.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/concatAll.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeAll_1 = __webpack_require__(/*! ./mergeAll */ "./node_modules/rxjs/operators/mergeAll.js");
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/concatMap.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/concatMap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(/*! ./mergeMap */ "./node_modules/rxjs/operators/mergeMap.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/concatMapTo.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/concatMapTo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatMap_1 = __webpack_require__(/*! ./concatMap */ "./node_modules/rxjs/operators/concatMap.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/count.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/count.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting a value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 4
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=count.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/debounce.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/debounce.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Emits a value from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * <img src="./img/debounce.png" width="100%">
 *
 * `debounce` delays values emitted by the source Observable, but drops previous
 * pending delayed emissions if a new value arrives on the source Observable.
 * This operator keeps track of the most recent value from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The value is emitted only when the duration
 * Observable emits a value or completes, and if no other value was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * value appears before the duration Observable emits, the previous value will
 * be dropped and will not be emitted on the output Observable.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 * @method debounce
 * @owner Observable
 */
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1.subscribeToResult(this, duration);
        if (!subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=debounce.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/debounceTime.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/operators/debounceTime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/defaultIfEmpty.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/operators/defaultIfEmpty.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/* tslint:enable:max-line-length */
/**
 * Emits a given value if the source Observable completes without emitting any
 * `next` value, otherwise mirrors the source Observable.
 *
 * <span class="informal">If the source Observable turns out to be empty, then
 * this operator will emit a default value.</span>
 *
 * <img src="./img/defaultIfEmpty.png" width="100%">
 *
 * `defaultIfEmpty` emits the values emitted by the source Observable or a
 * specified default value if the source Observable is empty (completes without
 * having emitted any `next` value).
 *
 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link empty}
 * @see {@link last}
 *
 * @param {any} [defaultValue=null] The default value used if the source
 * Observable is empty.
 * @return {Observable} An Observable that emits either the specified
 * `defaultValue` if the source Observable emits no items, or the values emitted
 * by the source Observable.
 * @method defaultIfEmpty
 * @owner Observable
 */
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _super.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/delay.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/delay.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/rxjs/util/isDate.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Notification_1 = __webpack_require__(/*! ../Notification */ "./node_modules/rxjs/Notification.js");
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/delayWhen.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/delayWhen.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * <img src="./img/delayWhen.png" width="100%">
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delayWhen(event =>
 *   Rx.Observable.interval(Math.random() * 5000)
 * );
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounce}
 * @see {@link delay}
 *
 * @param {function(value: T): Observable} delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param {Observable} subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        _super.call(this, destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.values = [];
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            this.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        _super.call(this);
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        _super.call(this);
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=delayWhen.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/dematerialize.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operators/dematerialize.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Converts an Observable of {@link Notification} objects into the emissions
 * that they represent.
 *
 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
 *
 * <img src="./img/dematerialize.png" width="100%">
 *
 * `dematerialize` is assumed to operate an Observable that only emits
 * {@link Notification} objects as `next` emissions, and does not emit any
 * `error`. Such Observable is the output of a `materialize` operation. Those
 * notifications are then unwrapped using the metadata they contain, and emitted
 * as `next`, `error`, and `complete` on the output Observable.
 *
 * Use this operator in conjunction with {@link materialize}.
 *
 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
 * var notifA = new Rx.Notification('N', 'A');
 * var notifB = new Rx.Notification('N', 'B');
 * var notifE = new Rx.Notification('E', void 0,
 *   new TypeError('x.toUpperCase is not a function')
 * );
 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
 * var upperCase = materialized.dematerialize();
 * upperCase.subscribe(x => console.log(x), e => console.error(e));
 *
 * // Results in:
 * // A
 * // B
 * // TypeError: x.toUpperCase is not a function
 *
 * @see {@link Notification}
 * @see {@link materialize}
 *
 * @return {Observable} An Observable that emits items and notifications
 * embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=dematerialize.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/distinct.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/distinct.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
var Set_1 = __webpack_require__(/*! ../util/Set */ "./node_modules/rxjs/util/Set.js");
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new Set_1.Set();
        if (flushes) {
            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;
//# sourceMappingURL=distinct.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/distinctUntilChanged.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/operators/distinctUntilChanged.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/distinctUntilKeyChanged.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/operators/distinctUntilKeyChanged.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var distinctUntilChanged_1 = __webpack_require__(/*! ./distinctUntilChanged */ "./node_modules/rxjs/operators/distinctUntilChanged.js");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
//# sourceMappingURL=distinctUntilKeyChanged.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/elementAt.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/elementAt.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/util/ArgumentOutOfRangeError.js");
/**
 * Emits the single value at the specified `index` in a sequence of emissions
 * from the source Observable.
 *
 * <span class="informal">Emits only the i-th value, then completes.</span>
 *
 * <img src="./img/elementAt.png" width="100%">
 *
 * `elementAt` returns an Observable that emits the item at the specified
 * `index` in the source Observable, or a default value if that `index` is out
 * of range and the `default` argument is provided. If the `default` argument is
 * not given and the `index` is out of range, the output Observable will emit an
 * `ArgumentOutOfRangeError` error.
 *
 * @example <caption>Emit only the third click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.elementAt(2);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // click 1 = nothing
 * // click 2 = nothing
 * // click 3 = MouseEvent object logged to console
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link skip}
 * @see {@link single}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
 * Observable has completed before emitting the i-th `next` notification.
 *
 * @param {number} index Is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {T} [defaultValue] The default value returned for missing indices.
 * @return {Observable} An Observable that emits a single item, if it is found.
 * Otherwise, will emit the default value if given. If not, then emits an error.
 * @method elementAt
 * @owner Observable
 */
function elementAt(index, defaultValue) {
    return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };
}
exports.elementAt = elementAt;
var ElementAtOperator = (function () {
    function ElementAtOperator(index, defaultValue) {
        this.index = index;
        this.defaultValue = defaultValue;
        if (index < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    ElementAtOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
    };
    return ElementAtOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ElementAtSubscriber = (function (_super) {
    __extends(ElementAtSubscriber, _super);
    function ElementAtSubscriber(destination, index, defaultValue) {
        _super.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }
    ElementAtSubscriber.prototype._next = function (x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };
    ElementAtSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            }
            else {
                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
            }
        }
        destination.complete();
    };
    return ElementAtSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=elementAt.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/every.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/every.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
 *
 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
 *  Observable.of(1, 2, 3, 4, 5, 6)
 *     .every(x => x < 5)
 *     .subscribe(x => console.log(x)); // -> false
 *
 * @param {function} predicate A function for determining if an item meets a specified condition.
 * @param {any} [thisArg] Optional object to use for `this` in the callback.
 * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
 * @method every
 * @owner Observable
 */
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
exports.every = every;
var EveryOperator = (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var EverySubscriber = (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
        this.index = 0;
        this.thisArg = thisArg || this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=every.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/exhaust.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/exhaust.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Converts a higher-order Observable into a first-order Observable by dropping
 * inner Observables while the previous inner Observable has not yet completed.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * next inner Observables while the current inner is still executing.</span>
 *
 * <img src="./img/exhaust.png" width="100%">
 *
 * `exhaust` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable begins emitting the items emitted by that
 * inner Observable. So far, it behaves like {@link mergeAll}. However,
 * `exhaust` ignores every new inner Observable if the previous Observable has
 * not yet completed. Once that one completes, it will accept and flatten the
 * next inner Observable and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));
 * var result = higherOrder.exhaust();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link switch}
 * @see {@link mergeAll}
 * @see {@link exhaustMap}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
 * exclusively until it completes before subscribing to the next.
 * @method exhaust
 * @owner Observable
 */
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        _super.call(this, destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaust.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/exhaustMap.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/exhaustMap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = (function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = (function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaustMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/expand.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/expand.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1.tryCatch(this.project)(value, index);
            if (result === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;
//# sourceMappingURL=expand.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/filter.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/filter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/finalize.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/finalize.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=finalize.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/find.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/find.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Emits only the first value emitted by the source Observable that meets some
 * condition.
 *
 * <span class="informal">Finds the first value that passes some test and emits
 * that.</span>
 *
 * <img src="./img/find.png" width="100%">
 *
 * `find` searches for the first item in the source Observable that matches the
 * specified condition embodied by the `predicate`, and returns the first
 * occurrence in the source. Unlike {@link first}, the `predicate` is required
 * in `find`, and does not emit an error if a valid value is not found.
 *
 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link first}
 * @see {@link findIndex}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable<T>} An Observable of the first item that matches the
 * condition.
 * @method find
 * @owner Observable
 */
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;
//# sourceMappingURL=find.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/findIndex.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/findIndex.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var find_1 = __webpack_require__(/*! ../operators/find */ "./node_modules/rxjs/operators/find.js");
/**
 * Emits only the index of the first value emitted by the source Observable that
 * meets some condition.
 *
 * <span class="informal">It's like {@link find}, but emits the index of the
 * found value, not the value itself.</span>
 *
 * <img src="./img/findIndex.png" width="100%">
 *
 * `findIndex` searches for the first item in the source Observable that matches
 * the specified condition embodied by the `predicate`, and returns the
 * (zero-based) index of the first occurrence in the source. Unlike
 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
 * an error if a valid value is not found.
 *
 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link first}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
}
exports.findIndex = findIndex;
//# sourceMappingURL=findIndex.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/first.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/first.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ "./node_modules/rxjs/util/EmptyError.js");
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} An Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
function first(predicate, resultSelector, defaultValue) {
    return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };
}
exports.first = first;
var FirstOperator = (function () {
    function FirstOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    FirstOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return FirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = (function (_super) {
    __extends(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        }
        else if (!this.hasCompleted) {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return FirstSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=first.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/groupBy.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/groupBy.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var Map_1 = __webpack_require__(/*! ../util/Map */ "./node_modules/rxjs/util/Map.js");
var FastMap_1 = __webpack_require__(/*! ../util/FastMap */ "./node_modules/rxjs/util/FastMap.js");
/* tslint:enable:max-line-length */
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @example <caption>Group objects by id and return as array</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs3'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *     )
 *     .groupBy(p => p.id)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // [ { id: 1, name: 'aze1' },
 * //   { id: 1, name: 'erg1' },
 * //   { id: 1, name: 'df1' } ]
 * //
 * // [ { id: 2, name: 'sf2' },
 * //   { id: 2, name: 'dg2' },
 * //   { id: 2, name: 'sfqfb2' },
 * //   { id: 2, name: 'qsgqsfg2' } ]
 * //
 * // [ { id: 3, name: 'qfs3' } ]
 *
 * @example <caption>Pivot data on the id field</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs1'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *                   )
 *     .groupBy(p => p.id, p => p.name)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
 *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
 * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
 * // { id: 3, values: [ 'qfs1' ] }
 *
 * @param {function(value: T): K} keySelector A function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] A function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * A function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        _super.call(this, group);
        this.key = key;
        this.group = group;
        this.parent = parent;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        _super.call(this);
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        _super.call(this);
        this.parent = parent;
        parent.count++;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));
//# sourceMappingURL=groupBy.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/ignoreElements.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/operators/ignoreElements.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var noop_1 = __webpack_require__(/*! ../util/noop */ "./node_modules/rxjs/util/noop.js");
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ignoreElements.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/isEmpty.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/isEmpty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        _super.call(this, destination);
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=isEmpty.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/last.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/last.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ "./node_modules/rxjs/util/EmptyError.js");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - The condition any source emitted item has to satisfy.
 * @return {Observable} An Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
function last(predicate, resultSelector, defaultValue) {
    return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };
}
exports.last = last;
var LastOperator = (function () {
    function LastOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    LastOperator.prototype.call = function (observer, source) {
        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return LastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var LastSubscriber = (function (_super) {
    __extends(LastSubscriber, _super);
    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
    }
    LastSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        }
        else {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.lastValue = result;
        this.hasValue = true;
    };
    LastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return LastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=last.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/map.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/map.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/mapTo.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/mapTo.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=mapTo.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/materialize.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/materialize.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Notification_1 = __webpack_require__(/*! ../Notification */ "./node_modules/rxjs/Notification.js");
/**
 * Represents all of the notifications from the source Observable as `next`
 * emissions marked with their original types within {@link Notification}
 * objects.
 *
 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
 * {@link Notification} objects, emitted as `next` on the output Observable.
 * </span>
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * `materialize` returns an Observable that emits a `next` notification for each
 * `next`, `error`, or `complete` emission of the source Observable. When the
 * source Observable emits `complete`, the output Observable will emit `next` as
 * a Notification of type "complete", and then it will emit `complete` as well.
 * When the source Observable emits `error`, the output will emit `next` as a
 * Notification of type "error", and then `complete`.
 *
 * This operator is useful for producing metadata of the source Observable, to
 * be consumed as `next` emissions. Use it in conjunction with
 * {@link dematerialize}.
 *
 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
 * var upperCase = letters.map(x => x.toUpperCase());
 * var materialized = upperCase.materialize();
 * materialized.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
 * // - Notification {kind: "E", value: undefined, error: TypeError:
 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
 * //   [as project] (http://1, hasValue: false}
 *
 * @see {@link Notification}
 * @see {@link dematerialize}
 *
 * @return {Observable<Notification<T>>} An Observable that emits
 * {@link Notification} objects that wrap the original emissions from the source
 * Observable with metadata.
 * @method materialize
 * @owner Observable
 */
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=materialize.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/max.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/max.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(/*! ./reduce */ "./node_modules/rxjs/operators/reduce.js");
/**
 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the largest value.
 *
 * <img src="./img/max.png" width="100%">
 *
 * @example <caption>Get the maximal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .max()
 *   .subscribe(x => console.log(x)); // -> 8
 *
 * @example <caption>Use a comparer function to get the maximal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
 * }
 *
 * @see {@link min}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable} An Observable that emits item with the largest value.
 * @method max
 * @owner Observable
 */
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce_1.reduce(max);
}
exports.max = max;
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/merge.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/merge.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(/*! ../observable/merge */ "./node_modules/rxjs/observable/merge.js");
var merge_2 = __webpack_require__(/*! ../observable/merge */ "./node_modules/rxjs/observable/merge.js");
exports.mergeStatic = merge_2.merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeAll.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeAll.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(/*! ./mergeMap */ "./node_modules/rxjs/operators/mergeMap.js");
var identity_1 = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/util/identity.js");
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);
}
exports.mergeAll = mergeAll;
//# sourceMappingURL=mergeAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeMap.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeMap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function mergeMapOperatorFunction(source) {
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
            resultSelector = null;
        }
        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
    };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeMapTo.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeMapTo.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };
}
exports.mergeMapTo = mergeMapTo;
// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
var MergeMapToOperator = (function () {
    function MergeMapToOperator(ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapToOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
    };
    return MergeMapToOperator;
}());
exports.MergeMapToOperator = MergeMapToOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = (function (_super) {
    __extends(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapToSubscriber = MergeMapToSubscriber;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/mergeScan.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/mergeScan.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
/**
 * Applies an accumulator function over the source Observable where the
 * accumulator function itself returns an Observable, then each intermediate
 * Observable returned is merged into the output Observable.
 *
 * <span class="informal">It's like {@link scan}, but the Observables returned
 * by the accumulator are merged into the outer Observable.</span>
 *
 * @example <caption>Count the number of click events</caption>
 * const click$ = Rx.Observable.fromEvent(document, 'click');
 * const one$ = click$.mapTo(1);
 * const seed = 0;
 * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
 * count$.subscribe(x => console.log(x));
 *
 * // Results:
 * 1
 * 2
 * 3
 * 4
 * // ...and so on for each click
 *
 * @param {function(acc: R, value: T): Observable<R>} accumulator
 * The accumulator function called on each source value.
 * @param seed The initial accumulation value.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
 * input Observables being subscribed to concurrently.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method mergeScan
 * @owner Observable
 */
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject_1.errorObject) {
                destination.error(errorObject_1.errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;
//# sourceMappingURL=mergeScan.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/min.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(/*! ./reduce */ "./node_modules/rxjs/operators/reduce.js");
/**
 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the smallest value.
 *
 * <img src="./img/min.png" width="100%">
 *
 * @example <caption>Get the minimal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .min()
 *   .subscribe(x => console.log(x)); // -> 2
 *
 * @example <caption>Use a comparer function to get the minimal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
 * }
 *
 * @see {@link max}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable<R>} An Observable that emits item with the smallest value.
 * @method min
 * @owner Observable
 */
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce_1.reduce(min);
}
exports.min = min;
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/multicast.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/multicast.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ConnectableObservable_1 = __webpack_require__(/*! ../observable/ConnectableObservable */ "./node_modules/rxjs/observable/ConnectableObservable.js");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;
//# sourceMappingURL=multicast.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/observeOn.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/observeOn.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Notification_1 = __webpack_require__(/*! ../Notification */ "./node_modules/rxjs/Notification.js");
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/onErrorResumeNext.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/operators/onErrorResumeNext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FromObservable_1 = __webpack_require__(/*! ../observable/FromObservable */ "./node_modules/rxjs/observable/FromObservable.js");
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
 * as the source.
 *
 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
 * be happening until there is no more Observables left in the series, at which point returned Observable will
 * complete - even if the last subscribed stream ended with an error.
 *
 * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
 * an error.
 *
 * Note that you do not get any access to errors emitted by the Observables. In particular do not
 * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
 * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
 *
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * Rx.Observable.of(1, 2, 3, 0)
 *   .map(x => {
 *       if (x === 0) { throw Error(); }
         return 10 / x;
 *   })
 *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
 *   .subscribe(
 *     val => console.log(val),
 *     err => console.log(err),          // Will never be called.
 *     () => console.log('that\'s it!')
 *   );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "that's it!"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} observables Observables passed either directly or as an array.
 * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
 * to the next passed Observable and so on, until it completes or runs out of Observables.
 * @method onErrorResumeNext
 * @owner Observable
 */
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
exports.onErrorResumeNext = onErrorResumeNext;
/* tslint:enable:max-line-length */
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        _super.call(this, destination);
        this.destination = destination;
        this.nextSources = nextSources;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1.subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=onErrorResumeNext.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/pairwise.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/pairwise.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=pairwise.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/partition.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/partition.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var not_1 = __webpack_require__(/*! ../util/not */ "./node_modules/rxjs/util/not.js");
var filter_1 = __webpack_require__(/*! ./filter */ "./node_modules/rxjs/operators/filter.js");
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
function partition(predicate, thisArg) {
    return function (source) { return [
        filter_1.filter(predicate, thisArg)(source),
        filter_1.filter(not_1.not(predicate, thisArg))(source)
    ]; };
}
exports.partition = partition;
//# sourceMappingURL=partition.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/pluck.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/pluck.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var map_1 = __webpack_require__(/*! ./map */ "./node_modules/rxjs/operators/map.js");
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} A new Observable of property values from the source values.
 * @method pluck
 * @owner Observable
 */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/publish.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/publish.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var multicast_1 = __webpack_require__(/*! ./multicast */ "./node_modules/rxjs/operators/multicast.js");
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/publishBehavior.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/operators/publishBehavior.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var BehaviorSubject_1 = __webpack_require__(/*! ../BehaviorSubject */ "./node_modules/rxjs/BehaviorSubject.js");
var multicast_1 = __webpack_require__(/*! ./multicast */ "./node_modules/rxjs/operators/multicast.js");
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */
function publishBehavior(value) {
    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
}
exports.publishBehavior = publishBehavior;
//# sourceMappingURL=publishBehavior.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/publishLast.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/publishLast.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncSubject_1 = __webpack_require__(/*! ../AsyncSubject */ "./node_modules/rxjs/AsyncSubject.js");
var multicast_1 = __webpack_require__(/*! ./multicast */ "./node_modules/rxjs/operators/multicast.js");
function publishLast() {
    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
}
exports.publishLast = publishLast;
//# sourceMappingURL=publishLast.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/publishReplay.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operators/publishReplay.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReplaySubject_1 = __webpack_require__(/*! ../ReplaySubject */ "./node_modules/rxjs/ReplaySubject.js");
var multicast_1 = __webpack_require__(/*! ./multicast */ "./node_modules/rxjs/operators/multicast.js");
/* tslint:enable:max-line-length */
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;
//# sourceMappingURL=publishReplay.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/race.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/race.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
var race_1 = __webpack_require__(/*! ../observable/race */ "./node_modules/rxjs/observable/race.js");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables.
 * @param {...Observables} ...observables Sources used to race for which Observable emits first.
 * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 */
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        // if the only argument is an array, it was most likely called with
        // `pair([obs1, obs2, ...])`
        if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
    };
}
exports.race = race;
//# sourceMappingURL=race.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/reduce.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/reduce.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var scan_1 = __webpack_require__(/*! ./scan */ "./node_modules/rxjs/operators/scan.js");
var takeLast_1 = __webpack_require__(/*! ./takeLast */ "./node_modules/rxjs/operators/takeLast.js");
var defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ "./node_modules/rxjs/operators/defaultIfEmpty.js");
var pipe_1 = __webpack_require__(/*! ../util/pipe */ "./node_modules/rxjs/util/pipe.js");
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
function reduce(accumulator, seed) {
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) {
            return accumulator(acc, value, index + 1);
        }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;
//# sourceMappingURL=reduce.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/refCount.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/refCount.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=refCount.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/repeat.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/repeat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var EmptyObservable_1 = __webpack_require__(/*! ../observable/EmptyObservable */ "./node_modules/rxjs/observable/EmptyObservable.js");
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */
function repeat(count) {
    if (count === void 0) { count = -1; }
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/repeatWhen.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/repeatWhen.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
 * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
 * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
 * this method will resubscribe to the source Observable.
 *
 * <img src="./img/repeatWhen.png" width="100%">
 *
 * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
 * which a user can `complete` or `error`, aborting the repetition.
 * @return {Observable} The source Observable modified with repeat logic.
 * @method repeatWhen
 * @owner Observable
 */
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
        this.sourceIsBeingSubscribedTo = true;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.notifications = null;
        this.retries = null;
        this.retriesSubscription = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this.notifications = notifications;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject_1.errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=repeatWhen.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/retry.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/retry.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} count - Number of retry attempts before failing.
 * @return {Observable} The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=retry.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/retryWhen.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/retryWhen.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=retryWhen.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/sample.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/sample.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=sample.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/sampleTime.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/sampleTime.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * <img src="./img/sampleTime.png" width="100%">
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * @example <caption>Every second, emit the most recent click at most once</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.sampleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {number} period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        _super.call(this, destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/scan.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/scan.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/sequenceEqual.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/operators/sequenceEqual.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
/**
 * Compares all values of two observables in sequence using an optional comparor function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * <img src="./img/sequenceEqual.png" width="100%">
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * @example <caption>figure out if the Konami code matches</caption>
 * var code = Rx.Observable.from([
 *  "ArrowUp",
 *  "ArrowUp",
 *  "ArrowDown",
 *  "ArrowDown",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "KeyB",
 *  "KeyA",
 *  "Enter" // no start key, clearly.
 * ]);
 *
 * var keys = Rx.Observable.fromEvent(document, 'keyup')
 *  .map(e => e.code);
 * var matches = keys.bufferCount(11, 1)
 *  .mergeMap(
 *    last11 =>
 *      Rx.Observable.from(last11)
 *        .sequenceEqual(code)
 *   );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} compareTo The observable sequence to compare the source sequence to.
 * @param {function} [comparor] An optional function to compare each value pair
 * @return {Observable} An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence.
 * @method sequenceEqual
 * @owner Observable
 */
function sequenceEqual(compareTo, comparor) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        _super.call(this, destination);
        this.compareTo = compareTo;
        this.comparor = comparor;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
                if (areEqual === errorObject_1.errorObject) {
                    this.destination.error(errorObject_1.errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        _super.call(this, destination);
        this.parent = parent;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=sequenceEqual.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/share.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/operators/share.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var multicast_1 = __webpack_require__(/*! ./multicast */ "./node_modules/rxjs/operators/multicast.js");
var refCount_1 = __webpack_require__(/*! ./refCount */ "./node_modules/rxjs/operators/refCount.js");
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .multicast(() => new Subject()).refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/shareReplay.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/shareReplay.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ReplaySubject_1 = __webpack_require__(/*! ../ReplaySubject */ "./node_modules/rxjs/ReplaySubject.js");
/**
 * @method shareReplay
 * @owner Observable
 */
function shareReplay(bufferSize, windowTime, scheduler) {
    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(bufferSize, windowTime, scheduler) {
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        return function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && refCount === 0 && isComplete) {
                subscription.unsubscribe();
            }
        };
    };
}
;
//# sourceMappingURL=shareReplay.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/single.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/single.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ "./node_modules/rxjs/util/EmptyError.js");
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=single.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/skip.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/skip.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skip.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/skipLast.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/skipLast.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/util/ArgumentOutOfRangeError.js");
/**
 * Skip the last `count` values emitted by the source Observable.
 *
 * <img src="./img/skipLast.png" width="100%">
 *
 * `skipLast` returns an Observable that accumulates a queue with a length
 * enough to store the first `count` values. As more values are received,
 * values are taken from the front of the queue and produced on the result
 * sequence. This causes values to be delayed.
 *
 * @example <caption>Skip the last 2 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 5);
 * var skipLastTwo = many.skipLast(2);
 * skipLastTwo.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 1 2 3
 *
 * @see {@link skip}
 * @see {@link skipUntil}
 * @see {@link skipWhile}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
 * ArgumentOutOrRangeError if `i < 0`.
 *
 * @param {number} count Number of elements to skip from the end of the source Observable.
 * @returns {Observable<T>} An Observable that skips the last count values
 * emitted by the source Observable.
 * @method skipLast
 * @owner Observable
 */
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
exports.skipLast = skipLast;
var SkipLastOperator = (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            // If we don't want to skip any values then just subscribe
            // to Subscriber without any further logic.
            return source.subscribe(new Subscriber_1.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipLastSubscriber = (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        _super.call(this, destination);
        this._skipCount = _skipCount;
        this._count = 0;
        this._ring = new Array(_skipCount);
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipLast.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/skipUntil.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/skipUntil.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=skipUntil.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/skipWhile.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/skipWhile.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipWhile.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/startWith.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/startWith.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
var ScalarObservable_1 = __webpack_require__(/*! ../observable/ScalarObservable */ "./node_modules/rxjs/observable/ScalarObservable.js");
var EmptyObservable_1 = __webpack_require__(/*! ../observable/EmptyObservable */ "./node_modules/rxjs/observable/EmptyObservable.js");
var concat_1 = __webpack_require__(/*! ../observable/concat */ "./node_modules/rxjs/observable/concat.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1) {
            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);
        }
        else if (len > 1) {
            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);
        }
        else {
            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);
        }
    };
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/switchAll.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/switchAll.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var switchMap_1 = __webpack_require__(/*! ./switchMap */ "./node_modules/rxjs/operators/switchMap.js");
var identity_1 = __webpack_require__(/*! ../util/identity */ "./node_modules/rxjs/util/identity.js");
function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
}
exports.switchAll = switchAll;
//# sourceMappingURL=switchAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/switchMap.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/switchMap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return function switchMapOperatorFunction(source) {
        return source.lift(new SwitchMapOperator(project, resultSelector));
    };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/switchMapTo.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/switchMapTo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };
}
exports.switchMapTo = switchMapTo;
var SwitchMapToOperator = (function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMapTo.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/take.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/operators/take.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/util/ArgumentOutOfRangeError.js");
var EmptyObservable_1 = __webpack_require__(/*! ../observable/EmptyObservable */ "./node_modules/rxjs/observable/EmptyObservable.js");
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=take.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/takeLast.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/takeLast.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ "./node_modules/rxjs/util/ArgumentOutOfRangeError.js");
var EmptyObservable_1 = __webpack_require__(/*! ../observable/EmptyObservable */ "./node_modules/rxjs/observable/EmptyObservable.js");
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeLast.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/takeUntil.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/takeUntil.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=takeUntil.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/takeWhile.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/takeWhile.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
function takeWhile(predicate) {
    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeWhile.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/tap.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/tap.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @name tap
 */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=tap.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/throttle.js":
/*!*************************************************!*\
  !*** ./node_modules/rxjs/operators/throttle.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasTrailingValue = false;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this._trailing) {
                this._hasTrailingValue = true;
                this._trailingValue = value;
            }
        }
        else {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
            }
            if (this._leading) {
                this.destination.next(value);
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
        this._trailingValue = null;
        this._hasTrailingValue = false;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype._sendTrailing = function () {
        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
        if (throttled && _trailing && _hasTrailingValue) {
            destination.next(_trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._sendTrailing();
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._sendTrailing();
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=throttle.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/throttleTime.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/operators/throttleTime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var throttle_1 = __webpack_require__(/*! ./throttle */ "./node_modules/rxjs/operators/throttle.js");
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/timeInterval.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/operators/timeInterval.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;
;
var TimeIntervalOperator = (function () {
    function TimeIntervalOperator(scheduler) {
        this.scheduler = scheduler;
    }
    TimeIntervalOperator.prototype.call = function (observer, source) {
        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
    };
    return TimeIntervalOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeIntervalSubscriber = (function (_super) {
    __extends(TimeIntervalSubscriber, _super);
    function TimeIntervalSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.lastTime = 0;
        this.lastTime = scheduler.now();
    }
    TimeIntervalSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        var span = now - this.lastTime;
        this.lastTime = now;
        this.destination.next(new TimeInterval(value, span));
    };
    return TimeIntervalSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeInterval.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/timeout.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/timeout.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/rxjs/util/isDate.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var TimeoutError_1 = __webpack_require__(/*! ../util/TimeoutError */ "./node_modules/rxjs/util/TimeoutError.js");
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeout.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/timeoutWith.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/timeoutWith.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/rxjs/util/isDate.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 *
 * Errors if Observable does not emit a value in given time span, in case of which
 * subscribes to the second Observable.
 *
 * <span class="informal">It's a version of `timeout` operator that let's you specify fallback Observable.</span>
 *
 * <img src="./img/timeoutWith.png" width="100%">
 *
 * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,
 * still accepting as a first argument either a number or a Date, which control - respectively -
 * when values of source Observable should be emitted or when it should complete.
 *
 * The only difference is that it accepts a second, required parameter. This parameter
 * should be an Observable which will be subscribed when source Observable fails any timeout check.
 * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting
 * values from second Observable. Note that this fallback Observable is not checked for timeouts
 * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second
 * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that
 * stream completes, it completes as well.
 *
 * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided
 * here - as a third, optional parameter. It still is used to schedule timeout checks and -
 * as a consequence - when second Observable will be subscribed, since subscription happens
 * immediately after failing check.
 *
 * @example <caption>Add fallback observable</caption>
 * const seconds = Rx.Observable.interval(1000);
 * const minutes = Rx.Observable.interval(60 * 1000);
 *
 * seconds.timeoutWith(900, minutes)
 *     .subscribe(
 *         value => console.log(value), // After 900ms, will start emitting `minutes`,
 *                                      // since first value of `seconds` will not arrive fast enough.
 *         err => console.log(err) // Would be called after 900ms in case of `timeout`,
 *                                 // but here will never be called.
 *     );
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable
 *                          passed as a second parameter.
 * @method timeoutWith
 * @owner Observable
 */
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) {
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=timeoutWith.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/timestamp.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/operators/timestamp.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var map_1 = __webpack_require__(/*! ./map */ "./node_modules/rxjs/operators/map.js");
/**
 * @param scheduler
 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timestamp
 * @owner Observable
 */
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
    // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;
;
//# sourceMappingURL=timestamp.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/toArray.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/operators/toArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var reduce_1 = __webpack_require__(/*! ./reduce */ "./node_modules/rxjs/operators/reduce.js");
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;
//# sourceMappingURL=toArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/window.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/window.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */
function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        _super.call(this, destination);
        this.window = new Subject_1.Subject();
        destination.next(this.window);
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=window.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/windowCount.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/operators/windowCount.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new Subject_1.Subject()];
        this.count = 0;
        destination.next(this.windows[0]);
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=windowCount.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/windowTime.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/windowTime.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/rxjs/scheduler/async.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var isNumeric_1 = __webpack_require__(/*! ../util/isNumeric */ "./node_modules/rxjs/util/isNumeric.js");
var isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/rxjs/util/isScheduler.js");
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        _super.apply(this, arguments);
        this._numberOfNextedValues = 0;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        var window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/windowToggle.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/operators/windowToggle.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.error(err);
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.complete();
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.unsubscribe();
                context.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject_1.errorObject) {
                return this.error(errorObject_1.errorObject.e);
            }
            else {
                var window_1 = new Subject_1.Subject();
                var subscription = new Subscription_1.Subscription();
                var context = { window: window_1, subscription: subscription };
                this.contexts.push(context);
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=windowToggle.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/windowWhen.js":
/*!***************************************************!*\
  !*** ./node_modules/rxjs/operators/windowWhen.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/rxjs/Subject.js");
var tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/rxjs/util/tryCatch.js");
var errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/rxjs/util/errorObject.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1.errorObject) {
            var err = errorObject_1.errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=windowWhen.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/withLatestFrom.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/operators/withLatestFrom.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/zip.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/operators/zip.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ "./node_modules/rxjs/observable/ArrayObservable.js");
var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/rxjs/OuterSubscriber.js");
var subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/rxjs/util/subscribeToResult.js");
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/symbol/iterator.js");
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = (function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) { values = Object.create(null); }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = (typeof project === 'function') ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=zip.js.map

/***/ }),

/***/ "./node_modules/rxjs/operators/zipAll.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/operators/zipAll.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var zip_1 = __webpack_require__(/*! ./zip */ "./node_modules/rxjs/operators/zip.js");
function zipAll(project) {
    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
}
exports.zipAll = zipAll;
//# sourceMappingURL=zipAll.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/Action.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/scheduler/Action.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/rxjs/Subscription.js");
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/AsyncAction.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/scheduler/AsyncAction.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/rxjs/util/root.js");
var Action_1 = __webpack_require__(/*! ./Action */ "./node_modules/rxjs/scheduler/Action.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/AsyncScheduler.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/scheduler/AsyncScheduler.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = __webpack_require__(/*! ../Scheduler */ "./node_modules/rxjs/Scheduler.js");
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/QueueAction.js":
/*!****************************************************!*\
  !*** ./node_modules/rxjs/scheduler/QueueAction.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ "./node_modules/rxjs/scheduler/AsyncAction.js");
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/QueueScheduler.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/scheduler/QueueScheduler.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ "./node_modules/rxjs/scheduler/AsyncScheduler.js");
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/async.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/scheduler/async.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ "./node_modules/rxjs/scheduler/AsyncAction.js");
var AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ "./node_modules/rxjs/scheduler/AsyncScheduler.js");
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/rxjs/scheduler/queue.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/scheduler/queue.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var QueueAction_1 = __webpack_require__(/*! ./QueueAction */ "./node_modules/rxjs/scheduler/QueueAction.js");
var QueueScheduler_1 = __webpack_require__(/*! ./QueueScheduler */ "./node_modules/rxjs/scheduler/QueueScheduler.js");
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),

/***/ "./node_modules/rxjs/symbol/iterator.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/symbol/iterator.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/rxjs/util/root.js");
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map

/***/ }),

/***/ "./node_modules/rxjs/symbol/observable.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/symbol/observable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/rxjs/util/root.js");
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/rxjs/symbol/rxSubscriber.js":
/*!**************************************************!*\
  !*** ./node_modules/rxjs/symbol/rxSubscriber.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/rxjs/util/root.js");
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/ArgumentOutOfRangeError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/util/ArgumentOutOfRangeError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/EmptyError.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/util/EmptyError.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = (function (_super) {
    __extends(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error));
exports.EmptyError = EmptyError;
//# sourceMappingURL=EmptyError.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/FastMap.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/util/FastMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FastMap = (function () {
    function FastMap() {
        this.values = {};
    }
    FastMap.prototype.delete = function (key) {
        this.values[key] = null;
        return true;
    };
    FastMap.prototype.set = function (key, value) {
        this.values[key] = value;
        return this;
    };
    FastMap.prototype.get = function (key) {
        return this.values[key];
    };
    FastMap.prototype.forEach = function (cb, thisArg) {
        var values = this.values;
        for (var key in values) {
            if (values.hasOwnProperty(key) && values[key] !== null) {
                cb.call(thisArg, values[key], key);
            }
        }
    };
    FastMap.prototype.clear = function () {
        this.values = {};
    };
    return FastMap;
}());
exports.FastMap = FastMap;
//# sourceMappingURL=FastMap.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/Map.js":
/*!***************************************!*\
  !*** ./node_modules/rxjs/util/Map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ./root */ "./node_modules/rxjs/util/root.js");
var MapPolyfill_1 = __webpack_require__(/*! ./MapPolyfill */ "./node_modules/rxjs/util/MapPolyfill.js");
exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();
//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/MapPolyfill.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/MapPolyfill.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var MapPolyfill = (function () {
    function MapPolyfill() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    MapPolyfill.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    MapPolyfill.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        }
        else {
            this._values[i] = value;
        }
        return this;
    };
    MapPolyfill.prototype.delete = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    MapPolyfill.prototype.clear = function () {
        this._keys.length = 0;
        this._values.length = 0;
        this.size = 0;
    };
    MapPolyfill.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return MapPolyfill;
}());
exports.MapPolyfill = MapPolyfill;
//# sourceMappingURL=MapPolyfill.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/ObjectUnsubscribedError.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/util/ObjectUnsubscribedError.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/Set.js":
/*!***************************************!*\
  !*** ./node_modules/rxjs/util/Set.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ./root */ "./node_modules/rxjs/util/root.js");
function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}
exports.minimalSetImpl = minimalSetImpl;
exports.Set = root_1.root.Set || minimalSetImpl();
//# sourceMappingURL=Set.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/TimeoutError.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/util/TimeoutError.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/UnsubscriptionError.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/util/UnsubscriptionError.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/errorObject.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/errorObject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/identity.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/util/identity.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function identity(x) {
    return x;
}
exports.identity = identity;
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isArray.js":
/*!*******************************************!*\
  !*** ./node_modules/rxjs/util/isArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isArrayLike.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/isArrayLike.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isDate.js":
/*!******************************************!*\
  !*** ./node_modules/rxjs/util/isDate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/rxjs/util/isFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isNumeric.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/util/isNumeric.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/rxjs/util/isArray.js");
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
;
//# sourceMappingURL=isNumeric.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/util/isObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isPromise.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/util/isPromise.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/isScheduler.js":
/*!***********************************************!*\
  !*** ./node_modules/rxjs/util/isScheduler.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/noop.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/util/noop.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/not.js":
/*!***************************************!*\
  !*** ./node_modules/rxjs/util/not.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;
//# sourceMappingURL=not.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/pipe.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/util/pipe.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var noop_1 = __webpack_require__(/*! ./noop */ "./node_modules/rxjs/util/noop.js");
/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/root.js":
/*!****************************************!*\
  !*** ./node_modules/rxjs/util/root.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/rxjs/util/subscribeToResult.js":
/*!*****************************************************!*\
  !*** ./node_modules/rxjs/util/subscribeToResult.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(/*! ./root */ "./node_modules/rxjs/util/root.js");
var isArrayLike_1 = __webpack_require__(/*! ./isArrayLike */ "./node_modules/rxjs/util/isArrayLike.js");
var isPromise_1 = __webpack_require__(/*! ./isPromise */ "./node_modules/rxjs/util/isPromise.js");
var isObject_1 = __webpack_require__(/*! ./isObject */ "./node_modules/rxjs/util/isObject.js");
var Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/rxjs/Observable.js");
var iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/rxjs/symbol/iterator.js");
var InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/rxjs/InnerSubscriber.js");
var observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/rxjs/symbol/observable.js");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/toSubscriber.js":
/*!************************************************!*\
  !*** ./node_modules/rxjs/util/toSubscriber.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/rxjs/Subscriber.js");
var rxSubscriber_1 = __webpack_require__(/*! ../symbol/rxSubscriber */ "./node_modules/rxjs/symbol/rxSubscriber.js");
var Observer_1 = __webpack_require__(/*! ../Observer */ "./node_modules/rxjs/Observer.js");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),

/***/ "./node_modules/rxjs/util/tryCatch.js":
/*!********************************************!*\
  !*** ./node_modules/rxjs/util/tryCatch.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var errorObject_1 = __webpack_require__(/*! ./errorObject */ "./node_modules/rxjs/util/errorObject.js");
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ }),

/***/ "./node_modules/semver/semver.js":
/*!***************************************!*\
  !*** ./node_modules/semver/semver.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function(comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, loose) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, loose) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function(range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose)
  r2 = new Range(r2, loose)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sha1/sha1.js":
/*!***********************************!*\
  !*** ./node_modules/sha1/sha1.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {(function() {
  var crypt = __webpack_require__(/*! crypt */ "./node_modules/crypt/crypt.js"),
      utf8 = __webpack_require__(/*! charenc */ "./node_modules/charenc/charenc.js").utf8,
      bin = __webpack_require__(/*! charenc */ "./node_modules/charenc/charenc.js").bin,

  // The core
  sha1 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();

    // otherwise assume byte array

    var m  = crypt.bytesToWords(message),
        l  = message.length * 8,
        w  = [],
        H0 =  1732584193,
        H1 = -271733879,
        H2 = -1732584194,
        H3 =  271733878,
        H4 = -1009589776;

    // Padding
    m[l >> 5] |= 0x80 << (24 - l % 32);
    m[((l + 64 >>> 9) << 4) + 15] = l;

    for (var i = 0; i < m.length; i += 16) {
      var a = H0,
          b = H1,
          c = H2,
          d = H3,
          e = H4;

      for (var j = 0; j < 80; j++) {

        if (j < 16)
          w[j] = m[i + j];
        else {
          var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = (n << 1) | (n >>> 31);
        }

        var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                         (H1 ^ H2 ^ H3) - 899497514);

        H4 = H3;
        H3 = H2;
        H2 = (H1 << 30) | (H1 >>> 2);
        H1 = H0;
        H0 = t;
      }

      H0 += a;
      H1 += b;
      H2 += c;
      H3 += d;
      H4 += e;
    }

    return [H0, H1, H2, H3, H4];
  },

  // Public API
  api = function (message, options) {
    var digestbytes = crypt.wordsToBytes(sha1(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

  api._blocksize = 16;
  api._digestsize = 20;

  module.exports = api;
})();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/lib/decoder/AbstractDecoder.ts":
/*!********************************************!*\
  !*** ./src/lib/decoder/AbstractDecoder.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BitPackedBuffer_1 = __webpack_require__(/*! ./BitPackedBuffer */ "./src/lib/decoder/BitPackedBuffer.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/lib/decoder/errors/index.ts");
class AbstractDecoder {
    constructor(data, typeIfo) {
        this._buffer = new BitPackedBuffer_1.BitPackedBuffer(data);
        this._typeinfos = typeIfo;
    }
    toString() {
        return this._buffer.toString();
    }
    instance(typeid) {
        if (typeid >= this._typeinfos.length) {
            throw new errors_1.CorruptedError(this.toString());
        }
        const typeinfo = this._typeinfos[typeid];
        return this[typeinfo[0]].apply(this, typeinfo[1]);
    }
    byteAlign() {
        this._buffer.byteAlign();
    }
    get isDone() {
        return this._buffer.isDone;
    }
    get usedBits() {
        return this._buffer.usedBits;
    }
    get size() {
        return this._buffer.size;
    }
}
exports.AbstractDecoder = AbstractDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3REZWNvZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQWJzdHJhY3REZWNvZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsdURBQW9EO0FBQ3BELHFDQUEwQztBQUUxQztJQUlJLFlBQW1CLElBQVksRUFBRSxPQUFPO1FBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDO0lBQzlCLENBQUM7SUFFTSxRQUFRO1FBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFTSxRQUFRLENBQUMsTUFBTTtRQUNsQixJQUFJLE1BQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTtZQUFFLE1BQU0sSUFBSSx1QkFBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQUU7UUFFcEYsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFTSxTQUFTO1FBQ1osSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsSUFBVyxNQUFNO1FBQ2IsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsSUFBVyxJQUFJO1FBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUM3QixDQUFDO0NBQ0o7QUFsQ0QsMENBa0NDIn0=

/***/ }),

/***/ "./src/lib/decoder/BitPackedBuffer.ts":
/*!********************************************!*\
  !*** ./src/lib/decoder/BitPackedBuffer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/lib/decoder/errors/index.ts");
class BitPackedBuffer {
    constructor(data, endian = 'big') {
        this._used = 0;
        this._next = null;
        this._nextBits = 0;
        this._data = data || new buffer_1.Buffer(0);
        this._bigEndian = endian === 'big';
    }
    toString() {
        return 'buffer(' +
            (this._nextBits && this._next || 0).toString(16) + '/' + this._nextBits +
            ',[' + this._used + ']=' + ((this._used < this._data.length) ? this._data.readUInt8(this._used).toString(16) : '--') +
            ')';
    }
    get isDone() {
        return this._nextBits === 0 && this._used >= this._data.length;
    }
    get size() {
        return this._data.length * 8;
    }
    get usedBits() {
        return this._used * 8 - this._nextBits;
    }
    byteAlign() {
        this._nextBits = 0;
    }
    readAlignedBytes(bytes) {
        this.byteAlign();
        const data = this._data.slice(this._used, this._used + bytes);
        this._used += bytes;
        if (data.length !== bytes) {
            throw new errors_1.TruncateError(this.toString());
        }
        return data;
    }
    readBits(bits) {
        let result = 0;
        let resultbits = 0;
        while (resultbits !== bits) {
            if (this._nextBits === 0) {
                if (this.isDone) {
                    throw new errors_1.TruncateError(this.toString());
                }
                this._next = this._data.readUInt8(this._used);
                this._used += 1;
                this._nextBits = 8;
            }
            const copybits = Math.min(bits - resultbits, this._nextBits);
            const copy = this._next & ((1 << copybits) - 1);
            if (this._bigEndian) {
                result |= copy << (bits - resultbits - copybits);
            }
            else {
                result |= copy << resultbits;
            }
            this._next >>= copybits;
            this._nextBits -= copybits;
            resultbits += copybits;
        }
        return result;
    }
    readUnalignedBytes(bytes) {
        const buff = new buffer_1.Buffer(bytes);
        for (let i = 0; i < bytes; i += 1) {
            buff.writeUInt8(this.readBits(8), i);
        }
        return buff;
    }
}
exports.BitPackedBuffer = BitPackedBuffer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQml0UGFja2VkQnVmZmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQml0UGFja2VkQnVmZmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsbUNBQWdDO0FBQ2hDLHFDQUF5QztBQUN6QztJQVFJLFlBQW1CLElBQVksRUFBRSxTQUEwQixLQUFLO1FBTHhELFVBQUssR0FBRyxDQUFDLENBQUM7UUFDVixVQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2IsY0FBUyxHQUFHLENBQUMsQ0FBQztRQUlsQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksSUFBSSxJQUFJLGVBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sS0FBSyxLQUFLLENBQUM7SUFDdkMsQ0FBQztJQUdNLFFBQVE7UUFDWCxPQUFPLFNBQVM7WUFDWixDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTO1lBQ3ZFLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDcEgsR0FBRyxDQUFDO0lBQ1osQ0FBQztJQUVELElBQVcsTUFBTTtRQUNiLE9BQU8sSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUNuRSxDQUFDO0lBRUQsSUFBVyxJQUFJO1FBQ1gs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

/***/ }),

/***/ "./src/lib/decoder/BitPackedDecoder.ts":
/*!*********************************************!*\
  !*** ./src/lib/decoder/BitPackedDecoder.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = __webpack_require__(/*! ./errors */ "./src/lib/decoder/errors/index.ts");
const AbstractDecoder_1 = __webpack_require__(/*! ./AbstractDecoder */ "./src/lib/decoder/AbstractDecoder.ts");
class BitPackedDecoder extends AbstractDecoder_1.AbstractDecoder {
    constructor(data, typeIfo) {
        super(data, typeIfo);
    }
    _array(bounds, typeid) {
        const length = this._int(bounds);
        const ar = [];
        for (let i = 0; i < length; i += 1) {
            ar[i] = this.instance(typeid);
        }
        return ar;
    }
    _bitarray(bounds) {
        const length = this._int(bounds);
        return [length, this._buffer.readBits(length)];
    }
    _blob(bounds) {
        const length = this._int(bounds);
        return this._buffer.readAlignedBytes(length);
    }
    _bool() {
        return this._int([0, 1]) !== 0;
    }
    _choice(bounds, fields) {
        const tag = this._int(bounds);
        const field = fields[tag];
        if (!field) {
            throw new errors_1.CorruptedError(this.toString());
        }
        const ret = {};
        ret[field[0]] = this.instance(field[1]);
        return ret;
    }
    _fourcc() {
        return this._buffer.readUnalignedBytes(4);
    }
    _int(bounds) {
        const value = bounds[0] + this._buffer.readBits(bounds[1]);
        return value;
    }
    _null() {
        return null;
    }
    _optional(typeid) {
        const exists = this._bool();
        return exists ? this.instance(typeid) : null;
    }
    _real32() {
        return this._buffer.readUnalignedBytes(4).readFloatBE(0);
    }
    _real64() {
        return this._buffer.readUnalignedBytes(8).readDoubleBE(0);
    }
    _struct(fields) {
        let result = {};
        fields.forEach(field => {
            if (field[0] === '__parent') {
                const parent = this.instance(field[1]);
                if (parent && typeof parent === 'object' && !Array.isArray(parent)) {
                    result = Object.assign(result, parent);
                }
                else if (fields.length === 0) {
                    result = parent;
                }
                else {
                    result[field[0]] = parent;
                }
            }
            else {
                result[field[0]] = this.instance(field[1]);
            }
        });
        return result;
    }
}
exports.BitPackedDecoder = BitPackedDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQml0UGFja2VkRGVjb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkJpdFBhY2tlZERlY29kZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQSxxQ0FBMEM7QUFDMUMsdURBQW9EO0FBR3BELHNCQUE4QixTQUFRLGlDQUFlO0lBRWpELFlBQW1CLElBQVksRUFBRSxPQUFPO1FBQ3BDLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVNLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTTtRQUN4QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNkLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNoQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVNLFNBQVMsQ0FBQyxNQUFNO1FBQ25CLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakMsT0FBTyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFTSxLQUFLLENBQUMsTUFBTTtRQUNmLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTSxLQUFLO1FBQ1IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFF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

/***/ }),

/***/ "./src/lib/decoder/VersionDecoder.ts":
/*!*******************************************!*\
  !*** ./src/lib/decoder/VersionDecoder.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = __webpack_require__(/*! ./errors */ "./src/lib/decoder/errors/index.ts");
const AbstractDecoder_1 = __webpack_require__(/*! ./AbstractDecoder */ "./src/lib/decoder/AbstractDecoder.ts");
const Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
class VersionDecoder extends AbstractDecoder_1.AbstractDecoder {
    constructor(data, typeIfo) {
        super(data, typeIfo);
    }
    _expectSkip(expected) {
        const r = this._buffer.readBits(8);
        if (r !== expected) {
            throw new errors_1.CorruptedError(this.toString());
        }
        ;
    }
    _vint() {
        let b = this._buffer.readBits(8);
        const negative = b & 1;
        let result = (b >> 1) & 0x3f;
        let bits = 6;
        while ((b & 0x80) !== 0) {
            b = this._buffer.readBits(8);
            let myLong = new Long;
            myLong = Long.fromString(result.toString(), false);
            result = myLong.or((b & 0x7f) * Math.pow(2, bits)).toString();
            bits += 7;
        }
        result = parseInt(result.toString(), 10);
        return negative ? -result : result;
    }
    ;
    _array(bounds, typeid) {
        this._expectSkip(0);
        const length = this._vint();
        const ar = [];
        for (let i = 0; i < length; i++) {
            ar[i] = this.instance(typeid);
        }
        return ar;
    }
    _bitarray(bounds) {
        this._expectSkip(1);
        const length = this._vint();
        return [length, this._buffer.readAlignedBytes((length + 7) / 8)];
    }
    _blob(bounds) {
        this._expectSkip(2);
        const length = this._vint();
        return this._buffer.readAlignedBytes(length);
    }
    _bool() {
        this._expectSkip(6);
        return this._buffer.readBits(8) !== 0;
    }
    _choice(bounds, fields) {
        this._expectSkip(3);
        const tag = this._vint();
        const field = fields[tag];
        if (!field) {
            this._skipInstance();
            return {};
        }
        const ret = {};
        ret[field[0]] = this.instance(field[1]);
        return ret;
    }
    _fourcc() {
        this._expectSkip(7);
        return this._buffer.readAlignedBytes(4);
    }
    _int() {
        this._expectSkip(9);
        return this._vint();
    }
    _null() {
        return null;
    }
    _optional(typeid) {
        this._expectSkip(4);
        const exists = this._buffer.readBits(8) !== 0;
        return exists ? this.instance(typeid) : null;
    }
    _real32() {
        this._expectSkip(7);
        return this._buffer.readAlignedBytes(4).readFloatBE(0);
    }
    _real64() {
        this._expectSkip(8);
        return this._buffer.readAlignedBytes(8).readDoubleBE(0);
    }
    _struct(fields) {
        function matchTag(tag) {
            return function (field) {
                return tag === field[2];
            };
        }
        this._expectSkip(5);
        let result = {};
        const length = this._vint();
        for (let i = 0; i < length; i += 1) {
            const tag = this._vint();
            const field = fields.find(matchTag(tag));
            if (field) {
                if (field[0] === '__parent') {
                    const parent = this.instance(field[1]);
                    if (parent && typeof parent === 'object' && !Array.isArray(parent)) {
                        result = Object.assign(result, parent);
                    }
                    else if (fields.length === 0) {
                        result = parent;
                    }
                    else {
                        result[field[0]] = parent;
                    }
                }
                else {
                    result[field[0]] = this.instance(field[1]);
                }
            }
            else {
                this._skipInstance();
            }
        }
        return result;
    }
    _skipInstance() {
        const skip = this._buffer.readBits(8);
        let length;
        let exists;
        let tag;
        if (skip === 0) {
            length = this._vint();
            for (let i = 0; i < length; i++) {
                this._skipInstance();
            }
        }
        else if (skip === 1) {
            length = this._vint();
            this._buffer.readAlignedBytes((length + 7) / 8);
        }
        else if (skip === 2) {
            length = this._vint();
            this._buffer.readAlignedBytes(length);
        }
        else if (skip === 3) {
            tag = this._vint();
            this._skipInstance();
        }
        else if (skip === 4) {
            exists = this._buffer.readBits(8) !== 0;
            if (exists) {
                this._skipInstance();
            }
        }
        else if (skip === 5) {
            length = this._vint();
            for (let i = 0; i < length; i += 1) {
                tag = this._vint();
                this._skipInstance();
            }
        }
        else if (skip === 6) {
            this._buffer.readAlignedBytes(1);
        }
        else if (skip === 7) {
            this._buffer.readAlignedBytes(4);
        }
        else if (skip === 8) {
            this._buffer.readAlignedBytes(8);
        }
        else if (skip === 9) {
            this._vint();
        }
    }
}
exports.VersionDecoder = VersionDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVyc2lvbkRlY29kZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJWZXJzaW9uRGVjb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUdBLHFDQUEwQztBQUMxQyx1REFBb0Q7QUFDcEQsNkJBQTZCO0FBRTdCLG9CQUE0QixTQUFRLGlDQUFlO0lBRy9DLFlBQW1CLElBQVksRUFBRSxPQUFPO1FBQ3BDLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUdNLFdBQVcsQ0FBQyxRQUFRO1FBQ3ZCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUFFLE1BQU0sSUFBSSx1QkFBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFBO1NBQUU7UUFBQSxDQUFDO0lBQ3RFLENBQUM7SUFFTSxLQUFLO1FBQ1IsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDN0IsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBRWIsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTdCLElBQUksTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDO1lBQ3RCLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNuRCxNQUFNLEdBQUcs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

/***/ }),

/***/ "./src/lib/decoder/errors/CorruptedError.ts":
/*!**************************************************!*\
  !*** ./src/lib/decoder/errors/CorruptedError.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CorruptedError extends Error {
    constructor(message = 'Corrupted Error') {
        super(message);
    }
}
exports.CorruptedError = CorruptedError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29ycnVwdGVkRXJyb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJDb3JydXB0ZWRFcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG9CQUE0QixTQUFRLEtBQUs7SUFDckMsWUFBbUIsT0FBTyxHQUFHLGlCQUFpQjtRQUMxQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkIsQ0FBQztDQUNKO0FBSkQsd0NBSUMifQ==

/***/ }),

/***/ "./src/lib/decoder/errors/TruncateError.ts":
/*!*************************************************!*\
  !*** ./src/lib/decoder/errors/TruncateError.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TruncateError extends Error {
    constructor(message = 'Truncate Error') {
        super(message);
    }
}
exports.TruncateError = TruncateError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJ1bmNhdGVFcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlRydW5jYXRlRXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQkFBMkIsU0FBUSxLQUFLO0lBQ3BDLFlBQW1CLE9BQU8sR0FBRyxnQkFBZ0I7UUFDekMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CLENBQUM7Q0FDSjtBQUpELHNDQUlDIn0=

/***/ }),

/***/ "./src/lib/decoder/errors/index.ts":
/*!*****************************************!*\
  !*** ./src/lib/decoder/errors/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./CorruptedError */ "./src/lib/decoder/errors/CorruptedError.ts"));
__export(__webpack_require__(/*! ./TruncateError */ "./src/lib/decoder/errors/TruncateError.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHNDQUFpQztBQUNqQyxxQ0FBZ0MifQ==

/***/ }),

/***/ "./src/lib/decoder/index.ts":
/*!**********************************!*\
  !*** ./src/lib/decoder/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./errors */ "./src/lib/decoder/errors/index.ts"));
__export(__webpack_require__(/*! ./BitPackedBuffer */ "./src/lib/decoder/BitPackedBuffer.ts"));
__export(__webpack_require__(/*! ./BitPackedDecoder */ "./src/lib/decoder/BitPackedDecoder.ts"));
__export(__webpack_require__(/*! ./VersionDecoder */ "./src/lib/decoder/VersionDecoder.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhCQUF5QjtBQUN6Qix1Q0FBa0M7QUFDbEMsd0NBQW1DO0FBQ25DLHNDQUFpQyJ9

/***/ }),

/***/ "./src/lib/heroprotocol.ts":
/*!*********************************!*\
  !*** ./src/lib/heroprotocol.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const PythonProtocolConverter_1 = __webpack_require__(/*! ./protocols/PythonProtocolConverter */ "./src/lib/protocols/PythonProtocolConverter.ts");
const errors_1 = __webpack_require__(/*! ./replay/errors */ "./src/lib/replay/errors/index.ts");
class HeroProtocol {
    static loadProtocol(protocolVersion) {
        const path = `https://raw.githubusercontent.com/Blizzard/heroprotocol/master/protocol${protocolVersion}.py`;
        return new Promise((resolve, reject) => {
            if (HeroProtocol._protocolCode.has(protocolVersion)) {
                resolve(HeroProtocol._protocolCode.get(protocolVersion));
            }
            else {
                const request = new XMLHttpRequest();
                request.open('GET', path, true);
                request.onload = (evt) => {
                    if (request.status === 200) {
                        const p = HeroProtocol.convertProtocolFromPython(protocolVersion, request.responseText);
                        HeroProtocol._protocolCode.set(protocolVersion, p);
                        resolve(p);
                    }
                    else {
                        reject(new errors_1.FailedToLoadProtocolError(protocolVersion, `Failed to load Heroes Protocol ${protocolVersion}`));
                    }
                };
                request.onabort = (event) => {
                    reject(event);
                };
                request.onerror = (event) => {
                    reject(event);
                };
                request.send();
            }
        });
    }
    static loadHeroData() {
        if (HeroProtocol._heroDataPromise) {
            return HeroProtocol._heroDataPromise;
        }
        HeroProtocol._heroDataPromise = new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            const path = '//hotsapi.net/api/v1/heroes';
            request.open('GET', path, true);
            request.onload = () => {
                const data = JSON.parse(request.responseText);
                resolve(data);
            };
            request.onabort = (event) => {
                reject(event);
            };
            request.onerror = (event) => {
                reject(event);
            };
            request.send();
        });
        return HeroProtocol._heroDataPromise;
    }
    static getProtocol(protocolVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (HeroProtocol.hasProtocol(protocolVersion)) {
                return HeroProtocol._protocols.get(protocolVersion);
            }
            const code = yield HeroProtocol.loadProtocol(protocolVersion);
            return HeroProtocol.compile(protocolVersion, code);
        });
    }
    static compile(protocolVersion, code) {
        const protocol = PythonProtocolConverter_1.PythonProtocolConverter.compile(code);
        HeroProtocol._protocols.set(protocolVersion, protocol);
        return protocol;
    }
    static hasProtocol(protocolVersion) {
        return HeroProtocol._protocols.has(protocolVersion);
    }
    static convertProtocolFromPython(version, pyCode) {
        const converter = new PythonProtocolConverter_1.PythonProtocolConverter(version, pyCode);
        return converter.getCode();
    }
}
HeroProtocol.env = 'development';
HeroProtocol._protocols = new Map();
HeroProtocol._protocolCode = new Map();
exports.HeroProtocol = HeroProtocol;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVyb3Byb3RvY29sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaGVyb3Byb3RvY29sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQSxpRkFBOEU7QUFDOUUsNENBQTREO0FBRTVEO0lBTVcsTUFBTSxDQUFDLFlBQVksQ0FBQyxlQUF1QjtRQUM5QyxNQUFNLElBQUksR0FBRywwRUFBMEUsZUFBZSxLQUFLLENBQUM7UUFDNUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNuQyxJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxFQUFFO2dCQUNqRCxPQUFPLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQzthQUM1RDtpQkFBTTtnQkFDSCxNQUFNLE9BQU8sR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO2dCQUNyQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ2hDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDckIsSUFBRyxPQUFPLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBQzt3QkFDdEIsTUFBTSxDQUFDLEdBQUcsWUFBWSxDQUFDLHlCQUF5QixDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7d0JBQ3hGLFlBQVksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFDbkQsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNkO3lCQUFJO3dCQUNELE1BQU0sQ0FBQyxJQUFJLGtDQUF5QixDQUFDLGVBQWUsRUFBRSxrQ0FBa0MsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO3FCQUMvRztnQkFDTCxDQUFDLENBQUM7Z0JBQ0YsT0FBTyxD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

/***/ }),

/***/ "./src/lib/index.ts":
/*!**************************!*\
  !*** ./src/lib/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./replay */ "./src/lib/replay/index.ts"));
__export(__webpack_require__(/*! ./types */ "./src/lib/types/index.ts"));
__export(__webpack_require__(/*! ./heroprotocol */ "./src/lib/heroprotocol.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhCQUF5QjtBQUN6Qiw2QkFBd0I7QUFDeEIsb0NBQStCIn0=

/***/ }),

/***/ "./src/lib/protocols/PythonProtocolConverter.ts":
/*!******************************************************!*\
  !*** ./src/lib/protocols/PythonProtocolConverter.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decoders = __webpack_require__(/*! ./decoders */ "./src/lib/protocols/decoders.ts");
const _template = `
    "use strict";

    const progress = {
        current: -1,
        total: -1
    }
    exports.progress = progress;

    exports.version = \${version};
    \${patch}

    const BitPackedDecoder = decoders.BitPackedDecoder;
    const VersionDecoder = decoders.VersionDecoder;


    // Decoding instructions for each protocol type.
    const typeinfos = [
    \${typeinfos}
    ];

    // Map from protocol NNet.Game.*Event eventid to [typeid, name]
    const game_event_types = {
    \${gameeventsTypes}
    };

    // The typeid of the NNet.Game.EEventId enum.
    const game_eventid_typeid = \${gameeventsTypeid};

    // Map from protocol NNet.Game.*Message eventid to [typeid, name]
    const message_event_types = {
    \${messageeventsTypes}
    };

    // The typeid of the NNet.Game.EMessageId enum.
    const message_eventid_typeid = \${messageeventsTypeid};

    // Map from protocol NNet.Replay.Tracker.*Event eventid to [typeid, name]
    const tracker_event_types = {
    \${trackereventstypes}
    };

    // The typeid of the NNet.Replay.Tracker.EEventId enum.
    const tracker_eventid_typeid = \${trackereventsTypeid};

    // The typeid of NNet.SVarUint32 (the type used to encode gameloop deltas).
    const svaruint32_typeid = 7;

    // The typeid of NNet.Replay.SGameUserId (the type used to encode player ids).
    const replay_userid_typeid = 8;

    // The typeid of NNet.Replay.SHeader (the type used to store replay game version and length).
    const replay_header_typeid = \${headerTypeid};

    // The typeid of NNet.Game.SDetails (the type used to store overall replay details).
    const game_details_typeid = \${detailsTypeid};

    // The typeid of NNet.Replay.SInitData (the type used to store the inital lobby).
    const replay_initdata_typeid = \${initdataTypeid};

    // not sure if correct port
    function _varuint32Value(value) {
    // Returns the numeric value from a SVarUint32 instance.
    return value[Object.keys(value)[0]];
    }

    function* _decode_event_stream(decoder, eventidTypeid, eventTypes, decodeUserId) {
    // Decodes events prefixed with a gameloop and possibly userid
    var gameloop = 0;
    while (!decoder.isDone) {
        
        var startBits = decoder.usedBits;

        // decode the gameloop delta before each event
        var delta = _varuint32Value(decoder.instance(svaruint32_typeid));
        gameloop += delta;

        // decode the userid before each event
        var userid = (decodeUserId === true) ? decoder.instance(replay_userid_typeid) : undefined;

        // decode the event id
        var eventid = decoder.instance(eventidTypeid);
        var eventType = eventTypes[eventid] || [null, null];
        var typeid = eventType[0];
        var typename = eventType[1];
        if (typeid === null) throw new decoders.CorruptedError('eventid(' + eventid + ') at ' + decoder.toString());

        // decode the event struct instance
        var event = decoder.instance(typeid);
        event._event = typename;
        event._eventid = eventid;

        // insert gameloop and userid
        event._gameloop = gameloop;
        if (decodeUserId) event._userid = userid;

        // the next event is byte aligned
        decoder.byteAlign();

        // insert bits used in stream
        event._bits = decoder.usedBits - startBits;
        progress.current = decoder.usedBits;
        yield event;
    }
    }

    exports.decodeReplayGameEvents = function* (contents) {
    // Decodes and yields each game event from the contents byte string.
    const decoder = new BitPackedDecoder(contents, typeinfos);
    progress.current = 0;
    progress.total = decoder.size;
    for (let event of _decode_event_stream(decoder, game_eventid_typeid, game_event_types, true))
        yield event;
    };

    exports.decodeReplayMessageEvents = function* (contents) {
        // Decodes and yields each message event from the contents byte string.
        const decoder = new BitPackedDecoder(contents, typeinfos);
        progress.current = 0;
        progress.total = decoder.size;
        for (let event of _decode_event_stream(decoder, message_eventid_typeid, message_event_types, true))
            yield event;
    };

    exports.decodeReplayTrackerEvents = function* (contents) {
    // Decodes and yields each tracker event from the contents byte string.
    const decoder = new VersionDecoder(contents, typeinfos);
    progress.current = 0;
    progress.total = decoder.size;
    for (let event of _decode_event_stream(decoder, tracker_eventid_typeid, tracker_event_types, false))
        yield event;
    };

    exports.decodeReplayHeader = function(contents) {
    // Decodes and return the replay header from the contents byte string.
    const decoder = new VersionDecoder(contents, typeinfos);
    return decoder.instance(replay_header_typeid);
    };

    exports.decodeReplayDetails = function(contents) {
    // Decodes and returns the game details from the contents byte string.
    const decoder = new VersionDecoder(contents, typeinfos);
    return decoder.instance(game_details_typeid);
    };

    exports.decodeReplayInitdata = function(contents) {
    // Decodes and return the replay init data from the contents byte string.
    const decoder = new BitPackedDecoder(contents, typeinfos);
    return decoder.instance(replay_initdata_typeid);
    };

    exports.decodeReplayAttributesEvents = function (contents) {
    // Decodes and yields each attribute from the contents byte string.
    const buffer = new decoders.BitPackedBuffer(contents, 'little');
    progress.current = 0;
    progress.total = buffer.size;
    const attributes = {};

    if (!buffer.isDone) {
        attributes.source = buffer.readBits(8);
        attributes.mapNameSpace = buffer.readBits(32);
        var count = buffer.readBits(32);
        attributes.scopes = {};

        while (!buffer.isDone) {
        var value = {};
        value.namespace = buffer.readBits(32);
        var attrid = value.attrid = buffer.readBits(32);
        var scope = buffer.readBits(8);
        value.value = buffer.readAlignedBytes(4).reverse();
        while (value.value[0] === 0) value.value = value.value.slice(1);
        while (value.value[value.value.length - 1] === 0) value.value = value.value.slice(0, -1);
        if (!attributes.scopes[scope])
            attributes.scopes[scope] = {};
        if (!attributes.scopes[scope][attrid])
            attributes.scopes[scope][attrid] = [];
        attributes.scopes[scope][attrid].push(value);
        progress.current = buffer.usedBits;
        }
    }

    return attributes;
    };

    exports.unitTag = function(unitTagIndex, unitTagRecycle) {
    return (unitTagIndex << 18) + unitTagRecycle;
    };

    exports.unitTagIndex = function(unitTag) {
    return (unitTag >> 18) & 0x00003FFF;
    };

    exports.unitTagRecycle = function(unitTag) {
    return unitTag & 0x0003FFFF;
    };
`;
const types = {
    tuple: function (str) {
        return str.match(/(-?\w+)/g);
    },
    tuples: function (str) {
        return str.match(/(\(.*?\))/g);
    },
    _int: {
        decode: function (str) {
            const ret = {};
            const res = types.tuple(str);
            ret['bounds'] = [res[0], res[1]];
            return ret;
        },
        encode: function (infos) {
            return `[${infos.bounds[0]}, ${infos.bounds[1]}]`;
        }
    },
    _choice: {
        decode: function (str) {
            const ret = { bounds: [], choices: [] };
            const res = types.tuples(str);
            Object.assign(ret, types._int.decode(res[0]));
            for (let i = 1; i < res.length; i += 1) {
                const tuple = types.tuple(res[i]);
                ret.choices.push({
                    label: tuple[0],
                    typeIndex: tuple[1]
                });
            }
            return ret;
        },
        encode: function (infos) {
            return `[${infos.bounds[0]}, ${infos.bounds[1]}], { ${infos.choices.map((choice, index, ar) => {
                return `${index}: ['${choice.label}', ${choice.typeIndex}]${(index === ar.length - 1) ? '' : ', '}`;
            }).join('')}}`;
        }
    },
    _struct: {
        decode: function (str) {
            const ret = { items: [] };
            const tuples = types.tuples(str);
            if (tuples) {
                tuples.forEach(tuple => {
                    tuple = types.tuple(tuple);
                    ret.items.push({
                        label: tuple[0],
                        typeIndex: tuple[1],
                        tag: tuple[2]
                    });
                });
            }
            return ret;
        },
        encode: function (infos) {
            return `[${infos.items.map((item, index, ar) => {
                return `['${item.label}', ${item.typeIndex}, ${item.tag}]${(index === ar.length - 1) ? '' : ', '}`;
            }).join('')}]`;
        }
    },
    _blob: {
        decode: function (str) {
            return types._int.decode(str);
        },
        encode: function (infos) {
            return types._int.encode(infos);
        }
    },
    _bool: {
        decode: function (str) {
            return {};
        },
        encode: function (infos) {
            return '';
        }
    },
    _array: {
        decode: function (str) {
            return Object.assign({ typeIndex: str.match(/\d+$/)[0] }, types._int.decode(str));
        },
        encode: function (infos) {
            return `[${infos.bounds[0]}, ${infos.bounds[1]}], ${infos.typeIndex}`;
        }
    },
    _optional: {
        decode: function (str) {
            return { typeIndex: Number(str) };
        },
        encode: function (infos) {
            return `${infos.typeIndex}`;
        }
    },
    _fourcc: {
        decode: function (str) {
            return {};
        },
        encode: function (infos) {
            return '';
        }
    },
    _bitarray: {
        decode: function (str) {
            return types._int.decode(str);
        },
        encode: function (infos) {
            return types._int.encode(infos);
        }
    },
    _null: {
        decode: function (str) {
            return {};
        },
        encode: function (infos) {
            return '';
        }
    }
};
const tokens = {
    newline: '\n',
    indent: '  ',
    typeinfosStart: 'typeinfos = [',
    typeinfosEnd: ']',
    gameeventsStart: 'game_event_types = {',
    gameeventsEnd: '}',
    messageeventsStart: 'message_event_types = {',
    messageeventsEnd: '}',
    trackereventsStart: 'tracker_event_types = {',
    trackereventsEnd: '}',
    gameeventsTypeid: 'game_eventid_typeid =',
    messageeventsTypeid: 'message_eventid_typeid =',
    trackereventsTypeid: 'tracker_eventid_typeid =',
    headerTypeid: 'replay_header_typeid =',
    detailsTypeid: 'game_details_typeid =',
    initdataTypeid: 'replay_initdata_typeid ='
};
const _data = {
    realms: [undefined, 'live'],
    regions: [
        undefined,
        undefined,
        'Europe'
    ],
    heroes: [],
    mounts: [],
    maps: [],
    builds: []
};
class PythonProtocolConverter {
    constructor(version, pyCode) {
        this.version = version;
        this.pyCode = pyCode;
    }
    static compile(protocolCode) {
        const start = new Date().getTime();
        const protocol = {};
        const fn = Function('exports', 'decoders', protocolCode);
        fn(protocol, decoders);
        console.log('Protocol Compile Time: ', new Date().getTime() - start);
        return protocol;
    }
    convert() {
        return PythonProtocolConverter.compile(this.getCode());
    }
    getCode() {
        this.parse(this.pyCode);
        return this.write();
    }
    parse(raw) {
        const start = new Date().getTime();
        const lines = raw.split(tokens.newline);
        let line = 0, str;
        this.typeinfos = [];
        this.gameeventsTypes = [];
        this.messageeventsTypes = [];
        this.trackereventstypes = [];
        while (line < lines.length) {
            str = lines[line].trim();
            if (str === tokens.typeinfosStart) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.typeinfos.push(this.parseTypeinfos(str));
                    line += 1;
                    str = lines[line].trim();
                } while (str !== tokens.typeinfosEnd);
            }
            else if (tokens.gameeventsStart === str) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.gameeventsTypes.push(this.parseEvent(str));
                    line += 1;
                    str = lines[line].trim();
                } while (tokens.gameeventsEnd !== str);
            }
            else if (tokens.messageeventsStart === str) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.messageeventsTypes.push(this.parseEvent(str));
                    line += 1;
                    str = lines[line].trim();
                } while (tokens.messageeventsEnd !== str);
            }
            else if (tokens.trackereventsStart === str) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.trackereventstypes.push(this.parseEvent(str));
                    line += 1;
                    str = lines[line].trim();
                } while (tokens.trackereventsEnd !== str);
            }
            else if (str.startsWith(tokens.gameeventsTypeid)) {
                this.gameeventsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.messageeventsTypeid)) {
                this.messageeventsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.trackereventsTypeid)) {
                this.trackereventsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.headerTypeid)) {
                this.headerTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.detailsTypeid)) {
                this.detailsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.initdataTypeid)) {
                this.initdataTypeid = str.match(/\d+/)[0];
            }
            line += 1;
        }
        console.log('Protocol Parse Time: ', new Date().getTime() - start);
    }
    parseEvent(str) {
        const res = str.match(/^(\d+):\s\((\d+),\s\'(.*)\'/);
        return {
            key: res[1],
            typeIndex: res[2],
            name: res[3]
        };
    }
    parseTypeinfos(str) {
        const typeRegex = /^\('(.*?)',\[(.*)\]\),\s*#(\d+)$/;
        const infos = { str: str };
        const res = typeRegex.exec(str);
        infos.type = res[1];
        Object.assign(infos, types[infos.type].decode(res[2]));
        infos.index = res[3];
        return infos;
    }
    write() {
        const start = new Date().getTime();
        const buildInfos = _data.builds[this.version];
        let out = _template;
        out = out.replace('${date}', new Date().toUTCString());
        out = out.replace('${version}', this.version);
        if (buildInfos) {
            const patch = buildInfos.live ? buildInfos.live.patch : buildInfos.ptr.patch;
            out = out.replace('${patch}', `exports.patch = \'${patch}\';${tokens.newline}`);
        }
        else {
            out = out.replace('${patch}', '');
        }
        out = out.replace('${typeinfos}', this.typeinfos.map((infos, index, ar) => {
            let str = tokens.indent;
            str += `['${infos.type}', [`;
            str += types[infos.type].encode(infos);
            str += `]]${index === (ar.length - 1) ? '' : ','}`;
            str += `  //${infos.index}`;
            return str;
        }).join(tokens.newline));
        out = out.replace('${gameeventsTypes}', this.gameeventsTypes.map((event, index, ar) => {
            let str = tokens.indent;
            str += `${event.key}: [${event.typeIndex}, \'${event.name}\']`;
            str += index === ar.length - 1 ? '' : ',';
            return str;
        }).join(tokens.newline));
        out = out.replace('${messageeventsTypes}', this.messageeventsTypes.map((event, index, ar) => {
            let str = tokens.indent;
            str += `${event.key}: [${event.typeIndex}, \'${event.name}\']`;
            str += index === ar.length - 1 ? '' : ',';
            return str;
        }).join(tokens.newline));
        out = out.replace('${trackereventstypes}', this.trackereventstypes.map((event, index, ar) => {
            let str = tokens.indent + tokens.indent;
            str += `${event.key}: [${event.typeIndex}, \'${event.name}\']`;
            str += index === ar.length - 1 ? '' : ',';
            return str;
        }).join(tokens.newline));
        out = out.replace('${gameeventsTypeid}', this.gameeventsTypeid);
        out = out.replace('${messageeventsTypeid}', this.messageeventsTypeid);
        out = out.replace('${trackereventsTypeid}', this.trackereventsTypeid);
        out = out.replace('${headerTypeid}', this.headerTypeid);
        out = out.replace('${detailsTypeid}', this.detailsTypeid);
        out = out.replace('${initdataTypeid}', this.initdataTypeid);
        console.log('Protocol Write Time: ', new Date().getTime() - start);
        return out;
    }
}
exports.PythonProtocolConverter = PythonProtocolConverter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJQeXRob25Qcm90b2NvbENvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHVDQUF1QztBQUV2QyxNQUFNLFNBQVMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbU1qQixDQUFDO0FBR0YsTUFBTSxLQUFLLEdBQUc7SUFDVixLQUFLLEVBQUUsVUFBVSxHQUFHO1FBQ2hCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsTUFBTSxFQUFFLFVBQVUsR0FBRztRQUNqQixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELElBQUksRUFBRTtRQUNGLE1BQU0sRUFBRSxVQUFVLEdBQUc7WUFDakIsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO1lBQ2YsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QixHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakMsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDO1FBQ0QsTUFBTSxFQUFFLFVBQVUsS0FBSztZQUNuQixPQUFPLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsTUFBTSxDQUFDLENB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

/***/ }),

/***/ "./src/lib/protocols/decoders.ts":
/*!***************************************!*\
  !*** ./src/lib/protocols/decoders.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decoder_1 = __webpack_require__(/*! ../decoder */ "./src/lib/decoder/index.ts");
exports.BitPackedBuffer = decoder_1.BitPackedBuffer;
exports.VersionDecoder = decoder_1.VersionDecoder;
exports.BitPackedDecoder = decoder_1.BitPackedDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2RlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZWNvZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdDQUE2RTtBQUV4RSwwQkFGRyx5QkFBZSxDQUVIO0FBQ2YseUJBSG9CLHdCQUFjLENBR3BCO0FBQ2QsMkJBSm9DLDBCQUFnQixDQUlwQyJ9

/***/ }),

/***/ "./src/lib/replay/Replay.ts":
/*!**********************************!*\
  !*** ./src/lib/replay/Replay.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js");
const mpq_1 = __webpack_require__(/*! @heroesbrowser/mpq */ "./node_modules/@heroesbrowser/mpq/dist/index.js");
const heroprotocol_1 = __webpack_require__(/*! ../heroprotocol */ "./src/lib/heroprotocol.ts");
const types_1 = __webpack_require__(/*! ../types */ "./src/lib/types/index.ts");
const decorators_1 = __webpack_require__(/*! ./decorators */ "./src/lib/replay/decorators.ts");
const BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ "./node_modules/rxjs/BehaviorSubject.js");
function parseStrings(data) {
    if (!data) {
        return data;
    }
    else if (data instanceof buffer_1.Buffer) {
        return data.toString();
    }
    else if (Array.isArray(data)) {
        return data.map(item => parseStrings(item));
    }
    else if (typeof data === 'object') {
        for (const key in data) {
            data[key] = parseStrings(data[key]);
        }
    }
    return data;
}
;
var ReplayFiles;
(function (ReplayFiles) {
    ReplayFiles["DETAILS"] = "replay.details";
    ReplayFiles["INITDATA"] = "replay.initdata";
    ReplayFiles["GAME_EVENTS"] = "replay.game.events";
    ReplayFiles["MESSAGE_EVENTS"] = "replay.message.events";
    ReplayFiles["TRACKER_EVENTS"] = "replay.tracker.events";
    ReplayFiles["ATTRIBUTES_EVENTS"] = "replay.attributes.events";
})(ReplayFiles = exports.ReplayFiles || (exports.ReplayFiles = {}));
const decoderMap = {
    [ReplayFiles.DETAILS]: 'decodeReplayDetails',
    [ReplayFiles.INITDATA]: 'decodeReplayInitdata',
    [ReplayFiles.GAME_EVENTS]: 'decodeReplayGameEvents',
    [ReplayFiles.MESSAGE_EVENTS]: 'decodeReplayMessageEvents',
    [ReplayFiles.TRACKER_EVENTS]: 'decodeReplayTrackerEvents',
    [ReplayFiles.ATTRIBUTES_EVENTS]: 'decodeReplayAttributesEvents',
};
let Replay = class Replay {
    constructor(mpqData) {
        this._data = new Map();
        this._statusSubject = new BehaviorSubject_1.BehaviorSubject(undefined);
        this._stateSubject = new BehaviorSubject_1.BehaviorSubject(undefined);
        this._lastProgressTime = 0;
        this.loadProtocol = (protocolVersion) => __awaiter(this, void 0, void 0, function* () {
            return yield heroprotocol_1.HeroProtocol.loadProtocol(protocolVersion);
        });
        this.loadHeroData = () => __awaiter(this, void 0, void 0, function* () {
            return yield heroprotocol_1.HeroProtocol.loadHeroData();
        });
        this._mpq = new mpq_1.MPQArchive(mpqData);
        console.log(this._mpq.files);
        this.manageStatus();
    }
    get status() {
        return this._statusSubject;
    }
    get protocol() {
        if (this._protocol) {
            return this.asPromise(this._protocol);
        }
        return this.parseHeader().then(() => {
            return this.asPromise(this._protocol);
        });
    }
    get heroData() {
        return this.getHeroData();
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.parseHeader();
            this.updateStatus('REPLAY_READY');
        });
    }
    get header() {
        if (this._header) {
            this.asPromise(this._header);
        }
        return this.parseHeader();
    }
    get details() {
        return this.data(ReplayFiles.DETAILS);
    }
    get initData() {
        return this.data(ReplayFiles.INITDATA);
    }
    get gameEvents() {
        return this.events(ReplayFiles.GAME_EVENTS);
    }
    get messageEvents() {
        return this.events(ReplayFiles.MESSAGE_EVENTS);
    }
    get trackerEvents() {
        return this.events(ReplayFiles.TRACKER_EVENTS);
    }
    get attributeEvents() {
        return this.data(ReplayFiles.ATTRIBUTES_EVENTS);
    }
    manageStatus() {
        const stateSub = this._stateSubject.subscribe((next) => {
            this._statusSubject.next(next);
        });
    }
    updateStatus(status, current = 0, total = -1) {
        const msg = {
            type: 'replay-status',
            status,
            current,
            total
        };
        if (total === -1) {
            if (this._lastProgress) {
                this._stateSubject.next(this._lastProgress);
                this._lastProgress = undefined;
            }
            this._stateSubject.next(msg);
        }
        else {
            const now = new Date().getTime();
            const delta = now - this._lastProgressTime;
            if (delta > 10) {
                this._stateSubject.next(msg);
                this._lastProgressTime = now;
            }
            else {
                this._lastProgress = msg;
            }
        }
    }
    parseHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            this.updateStatus('parseHeader');
            const headProtocol = yield this.getProtocol(29406);
            const rawHeader = parseStrings(headProtocol.decodeReplayHeader(this._mpq.header.userDataHeader.content));
            this._protocolPromise = this.getProtocol(rawHeader.m_version.m_baseBuild);
            this._protocol = yield this._protocolPromise;
            this._header = parseStrings(this._protocol.decodeReplayHeader(this._mpq.header.userDataHeader.content));
            this.updateStatus('parseHeader', -1);
            return this._header;
        });
    }
    getProtocol(protocolVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            this.updateStatus('getProtocol');
            if (heroprotocol_1.HeroProtocol.hasProtocol(protocolVersion)) {
                return heroprotocol_1.HeroProtocol.getProtocol(protocolVersion);
            }
            const code = yield this.loadProtocol(protocolVersion);
            const protocol = heroprotocol_1.HeroProtocol.compile(protocolVersion, code);
            this.updateStatus('getProtocol', -1);
            return protocol;
        });
    }
    getHeroData() {
        return __awaiter(this, void 0, void 0, function* () {
            this.updateStatus('getHeroData');
            const data = yield this.loadHeroData();
            this.updateStatus('getHeroData', -1);
            return data;
        });
    }
    parse(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.protocol;
            const data = parseStrings(protocol[decoderMap[type]](this._mpq.readFile(type)));
            this._data.set(type, data);
            return data;
        });
    }
    parseEvents(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.protocol;
            const eventGen = protocol[decoderMap[type]](this._mpq.readFile(type));
            const events = [];
            this.updateStatus('parse-event-' + type, 0, protocol.progress.total);
            for (const event of eventGen) {
                if (types_1.FilteredEvents.indexOf(event._event) === -1) {
                    events.push(parseStrings(event));
                }
                this.updateStatus('parse-event-' + type, protocol.progress.current, protocol.progress.total);
            }
            this._data.set(type, events);
            this.updateStatus('parse-event-' + type, -1);
            return events;
        });
    }
    data(type) {
        if (this._data.has(type)) {
            return this.asPromise(this._data.get(type));
        }
        return this.parse(type);
    }
    events(type) {
        if (this._data.has(type)) {
            return this.asPromise(this._data.get(type));
        }
        return this.parseEvents(type);
    }
    asPromise(value) {
        return new Promise((res, rej) => {
            res(value);
        });
    }
    dispose() {
        this._mpq = undefined;
        this._data = undefined;
        this._header = undefined;
        this._protocol = undefined;
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "header", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "details", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "initData", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "gameEvents", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "messageEvents", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "trackerEvents", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "attributeEvents", null);
Replay = __decorate([
    decorators_1.ReplayWorkerContext('008DCF70-B7E4-42DF-A3F9-4D2ADE13E718'),
    __metadata("design:paramtypes", [ArrayBuffer])
], Replay);
exports.Replay = Replay;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUmVwbGF5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBZ0M7QUFDaEMsNENBQWdEO0FBQ2hELGtEQUErQztBQUMvQyxvQ0FNa0I7QUFDbEIsNkNBQWdFO0FBQ2hFLDBEQUF1RDtBQU92RCxzQkFBeUIsSUFBSTtJQUN6QixJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUM7S0FDZjtTQUFNLElBQUksSUFBSSxZQUFZLGVBQU0sRUFBRTtRQUMvQixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUMxQjtTQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUM1QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUMvQztTQUFNLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBRWpDLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDdkM7S0FDSjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFBQSxDQUFDO0FBR0YsSUFBWSxXQVFYO0FBUkQsV0FBWSxXQUFXO0lBQ25CLHlDQUEwQixDQUFBO0lBQzFCLDJDQUE0QixDQUFBO0lBQzVCLGlEQUFrQyxDQUFBO0lBQ2xDLHVEQUF3QyxDQUFBO0lBQ3hDLHVEQUF3QyxDQUFBO0lBQ3hDLDZEQUE4QyxDQUFBO0FBRWxELENBQUMsRUFSVyxXQUFXLEdBQVgsbUJBQVcsS0FBWCxtQkFBVyxRQVF0QjtBQUVELE1BQU0sVUFBVSxHQUFHO0lBQ2YsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUUs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

/***/ }),

/***/ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts":
/*!************************************************************!*\
  !*** ./src/lib/replay/analyzers/AbstractReplayAnalyser.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../decorators */ "./src/lib/replay/decorators.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/lib/replay/analyzers/types/index.ts");
const errors_1 = __webpack_require__(/*! ../errors */ "./src/lib/replay/errors/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const semver = __webpack_require__(/*! semver */ "./node_modules/semver/semver.js");
class AbstractReplayAnalyser {
    constructor(replay) {
        this.replay = replay;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const head = this._replayHeader = yield this.replay.header;
            this._replayVersion = {
                protocol: head.m_version.m_baseBuild,
                build: head.m_version.m_build,
                major: head.m_version.m_major,
                minor: head.m_version.m_minor,
                revision: head.m_version.m_revision
            };
            const initData = this._initData = yield this.replay.initData;
            this._gameType = this.getGameType();
        });
    }
    getGameType() {
        const init = this._initData;
        const gameDesc = init.m_syncLobbyState.m_gameDescription;
        switch (gameDesc.m_gameOptions.m_ammId) {
            case 50021:
            case 50021:
                return types_1.GameType.MODE_AI;
            case 50001:
                return types_1.GameType.QUICK_MATCH;
            case 50031:
                return types_1.GameType.BRAWL;
            case 50051:
                return types_1.GameType.UNRANKED_DRAFT;
            case 50061:
                return types_1.GameType.HERO_LEAGUE;
            case 50071:
                return types_1.GameType.TEAM_LEAGUE;
            default:
                if (!gameDesc.m_gameOptions.m_competitive && !gameDesc.m_gameOptions.m_cooperative) {
                    if (gameDesc.m_gameOptions.m_heroDuplicatesAllowed) {
                        return types_1.GameType.CUSTOM;
                    }
                    else {
                        return types_1.GameType.CUSTOM_DRAFT;
                    }
                }
                return types_1.GameType.UNKNOWN;
        }
    }
    get protocolVersion() {
        return this._replayVersion.protocol;
    }
    get version() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return this._replayVersion;
        }))();
    }
    get heroData() {
        return this.replay.heroData;
    }
    get gameType() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return this._gameType;
        }))();
    }
    get tickRate() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return 16;
        }))();
    }
    isGameType(type) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const gameType = yield this.gameType;
            return (gameType & type) === type;
        }))();
    }
    checkMinVersion(minVer, message) {
        if (!this.versionMatches('>=' + minVer)) {
            throw new errors_1.ReplayVersionOutOfRangeError(message || "Replay to Old");
        }
    }
    versionMatches(semVer) {
        return semver.satisfies(this.protocolVersion + '.0.0', semVer);
    }
    get header() {
        return Promise.resolve(this._replayHeader);
    }
    get initData() {
        return Promise.resolve(this._initData);
    }
    get details() {
        return this.replay.details;
    }
    get attributeEvents() {
        return this.replay.attributeEvents;
    }
    get trackerEvents() {
        return this.replay.trackerEvents;
    }
    get messageEvents() {
        return this.replay.messageEvents;
    }
    get gameEvents() {
        return this.replay.gameEvents;
    }
    get trackerEventsQueriable() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return linq.from(yield this.trackerEvents);
        }))();
    }
    get messageEventsQueriable() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return linq.from(yield this.messageEvents);
        }))();
    }
    get gameEventsQueriable() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return linq.from(yield this.gameEvents);
        }))();
    }
    dispose() { }
}
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AbstractReplayAnalyser.prototype, "initialize", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], AbstractReplayAnalyser.prototype, "getGameType", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "protocolVersion", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "version", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "gameType", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "tickRate", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String]),
    __metadata("design:returntype", void 0)
], AbstractReplayAnalyser.prototype, "checkMinVersion", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Boolean)
], AbstractReplayAnalyser.prototype, "versionMatches", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "header", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "initData", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "details", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "attributeEvents", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "trackerEvents", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "messageEvents", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "gameEvents", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "trackerEventsQueriable", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "messageEventsQueriable", null);
__decorate([
    decorators_1.WorkerOnly(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], AbstractReplayAnalyser.prototype, "gameEventsQueriable", null);
exports.AbstractReplayAnalyser = AbstractReplayAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RSZXBsYXlBbmFseXNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkFic3RyYWN0UmVwbGF5QW5hbHlzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLDhDQUF3RDtBQUV4RCxtQ0FBbUQ7QUFDbkQsc0NBQXlEO0FBQ3pELDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFFakM7SUFPSSxZQUE2QixNQUFjO1FBQWQsV0FBTSxHQUFOLE1BQU0sQ0FBUTtJQUFJLENBQUM7SUFHbkMsVUFBVTs7WUFDbkIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1lBQzNELElBQUksQ0FBQyxjQUFjLEdBQUc7Z0JBQ2xCLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVc7Z0JBQ3BDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU87Z0JBQzdCLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU87Z0JBQzdCLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU87Z0JBQzdCLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVU7YUFDdEMsQ0FBQztZQUNGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztZQUM3RCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN4QyxDQUFDO0tBQUE7SUFHTyxXQUFXO1FBQ2YsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUM1QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUM7UUFDekQsUUFBUSxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRTtZQUNwQyxLQUFL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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/BasicReplayAnalyser.ts":
/*!*****************************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/BasicReplayAnalyser.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const sha1 = __webpack_require__(/*! sha1 */ "./node_modules/sha1/sha1.js");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
const PlayerAnalyser_1 = __webpack_require__(/*! ./PlayerAnalyser */ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts");
let BasicReplayAnalyser = class BasicReplayAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.playerAnalyser = new PlayerAnalyser_1.PlayerAnalyser(this.replay);
            yield this.playerAnalyser.initialize();
        });
    }
    get fingerPrint() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            let fp = '';
            const head = yield this.header;
            const init = yield this.initData;
            fp = head.m_elapsedGameLoops.toString(16);
            fp += '|' + init.m_syncLobbyState.m_gameDescription.m_randomValue;
            fp += '|' + init.m_syncLobbyState.m_gameDescription.m_gameOptions.m_ammId;
            fp += '|' + linq.from(init.m_syncLobbyState.m_lobbyState.m_slots)
                .toJoinedString('#', elm => elm.m_hero + '~' + elm.m_teamId + '~' + elm.m_toonHandle);
            return sha1(fp);
        }))();
    }
    get gameDurationTicks() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const head = yield this.header;
            return head.m_elapsedGameLoops;
        }))();
    }
    get gameDuration() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return (yield this.gameDurationTicks) / 16;
        }))();
    }
    get mapName() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.details;
            return details.m_title;
        }))();
    }
    get winningTeam() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const players = yield this.playerList;
            return linq.from(players).first(_ => _.team === 0).won ? 0 : 1;
        }))();
    }
    get timeZone() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.details;
            return details.m_timeLocalOffset / 10000000 / 60 / 60;
        }))();
    }
    get playedOn() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.details;
            return new Date(details.m_timeUTC / 10000 - 11644473600000);
        }))();
    }
    get playerList() {
        return this.playerAnalyser.playerSlotData;
    }
    get replayDescription() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return {
                fingerPrint: yield this.fingerPrint,
                gameType: yield this.gameType,
                version: yield this.version,
                gameDurationTicks: yield this.gameDurationTicks,
                gameDuration: yield this.gameDuration,
                mapName: yield this.mapName,
                timeZone: yield this.timeZone,
                playedOn: yield this.playedOn,
                winningTeam: yield this.winningTeam,
                players: yield this.playerList
            };
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "fingerPrint", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "gameDurationTicks", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "mapName", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "winningTeam", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "timeZone", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "playedOn", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "playerList", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "replayDescription", null);
BasicReplayAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('1B90BC76-8CE8-495C-A978-ABFD78DBB72A'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], BasicReplayAnalyser);
exports.BasicReplayAnalyser = BasicReplayAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzaWNSZXBsYXlBbmFseXNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkJhc2ljUmVwbGF5QW5hbHlzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlDQUFzQztBQUN0Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBRTdCLGlEQUFzRTtBQUN0RSxzRUFBbUU7QUFFbkUscURBQStEO0FBa0IvRCxJQUFhLG1CQUFtQixHQUFoQyx5QkFBaUMsU0FBUSwrQ0FBc0I7SUFHM0QsWUFBbUIsTUFBYztRQUM3QixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFbEIsQ0FBQztJQUVZLFVBQVU7OztZQUNuQixNQUFNLG9CQUFnQixXQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLCtCQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3RELE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUMzQyxDQUFDO0tBQUE7SUFHRCxJQUFXLFdBQVc7UUFDbEIsT0FBTyxDQUFDLEdBQTBCLEVBQUU7WUFDaEMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDO1lBQ1osTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQy9CLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNqQyxFQUFFLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxQyxFQUFFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUM7WUFDbEUsRUFBRSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztZQUMxRSxFQUFFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUM7aUJBQzVELGNBQWMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDMUYsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDcEIsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDO0lBQ1QsQ0FBQztJQUdELElBQVcsaUJBQWlCO1FBQ3hCLE9BQU8sQ0FBQyxHQUEwQixFQUFFO1lBQ2hDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUMvQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztRQUNuQyxDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUM7SUFDVCxDQUFDO0lBRUQsSUFBVyxZQUFZO1FBQ25CLE9BQU8sQ0FBQyxHQUEwQixFQUFFO1lBQ2hDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMvQyxDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUM7SUFDVCxDQUFDO0lBR0QsSUFBVyxPQUFPO1FBQ2QsT0FBTyxDQUFDLEdBQTBCLEVBQUU7WUFDaEMsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQ25DLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMzQixDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUM7SUFDVCxDQUFDO0lBR0QsSUFBVyxXQUFXO1FBQ2xCLE9BQU8sQ0FBQyxHQUEwQixFQUFFO1lBQ2hDLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUN0QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25FLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQztJQUNULENBQUM7SUFHRCxJQUFXLFFBQVE7UUFDZixPQUFPLENBQUMsR0FBMEIsRUFBRTtZQUNoQyxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUM7WUFDbkMsT0FBTyxPQUFPLENBQUMsaUJBQWlCLEdBQUcsUUFBUSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDMUQsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDO0lBQ1QsQ0FBQztJQUdELElBQVcsUUFBUTtRQUNmLE9BQU8sQ0FBQyxHQUF3QixFQUFFO1lBQzlCLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUNuQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsS0FBSyxHQUFHLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQztJQUNULENBQUM7SUFHRCxJQUFXLFVBQVU7UUFDakIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQztJQUM5QyxDQUFDO0lBR0QsSUFBVyxpQkFBaUI7UUFDeEIsT0FBTyxDQUFDLEdBQXFDLEVBQUU7WUFDM0MsT0FBTztnQkFDSCxXQUFXLEVBQUUsTUFBTSxJQUFJLENBQUMsV0FBVztnQkFDbkMsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLFFBQVE7Z0JBQzdCLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQyxPQUFPO2dCQUMzQixpQkFBaUIsRUFBRSxNQUFNLElBQUksQ0FBQyxpQkFBaUI7Z0JBQy9DLFlBQVksRUFBRSxNQUFNLElBQUksQ0FBQyxZQUFZO2dCQUNyQyxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUMsT0FBTztnQkFDM0IsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLFFBQVE7Z0JBQzdCLFFBQVEsRUFBRSxNQUFNLElBQUksQ0FBQyxRQUFRO2dCQUM3QixXQUFXLEVBQUUsTUFBTSxJQUFJLENBQUMsV0FBVztnQkFDbkMsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLFVBQVU7YUFDakMsQ0FBQztRQUNOLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQztJQUNULENBQUM7Q0FDSixDQUFBO0FBbEZHO0lBREMsd0JBQVcsRUFBRTs7O3NEQWFiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7NERBTWI7QUFTRDtJQURDLHdCQUFXLEVBQUU7OztrREFNYjtBQUdEO0lBREMsd0JBQVcsRUFBRTs7O3NEQU1iO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7bURBTWI7QUFHRDtJQURDLHdCQUFXLEVBQUU7OzttREFNYjtBQUdEO0lBREMsd0JBQVcsRUFBRTs7O3FEQUdiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7NERBZ0JiO0FBaEdRLG1CQUFtQjtJQUQvQixrQ0FBcUIsQ0FBQyxzQ0FBc0MsQ0FBQztxQ0FJL0IsZUFBTTtHQUh4QixtQkFBbUIsQ0FpRy9CO0FBakdZLGtEQUFtQiJ9

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/ChatAnalyser.ts":
/*!**********************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/ChatAnalyser.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const PlayerAnalyser_1 = __webpack_require__(/*! ./PlayerAnalyser */ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
let ChatAnalyser = class ChatAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.playerAnalyser = new PlayerAnalyser_1.PlayerAnalyser(this.replay);
            yield this.playerAnalyser.initialize();
        });
    }
    get chatMessages() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const messageQ = yield this.messageEventsQueriable;
            const playerQ = linq.from(this.playerAnalyser.playerSlotData);
            const tickRate = yield this.tickRate;
            const result = messageQ
                .where(_ => types_1.isISChatMessage(_))
                .join(playerQ, m => m._userid.m_userId, p => p.userId, (m, p) => ({
                message: m.m_string,
                time: m._gameloop / tickRate,
                recipient: m.m_recipient,
                userId: p.userId,
                playerName: p.name,
                team: p.team
            })).toArray();
            return result;
        }))();
    }
    get pings() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const messageQ = yield this.messageEventsQueriable;
            const playerQ = linq.from(this.playerAnalyser.playerSlotData);
            const tickRate = yield this.tickRate;
            const result = messageQ
                .where(_ => types_1.isISPingMessage(_))
                .join(playerQ, m => m._userid.m_userId, p => p.userId, (m, p) => ({
                point: {
                    x: m.m_point.x / 4096,
                    y: m.m_point.y / 4096
                },
                time: m._gameloop / tickRate,
                recipient: m.m_recipient,
                userId: p.userId,
                playerName: p.name,
                team: p.team
            })).toArray();
            return result;
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ChatAnalyser.prototype, "chatMessages", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ChatAnalyser.prototype, "pings", null);
ChatAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('80021810-3AD4-418D-9FB5-49081355019A'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], ChatAnalyser);
exports.ChatAnalyser = ChatAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hhdEFuYWx5c2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQ2hhdEFuYWx5c2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxpREFBc0U7QUFDdEUseUNBQXNDO0FBQ3RDLDBDQUl3QjtBQUN4Qiw2QkFBNkI7QUFDN0IscURBQStEO0FBRS9ELHNFQUFtRTtBQXlCbkUsSUFBYSxZQUFZLEdBQXpCLGtCQUEwQixTQUFRLCtDQUFzQjtJQUVwRCxZQUFtQixNQUFjO1FBQzdCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBQ1ksVUFBVTs7O1lBQ25CLE1BQU0sb0JBQWdCLFdBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksK0JBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEQsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUdELElBQVcsWUFBWTtRQUNuQixPQUFPLENBQUMsR0FBa0MsRUFBRTtZQUN4QyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQztZQUNuRCxNQUFNLE9BQU8sR0FBdUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2xHLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNyQyxNQUFNLE1BQU0sR0FBRyxRQUFRO2lCQUNsQixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyx1QkFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM5QixJQUFJLENBQ0QsT0FBTyxFQUNQLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQ3ZCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFDYixDQUFDLENBQWdCLEVBQUUsQ0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNuQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLFFBQVE7Z0JBQ25CLElBQUksRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLFFBQVE7Z0JBQzVCLFNBQVMsRUFBRSxDQUFDLENBQUMsV0FBVztnQkFDeEIsTUFBTSxFQUFFLENBQUMsQ0FBQyxNQUFNO2dCQUNoQixVQUFVLEVBQUUsQ0FBQyxDQUFDLElBQUk7Z0JBQ2xCLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSTthQUNmLENBQUMsQ0FDTCxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2hCLE9BQU8sTUFBTSxDQUFDO1FBQ2xCLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQztJQUNULENBQUM7SUFHRCxJQUFXLEtBQUs7UUFDWixPQUFPLENBQUMsR0FBMkIsRUFBRTtZQUNqQyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQztZQUNuRCxNQUFNLE9BQU8sR0FBdUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2xHLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNyQyxNQUFNLE1BQU0sR0FBRyxRQUFRO2lCQUNsQixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyx1QkFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM5QixJQUFJLENBQ0QsT0FBTyxFQUNQLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQ3ZCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFDYixDQUFDLENBQWdCLEVBQUUsQ0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNuQyxLQUFLLEVBQUU7b0JBQ0gsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUk7b0JBQ3JCLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJO2lCQUN4QjtnQkFDRCxJQUFJLEVBQUUsQ0FBQyxDQUFDLFNBQVMsR0FBRyxRQUFRO2dCQUM1QixTQUFTLEVBQUUsQ0FBQyxDQUFDLFdBQVc7Z0JBQ3hCLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTTtnQkFDaEIsVUFBVSxFQUFFLENBQUMsQ0FBQyxJQUFJO2dCQUNsQixJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUk7YUFDZixDQUFDLENBQ0wsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNoQixPQUFPLE1BQU0sQ0FBQztRQUNsQixDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUM7SUFDVCxDQUFDO0NBQ0osQ0FBQTtBQW5ERztJQURDLHdCQUFXLEVBQUU7OztnREF1QmI7QUFHRDtJQURDLHdCQUFXLEVBQUU7Ozt5Q0EwQmI7QUE5RFEsWUFBWTtJQUR4QixrQ0FBcUIsQ0FBQyxzQ0FBc0MsQ0FBQztxQ0FHL0IsZUFBTTtHQUZ4QixZQUFZLENBK0R4QjtBQS9EWSxvQ0FBWSJ9

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/DraftAnalyser.ts":
/*!***********************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/DraftAnalyser.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const PlayerAnalyser_1 = __webpack_require__(/*! ./PlayerAnalyser */ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts");
const ReplayAttributeHelper_1 = __webpack_require__(/*! ../../util/ReplayAttributeHelper */ "./src/lib/replay/util/ReplayAttributeHelper.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
let DraftAnalyser = class DraftAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.playerAnalyser = new PlayerAnalyser_1.PlayerAnalyser(this.replay);
            yield this.playerAnalyser.initialize();
        });
    }
    get bans() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const heroData = linq.from(yield this.heroData);
            const helper = new ReplayAttributeHelper_1.ReplayAttributeHelper(yield this.attributeEvents);
            const trackQ = yield this.trackerEventsQueriable;
            const result = trackQ
                .where(_ => types_1.isSHeroBannedEvent(_))
                .select((_, i) => {
                const team = _.m_controllingTeam - 1;
                const heroShort = helper.getBan(team, i < 2 ? 0 : 1);
                const hero = heroData.first((_) => _.attribute_id === heroShort);
                return {
                    type: 'ban',
                    team: _.m_controllingTeam - 1,
                    hero: hero.name
                };
            })
                .toArray();
            return result;
        }))();
    }
    get picks() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const trackQ = yield this.trackerEventsQueriable;
            const players = linq.from(yield this.playerAnalyser.playerSlotData);
            const result = trackQ
                .where(_ => types_1.isSHeroPickedEvent(_))
                .join(players, (pick) => pick.m_controllingPlayer, (player) => player.userId, (pick, player) => ({
                type: 'pick',
                team: player.team,
                userId: player.userId,
                playerName: player.name,
                hero: player.hero
            }))
                .toArray();
            return result;
        }))();
    }
    get draft() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const bans = yield this.bans;
            const picks = yield this.picks;
            const helper = new ReplayAttributeHelper_1.ReplayAttributeHelper(yield this.attributeEvents);
            switch (helper.banType) {
                case '1ban': {
                    return this.order1banDraft(bans, picks);
                }
                case '2ban': {
                    return this.order2banDraft(bans, picks);
                }
                case 'Mban': {
                    return this.orderMbanDraft(bans, picks);
                }
            }
        }))();
    }
    orderMbanDraft(bans, picks) {
        const result = [];
        result.push(bans[0]);
        result.push(bans[1]);
        result.push(picks[0]);
        result.push(picks[1]);
        result.push(picks[2]);
        result.push(picks[3]);
        result.push(picks[4]);
        result.push(bans[2]);
        result.push(bans[3]);
        result.push(picks[5]);
        result.push(picks[6]);
        result.push(picks[7]);
        result.push(picks[8]);
        result.push(picks[9]);
        return result;
    }
    order1banDraft(bans, picks) {
        return [...bans, ...picks];
    }
    order2banDraft(bans, picks) {
        return [...bans, ...picks];
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], DraftAnalyser.prototype, "bans", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], DraftAnalyser.prototype, "picks", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], DraftAnalyser.prototype, "draft", null);
DraftAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('DF24FAC3-D273-4CA0-83A3-E8D365F15283'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], DraftAnalyser);
exports.DraftAnalyser = DraftAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRHJhZnRBbmFseXNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkRyYWZ0QW5hbHlzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLGlEQUFzRTtBQUN0RSx5Q0FBc0M7QUFDdEMsMENBR3dCO0FBQ3hCLDZCQUE2QjtBQUM3QixxREFBK0Q7QUFDL0QsNEVBQXlFO0FBQ3pFLHNFQUFtRTtBQWlCbkUsSUFBYSxhQUFhLEdBQTFCLG1CQUEyQixTQUFRLCtDQUFzQjtJQUVyRCxZQUFtQixNQUFjO1FBQzdCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBQ1ksVUFBVTs7O1lBQ25CLE1BQU0sb0JBQWdCLFdBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksK0JBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEQsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUdELElBQVcsSUFBSTtRQUNYLE9BQU8sQ0FBQyxHQUE4QixFQUFFO1lBQ3BDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFaEQsTUFBTSxNQUFNLEdBQUcsSUFBSSw2Q0FBcUIsQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNyRSxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQztZQUNqRCxNQUFNLE1BQU0sR0FBRyxNQUFNO2lCQUNoQixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQywwQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDakMsTUFBTSxDQUFDLENBQUMsQ0FBb0IsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDaEMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixHQUFHLENB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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts":
/*!************************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
var SlotType;
(function (SlotType) {
    SlotType[SlotType["EMPTY"] = 0] = "EMPTY";
    SlotType[SlotType["PLAYER"] = 1] = "PLAYER";
    SlotType[SlotType["OBSERVER"] = 2] = "OBSERVER";
    SlotType[SlotType["AI"] = 3] = "AI";
})(SlotType = exports.SlotType || (exports.SlotType = {}));
let PlayerAnalyser = class PlayerAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    get playerSlotData() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const initData = yield this.initData;
            const details = yield this.details;
            const slotInfo = [];
            const lobbySlots = initData.m_syncLobbyState.m_lobbyState.m_slots;
            const userInit = initData.m_syncLobbyState.m_userInitialData;
            const detailPlayerlist = details.m_playerList;
            for (let i = 0; i < 10; i++) {
                const slot = lobbySlots[i];
                const info = {
                    index: i,
                    m_announcerPack: slot.m_announcerPack,
                    m_banner: slot.m_banner,
                    m_control: slot.m_control,
                    m_hasSilencePenalty: slot.m_hasSilencePenalty,
                    m_hasVoiceSilencePenalty: slot.m_hasVoiceSilencePenalty,
                    m_heroHandle: slot.m_hero,
                    m_mount: slot.m_mount,
                    m_observe: slot.m_observe,
                    m_skin: slot.m_skin,
                    m_spray: slot.m_spray,
                    m_teamId: slot.m_teamId,
                    m_toonHandle: slot.m_toonHandle,
                    m_userId: slot.m_userId,
                    m_voiceLine: slot.m_voiceLine,
                    m_workingSetSlotId: slot.m_workingSetSlotId,
                    m_name: slot.m_userId !== null ? userInit[slot.m_userId].m_name : null
                };
                slotInfo.push(info);
            }
            const slotInfoQ = linq.from(slotInfo);
            for (let i = 0; i < detailPlayerlist.length; i++) {
                const detail = detailPlayerlist[i];
                const slot = slotInfoQ.singleOrDefault(_ => _.m_workingSetSlotId === detail.m_workingSetSlotId);
                if (slot) {
                    slot.m_toon_id = detail.m_toon.m_id;
                    slot.m_programId = detail.m_toon.m_programId;
                    slot.m_realm = detail.m_toon.m_realm;
                    slot.m_region = detail.m_toon.m_region;
                    slot.m_result = detail.m_result;
                    slot.m_hero = detail.m_hero;
                }
            }
            const slotList = slotInfoQ
                .orderBy(_ => _.m_workingSetSlotId)
                .select(_ => {
                let slotType;
                if (_.m_toonHandle && _.m_observe == 1) {
                    slotType = SlotType.OBSERVER;
                }
                else if (_.m_toonHandle) {
                    slotType = SlotType.PLAYER;
                }
                else if (_.m_hero) {
                    slotType = SlotType.AI;
                }
                else {
                    slotType = SlotType.EMPTY;
                }
                const slot = {
                    type: slotType,
                    id: _.m_toon_id,
                    index: _.index,
                    realm: _.m_realm,
                    region: _.m_region,
                    handle: _.m_toonHandle,
                    userId: _.m_userId,
                    won: _.m_result === 1,
                    slot: _.m_workingSetSlotId,
                    name: _.m_name,
                    team: slotType === SlotType.PLAYER || slotType === SlotType.AI ? _.m_teamId : -1,
                    hero: _.m_hero,
                    heroHandle: _.m_heroHandle,
                    skin: _.m_skin,
                    mount: _.m_mount,
                    spray: _.m_spray,
                    announcerPack: _.m_announcerPack,
                    banner: _.m_banner,
                    voiceLine: _.m_voiceLine,
                    hasChatSilence: _.m_hasSilencePenalty,
                    hasVoiceSilence: _.m_hasVoiceSilencePenalty
                };
                return slot;
            })
                .toArray();
            return slotList;
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], PlayerAnalyser.prototype, "playerSlotData", null);
PlayerAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('09E13E2D-581E-4929-AEDA-FE8DA3FF3ACF'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], PlayerAnalyser);
exports.PlayerAnalyser = PlayerAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxheWVyQW5hbHlzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJQbGF5ZXJBbmFseXNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsaURBQXNFO0FBQ3RFLHlDQUFzQztBQUV0Qyw2QkFBNkI7QUFHN0Isc0VBQW1FO0FBRW5FLElBQVksUUFLWDtBQUxELFdBQVksUUFBUTtJQUNoQix5Q0FBSyxDQUFBO0lBQ0wsMkNBQU0sQ0FBQTtJQUNOLCtDQUFRLENBQUE7SUFDUixtQ0FBRSxDQUFBO0FBQ04sQ0FBQyxFQUxXLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBS25CO0FBMERELElBQWEsY0FBYyxHQUEzQixvQkFBNEIsU0FBUSwrQ0FBc0I7SUFFdEQsWUFBbUIsTUFBYztRQUM3QixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUlELElBQVcsY0FBYztRQUNyQixPQUFPLENBQUMsR0FBaUMsRUFBRTtZQUN2QyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDckMsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDO1lBRW5DLE1BQU0sUUFBUSxHQUF5QixFQUFFLENBQUM7WUFHMUMsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUM7WUFHbEUsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDO1lBRzdELE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztZQUU5QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN6QixNQUFNLElBQUksR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRTNCLE1BQU0sSUFBSSxHQUF1QjtvQkFDN0Is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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/ReplayMapAnalyser.ts":
/*!***************************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/ReplayMapAnalyser.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const PlayerAnalyser_1 = __webpack_require__(/*! ./PlayerAnalyser */ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
let ReplayMapAnalyser = class ReplayMapAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.playerAnalyser = new PlayerAnalyser_1.PlayerAnalyser(this.replay);
            yield this.playerAnalyser.initialize();
        });
    }
    get mapName() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.details;
            return details.m_title;
        }))();
    }
    get mapSize() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const init = yield this.initData;
            const trackerQ = yield this.trackerEventsQueriable;
            return trackerQ.where(_ => types_1.isGameStartSStatGameEvent(_)).select((_) => ({
                x: types_1.getSStatValue(_.m_fixedData, 'MapSizeX', true),
                y: types_1.getSStatValue(_.m_fixedData, 'MapSizeY', true)
            })).first();
        }))();
    }
    get mapDescriptor() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return {
                name: yield this.mapName,
                build: this.protocolVersion,
                size: yield this.mapSize
            };
        }))();
    }
    getMinionSpawns(team) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.replay.protocol;
            let q = (yield this.trackerEventsQueriable)
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_controlPlayerId === 11 || e.m_controlPlayerId === 12) && e.m_unitTypeName.endsWith('Minion'));
            if (team === 1) {
                q = q.where(e => e.m_controlPlayerId === 11);
            }
            else if (team === 2) {
                q = q.where(e => e.m_controlPlayerId === 12);
            }
            const result = q.select(e => ({
                tag: protocol.unitTag(e.m_unitTagIndex, e.m_unitTagRecycle),
                unitType: e.m_unitTypeName,
                time: e._gameloop / 16,
                team: e.m_controlPlayerId === 11 ? 1 : 2,
                x: e.m_x,
                y: e.m_y
            })).toArray();
            return result;
        });
    }
    getMercSpawns() {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.replay.protocol;
            let q = (yield this.trackerEventsQueriable)
                .where(e => types_1.isSUnitBornEvent(e)
                && (e.m_unitTypeName.startsWith('King') || e.m_unitTypeName.startsWith('Town') || e.m_unitTypeName.startsWith('Underworld')));
            const result = q.select(e => ({
                tag: protocol.unitTag(e.m_unitTagIndex, e.m_unitTagRecycle),
                unitType: e.m_unitTypeName,
                time: e._gameloop / 16,
                x: e.m_x,
                y: e.m_y
            }));
            return result.toArray();
        });
    }
    getMinionSpawnHeatmap(team) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.replay.protocol;
            let q = (yield this.trackerEventsQueriable)
                .where(e => types_1.isSUnitBornEvent(e));
            if (team === 1) {
                q = q.where(e => e.m_controlPlayerId === 11);
            }
            else if (team === 2) {
                q = q.where(e => e.m_controlPlayerId === 12);
            }
            const result = q.groupBy(i => `${i.m_x},${i.m_y}`)
                .select(g => ({
                value: g.count(),
                x: g.first().m_x,
                y: g.first().m_y
            }));
            return result.toArray();
        });
    }
    genUnitTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._unitTypesByTag) {
                const protocol = yield this.replay.protocol;
                this._unitTypesByTag = {};
                let q = (yield this.trackerEventsQueriable);
                const result = q.where(_ => types_1.isSUnitBornEvent(_))
                    .select(_ => ({
                    id: protocol.unitTag(_.m_unitTagIndex, _.m_unitTagRecycle),
                    type: _.m_unitTypeName,
                    spawnControlPlayerId: _.m_controlPlayerId,
                    spawnX: _.m_x,
                    spawnY: _.m_y,
                    spawnTime: _._gameloop
                }));
                this._unitTypesByTag = result.toObject(_ => _.id, _ => _);
                this._unitTypes = result.toArray();
            }
        });
    }
    getUnitDeaths(filterPredicate) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getUnitDeathsQuery(filterPredicate)).toArray();
        });
    }
    getUnitDeathsQuery(filterPredicate) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.genUnitTypes();
            const players = yield this.playerAnalyser.playerSlotData;
            const protocol = yield this.replay.protocol;
            let q = yield this.trackerEventsQueriable;
            let query = q.where(_ => types_1.isSUnitDiedEvent(_)).join(linq.from(this._unitTypes), (died) => protocol.unitTag(died.m_unitTagIndex, died.m_unitTagRecycle), born => born.id, (died, born) => {
                const killPlayerIdx = died.m_killerPlayerId ? died.m_killerPlayerId - 1 : null;
                const killingUnitId = died.m_killerUnitTagIndex ? protocol.unitTag(died.m_killerUnitTagIndex, died.m_killerUnitTagRecycle) : null;
                let killingPlayer = null;
                let killingTeam = null;
                let killingUnit = null;
                if (killPlayerIdx !== null) {
                    if (killPlayerIdx < 10) {
                        killingPlayer = players[killPlayerIdx];
                        killingTeam = killingPlayer.team;
                    }
                    else if (killPlayerIdx === 10) {
                        killingTeam = 0;
                    }
                    else if (killPlayerIdx === 11) {
                        killingTeam = 1;
                    }
                    else {
                        console.log('UNKNOWN kill index:', killPlayerIdx, died, born.type);
                    }
                }
                else {
                    console.log('NULL kill index:', died, born.type);
                }
                if (killingUnitId != null) {
                    killingUnit = this._unitTypesByTag[killingUnitId];
                }
                const spawnPlayerIdx = born.spawnControlPlayerId ? born.spawnControlPlayerId - 1 : null;
                let spawnPlayer = null;
                let spawnTeam = null;
                if (spawnPlayerIdx !== null) {
                    if (spawnPlayerIdx < 10) {
                        spawnPlayer = players[spawnPlayerIdx];
                        spawnTeam = spawnPlayer.team;
                    }
                    else if (spawnPlayerIdx === 10) {
                        spawnTeam = 0;
                    }
                    else if (spawnPlayerIdx === 11) {
                        spawnTeam = 1;
                    }
                    else {
                        console.log('UNKNOWN spawn control index:', spawnPlayerIdx, died, born.type);
                    }
                }
                return Object.assign({}, born, {
                    killingPlayerId: killPlayerIdx,
                    killingUnitTag: killingUnitId,
                    killingUnitType: killingUnit ? killingUnit.type : null,
                    killingTeam: killingTeam,
                    spawnTeam: spawnTeam,
                    spawnPlayerId: spawnPlayerIdx,
                    deathX: died.m_x,
                    deathY: died.m_y,
                    deathTime: died._gameloop
                });
            });
            if (filterPredicate) {
                query = query.where(filterPredicate);
            }
            return query;
        });
    }
    checkUnitLifeFilter(unit, filter) {
        if (!filter) {
            return true;
        }
        if (filter.killedByPlayers === true && unit.killingPlayerId > 9) {
            return false;
        }
        if (Array.isArray(filter.killedByPlayers) && filter.killedByPlayers.indexOf(unit.killingPlayerId) === -1) {
            return false;
        }
        if (unit.killingUnitType === 'RangedMinion' || unit.killingUnitType === 'FootmanMinion' || unit.killingUnitType === 'WizardMinion') {
            if (filter.killedByMinions === false) {
                return false;
            }
        }
        else {
            if (filter.killedByMinions === true) {
                return false;
            }
        }
        if (filter.killedByTeams !== undefined) {
            if (!Array.isArray(filter.killedByTeams)) {
                filter.killedByTeams = [filter.killedByTeams];
            }
            if (filter.killedByTeams.indexOf(unit.killingTeam) === -1) {
                return false;
            }
        }
        if (filter.isOnTeam !== undefined) {
            if (!Array.isArray(filter.isOnTeam)) {
                filter.isOnTeam = [filter.isOnTeam];
            }
            if (filter.isOnTeam.indexOf(unit.spawnTeam) === -1) {
                return false;
            }
        }
        if (filter.isOwnedByPlayers === true && unit.spawnPlayerId > 9) {
            return false;
        }
        if (Array.isArray(filter.isOwnedByPlayers) && filter.isOwnedByPlayers.indexOf(unit.spawnPlayerId) === -1) {
            return false;
        }
        return true;
    }
    getMinionDeaths(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getUnitDeaths((_) => {
                if (!(_.type === 'RangedMinion' || _.type === 'FootmanMinion' || _.type === 'WizardMinion')) {
                    return false;
                }
                return this.checkUnitLifeFilter(_, filter);
            });
        });
    }
    getGlobeDeaths() {
        return __awaiter(this, void 0, void 0, function* () {
            const trackerQ = yield this.trackerEventsQueriable;
            const q = yield this.getUnitDeathsQuery((_) => _.type === 'RegenGlobe' ||
                _.type === 'RegenGlobeNeutral');
            const globesQ = q.groupBy(_ => {
                if (_.type === 'RegenGlobe') {
                    return JSON.stringify({
                        x: _.deathX,
                        y: _.deathY,
                        time: _.deathTime,
                        control: _.spawnControlPlayerId
                    });
                }
                return JSON.stringify({
                    x: _.spawnX,
                    y: _.spawnY,
                    time: _.spawnTime,
                    control: _.spawnControlPlayerId
                });
            }, _ => _, (key, _) => {
                const spawn = _.first();
                const neutral = _.last();
                const globe = {
                    type: 'globe',
                    x: spawn.spawnX,
                    y: spawn.spawnY,
                    spawnTime: spawn.spawnTime,
                    deathTime: neutral.deathTime,
                    lifeDuration: (neutral.deathTime - spawn.spawnTime) / 16,
                    lifeDurationTicks: (neutral.deathTime - spawn.spawnTime),
                    neutral: _.count() > 1,
                    stolen: neutral.spawnControlPlayerId !== neutral.killingPlayerId,
                    team: neutral.killingPlayerId === 11 ? 0 : 1
                };
                return globe;
            });
            const pickupQ = trackerQ.where(_ => types_1.isSStatGameEvent(_) && _.m_eventName === 'RegenGlobePickedUp')
                .select((_) => ({
                type: 'Pickup',
                deathTime: _._gameloop,
                playerId: types_1.getSStatValue(_.m_intData, 'PlayerID')
            }));
            const merged = linq.from([...globesQ.toArray(), ...pickupQ.toArray()]).orderBy(_ => _.deathTime).toArray();
            return merged;
        });
    }
    getMinionDeathHeatmap(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const minionDeaths = linq.from(yield this.getMinionDeaths(filter));
            const result = minionDeaths.groupBy(_ => `${_.deathX},${_.deathY}`)
                .select(g => ({
                value: g.count(),
                x: g.first().deathX,
                y: g.first().deathY
            }));
            return result.toArray();
        });
    }
    getPointsOfInterest() {
        return __awaiter(this, void 0, void 0, function* () {
            const trackerQ = yield this.trackerEventsQueriable;
            let cores = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName === 'KingsCore')
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1,
                type: 'Core'
            }));
            let wells = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.startsWith('TownMoonwell'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1,
                type: 'MoonWell'
            }));
            let towers = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.startsWith('TownCannonTower'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1,
                type: 'Tower'
            }));
            let towns = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.startsWith('TownTownHall'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1,
                type: 'Town'
            }));
            let watchTowers = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.endsWith('WatchTower'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 2,
                type: 'WatchTower'
            }));
            let camps = trackerQ
                .where(e => types_1.isSStatGameEvent(e) && e.m_eventName === 'JungleCampInit')
                .select((_) => ({
                x: types_1.getSStatValue(_.m_fixedData, 'PositionX', true),
                y: types_1.getSStatValue(_.m_fixedData, 'PositionY', true),
                team: 2,
                type: 'JungleCamp'
            }));
            const mapSpecificPOIs = yield this.getMapSpecificPOIs();
            return cores.merge(wells, towers, towns, watchTowers, camps, ...mapSpecificPOIs).toArray();
        });
    }
    getMapSpecificPOIs() {
        return __awaiter(this, void 0, void 0, function* () {
            const mapName = yield this.mapName;
            switch (mapName) {
                case 'Battlefield of Eternity':
                    return yield this.getBattlefiledOfEternityPOIs();
                case 'Blackheart\'s Bay':
                    return yield this.getBlackheartsBayPOIs();
                case 'Cursed Hollow':
                    return yield this.getCursedHollowPOIs();
                case 'Haunted Mines':
                    return yield this.getHauntedMinesPOIs();
            }
            return [];
        });
    }
    getBattlefiledOfEternityPOIs() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const trackerQ = yield this.trackerEventsQueriable;
            let immortals = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'BossDuelBossHeaven' || e.m_unitTypeName === 'BossDuelBossHell'))
                .distinct((_) => _.m_x * 1000 + _.m_y)
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 3,
                type: 'BoE_Immortal'
            }));
            result.push(immortals);
            return result;
        });
    }
    getBlackheartsBayPOIs() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const trackerQ = yield this.trackerEventsQueriable;
            let chests = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'DocksTreasureChest'))
                .distinct((_) => _.m_x * 1000 + _.m_y)
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 3,
                type: 'BHB_TreasureChest'
            }));
            result.push(chests);
            let turnin = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'GhostShipBeacon'))
                .distinct((_) => _.m_x * 1000 + _.m_y)
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 3,
                type: 'BHB_Blackheart'
            }));
            result.push(turnin);
            return result;
        });
    }
    getCursedHollowPOIs() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const trackerQ = yield this.trackerEventsQueriable;
            let trib = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'RavenLordTribute'))
                .distinct((_) => _.m_x * 1000 + _.m_y)
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 3,
                type: 'CH_Tribute'
            }));
            result.push(trib);
            return result;
        });
    }
    getHauntedMinesPOIs() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const trackerQ = yield this.trackerEventsQueriable;
            let mineEntrances = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'HoleLadderDown' || e.m_unitTypeName === 'HoleLadderUp'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 2,
                type: 'HM_MineEntrance'
            }));
            result.push(mineEntrances);
            let underworldBoss = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'UnderworldBoss'))
                .distinct((_) => _.m_unitTypeName)
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: 3,
                type: 'HM_UnderworldBoss'
            }));
            result.push(underworldBoss);
            let underworldBossSummon = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_unitTypeName === 'UnderworldSummonedBoss'))
                .distinct((_) => _.m_x * 1000 + _.m_y)
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1,
                type: 'HM_UnderworldBoss'
            }));
            result.push(underworldBossSummon);
            return result;
        });
    }
    getMajorLocations() {
        return __awaiter(this, void 0, void 0, function* () {
            const trackerQ = yield this.trackerEventsQueriable;
            let cores = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName === 'KingsCore')
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1
            })).toArray();
            let wells = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.startsWith('TownMoonwell'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1
            })).toArray();
            let towers = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.startsWith('TownCannonTower'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1
            })).toArray();
            let towns = trackerQ
                .where(e => types_1.isSUnitBornEvent(e) && e.m_unitTypeName.startsWith('TownTownHall'))
                .select((_) => ({
                x: _.m_x,
                y: _.m_y,
                team: _.m_controlPlayerId === 11 ? 0 : 1
            })).toArray();
            return {
                cores,
                wells,
                towers,
                towns
            };
        });
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ReplayMapAnalyser.prototype, "mapName", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ReplayMapAnalyser.prototype, "mapSize", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ReplayMapAnalyser.prototype, "mapDescriptor", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMinionSpawns", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMercSpawns", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMinionSpawnHeatmap", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMinionDeaths", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getGlobeDeaths", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMinionDeathHeatmap", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getPointsOfInterest", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMajorLocations", null);
ReplayMapAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('D90DC9EF-B016-47F1-984B-B9BA099869E6'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], ReplayMapAnalyser);
exports.ReplayMapAnalyser = ReplayMapAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5TWFwQW5hbHlzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJSZXBsYXlNYXBBbmFseXNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUNBQXNDO0FBQ3RDLDBDQVl3QjtBQUN4Qiw2QkFBNkI7QUFFN0IsaURBQXNFO0FBQ3RFLHFEQUErRDtBQUUvRCxzRUFBbUU7QUE0Q25FLElBQWEsaUJBQWlCLEdBQTlCLHVCQUErQixTQUFRLCtDQUFzQjtJQUt6RCxZQUFtQixNQUFjO1FBQzdCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRVksVUFBVTs7O1lBQ25CLE1BQU0sb0JBQWdCLFdBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksK0JBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEQsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUdELElBQVcsT0FBTztRQUNkLE9BQU8sQ0FBQyxHQUEwQixFQUFFO1lBQ2hDLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUNuQyxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDM0IsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDO0lBQ1QsQ0FBQztJQUlELElBQVcsT0FBTztRQUNkLE9BQU8sQ0FBQyxHQUEwQixFQUFFO1lBQ2hDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNqQyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxzQkFBc0IsQ0FBQztZQUNuRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxpQ0FBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQWtCLEVBQUUsRUFBRSxDQUFDLENB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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/ScoreAnalyser.ts":
/*!***********************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/ScoreAnalyser.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const BasicReplayAnalyser_1 = __webpack_require__(/*! ./BasicReplayAnalyser */ "./src/lib/replay/analyzers/builtin/BasicReplayAnalyser.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
const decorators_2 = __webpack_require__(/*! ../decorators */ "./src/lib/replay/analyzers/decorators.ts");
let ScoreAnalyser = class ScoreAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.basicReplayAnalyser = new BasicReplayAnalyser_1.BasicReplayAnalyser(this.replay);
            yield this.basicReplayAnalyser.initialize();
        });
    }
    get scoreScreenData() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const playerScores = yield this.playerScoresSimple;
            const playerScoresQ = linq.from(playerScores);
            const team1Kills = playerScoresQ.where(_ => _.team === 1).sum(_ => _.stats.Deaths);
            const team2Kills = playerScoresQ.where(_ => _.team === 0).sum(_ => _.stats.Deaths);
            const team1Level = playerScoresQ.first(_ => _.team === 0).stats.TeamLevel;
            const team2Level = playerScoresQ.first(_ => _.team === 1).stats.TeamLevel;
            const winningTeam = playerScoresQ.first(_ => _.team === 0).won ? 0 : 1;
            const scoreData = {
                winningTeam,
                team1Kills,
                team2Kills,
                team1Level,
                team2Level,
                playerScores
            };
            return scoreData;
        }))();
    }
    get playerScoresSimple() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const trackerQueriable = yield this.trackerEventsQueriable;
            const players = yield this.basicReplayAnalyser.playerList;
            const playersQ = linq.from(players);
            const results = trackerQueriable.where(e => types_1.isSScoreResultEvent(e)).last();
            const scoreStats = [
                "Takedowns",
                "Deaths",
                "SoloKill",
                "Assists",
                "ExperienceContribution",
                "Healing",
                "SiegeDamage",
                "HeroDamage",
                "DamageTaken",
                "TeamLevel"
            ];
            const stats = linq.from(results.m_instanceList)
                .where(e => scoreStats.indexOf(e.m_name) !== -1)
                .toArray();
            const awards = linq.from(results.m_instanceList)
                .where(e => e.m_name.startsWith('EndOfMatchAward'))
                .toArray();
            const playerScores = playersQ.select(_ => ({
                slot: _.slot,
                name: _.name,
                team: _.team,
                hero: _.hero,
                won: _.won,
                hasChatSilence: _.hasChatSilence,
                hasVoiceSilence: _.hasVoiceSilence,
                stats: {},
                awards: []
            })).toArray();
            const playerScoresQ = linq.from(playerScores);
            for (let i = 0; i < stats.length; i++) {
                const stat = stats[i];
                const statName = stat.m_name;
                const statQ = linq.from(stat.m_values)
                    .select((_, i) => ({
                    slot: i, value: _.length ? _[0].m_value : undefined
                }))
                    .where(_ => _.value != undefined)
                    .join(playerScoresQ, (s) => s.slot, p => p.slot, (s, p) => {
                    p.stats[statName] = s.value;
                    return p;
                }).toArray();
            }
            for (let i = 0; i < awards.length; i++) {
                const award = awards[i];
                const awardName = award.m_name.substring(0, award.m_name.length - 7).substring(15);
                const statQ = linq.from(award.m_values)
                    .select((_, i) => ({
                    slot: i, value: _.length ? _[0].m_value : undefined
                }))
                    .where(_ => _.value != undefined)
                    .join(playerScoresQ, (s) => s.slot, p => p.slot, (s, p) => {
                    if (s.value === 1) {
                        p.awards.push(awardName);
                    }
                    return p;
                }).toArray();
            }
            const tmp = yield this.playerScoresFull;
            console.log('playerScoresFull', tmp);
            return playerScores;
        }))();
    }
    get playerScoresFull() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const trackerQueriable = yield this.trackerEventsQueriable;
            const players = yield this.basicReplayAnalyser.playerList;
            const stats = trackerQueriable.where(_ => types_1.isSScoreResultEvent(_)).last();
            const playerStats = [];
            for (let i = 0; i < players.length; i++) {
                const player = players[i];
                const playerScore = {
                    name: player.name,
                    hero: player.hero,
                    team: player.team,
                    won: player.won,
                    hasChatSilence: player.hasChatSilence,
                    hasVoiceSilence: player.hasVoiceSilence,
                    stats: {}
                };
                for (let j = 0; j < stats.m_instanceList.length; j++) {
                    const stat = stats.m_instanceList[j];
                    if (!stat.m_name.endsWith('Boolean') &&
                        !stat.m_name.endsWith('Talent') &&
                        !stat.m_name.startsWith('Plays') &&
                        !stat.m_name.startsWith('Wins') &&
                        !stat.m_name.startsWith('TeamWins') &&
                        !stat.m_name.endsWith('Level') &&
                        stat.m_name !== 'Role' &&
                        stat.m_name !== 'GameScore') {
                        const pStats = stat.m_values[player.slot];
                        if (Array.isArray(pStats) && pStats.length) {
                            const pStat = pStats[0];
                            playerScore.stats[stat.m_name] = pStat.m_value;
                        }
                    }
                }
                playerStats.push(playerScore);
            }
            const playerStatsQ = linq.from(playerStats);
            const teamTakedowns = [
                playerStatsQ.where(_ => _.team === 1).sum(_ => _.stats.Deaths),
                playerStatsQ.where(_ => _.team === 0).sum(_ => _.stats.Deaths)
            ];
            const teamDamageTaken = [
                playerStatsQ.where(_ => _.team === 0).sum(_ => _.stats.DamageTaken),
                playerStatsQ.where(_ => _.team === 1).sum(_ => _.stats.DamageTaken),
            ];
            const teamHeroDamageAgainst = [
                playerStatsQ.where(_ => _.team === 1).sum(_ => _.stats.HeroDamage),
                playerStatsQ.where(_ => _.team === 0).sum(_ => _.stats.HeroDamage),
            ];
            for (let i = 0; i < playerStats.length; i++) {
                const player = playerStats[i];
                const pStats = player.stats;
                pStats['KillParticipation'] = pStats.Takedowns / teamTakedowns[player.team];
                pStats['AverageDamageTakenPerLife'] = pStats.DamageTaken / (pStats.Deaths + 1);
                pStats['KDARatio'] = pStats.Takedowns / (pStats.Deaths + 1);
                pStats['KDRatio'] = pStats.SoloKill / (pStats.Deaths + 1);
                pStats['ADRatio'] = pStats.Assists / (pStats.Deaths + 1);
                pStats['PercentDamageHealed'] = pStats.Healing / (teamDamageTaken[player.team] || 1);
                if (this.versionMatches('<63507')) {
                    pStats['PercentDamageHealed'] = pStats.Healing / (teamHeroDamageAgainst[player.team] || 1);
                }
            }
            return playerStats;
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    decorators_2.RequiredReplayVersion(40336, 'Scorescreen Data not supported by this version of replay'),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ScoreAnalyser.prototype, "scoreScreenData", null);
__decorate([
    decorators_1.RunOnWorker(),
    decorators_2.RequiredReplayVersion(40336, 'Player score data not supported by this version of replay'),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ScoreAnalyser.prototype, "playerScoresSimple", null);
__decorate([
    decorators_1.RunOnWorker(),
    decorators_2.RequiredReplayVersion(40336, 'Player score data not supported by this version of replay'),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ScoreAnalyser.prototype, "playerScoresFull", null);
ScoreAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('0B9EBC25-CB1F-47CC-B287-D806D58E2C55'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], ScoreAnalyser);
exports.ScoreAnalyser = ScoreAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NvcmVBbmFseXNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlNjb3JlQW5hbHlzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLGlEQUFzRTtBQUN0RSx5Q0FBc0M7QUFDdEMsMENBQThGO0FBQzlGLDZCQUE2QjtBQUM3QiwrREFBMkQ7QUFDM0Qsc0VBQW1FO0FBQ25FLDhDQUFzRDtBQXlGdEQsSUFBYSxhQUFhLEdBQTFCLG1CQUEyQixTQUFRLCtDQUFzQjtJQUdyRCxZQUFtQixNQUFjO1FBQzdCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRVksVUFBVTs7O1lBQ25CLE1BQU0sb0JBQWdCLFdBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSx5Q0FBbUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDaEUsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDaEQsQ0FBQztLQUFBO0lBSUQsSUFBVyxlQUFlO1FBQ3RCLE9BQU8sQ0FBQyxHQUFvQyxFQUFFO1lBQzFDLE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDO1lBRW5ELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDOUMsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNuRixNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFH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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/TalentAnalyser.ts":
/*!************************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/TalentAnalyser.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const BasicReplayAnalyser_1 = __webpack_require__(/*! ./BasicReplayAnalyser */ "./src/lib/replay/analyzers/builtin/BasicReplayAnalyser.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
const decorators_2 = __webpack_require__(/*! ../decorators */ "./src/lib/replay/analyzers/decorators.ts");
let TalentAnalyser = class TalentAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.basicReplayAnalyser = new BasicReplayAnalyser_1.BasicReplayAnalyser(this.replay);
            yield this.basicReplayAnalyser.initialize();
        });
    }
    get talents() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const trackerQueriable = yield this.trackerEventsQueriable;
            const playerList = yield this.basicReplayAnalyser.playerList;
            const players = linq.from(playerList);
            const heroData = linq.from(yield this.replay.heroData);
            const tickRate = yield this.tickRate;
            const talentQuery = trackerQueriable
                .where(_ => types_1.isSStatGameEvent(_) && _.m_eventName === 'TalentChosen')
                .groupBy((_) => types_1.getSStatValue(_.m_intData, 'PlayerID') - 1, _ => _, (key, event) => ({
                index: key,
                talents: event.select((_) => {
                    const player = playerList[key];
                    const talentName = types_1.getSStatValue(_.m_stringData, 'PurchaseName');
                    const hero = heroData.first(_ => _.name === player.hero);
                    if (!hero || !hero.talents || !hero.talents.length) {
                        return {
                            name: talentName,
                            time: _._gameloop / tickRate
                        };
                    }
                    const talentQ = linq.from(hero.talents);
                    return Object.assign({}, talentQ.first(_ => _.name === talentName), { time: _._gameloop / tickRate });
                }).toArray()
            }));
            return players.join(talentQuery, p => p.index, e => e.index, (p, t) => ({
                playerName: p.name,
                team: p.team,
                hero: p.hero,
                talents: t.talents
            })).toArray();
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    decorators_2.RequiredReplayVersion(40336, 'Player talent data not supported by this version of replay'),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], TalentAnalyser.prototype, "talents", null);
TalentAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('959FCF54-0284-452B-85F9-81439FB7F498'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], TalentAnalyser);
exports.TalentAnalyser = TalentAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFsZW50QW5hbHlzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJUYWxlbnRBbmFseXNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsaURBQXNFO0FBQ3RFLHlDQUFzQztBQUN0QywwQ0FBb0g7QUFDcEgsNkJBQTZCO0FBQzdCLCtEQUEyRDtBQUUzRCxzRUFBbUU7QUFDbkUsOENBQXNEO0FBZXRELElBQWEsY0FBYyxHQUEzQixvQkFBNEIsU0FBUSwrQ0FBc0I7SUFHdEQsWUFBbUIsTUFBYztRQUM3QixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVZLFVBQVU7OztZQUNuQixNQUFNLG9CQUFnQixXQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUkseUNBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2hFLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2hELENBQUM7S0FBQTtJQUlELElBQVcsT0FBTztRQUNkLE9BQU8sQ0FBQyxHQUEwQyxFQUFFO1lBQ2hELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsc0JBQXNCLENBQUM7WUFDM0QsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDO1lBQzdELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdkQsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3JDLE1BQU0sV0FBVyxHQUFHLGdCQUFnQjtpQkFDL0IsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsd0JBQWdCLENB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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/XPAnalyser.ts":
/*!********************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/XPAnalyser.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/lib/replay/decorators.ts");
const Replay_1 = __webpack_require__(/*! ../../Replay */ "./src/lib/replay/Replay.ts");
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
const PlayerAnalyser_1 = __webpack_require__(/*! ./PlayerAnalyser */ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts");
const AbstractReplayAnalyser_1 = __webpack_require__(/*! ../AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts");
const decorators_2 = __webpack_require__(/*! ../decorators */ "./src/lib/replay/analyzers/decorators.ts");
let XPAnalyser = class XPAnalyser extends AbstractReplayAnalyser_1.AbstractReplayAnalyser {
    constructor(replay) {
        super(replay);
    }
    initialize() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("initialize").call(this);
            this.playerAnalyser = new PlayerAnalyser_1.PlayerAnalyser(this.replay);
            yield this.playerAnalyser.initialize();
        });
    }
    getStat(from, key) {
        if (from) {
            var r = linq.from(from).singleOrDefault(_ => _.m_key === key);
            if (r) {
                return r.m_value;
            }
        }
        return undefined;
    }
    get periodicXP() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const trackableQ = yield this.trackerEventsQueriable;
            const players = yield this.playerAnalyser.playerSlotData;
            const protocol = yield this.replay.protocol;
            const tickRate = yield this.tickRate;
            const result = trackableQ
                .where(_ => types_1.isPeriodicXPBreakdownSStatGameEvent(_))
                .select((_) => ({
                team: types_1.getSStatValue(_.m_intData, 'Team') - 1,
                teamLevel: types_1.getSStatValue(_.m_intData, 'TeamLevel'),
                time: types_1.getSStatValue(_.m_fixedData, 'GameTime', true),
                previousTime: types_1.getSStatValue(_.m_fixedData, 'PreviousGameTime', true),
                minionXP: types_1.getSStatValue(_.m_fixedData, 'MinionXP', true),
                creepXP: types_1.getSStatValue(_.m_fixedData, 'CreepXP', true),
                structureXP: types_1.getSStatValue(_.m_fixedData, 'StructureXP', true),
                heroXP: types_1.getSStatValue(_.m_fixedData, 'HeroXP', true),
                trickleXP: types_1.getSStatValue(_.m_fixedData, 'TrickleXP', true)
            }))
                .toArray();
            const lvlResult = trackableQ.where(e => types_1.isSScoreResultEvent(e)).last();
            const levels = linq.from(lvlResult.m_instanceList)
                .where(l => l.m_name === 'Level')
                .selectMany(_ => _.m_values)
                .select((l, i) => ({
                i: i,
                l: l[0] ? l[0].m_value : undefined
            }))
                .where(r => r.i === 0 || r.i === 5)
                .select(_ => _.l)
                .toArray();
            const coreDeath = trackableQ.where(_ => types_1.isSUnitBornEvent(_) && _.m_unitTypeName === 'KingsCore')
                .join(trackableQ.where(_ => types_1.isSUnitDiedEvent(_)), (b) => protocol.unitTag(b.m_unitTagIndex, b.m_unitTagRecycle), (d) => protocol.unitTag(d.m_unitTagIndex, d.m_unitTagRecycle), (b, d) => d._gameloop).first();
            const endOfGameResults = trackableQ
                .where(_ => types_1.isEndOfGameXPBreakdownSStatGameEvent(_))
                .select((_) => {
                const playerIndex = types_1.getSStatValue(_.m_intData, 'PlayerID') - 1;
                const player = players[playerIndex];
                return {
                    team: player.team,
                    teamLevel: player.team == 0 ? levels[0] : levels[1],
                    time: coreDeath / tickRate,
                    previousTime: result[result.length - 1].time,
                    userId: types_1.getSStatValue(_.m_intData, 'PlayerID'),
                    minionXP: types_1.getSStatValue(_.m_fixedData, 'MinionXP', true),
                    creepXP: types_1.getSStatValue(_.m_fixedData, 'CreepXP', true),
                    structureXP: types_1.getSStatValue(_.m_fixedData, 'StructureXP', true),
                    heroXP: types_1.getSStatValue(_.m_fixedData, 'HeroXP', true),
                    trickleXP: types_1.getSStatValue(_.m_fixedData, 'TrickleXP', true),
                };
            });
            result.push(endOfGameResults.first(_ => _.team === 0));
            result.push(endOfGameResults.first(_ => _.team === 1));
            return result;
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    decorators_2.RequiredReplayVersion(40336, 'Player xp data not supported by this version of replay'),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], XPAnalyser.prototype, "periodicXP", null);
XPAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('CDDD28FF-DAB2-4710-A28F-8D48DD6DE84F'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], XPAnalyser);
exports.XPAnalyser = XPAnalyser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWFBBbmFseXNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlhQQW5hbHlzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLGlEQUFzRTtBQUN0RSx5Q0FBc0M7QUFDdEMsMENBT3dCO0FBQ3hCLDZCQUE2QjtBQUM3QixxREFBK0Q7QUFFL0Qsc0VBQW1FO0FBQ25FLDhDQUFzRDtBQWlCdEQsSUFBYSxVQUFVLEdBQXZCLGdCQUF3QixTQUFRLCtDQUFzQjtJQUVsRCxZQUFtQixNQUFjO1FBQzdCLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBQ1ksVUFBVTs7O1lBQ25CLE1BQU0sb0JBQWdCLFdBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksK0JBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEQsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUVPLE9BQU8sQ0FBSSxJQUE4QixFQUFFLEdBQVc7UUFDMUQsSUFBSSxJQUFJLEVBQUU7WUFDTixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDOUQsSUFBSSxDQUFDLEVBQUU7Z0JBQ0gsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDO2FBQ3BCO1NBQ0o7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDO0lBSUQsSUFBVyxVQUFVO1FBQ2pCLE9BQU8sQ0FBQyxHQUFpQyxFQUFFO1lBQ3ZDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDO1lBQ3JELE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUM7WUFDekQs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

/***/ }),

/***/ "./src/lib/replay/analyzers/builtin/index.ts":
/*!***************************************************!*\
  !*** ./src/lib/replay/analyzers/builtin/index.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./BasicReplayAnalyser */ "./src/lib/replay/analyzers/builtin/BasicReplayAnalyser.ts"));
__export(__webpack_require__(/*! ./PlayerAnalyser */ "./src/lib/replay/analyzers/builtin/PlayerAnalyser.ts"));
__export(__webpack_require__(/*! ./ReplayMapAnalyser */ "./src/lib/replay/analyzers/builtin/ReplayMapAnalyser.ts"));
__export(__webpack_require__(/*! ./ScoreAnalyser */ "./src/lib/replay/analyzers/builtin/ScoreAnalyser.ts"));
__export(__webpack_require__(/*! ./DraftAnalyser */ "./src/lib/replay/analyzers/builtin/DraftAnalyser.ts"));
__export(__webpack_require__(/*! ./ChatAnalyser */ "./src/lib/replay/analyzers/builtin/ChatAnalyser.ts"));
__export(__webpack_require__(/*! ./XPAnalyser */ "./src/lib/replay/analyzers/builtin/XPAnalyser.ts"));
__export(__webpack_require__(/*! ./TalentAnalyser */ "./src/lib/replay/analyzers/builtin/TalentAnalyser.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUFzQztBQUN0QyxzQ0FBaUM7QUFDakMseUNBQW9DO0FBQ3BDLHFDQUFnQztBQUNoQyxxQ0FBZ0M7QUFDaEMsb0NBQStCO0FBQy9CLGtDQUE2QjtBQUM3QixzQ0FBaUMifQ==

/***/ }),

/***/ "./src/lib/replay/analyzers/decorators.ts":
/*!************************************************!*\
  !*** ./src/lib/replay/analyzers/decorators.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__(/*! ../decorators */ "./src/lib/replay/decorators.ts");
const errors_1 = __webpack_require__(/*! ../errors */ "./src/lib/replay/errors/index.ts");
function RequiredReplayVersion(version, customMessage) {
    return (target, propertyKey, descriptor) => {
        if (!decorators_1.isRunningInWorker()) {
            return;
        }
        const reqVer = typeof version === 'number' ? '>=' + version : version;
        if (descriptor.value) {
            const oFn = descriptor.value;
            const checkFn = function (...args) {
                if (!this.versionMatches(reqVer)) {
                    throw new errors_1.ReplayVersionOutOfRangeError(customMessage || 'Method not supported by this version of replay');
                }
                return oFn.apply(this, args);
            };
            return {
                value: checkFn
            };
        }
        else if (descriptor.get) {
            const oFn = descriptor.get;
            const checkFn = function () {
                if (!this.versionMatches(reqVer)) {
                    throw new errors_1.ReplayVersionOutOfRangeError(customMessage || 'Property not supported by this version of replay');
                }
                return oFn.apply(this);
            };
            return {
                get: checkFn
            };
        }
    };
}
exports.RequiredReplayVersion = RequiredReplayVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlY29yYXRvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSw4Q0FBa0Q7QUFFbEQsc0NBQXlEO0FBRXpELCtCQUFzQyxPQUF3QixFQUFFLGFBQXNCO0lBQ2xGLE9BQU8sQ0FBSSxNQUFjLEVBQUUsV0FBNEIsRUFBRSxVQUFzQyxFQUFxQyxFQUFFO1FBQ2xJLElBQUksQ0FBQyw4QkFBaUIsRUFBRSxFQUFFO1lBQ3RCLE9BQU87U0FDVjtRQUNELE1BQU0sTUFBTSxHQUFXLE9BQU8sT0FBTyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1FBQzlFLElBQUksVUFBVSxDQUFDLEtBQUssRUFBRTtZQUNsQixNQUFNLEdBQUcsR0FBaUIsVUFBVSxDQUFDLEtBQUssQ0FBQztZQUMzQyxNQUFNLE9BQU8sR0FBRyxVQUFpQyxHQUFHLElBQVc7Z0JBQzNELElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO29CQUM5QixNQUFNLElBQUkscUNBQTRCLENBQUMsYUFBYSxJQUFJLGdEQUFnRCxDQUFDLENBQUM7aUJBQzdHO2dCQUNELE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDakMsQ0FBQyxDQUFDO1lBQ0YsT0FBTztnQkFDSCxLQUFLLEVBQU8sT0FBTzthQUN0QixDQUFBO1NBQ0o7YUFBSyxJQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUM7WUFDcEIsTUFBTSxHQUFHLEdBQWlCLFVBQVUsQ0FBQyxHQUFHLENBQUM7WUFDekMsTUFBTSxPQUFPLEdBQUc7Z0JBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQzlCLE1BQU0sSUFBSSxxQ0FBNEIsQ0FBQyxhQUFhLElBQUksa0RBQWtELENBQUMsQ0FBQztpQkFDL0c7Z0JBQ0QsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNCLENBQUMsQ0FBQztZQUNGLE9BQU87Z0JBQ0gsR0FBRyxFQUFFLE9BQU87YUFDZixDQUFBO1NBQ0o7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBOUJELHNEQThCQyJ9

/***/ }),

/***/ "./src/lib/replay/analyzers/index.ts":
/*!*******************************************!*\
  !*** ./src/lib/replay/analyzers/index.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./types */ "./src/lib/replay/analyzers/types/index.ts"));
__export(__webpack_require__(/*! ./AbstractReplayAnalyser */ "./src/lib/replay/analyzers/AbstractReplayAnalyser.ts"));
__export(__webpack_require__(/*! ./builtin */ "./src/lib/replay/analyzers/builtin/index.ts"));
__export(__webpack_require__(/*! ./decorators */ "./src/lib/replay/analyzers/decorators.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDZCQUF3QjtBQUV4Qiw4Q0FBeUM7QUFDekMsK0JBQTBCO0FBQzFCLGtDQUE2QiJ9

/***/ }),

/***/ "./src/lib/replay/analyzers/types/GameType.ts":
/*!****************************************************!*\
  !*** ./src/lib/replay/analyzers/types/GameType.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GameType;
(function (GameType) {
    GameType[GameType["UNKNOWN"] = 0] = "UNKNOWN";
    GameType[GameType["FLAG_SOLO_QUEUE"] = 1] = "FLAG_SOLO_QUEUE";
    GameType[GameType["FLAG_COOP"] = 2] = "FLAG_COOP";
    GameType[GameType["FLAG_PVP"] = 4] = "FLAG_PVP";
    GameType[GameType["FLAG_DRAFT"] = 8] = "FLAG_DRAFT";
    GameType[GameType["FLAG_RANKED"] = 16] = "FLAG_RANKED";
    GameType[GameType["MODE_PRACTICE"] = 32] = "MODE_PRACTICE";
    GameType[GameType["MODE_AI"] = 64] = "MODE_AI";
    GameType[GameType["MODE_BRAWL"] = 128] = "MODE_BRAWL";
    GameType[GameType["MODE_QM"] = 256] = "MODE_QM";
    GameType[GameType["MODE_UR"] = 512] = "MODE_UR";
    GameType[GameType["MODE_HL"] = 1024] = "MODE_HL";
    GameType[GameType["MODE_TL"] = 2048] = "MODE_TL";
    GameType[GameType["MODE_CUSTOM"] = 4096] = "MODE_CUSTOM";
    GameType[GameType["PRACTICE"] = 33] = "PRACTICE";
    GameType[GameType["SOLO_AI"] = 65] = "SOLO_AI";
    GameType[GameType["COOP_AI"] = 66] = "COOP_AI";
    GameType[GameType["CUSTOM"] = 4100] = "CUSTOM";
    GameType[GameType["CUSTOM_DRAFT"] = 4108] = "CUSTOM_DRAFT";
    GameType[GameType["BRAWL"] = 132] = "BRAWL";
    GameType[GameType["QUICK_MATCH"] = 260] = "QUICK_MATCH";
    GameType[GameType["UNRANKED_DRAFT"] = 524] = "UNRANKED_DRAFT";
    GameType[GameType["HERO_LEAGUE"] = 1053] = "HERO_LEAGUE";
    GameType[GameType["TEAM_LEAGUE"] = 2076] = "TEAM_LEAGUE";
})(GameType = exports.GameType || (exports.GameType = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FtZVR5cGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJHYW1lVHlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQVksUUEwQlg7QUExQkQsV0FBWSxRQUFRO0lBQ2hCLDZDQUFXLENBQUE7SUFDWCw2REFBbUIsQ0FBQTtJQUNuQixpREFBa0IsQ0FBQTtJQUNsQiwrQ0FBaUIsQ0FBQTtJQUNqQixtREFBbUIsQ0FBQTtJQUNuQixzREFBb0IsQ0FBQTtJQUNwQiwwREFBc0IsQ0FBQTtJQUN0Qiw4Q0FBZ0IsQ0FBQTtJQUNoQixxREFBbUIsQ0FBQTtJQUNuQiwrQ0FBZ0IsQ0FBQTtJQUNoQiwrQ0FBZ0IsQ0FBQTtJQUNoQixnREFBaUIsQ0FBQTtJQUNqQixnREFBaUIsQ0FBQTtJQUNqQix3REFBcUIsQ0FBQTtJQUVyQixnREFBMEMsQ0FBQTtJQUMxQyw4Q0FBbUMsQ0FBQTtJQUNuQyw4Q0FBNkIsQ0FBQTtJQUM3Qiw4Q0FBK0IsQ0FBQTtJQUMvQiwwREFBa0QsQ0FBQTtJQUNsRCwyQ0FBNkIsQ0FBQTtJQUM3Qix1REFBZ0MsQ0FBQTtJQUNoQyw2REFBZ0QsQ0FBQTtJQUNoRCx3REFBNkUsQ0FBQTtJQUM3RSx3REFBMkQsQ0FBQTtBQUMvRCxDQUFDLEVBMUJXLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBMEJuQiJ9

/***/ }),

/***/ "./src/lib/replay/analyzers/types/index.ts":
/*!*************************************************!*\
  !*** ./src/lib/replay/analyzers/types/index.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./GameType */ "./src/lib/replay/analyzers/types/GameType.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdDQUEyQiJ9

/***/ }),

/***/ "./src/lib/replay/decorators.ts":
/*!**************************************!*\
  !*** ./src/lib/replay/decorators.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
const WorkerContextRegistry_1 = __webpack_require__(/*! ./proxy/context/WorkerContextRegistry */ "./src/lib/replay/proxy/context/WorkerContextRegistry.ts");
const ReplayContextCaller_1 = __webpack_require__(/*! ./proxy/ReplayContextCaller */ "./src/lib/replay/proxy/ReplayContextCaller.ts");
const ReplayAnalyserContextCaller_1 = __webpack_require__(/*! ./proxy/ReplayAnalyserContextCaller */ "./src/lib/replay/proxy/ReplayAnalyserContextCaller.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/lib/replay/errors/index.ts");
function isRunningInWorker() {
    return typeof importScripts === 'function' && navigator.constructor.name === 'WorkerNavigator';
}
exports.isRunningInWorker = isRunningInWorker;
function getPropertyNames(type) {
    const props = new Set();
    let proto = type.prototype;
    while (proto && proto.constructor !== Object) {
        Object.getOwnPropertyNames(proto).forEach(n => {
            props.add(n);
        });
        proto = Object.getPrototypeOf(proto);
    }
    return props;
}
function buildProxyObject(callerType, proxiedType, ctorArgs) {
    const callerInst = new callerType(...ctorArgs);
    const callerProps = getPropertyNames(callerType);
    let proto = proxiedType.prototype;
    while (proto && proto.constructor !== Object) {
        const props = Object.getOwnPropertyNames(proto);
        for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            if (!callerProps.has(prop)) {
                const desc = Object.getOwnPropertyDescriptor(proto, prop);
                Object.defineProperty(callerInst, prop, desc);
                callerProps.add(prop);
            }
        }
        proto = Object.getPrototypeOf(proto);
    }
    return callerInst;
}
function WorkerContextCaller(guid, proxyType) {
    return (target) => {
        if (isRunningInWorker()) {
            Reflect.defineMetadata('workerContext:typeId', guid, target);
            WorkerContextRegistry_1.WorkerContextRegistry.registerContextCaller(target);
            return;
        }
        const original = target;
        const f = function (...args) {
            const self = buildProxyObject(proxyType, original, args);
            Reflect.defineMetadata('workerContext:typeId', guid, self.constructor);
            WorkerContextRegistry_1.WorkerContextRegistry.registerContextCaller(self.constructor);
            return self;
        };
        f.prototype = original.prototype;
        return f;
    };
}
exports.WorkerContextCaller = WorkerContextCaller;
function ReplayWorkerContext(guid) {
    return WorkerContextCaller(guid, ReplayContextCaller_1.ReplayContextCaller);
}
exports.ReplayWorkerContext = ReplayWorkerContext;
function ReplayAnalyserContext(guid) {
    return WorkerContextCaller(guid, ReplayAnalyserContextCaller_1.ReplayAnalyserContextCaller);
}
exports.ReplayAnalyserContext = ReplayAnalyserContext;
function wrapProxiedMethod(methodId, cacheResult) {
    const fn = function (...args) {
        return this.workerContext.callMethod(this, methodId, args, cacheResult);
    };
    return fn;
}
function wrapProxiedGetter(propertyId, cacheResult) {
    const pId = propertyId;
    const fn = function () {
        return this.workerContext.getProperty(this, pId, cacheResult);
    };
    return fn;
}
function buildWorkerPoxyMethod(target, methodNum, propertyKey, descriptor) {
    const type = Reflect.getMetadata('design:returnType', target, propertyKey);
    return {
        enumerable: descriptor.enumerable,
        writable: descriptor.writable,
        value: wrapProxiedMethod(methodNum, true)
    };
}
function buildWorkerPoxyGetterProperty(target, methodNum, propertyKey, descriptor) {
    if (descriptor.set) {
        throw Error(`Cannot wrap setter "${propertyKey}". Only readonly properties are supported.`);
    }
    const type = Reflect.getMetadata('design:type', target, propertyKey);
    const desc = {
        get: wrapProxiedGetter(methodNum, true)
    };
    return desc;
}
let callAddress = -1;
function RunOnWorker() {
    return (target, propertyKey, descriptor) => {
        let proxyMap = Reflect.getOwnMetadata('woker:proxyMethods', target.constructor);
        if (!proxyMap) {
            proxyMap = {};
            Reflect.defineMetadata('woker:proxyMethods', proxyMap, target.constructor);
        }
        const mCount = ++callAddress;
        proxyMap[mCount] = propertyKey;
        if (isRunningInWorker()) {
            return;
        }
        if (typeof (descriptor.value) === 'function') {
            return buildWorkerPoxyMethod(target, mCount, propertyKey, descriptor);
        }
        else {
            return buildWorkerPoxyGetterProperty(target, mCount, propertyKey, descriptor);
        }
    };
}
exports.RunOnWorker = RunOnWorker;
function WorkerOnly() {
    return (target, propertyKey, descriptor) => {
        if (isRunningInWorker()) {
            return;
        }
        if (descriptor.value) {
            const desc = {
                value: ((...args) => {
                    throw new errors_1.InvalidExecutionContextError(`The Method "${propertyKey}" can only be called from the worker context.`);
                })
            };
            return desc;
        }
        else if (descriptor.get || descriptor.set) {
            const desc = {};
            const throwFn = ((...args) => {
                throw new errors_1.InvalidExecutionContextError(`The Property "${propertyKey}" can only be accessed from the worker context.`);
            });
            if (descriptor.get) {
                desc.get = throwFn;
            }
            if (descriptor.set) {
                desc.set = throwFn;
            }
            return desc;
        }
    };
}
exports.WorkerOnly = WorkerOnly;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb3JhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlY29yYXRvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSw0QkFBMEI7QUFDMUIsaUZBQThFO0FBRTlFLHFFQUFrRTtBQUNsRSxxRkFBa0Y7QUFFbEYscUNBQXVEO0FBRXZEO0lBQ0ksT0FBTyxPQUFPLGFBQWEsS0FBSyxVQUFVLElBQUksU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLENBQUM7QUFDbkcsQ0FBQztBQUZELDhDQUVDO0FBQ0QsMEJBQTBCLElBQWU7SUFDckMsTUFBTSxLQUFLLEdBQWdCLElBQUksR0FBRyxFQUFFLENBQUM7SUFDckMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMzQixPQUFPLEtBQUssSUFBSSxLQUFLLENBQUMsV0FBVyxLQUFLLE1BQU0sRUFBRTtRQUMxQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQzFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakIsQ0FBQyxDQUFDLENBQUM7UUFDSCxLQUFLLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN4QztJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFFRCwwQkFBMEIsVUFBb0MsRUFBRSxXQUFzQixFQUFFLFFBQWU7SUFDbkcsTUFBTSxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztJQUMvQyxNQUFNLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVqRCxJQUFJLEtBQUssR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO0lBQ2xDLE9BQU8sS0FBSyxJQUFJLEtBQUssQ0FBQyxXQUFXLEtBQUssTUFBTSxFQUFFO1FBQzFDLE1BQU0sS0FBSyxHQUFHLE1B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

/***/ }),

/***/ "./src/lib/replay/errors/FailedToLoadProtocolError.ts":
/*!************************************************************!*\
  !*** ./src/lib/replay/errors/FailedToLoadProtocolError.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ProxiableError_1 = __webpack_require__(/*! ../proxy/error/ProxiableError */ "./src/lib/replay/proxy/error/ProxiableError.ts");
class FailedToLoadProtocolError extends ProxiableError_1.ProxiableError {
    constructor(version, message) {
        super('FailedToLoadProtocolError', message);
        this.version = version;
    }
}
exports.FailedToLoadProtocolError = FailedToLoadProtocolError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmFpbGVkVG9Mb2FkUHJvdG9jb2xFcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkZhaWxlZFRvTG9hZFByb3RvY29sRXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxrRUFBK0Q7QUFFL0QsK0JBQXVDLFNBQVEsK0JBQWM7SUFFekQsWUFBbUIsT0FBZSxFQUFFLE9BQWU7UUFDL0MsS0FBSyxDQUFDLDJCQUEyQixFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRDdCLFlBQU8sR0FBUCxPQUFPLENBQVE7SUFFbEMsQ0FBQztDQUNKO0FBTEQsOERBS0MifQ==

/***/ }),

/***/ "./src/lib/replay/errors/GameTypeNotSupportedError.ts":
/*!************************************************************!*\
  !*** ./src/lib/replay/errors/GameTypeNotSupportedError.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ProxiableError_1 = __webpack_require__(/*! ../proxy/error/ProxiableError */ "./src/lib/replay/proxy/error/ProxiableError.ts");
class GameTypeNotSupportedError extends ProxiableError_1.ProxiableError {
    constructor(message) {
        super('GameTypeNotSupportedError', message);
    }
}
exports.GameTypeNotSupportedError = GameTypeNotSupportedError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FtZVR5cGVOb3RTdXBwb3J0ZWRFcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkdhbWVUeXBlTm90U3VwcG9ydGVkRXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxrRUFBK0Q7QUFFL0QsK0JBQXVDLFNBQVEsK0JBQWM7SUFDekQsWUFBWSxPQUFlO1FBQ3ZCLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNoRCxDQUFDO0NBQ0o7QUFKRCw4REFJQyJ9

/***/ }),

/***/ "./src/lib/replay/errors/InvalidExecutionContextError.ts":
/*!***************************************************************!*\
  !*** ./src/lib/replay/errors/InvalidExecutionContextError.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ProxiableError_1 = __webpack_require__(/*! ../proxy/error/ProxiableError */ "./src/lib/replay/proxy/error/ProxiableError.ts");
class InvalidExecutionContextError extends ProxiableError_1.ProxiableError {
    constructor(message) {
        super('InvalidExecutionContextError', message);
    }
}
exports.InvalidExecutionContextError = InvalidExecutionContextError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW52YWxpZEV4ZWN1dGlvbkNvbnRleHRFcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkludmFsaWRFeGVjdXRpb25Db250ZXh0RXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxrRUFBK0Q7QUFFL0Qsa0NBQTBDLFNBQVEsK0JBQWM7SUFDNUQsWUFBWSxPQUFlO1FBQ3ZCLEtBQUssQ0FBQyw4QkFBOEIsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRCxDQUFDO0NBQ0o7QUFKRCxvRUFJQyJ9

/***/ }),

/***/ "./src/lib/replay/errors/MapNotSupportedError.ts":
/*!*******************************************************!*\
  !*** ./src/lib/replay/errors/MapNotSupportedError.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ProxiableError_1 = __webpack_require__(/*! ../proxy/error/ProxiableError */ "./src/lib/replay/proxy/error/ProxiableError.ts");
class MapNotSupportedError extends ProxiableError_1.ProxiableError {
    constructor(message) {
        super('MapNotSupportedError', message);
    }
}
exports.MapNotSupportedError = MapNotSupportedError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFwTm90U3VwcG9ydGVkRXJyb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJNYXBOb3RTdXBwb3J0ZWRFcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGtFQUErRDtBQUUvRCwwQkFBa0MsU0FBUSwrQkFBYztJQUNwRCxZQUFZLE9BQWU7UUFDdkIsS0FBSyxDQUFDLHNCQUFzQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzNDLENBQUM7Q0FDSjtBQUpELG9EQUlDIn0=

/***/ }),

/***/ "./src/lib/replay/errors/ReplayVersionOutOfRangeError.ts":
/*!***************************************************************!*\
  !*** ./src/lib/replay/errors/ReplayVersionOutOfRangeError.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ProxiableError_1 = __webpack_require__(/*! ../proxy/error/ProxiableError */ "./src/lib/replay/proxy/error/ProxiableError.ts");
class ReplayVersionOutOfRangeError extends ProxiableError_1.ProxiableError {
    constructor(message) {
        super('ReplayVersionOutOfRangeError', message);
    }
}
exports.ReplayVersionOutOfRangeError = ReplayVersionOutOfRangeError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5VmVyc2lvbk91dE9mUmFuZ2VFcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlJlcGxheVZlcnNpb25PdXRPZlJhbmdlRXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxrRUFBK0Q7QUFFL0Qsa0NBQTBDLFNBQVEsK0JBQWM7SUFDNUQsWUFBWSxPQUFlO1FBQ3ZCLEtBQUssQ0FBQyw4QkFBOEIsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRCxDQUFDO0NBQ0o7QUFKRCxvRUFJQyJ9

/***/ }),

/***/ "./src/lib/replay/errors/index.ts":
/*!****************************************!*\
  !*** ./src/lib/replay/errors/index.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ReplayVersionOutOfRangeError */ "./src/lib/replay/errors/ReplayVersionOutOfRangeError.ts"));
__export(__webpack_require__(/*! ./InvalidExecutionContextError */ "./src/lib/replay/errors/InvalidExecutionContextError.ts"));
__export(__webpack_require__(/*! ./FailedToLoadProtocolError */ "./src/lib/replay/errors/FailedToLoadProtocolError.ts"));
__export(__webpack_require__(/*! ./GameTypeNotSupportedError */ "./src/lib/replay/errors/GameTypeNotSupportedError.ts"));
__export(__webpack_require__(/*! ./MapNotSupportedError */ "./src/lib/replay/errors/MapNotSupportedError.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9EQUErQztBQUMvQyxvREFBK0M7QUFDL0MsaURBQTRDO0FBQzVDLGlEQUE0QztBQUM1Qyw0Q0FBdUMifQ==

/***/ }),

/***/ "./src/lib/replay/index.ts":
/*!*********************************!*\
  !*** ./src/lib/replay/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./analyzers */ "./src/lib/replay/analyzers/index.ts"));
__export(__webpack_require__(/*! ./Replay */ "./src/lib/replay/Replay.ts"));
__export(__webpack_require__(/*! ./decorators */ "./src/lib/replay/decorators.ts"));
__export(__webpack_require__(/*! ./proxy */ "./src/lib/replay/proxy/index.ts"));
__export(__webpack_require__(/*! ./errors */ "./src/lib/replay/errors/index.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUE0QjtBQUM1Qiw4QkFBeUI7QUFDekIsa0NBQTZCO0FBQzdCLDZCQUF3QjtBQUN4Qiw4QkFBd0IifQ==

/***/ }),

/***/ "./src/lib/replay/proxy/ReplayAnalyserContextCaller.ts":
/*!*************************************************************!*\
  !*** ./src/lib/replay/proxy/ReplayAnalyserContextCaller.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ReplayAnalyserContextCaller {
    get workerContext() {
        return this._replay ? this._replay.workerContext : undefined;
    }
    constructor(replay) {
        this._replay = replay;
        this.workerContext.addCallContext(this);
    }
    initialize() {
        throw new Error('initialize can only be called in the web worker context');
    }
    dispose() {
        if (this._replay) {
            this.workerContext.removeCallContext(this);
            this._replay = undefined;
        }
    }
}
exports.ReplayAnalyserContextCaller = ReplayAnalyserContextCaller;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5QW5hbHlzZXJDb250ZXh0Q2FsbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUmVwbGF5QW5hbHlzZXJDb250ZXh0Q2FsbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBSUE7SUFHSSxJQUFXLGFBQWE7UUFDcEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxZQUFtQixNQUEyQjtRQUMxQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU0sVUFBVTtRQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMseURBQXlELENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRU0sT0FBTztRQUNWLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNkLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7U0FDNUI7SUFDTCxDQUFDO0NBRUo7QUF2QkQsa0VBdUJDIn0=

/***/ }),

/***/ "./src/lib/replay/proxy/ReplayContextCaller.ts":
/*!*****************************************************!*\
  !*** ./src/lib/replay/proxy/ReplayContextCaller.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WorkerContext_1 = __webpack_require__(/*! ./context/WorkerContext */ "./src/lib/replay/proxy/context/WorkerContext.ts");
const messages_1 = __webpack_require__(/*! ./messages */ "./src/lib/replay/proxy/messages/index.ts");
const heroprotocol_1 = __webpack_require__(/*! ../../heroprotocol */ "./src/lib/heroprotocol.ts");
const Subject_1 = __webpack_require__(/*! rxjs/Subject */ "./node_modules/rxjs/Subject.js");
const operators_1 = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/operators.js");
class ReplayContextCaller {
    constructor(mpqData) {
        this._statusSubject = new Subject_1.Subject();
        const initPromise = new Promise((res, rej) => {
            this.replayInitPromise = {
                resolve: res,
                reject: rej
            };
        });
        this.replayInitPromise.promise = initPromise;
        this._workerContext = new WorkerContext_1.WorkerContext(`./assets/webworker/replay-worker${heroprotocol_1.HeroProtocol.env === 'production' ? '.min' : ''}.js`, mpqData, [mpqData]);
        this._workerContext.addCallContext(this);
        this._statusSubjectSubscription = this._workerContext.channelMessages.pipe(operators_1.filter(msg => messages_1.isReplayStatusMessage(msg))).subscribe(((statusMessage) => {
            if (statusMessage.status === 'REPLAY_READY') {
                this.replayInitPromise.resolve();
            }
            this._statusSubject.next(statusMessage);
        }));
        this._protocolLoaderSubscription = this._workerContext.channelMessages.pipe(operators_1.filter(msg => messages_1.isLoadHeroDataMessage(msg))).subscribe(((heroDataLoadMessage) => __awaiter(this, void 0, void 0, function* () {
            const data = yield heroprotocol_1.HeroProtocol.loadHeroData();
            this.workerContext.send({
                type: 'load-hero-data-result',
                data: data
            });
        })));
        this._protocolLoaderSubscription = this._workerContext.channelMessages.pipe(operators_1.filter(msg => messages_1.isLoadProtocolMessage(msg))).subscribe(((protocolMessage) => __awaiter(this, void 0, void 0, function* () {
            try {
                const code = yield heroprotocol_1.HeroProtocol.loadProtocol(protocolMessage.version);
                this.workerContext.send({
                    type: 'load-protocol-result',
                    version: protocolMessage.version,
                    code: code
                });
            }
            catch (e) {
                this.replayInitPromise.reject(e);
            }
        })));
    }
    get workerContext() {
        return this._workerContext;
    }
    get status() {
        return this._statusSubject.asObservable();
    }
    get protocol() {
        throw new Error('Protocol can only be accessed in the web worker context');
    }
    initialize() {
        return this.replayInitPromise.promise;
    }
    dispose() {
        if (this._workerContext) {
            this._statusSubjectSubscription.unsubscribe();
            this._statusSubjectSubscription = undefined;
            this._statusSubject = undefined;
            this.workerContext.dispose();
            this._workerContext = undefined;
        }
    }
}
exports.ReplayContextCaller = ReplayContextCaller;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5Q29udGV4dENhbGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlJlcGxheUNvbnRleHRDYWxsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUdBLDJEQUF3RDtBQUN4RCx5Q0FJb0I7QUFDcEIscURBQWtEO0FBQ2xELDBDQUF1QztBQUd2Qyw4Q0FBd0M7QUFFeEM7SUFxQkksWUFBbUIsT0FBcUI7UUFqQmhDLG1CQUFjLEdBQWtDLElBQUksaUJBQU8sRUFBRSxDQUFDO1FBa0JsRSxNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sQ0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUMsRUFBRTtZQUM5QyxJQUFJLENBQUMsaUJBQWlCLEdBQUc7Z0JBQ3JCLE9BQU8sRUFBRSxHQUFHO2dCQUNaLE1BQU0sRUFBRSxHQUFHO2FBQ2QsQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFBO1FBQ0YsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUM7UUFDN0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLDZCQUFhLENBQUMsbUNBQW1DLDJCQUFZLENBQUMsR0FBRyxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3JKLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQ3RFLGtCQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQ0FBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFtQyxFQUFFLEVBQUU7WUFDMUYsSUFBRyxhQUFhLENBQUMsTUFBTSxLQUFLLGNBQWMsRUFBQztnQkFDdkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQ3BDO1lBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNSLElBQUksQ0FBQywyQkFBMkIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQ3ZFLGtCQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQ0FBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBTyxtQkFBeUMsRUFBRSxFQUFFO1lBQ3RHLE1BQU0sSUFBSSxHQUFHLE1BQU0sMkJBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUMvQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBNkI7Z0JBQ2hELElBQUksRUFBRSx1QkFBdUI7Z0JBQzdCLElBQUksRUFBRSxJQUFJO2FBQ2IsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDO1FBQ1IsSUFBSSxDQUFDLDJCQUEyQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFDLElBQUksQ0FDdkUsa0JBQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGdDQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFPLGVBQXFDLEVBQUUsRUFBRTtZQUNsRyxJQUFHO2dCQUNDLE1BQU0sSUFBSSxHQUFHLE1BQU0sMkJBQVksQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN0RSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBNkI7b0JBQ2hELElBQUksRUFBRSxzQkFBc0I7b0JBQzVCLE9BQU8sRUFBRSxlQUFlLENBQUMsT0FBTztvQkFDaEMsSUFBSSxFQUFFLElBQUk7aUJBQ2IsQ0FBQyxDQUFDO2FBQ047WUFBQSxPQUFNLENBQUMsRUFBQztnQkFDTCxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3BDO1FBQ0wsQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQWxERCxJQUFXLGFBQWE7UUFDcEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFXLE1BQU07UUFDYixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDOUMsQ0FBQztJQUVELElBQVcsUUFBUTtRQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMseURBQXlELENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBMENNLFVBQVU7UUFDYixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUM7SUFDMUMsQ0FBQztJQUVNLE9BQU87UUFDVixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQzlDLElBQUksQ0FBQywwQkFBMEIsR0FBRyxTQUFTLENBQUM7WUFDNUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUM7WUFDaEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUM3QixJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQztTQUNuQztJQUNMLENBQUM7Q0FDSjtBQTFFRCxrREEwRUMifQ==

/***/ }),

/***/ "./src/lib/replay/proxy/ReplayWorker.ts":
/*!**********************************************!*\
  !*** ./src/lib/replay/proxy/ReplayWorker.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(/*! ./messages */ "./src/lib/replay/proxy/messages/index.ts");
const WorkerContextRegistry_1 = __webpack_require__(/*! ./context/WorkerContextRegistry */ "./src/lib/replay/proxy/context/WorkerContextRegistry.ts");
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
__webpack_require__(/*! rxjs/operators/debounce */ "./node_modules/rxjs/operators/debounce.js");
const Replay_1 = __webpack_require__(/*! ../Replay */ "./src/lib/replay/Replay.ts");
class ReplayWorker {
    constructor(initCmd) {
        this._protocolPromisies = {};
        this._loadedContexts = new Map();
        this._messagePort = initCmd.port;
        this._messagePort.onmessage = (event) => __awaiter(this, void 0, void 0, function* () {
            if (messages_1.isWorkerCallMessage(event.data)) {
                try {
                    this.send(yield this.handleWorkerCallMessage(event.data));
                }
                catch (e) {
                    const errMsg = {
                        type: 'worker-call-result',
                        callId: event.data.callId,
                        error: true,
                        result: {
                            name: e.name,
                            message: e.message,
                            stack: e.stack
                        }
                    };
                    this.send(errMsg);
                }
            }
            else if (messages_1.isLoadProtocolResultMessage(event.data)) {
                this.handleProtocolResult(event.data);
            }
            else if (messages_1.isLoadHeroDataResultMessage(event.data)) {
                this._heroDataPromise.resolve(event.data.data);
            }
        });
        this._replay = new Replay_1.Replay(initCmd.data);
        const replayContextId = WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerId(this._replay);
        this._loadedContexts.set(replayContextId, this._replay);
        this._replay.status.subscribe((status) => {
            if (status) {
                this.send(status);
            }
        });
        this._replay.loadProtocol = (version) => {
            if (this._protocolPromisies[version]) {
                return this._protocolPromisies[version].promise;
            }
            const promise = new Promise((resolve, reject) => {
                this._protocolPromisies[version] = {
                    resolve,
                    reject,
                    promise: undefined
                };
            });
            this._protocolPromisies[version].promise = promise;
            this.send({
                type: 'load-protocol',
                version: version
            });
            return promise;
        };
        this._replay.loadHeroData = () => {
            if (this._heroDataPromise) {
                return this._heroDataPromise.promise;
            }
            const promise = new Promise((resolve, reject) => {
                this._heroDataPromise = {
                    resolve,
                    reject,
                    promise: undefined
                };
            });
            this._heroDataPromise.promise = promise;
            this.send({
                type: 'load-hero-data'
            });
            return promise;
        };
        this._replay.initialize();
    }
    send(data, transfer = []) {
        this._messagePort.postMessage(data, transfer);
    }
    handleProtocolResult(data) {
        const promise = this._protocolPromisies[data.version];
        promise.resolve(data.code);
    }
    handleWorkerCallMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (messages_1.isWorkerPropertyCall(msg.data)) {
                return yield this.handleWorkerPropertyCall(msg.callId, msg.data);
            }
            else if (messages_1.isWorkerMethodCall(msg.data)) {
                return yield this.handleWorkerMethodCall(msg.callId, msg.data);
            }
            else {
                throw new Error(`Unhandled Worker Call Message "${msg.type}"`);
            }
        });
    }
    handleWorkerPropertyCall(callId, call) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.getContextInstance(call.context);
            const value = yield context[this.getPropertyName(context, call.propertyId)];
            const result = {
                type: 'worker-call-result',
                callId,
                result: value
            };
            return result;
        });
    }
    handleWorkerMethodCall(callId, call) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.getContextInstance(call.context);
            const fn = context[this.getPropertyName(context, call.methodId)];
            const value = yield fn.apply(context, call.args || []);
            const result = {
                type: 'worker-call-result',
                callId,
                result: value
            };
            return result;
        });
    }
    getContextInstance(contextId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._loadedContexts.has(contextId)) {
                return this._loadedContexts.get(contextId);
            }
            const contextType = WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerById(contextId);
            const contextInst = new contextType(this._replay);
            this._loadedContexts.set(contextId, contextInst);
            yield contextInst.initialize();
            return contextInst;
        });
    }
    getPropertyName(context, id) {
        const proxyMap = Reflect.getOwnMetadata('woker:proxyMethods', context.constructor);
        return proxyMap[id];
    }
}
exports.ReplayWorker = ReplayWorker;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5V29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUmVwbGF5V29ya2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5Q0Fjb0I7QUFDcEIsMkVBQXdFO0FBQ3hFLDRCQUEwQjtBQUcxQixtQ0FBaUM7QUFFakMsc0NBQW1DO0FBQ25DO0lBUUksWUFBWSxPQUEyQjtRQUwvQix1QkFBa0IsR0FBNkYsRUFBRSxDQUFDO1FBR2xILG9CQUFlLEdBQXFCLElBQUksR0FBRyxFQUFFLENBQUM7UUFHbEQsSUFBSSxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxHQUFHLENBQU8sS0FBSyxFQUFFLEVBQUU7WUFDMUMsSUFBSSw4QkFBbUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2pDLElBQUk7b0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDN0Q7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1IsTUFBTSxNQUFNLEdBQTZCO3dCQUNyQyxJQUFJLEVBQUUsb0JBQW9CO3dCQUMxQixNQUFNLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNO3dCQUN6QixLQUFLLEVBQUUsSUFBSTt3QkFDWCxNQUFNLEVBQUU7NEJBQ0osSUFBSSxFQUFVLENBQUUsQ0FBQyxJQUFJOzRCQUNyQixPQUFPLEVBQVUsQ0FBRSxDQUFDLE9BQU87NEJBQzNCLEtBQUssRUFBVSxDQUFFLENBQUMsS0FBSzt5QkFDMUI7cUJBQ0osQ0FBQztvQkFDRixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUNyQjthQUNKO2lCQUFNLElBQUksc0NBQTJCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNoRCxJQUFJLENBQUMs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

/***/ }),

/***/ "./src/lib/replay/proxy/context/WorkerContext.ts":
/*!*******************************************************!*\
  !*** ./src/lib/replay/proxy/context/WorkerContext.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__(/*! ../messages */ "./src/lib/replay/proxy/messages/index.ts");
const WorkerContextRegistry_1 = __webpack_require__(/*! ./WorkerContextRegistry */ "./src/lib/replay/proxy/context/WorkerContextRegistry.ts");
const Subject_1 = __webpack_require__(/*! rxjs/Subject */ "./node_modules/rxjs/Subject.js");
const sha1 = __webpack_require__(/*! sha1 */ "./node_modules/sha1/sha1.js");
class WorkerContext {
    constructor(workerPath, initData, initTransfer = []) {
        this.workerPath = workerPath;
        this._initMessageQueue = [];
        this._workerMessages = new Subject_1.Subject();
        this._channelMessages = new Subject_1.Subject();
        this._callId = 0;
        this._resultCache = new Map();
        this._callPromises = {};
        this._pendingCachePromises = {};
        this._contextCallers = new Set();
        this._worker = new Worker(workerPath);
        this.initialize(initData, initTransfer);
    }
    get workerMessages() {
        return this._workerMessages.asObservable();
    }
    get channelMessages() {
        return this._channelMessages.asObservable();
    }
    initialize(initData, initTransfer) {
        this._worker.onmessage = (event) => {
            if (event.data === 'WORKER_INITIALIZED') {
                this._initialized = true;
                for (let i = 0; i < this._initMessageQueue.length; i++) {
                    const arg = this._initMessageQueue[i];
                    this.send(arg[0], arg[1]);
                }
            }
            else {
                this._workerMessages.next(event.data);
            }
        };
        const messageChannel = new MessageChannel();
        this._port = messageChannel.port1;
        this._port.onmessage = (event) => {
            if (!this.handleChannelMessage(event.data)) {
                this._channelMessages.next(event.data);
            }
        };
        const initCommand = {
            type: 'initialize',
            port: messageChannel.port2,
            data: initData
        };
        this._worker.postMessage(initCommand, [messageChannel.port2, ...initTransfer]);
    }
    handleChannelMessage(msg) {
        if (messages_1.isWorkerCallResultMessage(msg)) {
            this.handleWorkerCallResult(msg);
            return true;
        }
        return false;
    }
    computeCacheKey(...args) {
        const dataStr = JSON.stringify(args, (key, value) => {
            return value;
        });
        return sha1(dataStr);
    }
    hasCache(key) {
        return this._resultCache.has(key);
    }
    getCache(key) {
        return this._resultCache.get(key);
    }
    setCache(key, value) {
        this._resultCache.set(key, value);
    }
    handleWorkerCallResult(data) {
        const promise = this._callPromises[data.callId];
        delete this._callPromises[data.callId];
        if (promise.cacheKey) {
            delete this._pendingCachePromises[promise.cacheKey];
        }
        if (data.error) {
            promise.reject(data.result);
        }
        else {
            if (promise.cacheKey) {
                this.setCache(promise.cacheKey, data.result);
            }
            promise.resolve(data.result);
        }
    }
    send(data, transfer) {
        if (!this._initialized) {
            this._initMessageQueue.push([data, transfer]);
        }
        else {
            this._port.postMessage(data, transfer);
        }
    }
    call(data, cacheResult = true, transfer) {
        const callId = this._callId++;
        const cacheKey = cacheResult ? this.computeCacheKey(data) : undefined;
        if (cacheResult && this.hasCache(cacheKey)) {
            return new Promise((res) => {
                res(this.getCache(cacheKey));
            });
        }
        if (cacheResult && this._pendingCachePromises[cacheKey]) {
            return this._pendingCachePromises[cacheKey];
        }
        const promise = new Promise((resolve, reject) => {
            this._callPromises[callId] = {
                resolve,
                reject,
                cacheKey
            };
            this.send({
                type: 'worker-call',
                callId,
                data
            });
        });
        if (cacheResult) {
            this._pendingCachePromises[cacheKey] = promise;
        }
        return promise;
    }
    getProperty(context, propertyId, cacheResult) {
        const call = {
            type: 'get-property',
            context: WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerId(context),
            propertyId
        };
        return this.call(call, cacheResult);
    }
    callMethod(context, methodId, args, cacheResult, transfer) {
        const call = {
            type: 'call-method',
            context: WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerId(context),
            methodId,
            args
        };
        return this.call(call, cacheResult, transfer);
    }
    addCallContext(context) {
        this._contextCallers.add(context);
    }
    removeCallContext(context) {
        this._contextCallers.delete(context);
    }
    tryDispose() {
        if (this._contextCallers.size > 0) {
            return false;
        }
        this.dispose();
        return true;
    }
    dispose() {
        if (this._worker) {
            this._worker.terminate();
            this._worker = undefined;
            this._initialized = false;
            this._port = undefined;
            this._initMessageQueue = undefined;
            this._callPromises = undefined;
            this._pendingCachePromises = undefined;
        }
    }
}
exports.WorkerContext = WorkerContext;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV29ya2VyQ29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIldvcmtlckNvbnRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFHQSwwQ0FJcUI7QUFDckIsbUVBQWdFO0FBRWhFLDBDQUF1QztBQUd2Qyw2QkFBNkI7QUFFN0I7SUEyQkksWUFBMkIsVUFBa0IsRUFBRSxRQUFjLEVBQUUsZUFBc0IsRUFBRTtRQUE1RCxlQUFVLEdBQVYsVUFBVSxDQUFRO1FBcEJyQyxzQkFBaUIsR0FBc0IsRUFBRSxDQUFDO1FBQzFDLG9CQUFlLEdBQWlCLElBQUksaUJBQU8sRUFBRSxDQUFDO1FBQzlDLHFCQUFnQixHQUFpQixJQUFJLGlCQUFPLEVBQUUsQ0FBQztRQUUvQyxZQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ1osaUJBQVksR0FBcUIsSUFBSSxHQUFHLEVBQWUsQ0FBQztRQUN4RCxrQkFBYSxHQUErRSxFQUFFLENBQUM7UUFDL0YsMEJBQXFCLEdBQW9DLEVBQUUsQ0FBQztRQUc1RCxvQkFBZSxHQUE0QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBV3pELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQVhELElBQVcsY0FBYztRQUNyQixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQUVELElBQVcsZUFBZTtRQUN0QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBT08sVUFBVSxDQUFDLFFBQWEsRUFBRSxZQUFtQjtRQUNqRCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQy9CLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxvQkFBb0IsRUFBRTtn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

/***/ }),

/***/ "./src/lib/replay/proxy/context/WorkerContextRegistry.ts":
/*!***************************************************************!*\
  !*** ./src/lib/replay/proxy/context/WorkerContextRegistry.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(/*! ../../../types */ "./src/lib/types/index.ts");
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
class WorkerContextRegistry {
    static registerContextCaller(type) {
        const id = Reflect.getOwnMetadata('workerContext:typeId', type);
        if (WorkerContextRegistry._contextCallers.has(id)) {
            const regType = WorkerContextRegistry._contextCallers.get(id);
            if (regType !== type) {
                throw new Error('Duplicate TypeId');
            }
        }
        else {
            WorkerContextRegistry._contextCallers.set(id, type);
        }
    }
    static getContextCallerId(type) {
        if (!types_1.isType(type)) {
            type = type.constructor;
        }
        const id = Reflect.getOwnMetadata('workerContext:typeId', type);
        if (WorkerContextRegistry._contextCallers.has(id)) {
            return id;
        }
    }
    static getContextCallerById(id) {
        return WorkerContextRegistry._contextCallers.get(id);
    }
}
WorkerContextRegistry._contextCallers = new Map();
exports.WorkerContextRegistry = WorkerContextRegistry;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV29ya2VyQ29udGV4dFJlZ2lzdHJ5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiV29ya2VyQ29udGV4dFJlZ2lzdHJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMENBQThDO0FBRzlDLDRCQUEwQjtBQUUxQjtJQUlXLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxJQUE4QjtRQUM5RCxNQUFNLEVBQUUsR0FBVyxPQUFPLENBQUMsY0FBYyxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3hFLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUMvQyxNQUFNLE9BQU8sR0FBRyxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzlELElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtnQkFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3ZDO1NBQ0o7YUFBTTtZQUNILHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3ZEO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxJQUFtRDtRQUNoRixJQUFJLENBQUMsY0FBTSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2YsSUFBSSxHQUFRLElBQUksQ0FBQyxXQUFXLENBQUM7U0FDaEM7UUFDRCxNQUFNLEVBQUUsR0FBVyxPQUFPLENBQUMsY0FBYyxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3hFLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUMvQyxPQUFPLEVBQUUsQ0FBQztTQUNiO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFVO1FBQ3pDLE9BQU8scUJBQXFCLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN6RCxDQUFDOztBQTNCYyxxQ0FBZSxHQUEwQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBRHRGLHNEQThCQyJ9

/***/ }),

/***/ "./src/lib/replay/proxy/error/ProxiableError.ts":
/*!******************************************************!*\
  !*** ./src/lib/replay/proxy/error/ProxiableError.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ProxiableError extends Error {
    constructor(name, message) {
        super(message);
        this.name = name;
    }
}
exports.ProxiableError = ProxiableError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJveGlhYmxlRXJyb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJQcm94aWFibGVFcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG9CQUE0QixTQUFRLEtBQUs7SUFDckMsWUFBWSxJQUFXLEVBQUUsT0FBZTtRQUNwQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNyQixDQUFDO0NBQ0o7QUFMRCx3Q0FLQyJ9

/***/ }),

/***/ "./src/lib/replay/proxy/index.ts":
/*!***************************************!*\
  !*** ./src/lib/replay/proxy/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./messages */ "./src/lib/replay/proxy/messages/index.ts"));
__export(__webpack_require__(/*! ./ReplayContextCaller */ "./src/lib/replay/proxy/ReplayContextCaller.ts"));
__export(__webpack_require__(/*! ./ReplayWorker */ "./src/lib/replay/proxy/ReplayWorker.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdDQUEyQjtBQUMzQiwyQ0FBc0M7QUFDdEMsb0NBQStCIn0=

/***/ }),

/***/ "./src/lib/replay/proxy/messages/call.ts":
/*!***********************************************!*\
  !*** ./src/lib/replay/proxy/messages/call.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerCallMessage(obj) {
    return !!obj && obj.type === 'worker-call' && typeof obj.callId === 'number' && 'data' in obj;
}
exports.isWorkerCallMessage = isWorkerCallMessage;
function isWorkerCallResultMessage(obj) {
    return !!obj && obj.type === 'worker-call-result' && typeof obj.callId === 'number';
}
exports.isWorkerCallResultMessage = isWorkerCallResultMessage;
function isWorkerPropertyCall(obj) {
    return !!obj && obj.type === 'get-property' && typeof obj.context === 'string' && typeof obj.propertyId === 'number';
}
exports.isWorkerPropertyCall = isWorkerPropertyCall;
function isWorkerMethodCall(obj) {
    return !!obj && obj.type === 'call-method' && typeof obj.context === 'string' && typeof obj.methodId === 'number';
}
exports.isWorkerMethodCall = isWorkerMethodCall;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNhbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFNQSw2QkFBb0MsR0FBUTtJQUN4QyxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxhQUFhLElBQUksT0FBTyxHQUFHLENBQUMsTUFBTSxLQUFLLFFBQVEsSUFBSSxNQUFNLElBQUksR0FBRyxDQUFDO0FBQ2xHLENBQUM7QUFGRCxrREFFQztBQVVELG1DQUEwQyxHQUFRO0lBQzlDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLG9CQUFvQixJQUFJLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUM7QUFDeEYsQ0FBQztBQUZELDhEQUVDO0FBU0QsOEJBQXFDLEdBQVE7SUFDekMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssY0FBYyxJQUFJLE9BQU8sR0FBRyxDQUFDLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxHQUFHLENBQUMsVUFBVSxLQUFLLFFBQVEsQ0FBQztBQUN6SCxDQUFDO0FBRkQsb0RBRUM7QUFTRCw0QkFBbUMsR0FBUTtJQUN2QyxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxhQUFhLElBQUksT0FBTyxHQUFHLENBQUMsT0FBTyxLQUFLLFFBQVEsSUFBSSxPQUFPLEdBQUcsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDO0FBQ3RILENBQUM7QUFGRCxnREFFQyJ9

/***/ }),

/***/ "./src/lib/replay/proxy/messages/cmds.ts":
/*!***********************************************!*\
  !*** ./src/lib/replay/proxy/messages/cmds.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerCommand(obj) {
    return 'type' in obj && 'messageId' in obj
        && typeof obj.messageId === 'number'
        && typeof obj.context === 'string' && typeof obj.id === 'number';
}
exports.isWorkerCommand = isWorkerCommand;
function isWorkerGetPropertyCommand(obj) {
    return isWorkerCommand(obj) && obj.type === 'property';
}
exports.isWorkerGetPropertyCommand = isWorkerGetPropertyCommand;
function isWorkerCallMethodCommand(obj) {
    return isWorkerCommand(obj) && obj.type === 'method';
}
exports.isWorkerCallMethodCommand = isWorkerCallMethodCommand;
function isWorkerCommandResult(obj) {
    return obj.type === 'command-result' && typeof obj.messageId === 'number';
}
exports.isWorkerCommandResult = isWorkerCommandResult;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY21kcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNtZHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFPQSx5QkFBZ0MsR0FBUTtJQUNwQyxPQUFPLE1BQU0sSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEdBQUc7V0FDbkMsT0FBTyxHQUFHLENBQUMsU0FBUyxLQUFLLFFBQVE7V0FDakMsT0FBTyxHQUFHLENBQUMsT0FBTyxLQUFLLFFBQVEsSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFLEtBQUssUUFBUSxDQUFDO0FBQ3pFLENBQUM7QUFKRCwwQ0FJQztBQU9ELG9DQUEyQyxHQUFRO0lBQy9DLE9BQU8sZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDO0FBQzNELENBQUM7QUFGRCxnRUFFQztBQVFELG1DQUEwQyxHQUFRO0lBQzlDLE9BQU8sZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO0FBQ3pELENBQUM7QUFGRCw4REFFQztBQVVELCtCQUFzQyxHQUFRO0lBQzFDLE9BQU8sR0FBRyxDQUFDLElBQUksS0FBSyxnQkFBZ0IsSUFBSSxPQUFPLEdBQUcsQ0FBQyxTQUFTLEtBQUssUUFBUSxDQUFDO0FBQzlFLENBQUM7QUFGRCxzREFFQyJ9

/***/ }),

/***/ "./src/lib/replay/proxy/messages/index.ts":
/*!************************************************!*\
  !*** ./src/lib/replay/proxy/messages/index.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./init */ "./src/lib/replay/proxy/messages/init.ts"));
__export(__webpack_require__(/*! ./protocol */ "./src/lib/replay/proxy/messages/protocol.ts"));
__export(__webpack_require__(/*! ./cmds */ "./src/lib/replay/proxy/messages/cmds.ts"));
__export(__webpack_require__(/*! ./status */ "./src/lib/replay/proxy/messages/status.ts"));
__export(__webpack_require__(/*! ./call */ "./src/lib/replay/proxy/messages/call.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRCQUF1QjtBQUN2QixnQ0FBMkI7QUFDM0IsNEJBQXVCO0FBQ3ZCLDhCQUF5QjtBQUN6Qiw0QkFBdUIifQ==

/***/ }),

/***/ "./src/lib/replay/proxy/messages/init.ts":
/*!***********************************************!*\
  !*** ./src/lib/replay/proxy/messages/init.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isInitializeCommand(obj) {
    return obj.type === 'initialize' && obj.data instanceof ArrayBuffer && obj.port instanceof MessagePort;
}
exports.isInitializeCommand = isInitializeCommand;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFNQSw2QkFBb0MsR0FBUTtJQUN4QyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssWUFBWSxJQUFJLEdBQUcsQ0FBQyxJQUFJLFlBQVksV0FBVyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFlBQVksV0FBVyxDQUFDO0FBQzNHLENBQUM7QUFGRCxrREFFQyJ9

/***/ }),

/***/ "./src/lib/replay/proxy/messages/protocol.ts":
/*!***************************************************!*\
  !*** ./src/lib/replay/proxy/messages/protocol.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isLoadProtocolMessage(obj) {
    return obj.type === 'load-protocol';
}
exports.isLoadProtocolMessage = isLoadProtocolMessage;
function isLoadProtocolResultMessage(obj) {
    return obj.type === 'load-protocol-result';
}
exports.isLoadProtocolResultMessage = isLoadProtocolResultMessage;
function isLoadHeroDataMessage(obj) {
    return obj.type === 'load-hero-data';
}
exports.isLoadHeroDataMessage = isLoadHeroDataMessage;
function isLoadHeroDataResultMessage(obj) {
    return obj.type === 'load-hero-data-result';
}
exports.isLoadHeroDataResultMessage = isLoadHeroDataResultMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdG9jb2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcm90b2NvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQVFBLCtCQUFzQyxHQUFRO0lBQzFDLE9BQU8sR0FBRyxDQUFDLElBQUksS0FBSyxlQUFlLENBQUM7QUFDeEMsQ0FBQztBQUZELHNEQUVDO0FBU0QscUNBQTRDLEdBQVE7SUFDaEQsT0FBTyxHQUFHLENBQUMsSUFBSSxLQUFLLHNCQUFzQixDQUFDO0FBQy9DLENBQUM7QUFGRCxrRUFFQztBQU9ELCtCQUFzQyxHQUFRO0lBQzFDLE9BQU8sR0FBRyxDQUFDLElBQUksS0FBSyxnQkFBZ0IsQ0FBQztBQUN6QyxDQUFDO0FBRkQsc0RBRUM7QUFRRCxxQ0FBNEMsR0FBUTtJQUNoRCxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssdUJBQXVCLENBQUM7QUFDaEQsQ0FBQztBQUZELGtFQUVDIn0=

/***/ }),

/***/ "./src/lib/replay/proxy/messages/status.ts":
/*!*************************************************!*\
  !*** ./src/lib/replay/proxy/messages/status.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isReplayStatusMessage(obj) {
    return obj.type === 'replay-status' && typeof obj.status === 'string';
}
exports.isReplayStatusMessage = isReplayStatusMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdHVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhdHVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBT0EsK0JBQXNDLEdBQVE7SUFDMUMsT0FBTyxHQUFHLENBQUMsSUFBSSxLQUFLLGVBQWUsSUFBSSxPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQzFFLENBQUM7QUFGRCxzREFFQyJ9

/***/ }),

/***/ "./src/lib/replay/util/ReplayAttributeHelper.ts":
/*!******************************************************!*\
  !*** ./src/lib/replay/util/ReplayAttributeHelper.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ReplayAttributeHelper {
    constructor(replayAttributeEvents) {
        this.replayAttributeEvents = replayAttributeEvents;
    }
    get(scope, key) {
        return this.replayAttributeEvents.scopes[scope][key][0].value;
    }
    get pickOrder() {
        return this.get(16, 4018);
    }
    get gameSpeed() {
        return this.get(16, 3000);
    }
    get gamePrivate() {
        return this.get(16, 3009) === 'Priv';
    }
    get draftMode() {
        return this.get(16, 4010);
    }
    get banType() {
        return this.get(16, 4021);
    }
    get bannerChooseMethod() {
        return this.get(16, 4022);
    }
    getBanPlayerSlot(team) {
        const value = this.get(16, team === 0 ? 4022 : 4027).trim();
        return value === 'Hmmr' ? -1 : parseInt(value, 10);
    }
    getBanWasLocked(team, ban) {
        let key;
        if (team === 0) {
            key = ban ? 4024 : 4026;
        }
        else {
            key = ban ? 4029 : 4031;
        }
        return this.get(16, key) === 'yes';
    }
    getBan(team, ban) {
        let key;
        if (team === 0) {
            key = ban ? 4023 : 4025;
        }
        else {
            key = ban ? 4028 : 4030;
        }
        return this.get(16, key);
    }
    getWasBanned(team, ban) {
        const banned = this.getBan(team, ban);
        if (!banned) {
            return false;
        }
        return !!(banned.trim());
    }
}
exports.ReplayAttributeHelper = ReplayAttributeHelper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbGF5QXR0cmlidXRlSGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiUmVwbGF5QXR0cmlidXRlSGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7SUFFSSxZQUEyQixxQkFBMEI7UUFBMUIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFLO0lBQUksQ0FBQztJQUVuRCxHQUFHLENBQUMsS0FBYSxFQUFFLEdBQVc7UUFDakMsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUNsRSxDQUFDO0lBRUQsSUFBVyxTQUFTO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUdELElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxJQUFXLFdBQVc7UUFDbEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxNQUFNLENBQUM7SUFDekMsQ0FBQztJQUVELElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxJQUFXLGtCQUFrQjtRQUN6QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFTSxnQkFBZ0IsQ0FBQyxJQUFZO1FBQ2hDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDNUQsT0FBTyxLQUFLLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRU0sZUFBZSxDQUFDLElBQVksRUFBRSxHQUFXO1FBQzVDLElBQUksR0FBVyxDQUFDO1FBQ2hCLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNaLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1NBQzNCO2FBQU07WUFDSCxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztTQUMzQjtRQUNELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEtBQUssS0FBSyxDQUFDO0lBQ3ZDLENBQUM7SUFFTSxNQUFNLENBQUMsSUFBWSxFQUFFLEdBQVc7UUFDbkMsSUFBSSxHQUFXLENBQUM7UUFDaEIsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQ1osR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7U0FDM0I7YUFBTTtZQUNILEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1NBQzNCO1FBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRU0sWUFBWSxDQUFDLElBQVksRUFBRSxHQUFXO1FBQ3pDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDVCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0IsQ0FBQztDQUlKO0FBcEVELHNEQW9FQyJ9

/***/ }),

/***/ "./src/lib/types/events/FilteredEvents.ts":
/*!************************************************!*\
  !*** ./src/lib/types/events/FilteredEvents.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FilteredEvents = [
    'NNet.Game.SLoadingProgressMessage',
    'NNet.Replay.Tracker.SUnitPositionsEvent',
    'NNet.Game.SUserFinishedLoadingSyncEvent',
    'NNet.Game.STriggerSoundLengthSyncEvent',
    'NNet.Game.STriggerMouseMovedEvent',
    'NNet.Game.SCameraUpdateEvent',
    'NNet.Game.STriggerSoundOffsetEvent',
    'NNet.Game.SSelectionDeltaEvent',
    'NNet.Game.SControlGroupUpdateEvent',
    'NNet.Game.SCommandManagerStateEvent',
    'NNet.Game.SCmdUpdateTargetPointEvent',
    'NNet.Game.SCmdUpdateTargetUnitEvent',
    'NNet.Game.STriggerSoundtrackDoneEvent',
    'NNet.Game.STriggerDialogControlEvent',
    'NNet.Game.STriggerTransmissionCompleteEvent',
    'NNet.Game.STriggerTransmissionOffsetEvent',
    'NNet.Game.STriggerCutsceneEndSceneFiredEvent',
    'NNet.Game.STriggerTargetModeUpdateEvent',
    'NNet.Game.SCommandManagerResetEvent',
    'NNet.Game.STriggerKeyPressedEvent',
    'NNet.Game.SUnitClickEvent',
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsdGVyZWRFdmVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJGaWx0ZXJlZEV2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFhLFFBQUEsY0FBYyxHQUFhO0lBQ3BDLG1DQUFtQztJQUVuQyx5Q0FBeUM7SUFFekMseUNBQXlDO0lBQ3pDLHdDQUF3QztJQUN4QyxtQ0FBbUM7SUFDbkMsOEJBQThCO0lBQzlCLG9DQUFvQztJQUNwQyxnQ0FBZ0M7SUFDaEMsb0NBQW9DO0lBQ3BDLHFDQUFxQztJQUNyQyxzQ0FBc0M7SUFFdEMscUNBQXFDO0lBQ3JDLHVDQUF1QztJQUN2QyxzQ0FBc0M7SUFDdEMsNkNBQTZDO0lBQzdDLDJDQUEyQztJQUMzQyw4Q0FBOEM7SUFDOUMseUNBQXlDO0lBQ3pDLHFDQUFxQztJQUV0QyxtQ0FBbUM7SUFDbkMsMkJBQTJCO0NBZTdCLENBQUMifQ==

/***/ }),

/***/ "./src/lib/types/events/IMessageEvents.ts":
/*!************************************************!*\
  !*** ./src/lib/types/events/IMessageEvents.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IReplayEvent_1 = __webpack_require__(/*! ./IReplayEvent */ "./src/lib/types/events/IReplayEvent.ts");
exports.MessageEventTypes = [
    'NNet.Game.SLoadingProgressMessage',
    'NNet.Game.SPingMessage',
    'NNet.Game.SChatMessage',
    'NNet.Game.SPlayerAnnounceMessage',
    'NNet.Game.SReconnectNotifyMessage'
];
function isIReplayMessageEvent(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && exports.MessageEventTypes.indexOf(obj._event) !== -1;
}
exports.isIReplayMessageEvent = isIReplayMessageEvent;
function isISLoadingProgressMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SLoadingProgressMessage';
}
exports.isISLoadingProgressMessage = isISLoadingProgressMessage;
function isISPingMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SPingMessage';
}
exports.isISPingMessage = isISPingMessage;
function isISChatMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SChatMessage';
}
exports.isISChatMessage = isISChatMessage;
function isISPlayerAnnounceMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SPlayerAnnounceMessage';
}
exports.isISPlayerAnnounceMessage = isISPlayerAnnounceMessage;
function isISReconnectNotifyMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SReconnectNotifyMessage';
}
exports.isISReconnectNotifyMessage = isISReconnectNotifyMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSU1lc3NhZ2VFdmVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJJTWVzc2FnZUV2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLGlEQUE4RTtBQUdqRSxRQUFBLGlCQUFpQixHQUFhO0lBQ3ZDLG1DQUFtQztJQUNuQyx3QkFBd0I7SUFDeEIsd0JBQXdCO0lBQ3hCLGtDQUFrQztJQUNsQyxtQ0FBbUM7Q0FDdEMsQ0FBQztBQU1GLCtCQUFzQyxHQUFRO0lBQzFDLE9BQU8scUNBQXNCLENBQUMsR0FBRyxDQUFDLElBQUkseUJBQWlCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBRkQsc0RBRUM7QUFPRCxvQ0FBMkMsR0FBUTtJQUMvQyxPQUFPLHFDQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssbUNBQW1DLENBQUM7QUFDN0YsQ0FBQztBQUZELGdFQUVDO0FBUUQseUJBQWdDLEdBQVE7SUFDcEMsT0FBTyxxQ0FBc0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLHdCQUF3QixDQUFDO0FBQ2xGLENBQUM7QUFGRCwwQ0FFQztBQVFELHlCQUFnQyxHQUFRO0lBQ3BDLE9BQU8scUNBQXNCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyx3QkFBd0IsQ0FBQztBQUNsRixDQUFDO0FBRkQsMENBRUM7QUFVRCxtQ0FBMEMsR0FBUTtJQUM5QyxPQUFPLHFDQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssa0NBQWtDLENBQUM7QUFDNUYsQ0FBQztBQUZELDhEQUVDO0FBUUQsb0NBQTJDLEdBQVE7SUFDL0MsT0FBTyxxQ0FBc0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLG1DQUFtQyxDQUFDO0FBQzdGLENBQUM7QUFGRCxnRUFFQyJ9

/***/ }),

/***/ "./src/lib/types/events/IReplayEvent.ts":
/*!**********************************************!*\
  !*** ./src/lib/types/events/IReplayEvent.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isIReplayEvent(obj) {
    return '_event' in obj && obj._event.indexOf('NNet.') === 0;
}
exports.isIReplayEvent = isIReplayEvent;
function isIReplayUserEvent(obj) {
    return isIReplayEvent(obj) && '_userid' in obj;
}
exports.isIReplayUserEvent = isIReplayUserEvent;
function isIReplayGameEventBase(obj) {
    return isIReplayEvent(obj) && obj._event.indexOf('NNet.Game.') === 0;
}
exports.isIReplayGameEventBase = isIReplayGameEventBase;
function isIReplayTrackerEvent(obj) {
    return isIReplayEvent(obj) && obj._event.indexOf('NNet.Replay.Tracker.') === 0;
}
exports.isIReplayTrackerEvent = isIReplayTrackerEvent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSVJlcGxheUV2ZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiSVJlcGxheUV2ZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBUUEsd0JBQStCLEdBQVE7SUFDbkMsT0FBTyxRQUFRLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBRkQsd0NBRUM7QUFPRCw0QkFBbUMsR0FBUTtJQUN2QyxPQUFPLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxTQUFTLElBQUksR0FBRyxDQUFDO0FBQ25ELENBQUM7QUFGRCxnREFFQztBQUtELGdDQUF1QyxHQUFRO0lBQzNDLE9BQU8sY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6RSxDQUFDO0FBRkQsd0RBRUM7QUFJRCwrQkFBc0MsR0FBUTtJQUMxQyxPQUFPLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNuRixDQUFDO0FBRkQsc0RBRUMifQ==

/***/ }),

/***/ "./src/lib/types/events/ITrackerEvents.ts":
/*!************************************************!*\
  !*** ./src/lib/types/events/ITrackerEvents.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IReplayEvent_1 = __webpack_require__(/*! ./IReplayEvent */ "./src/lib/types/events/IReplayEvent.ts");
const linq = __webpack_require__(/*! linq */ "./node_modules/linq/linq.js");
function isSUnitBornEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SUnitBornEvent';
}
exports.isSUnitBornEvent = isSUnitBornEvent;
function isSUnitDiedEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SUnitDiedEvent';
}
exports.isSUnitDiedEvent = isSUnitDiedEvent;
function isSScoreResultEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SScoreResultEvent';
}
exports.isSScoreResultEvent = isSScoreResultEvent;
function isSHeroBannedEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SHeroBannedEvent';
}
exports.isSHeroBannedEvent = isSHeroBannedEvent;
function isSHeroPickedEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SHeroPickedEvent';
}
exports.isSHeroPickedEvent = isSHeroPickedEvent;
function isSStatGameEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SStatGameEvent';
}
exports.isSStatGameEvent = isSStatGameEvent;
function isPeriodicXPBreakdownSStatGameEvent(obj) {
    return isSStatGameEvent(obj) && obj.m_eventName === 'PeriodicXPBreakdown';
}
exports.isPeriodicXPBreakdownSStatGameEvent = isPeriodicXPBreakdownSStatGameEvent;
function isEndOfGameXPBreakdownSStatGameEvent(obj) {
    return isSStatGameEvent(obj) && obj.m_eventName === 'EndOfGameXPBreakdown';
}
exports.isEndOfGameXPBreakdownSStatGameEvent = isEndOfGameXPBreakdownSStatGameEvent;
function isGameStartSStatGameEvent(obj) {
    return isSStatGameEvent(obj) && obj.m_eventName === 'GameStart';
}
exports.isGameStartSStatGameEvent = isGameStartSStatGameEvent;
function getSStatValue(from, key, asFloat = false) {
    if (from) {
        var r = linq.from(from).singleOrDefault(_ => _.m_key === key);
        if (r) {
            if (asFloat && typeof r.m_value === 'number') {
                return (r.m_value / 4096);
            }
            return r.m_value;
        }
    }
    return undefined;
}
exports.getSStatValue = getSStatValue;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSVRyYWNrZXJFdmVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJJVHJhY2tlckV2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlEQUE0RTtBQUM1RSw2QkFBNkI7QUFhN0IsMEJBQWlDLEdBQVE7SUFDckMsT0FBTyxvQ0FBcUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLG9DQUFvQyxDQUFDO0FBQzdGLENBQUM7QUFGRCw0Q0FFQztBQWFELDBCQUFpQyxHQUFRO0lBQ3JDLE9BQU8sb0NBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxvQ0FBb0MsQ0FBQztBQUM3RixDQUFDO0FBRkQsNENBRUM7QUFnQkQsNkJBQW9DLEdBQVE7SUFDeEMsT0FBTyxvQ0FBcUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLHVDQUF1QyxDQUFDO0FBQ2hHLENBQUM7QUFGRCxrREFFQztBQVNELDRCQUFtQyxHQUFRO0lBQ3ZDLE9BQU8sb0NBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxzQ0FBc0MsQ0FBQztBQUMvRixDQUFDO0FBRkQsZ0RBRUM7QUFVRCw0QkFBbUMsR0FBUTtJQUN2QyxPQUFPLG9DQUFxQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssc0NBQXNDLENBQUM7QUFDL0YsQ0FBQztBQUZELGdEQUVDO0FBaUJELDBCQUFpQyxHQUFRO0lBQ3JDLE9BQU8sb0NBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxvQ0FBb0MsQ0FBQztBQUM3RixDQUFDO0FBRkQsNENBRUM7QUFFRCw2Q0FBb0QsR0FBUTtJQUN4RCxPQUFPLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxXQUFXLEtBQUsscUJBQXFCLENBQUM7QUFDOUUsQ0FBQztBQUZELGtGQUVDO0FBRUQsOENBQXFELEdBQVE7SUFDekQsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsV0FBVyxLQUFLLHNCQUFzQixDQUFDO0FBQy9FLENBQUM7QUFGRCxvRkFFQztBQUVELG1DQUEwQyxHQUFRO0lBQzlDLE9BQU8sZ0JBQWdCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLFdBQVcsS0FBSyxXQUFXLENBQUM7QUFDcEUsQ0FBQztBQUZELDhEQUVDO0FBRUQsdUJBQWlDLElBQThCLEVBQUUsR0FBVyxFQUFFLFVBQW1CLEtBQUs7SUFDbEcsSUFBSSxJQUFJLEVBQUU7UUFDTixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLEVBQUU7WUFDSCxJQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFDO2dCQUN4QyxPQUFlLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQzthQUNyQztZQUNELE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQztTQUNwQjtLQUNKO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDckIsQ0FBQztBQVhELHNDQVdDIn0=

/***/ }),

/***/ "./src/lib/types/events/index.ts":
/*!***************************************!*\
  !*** ./src/lib/types/events/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./IReplayEvent */ "./src/lib/types/events/IReplayEvent.ts"));
__export(__webpack_require__(/*! ./IMessageEvents */ "./src/lib/types/events/IMessageEvents.ts"));
__export(__webpack_require__(/*! ./FilteredEvents */ "./src/lib/types/events/FilteredEvents.ts"));
__export(__webpack_require__(/*! ./ITrackerEvents */ "./src/lib/types/events/ITrackerEvents.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUErQjtBQUMvQixzQ0FBaUM7QUFDakMsc0NBQWlDO0FBQ2pDLHNDQUFpQyJ9

/***/ }),

/***/ "./src/lib/types/index.ts":
/*!********************************!*\
  !*** ./src/lib/types/index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./events */ "./src/lib/types/events/index.ts"));
__export(__webpack_require__(/*! ./type */ "./src/lib/types/type.ts"));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUtBLDhCQUF5QjtBQUN6Qiw0QkFBdUIifQ==

/***/ }),

/***/ "./src/lib/types/type.ts":
/*!*******************************!*\
  !*** ./src/lib/types/type.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = Function;
function isType(v) {
    return typeof v === 'function';
}
exports.isType = isType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInR5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBYSxRQUFBLElBQUksR0FBRyxRQUFRLENBQUM7QUFFN0IsZ0JBQXVCLENBQU07SUFDM0IsT0FBTyxPQUFPLENBQUMsS0FBSyxVQUFVLENBQUM7QUFDakMsQ0FBQztBQUZELHdCQUVDIn0=

/***/ }),

/***/ "./src/webworker/worker.ts":
/*!*********************************!*\
  !*** ./src/webworker/worker.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const lib_1 = __webpack_require__(/*! ../lib */ "./src/lib/index.ts");
let replayWorker;
addEventListener('message', (evt) => __awaiter(this, void 0, void 0, function* () {
    try {
        if (!replayWorker && lib_1.isInitializeCommand(evt.data)) {
            replayWorker = new lib_1.ReplayWorker(evt.data);
            postMessage('WORKER_INITIALIZED');
        }
    }
    catch (e) {
        console.error(e);
    }
}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid29ya2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxnQ0FBMkQ7QUFFM0QsSUFBSSxZQUEwQixDQUFDO0FBQy9CLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFPLEdBQUcsRUFBRSxFQUFFO0lBQ3RDLElBQUk7UUFDQSxJQUFJLENBQUMsWUFBWSxJQUFJLHlCQUFtQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNoRCxZQUFZLEdBQUcsSUFBSSxrQkFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxQyxXQUFXLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUNyQztLQUNKO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDUixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0FBQ0wsQ0FBQyxDQUFBLENBQUMsQ0FBQyJ9

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoZXJvZXNicm93c2VyL21wcS9kaXN0L2RhdGEvaGVhZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhlcm9lc2Jyb3dzZXIvbXBxL2Rpc3QvZGF0YS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhlcm9lc2Jyb3dzZXIvbXBxL2Rpc3QvZGF0YS90YWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoZXJvZXNicm93c2VyL21wcS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGVyb2VzYnJvd3Nlci9tcHEvZGlzdC9tcHEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdC9jcnlwdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL21haW4yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0JXVC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9CV1RDLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0JpdFN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9CemlwMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9DUkMzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9Db250ZXh0MU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0RlZlN1bU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0RlZmxhdGVEaXN0YW5jZU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0RtYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9EdW1teVJhbmdlQ29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2tleWJhc2UtY29tcHJlc3Nqcy9vdXRsaWIvRmVud2lja01vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0h1ZmZtYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2tleWJhc2UtY29tcHJlc3Nqcy9vdXRsaWIvSHVmZm1hbkFsbG9jYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9Mb2dEaXN0YW5jZU1vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL0x6amIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2tleWJhc2UtY29tcHJlc3Nqcy9vdXRsaWIvTHpqYlIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2tleWJhc2UtY29tcHJlc3Nqcy9vdXRsaWIvTHpwMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9NVEZNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9Ob01vZGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL1BQTS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9SYW5nZUNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWNvbXByZXNzanMvb3V0bGliL1NpbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9TdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2tleWJhc2UtY29tcHJlc3Nqcy9vdXRsaWIvVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva2V5YmFzZS1jb21wcmVzc2pzL291dGxpYi9mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbnEvbGlucS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL0FzeW5jU3ViamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9CZWhhdmlvclN1YmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvSW5uZXJTdWJzY3JpYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL05vdGlmaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL09ic2VydmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL091dGVyU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9SZXBsYXlTdWJqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL1NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9BcnJheUxpa2VPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvRW1wdHlPYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvRnJvbU9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9JdGVyYXRvck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Qcm9taXNlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1NjYWxhck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9UaW1lck9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS90aW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2F1ZGl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9hdWRpdFRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvYnVmZmVyQ291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2J1ZmZlclRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2J1ZmZlclRvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvYnVmZmVyV2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY2F0Y2hFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY29tYmluZUFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY29tYmluZUxhdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY29uY2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9jb25jYXRBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2NvbmNhdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvY29uY2F0TWFwVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2NvdW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZGVsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2RlbGF5V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZGVtYXRlcmlhbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZGlzdGluY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZWxlbWVudEF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZXhoYXVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZXhoYXVzdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvZXhwYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2ZpbmFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9maW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL2ZpcnN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9ncm91cEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9pZ25vcmVFbGVtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9tYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWF0ZXJpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL21heC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL21lcmdlQWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9tZXJnZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWVyZ2VNYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvbWVyZ2VTY2FuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL211bHRpY2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvb2JzZXJ2ZU9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9vbkVycm9yUmVzdW1lTmV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcGFpcndpc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3BhcnRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcGx1Y2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3B1Ymxpc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3B1Ymxpc2hCZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcHVibGlzaExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3B1Ymxpc2hSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcmVmQ291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3JlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcmVwZWF0V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvcmV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3JldHJ5V2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2FtcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zYW1wbGVUaW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zY2FuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zZXF1ZW5jZUVxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zaGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2hhcmVSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3NpbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2tpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2tpcExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3NraXBVbnRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc2tpcFdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zdGFydFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3N3aXRjaEFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvc3dpdGNoTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy9zd2l0Y2hNYXBUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdGFrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdGFrZUxhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3Rha2VVbnRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdGFrZVdoaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy90YXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3Rocm90dGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy90aHJvdHRsZVRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3RpbWVJbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdGltZW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdGltZW91dFdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3JzL3RpbWVzdGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvdG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvd2luZG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy93aW5kb3dDb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvd2luZG93VGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvd2luZG93VG9nZ2xlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy93aW5kb3dXaGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvcnMvemlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9ycy96aXBBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9RdWV1ZUFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvUXVldWVTY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL29ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL3J4U3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvRW1wdHlFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL0Zhc3RNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9NYXBQb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvVGltZW91dEVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2Vycm9yT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNOdW1lcmljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc1NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL25vb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9ub3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9waXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3N1YnNjcmliZVRvUmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdG9TdWJzY3JpYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYTEvc2hhMS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2RlY29kZXIvQWJzdHJhY3REZWNvZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvZGVjb2Rlci9CaXRQYWNrZWRCdWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9kZWNvZGVyL0JpdFBhY2tlZERlY29kZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9kZWNvZGVyL1ZlcnNpb25EZWNvZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvZGVjb2Rlci9lcnJvcnMvQ29ycnVwdGVkRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9kZWNvZGVyL2Vycm9ycy9UcnVuY2F0ZUVycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvZGVjb2Rlci9lcnJvcnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9kZWNvZGVyL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvaGVyb3Byb3RvY29sLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9wcm90b2NvbHMvUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9wcm90b2NvbHMvZGVjb2RlcnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvUmVwbGF5LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2FuYWx5emVycy9BYnN0cmFjdFJlcGxheUFuYWx5c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2FuYWx5emVycy9idWlsdGluL0Jhc2ljUmVwbGF5QW5hbHlzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvYW5hbHl6ZXJzL2J1aWx0aW4vQ2hhdEFuYWx5c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2FuYWx5emVycy9idWlsdGluL0RyYWZ0QW5hbHlzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvYW5hbHl6ZXJzL2J1aWx0aW4vUGxheWVyQW5hbHlzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvYW5hbHl6ZXJzL2J1aWx0aW4vUmVwbGF5TWFwQW5hbHlzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvYW5hbHl6ZXJzL2J1aWx0aW4vU2NvcmVBbmFseXNlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9hbmFseXplcnMvYnVpbHRpbi9UYWxlbnRBbmFseXNlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9hbmFseXplcnMvYnVpbHRpbi9YUEFuYWx5c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2FuYWx5emVycy9idWlsdGluL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2FuYWx5emVycy9kZWNvcmF0b3JzLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2FuYWx5emVycy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9hbmFseXplcnMvdHlwZXMvR2FtZVR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvYW5hbHl6ZXJzL3R5cGVzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2RlY29yYXRvcnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvZXJyb3JzL0ZhaWxlZFRvTG9hZFByb3RvY29sRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvZXJyb3JzL0dhbWVUeXBlTm90U3VwcG9ydGVkRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvZXJyb3JzL0ludmFsaWRFeGVjdXRpb25Db250ZXh0RXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvZXJyb3JzL01hcE5vdFN1cHBvcnRlZEVycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2Vycm9ycy9SZXBsYXlWZXJzaW9uT3V0T2ZSYW5nZUVycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L2Vycm9ycy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9wcm94eS9SZXBsYXlBbmFseXNlckNvbnRleHRDYWxsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvcHJveHkvUmVwbGF5Q29udGV4dENhbGxlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9wcm94eS9SZXBsYXlXb3JrZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvcHJveHkvY29udGV4dC9Xb3JrZXJDb250ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L3Byb3h5L2NvbnRleHQvV29ya2VyQ29udGV4dFJlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L3Byb3h5L2Vycm9yL1Byb3hpYWJsZUVycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L3Byb3h5L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L3Byb3h5L21lc3NhZ2VzL2NhbGwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZXBsYXkvcHJveHkvbWVzc2FnZXMvY21kcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9wcm94eS9tZXNzYWdlcy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS9wcm94eS9tZXNzYWdlcy9pbml0LnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L3Byb3h5L21lc3NhZ2VzL3Byb3RvY29sLnRzIiwid2VicGFjazovLy8uL3NyYy9saWIvcmVwbGF5L3Byb3h5L21lc3NhZ2VzL3N0YXR1cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlcGxheS91dGlsL1JlcGxheUF0dHJpYnV0ZUhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3R5cGVzL2V2ZW50cy9GaWx0ZXJlZEV2ZW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3R5cGVzL2V2ZW50cy9JTWVzc2FnZUV2ZW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3R5cGVzL2V2ZW50cy9JUmVwbGF5RXZlbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi90eXBlcy9ldmVudHMvSVRyYWNrZXJFdmVudHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi90eXBlcy9ldmVudHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi90eXBlcy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3R5cGVzL3R5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3dlYndvcmtlci93b3JrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsYUFBYTs7Ozs7Ozs7Ozs7OztBQ3JDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBOztBQUVBLDJDQUEyQyxhQUFhOzs7Ozs7Ozs7Ozs7O0FDUnhEO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLGFBQWE7Ozs7Ozs7Ozs7Ozs7QUN0QnhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTs7QUFFQSwyQ0FBMkMsYUFBYTs7Ozs7Ozs7Ozs7OztBQ1J4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWSxFQUFFO0FBQy9DLCtDQUErQyxjQUFjLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWSxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLE9BQU8sb0JBQW9CO0FBQ3pELGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQTJEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEIsRUFBRTtBQUM5RDtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsZUFBZSxnQkFBZ0IsT0FBTyxVQUFVO0FBQ2hEO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxPQUFPLGFBQWE7QUFDOUM7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsT0FBTztBQUNQLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLHlCQUF5QixrQkFBa0I7QUFDM0Msd0JBQXdCLGtCQUFrQjtBQUMxQyx3QkFBd0Isa0JBQWtCO0FBQzFDLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsT0FBTyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQixPQUFPLFVBQVUsRUFBRTtBQUMvQyxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUIsT0FBTyxnQkFBZ0IsT0FBTyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQztBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBZ0Q7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUSxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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LG1FQUFtRSxjQUFjLEVBQUU7QUFDbkY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2QkFBNkIsMkJBQTJCLEVBQUU7QUFDMUQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIscUNBQXFDLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLDZCQUE2QiwyQkFBMkIsRUFBRTtBQUMxRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIscUNBQXFDLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2QkFBNkIsMkJBQTJCLEVBQUU7QUFDMUQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIscUNBQXFDLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZCQUE2QiwyQkFBMkIsRUFBRTtBQUMxRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDJDQUEyQyxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLDJCQUEyQixFQUFFO0FBQzFELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWUsRUFBRTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLDJCQUEyQixFQUFFO0FBQzFELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLDJCQUEyQixFQUFFO0FBQzFELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIscUNBQXFDLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLDJCQUEyQixFQUFFO0FBQzFELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSw4Q0FBOEMsa0NBQWtDLEVBQUU7QUFDbEYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsaUNBQWlDLEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzV2REEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtREFBbUQ7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLDZCQUE2QixnQkFBZ0Isa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUE0QztBQUMzRTtBQUNBLG1DQUFtQyx3QkFBd0Isa0JBQWtCLEVBQUU7QUFDL0UsbUNBQW1DLHlCQUF5QixFQUFFLEVBQUU7QUFDaEU7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFLHVDQUF1QyxtQkFBbUIsRUFBRTtBQUM1RDtBQUNBLHVDQUF1QyxxREFBcUQ7QUFDNUYsdUNBQXVDLGlCQUFpQixFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1QkFBdUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRixxRUFBcUUsYUFBYTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtCQUFrQjtBQUNsQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxtQkFBbUI7QUFDbEMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7Ozs7Ozs7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0M7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQzs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrRUFBa0U7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFDOzs7Ozs7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQsc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUM7Ozs7Ozs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHFCQUFxQjtBQUM3QixRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsV0FBVztBQUN0QixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0VBQWdFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9DOzs7Ozs7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRFQUE0RTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0Q7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQXFCO0FBQzdCLFFBQVEscUJBQXFCO0FBQzdCLFFBQVEscUJBQXFCO0FBQzdCLFFBQVEscUJBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUIsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxzQkFBc0I7QUFDOUIsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSw4REFBOEQsRUFBRTtBQUN4STtBQUNBO0FBQ0EsbUQ7Ozs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdFQUFnRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUM7Ozs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLElBQUk7QUFDZixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQW1FO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQzs7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQStDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUM7Ozs7Ozs7Ozs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0E7QUFDQSxXQUFXLG9GQUFvRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUVBQXlFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDOzs7Ozs7Ozs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVDQUF1QztBQUN2RSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0EsOEJBQThCLHdFQUF3RTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQzs7Ozs7Ozs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQzs7Ozs7Ozs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFtRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQzs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxrRUFBa0U7QUFDN0U7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhFQUE4RTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQzs7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNUO0FBQ0EsV0FBVyxrRUFBa0U7QUFDN0U7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9GQUFvRjtBQUNsSDtBQUNBO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3RkFBd0Y7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDOzs7Ozs7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0MsdUJBQXVCLG1CQUFtQjtBQUMxQyx1QkFBdUIsbUJBQW1CO0FBQzFDLHVCQUF1QixvQkFBb0I7QUFDM0MsdUJBQXVCLG1CQUFtQjtBQUMxQyx1QkFBdUIsc0JBQXNCO0FBQzdDLHVCQUF1QixvQkFBb0I7QUFDM0MsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CLFNBQVMsc0JBQXNCO0FBQy9CLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUIsU0FBUyxxQkFBcUI7QUFDOUIsU0FBUyx3QkFBd0I7QUFDakMsU0FBUywwQkFBMEI7QUFDbkM7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyx1QkFBdUIsbUJBQW1CO0FBQzFDLHVCQUF1QixtQkFBbUI7QUFDMUMsdUJBQXVCLG9CQUFvQjtBQUMzQyx1QkFBdUIsbUJBQW1CO0FBQzFDLHVCQUF1QixzQkFBc0I7QUFDN0MsdUJBQXVCLG9CQUFvQjtBQUMzQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQSxXQUFXLDJEQUEyRDtBQUN0RTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQzs7Ozs7Ozs7Ozs7O0FDblJBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFB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QUFDQSxnREFBZ0QsV0FBVyxFQUFFO0FBQzdELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQsMEJBQTBCLG9DQUFvQztBQUM5RCwwQkFBMEIsb0NBQW9DO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0Y7QUFDQTs7Ozs7Ozs7Ozs7OztBQzN5Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDakZEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtdEM7Ozs7Ozs7Ozs7OztBQ2pDM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDIzRzs7Ozs7Ozs7Ozs7O0FDMUUzQztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrOUc7Ozs7Ozs7Ozs7OztBQ2hGM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtaFM7Ozs7Ozs7Ozs7OztBQ2hSM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixpRUFBaUUsdUJBQXVCLEVBQUUsNEJBQTRCO0FBQ3JKO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdWtLOzs7Ozs7Ozs7Ozs7QUMvTzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IsaUVBQWlFLHVCQUF1QixFQUFFLDRCQUE0QjtBQUNySjtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK3BJOzs7Ozs7Ozs7Ozs7QUN0SjNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IsaUVBQWlFLHVCQUF1QixFQUFFLDRCQUE0QjtBQUNySjtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG03Rjs7Ozs7Ozs7Ozs7O0FDNUYzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLGlFQUFpRSx1QkFBdUIsRUFBRSw0QkFBNEI7QUFDcko7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbStKOzs7Ozs7Ozs7Ozs7QUMzSTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IsaUVBQWlFLHVCQUF1QixFQUFFLDRCQUE0QjtBQUNySjtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1REFBdUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCsySjs7Ozs7Ozs7Ozs7O0FDdEkzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLGlFQUFpRSx1QkFBdUIsRUFBRSw0QkFBNEI7QUFDcko7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sR0FBRyxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVMsR0FBRyxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtbUw7Ozs7Ozs7Ozs7OztBQ25IM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVSOzs7Ozs7Ozs7Ozs7QUNiM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHU0Qzs7Ozs7Ozs7Ozs7O0FDckMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtNOzs7Ozs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrekw7Ozs7Ozs7Ozs7OztBQzFKM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyck47Ozs7Ozs7Ozs7OztBQzFLM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdXlDOzs7Ozs7Ozs7Ozs7QUNoQzNDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMlY7Ozs7Ozs7Ozs7OztBQ1QzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrTDs7Ozs7Ozs7Ozs7O0FDUjNDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsKzhCOzs7Ozs7Ozs7Ozs7QUNsQjNDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCt6Qjs7Ozs7Ozs7Ozs7O0FDcEIzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbU87Ozs7Ozs7Ozs7OztBQ1YzQztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtUOzs7Ozs7Ozs7Ozs7QUNOM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxta0I7Ozs7Ozs7Ozs7OztBQ2xCM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtUzs7Ozs7Ozs7Ozs7O0FDTjNDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdWhGOzs7Ozs7Ozs7Ozs7QUM1RDNDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1akI7Ozs7Ozs7Ozs7OztBQ3pCM0M7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1zQzs7Ozs7Ozs7Ozs7O0FDbEMzQztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCt4Qjs7Ozs7Ozs7Ozs7O0FDbEIzQztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1L0Q7Ozs7Ozs7Ozs7OztBQ3JEM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrTTs7Ozs7Ozs7Ozs7O0FDVDNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBLDJDQUEyQywrSzs7Ozs7Ozs7Ozs7O0FDUDNDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtUjs7Ozs7Ozs7Ozs7O0FDUDNDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixpRUFBaUUsdUJBQXVCLEVBQUUsNEJBQTRCO0FBQ3JKO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJDQUEyQyxtbUIiLCJmaWxlIjoicmVwbGF5LXdvcmtlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImFzc2V0cy9yZXBsYXktd29ya2VyXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL3dlYndvcmtlci93b3JrZXIudHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE1QUVVzZXJEYXRhSGVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMubWFnaWMgPSBkYXRhLnRvU3RyaW5nKCd1dGY4JywgMCwgNCk7XG4gICAgICAgIHRoaXMudXNlckRhdGFTaXplID0gZGF0YS5yZWFkVUludDMyTEUoNCk7XG4gICAgICAgIHRoaXMubXBxSGVhZGVyT2Zmc2V0ID0gZGF0YS5yZWFkVUludDMyTEUoOCk7XG4gICAgICAgIHRoaXMudXNlckRhdGFIZWFkZXJTaXplID0gZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTVBRVXNlckRhdGFIZWFkZXIgPSBNUFFVc2VyRGF0YUhlYWRlcjtcbmNsYXNzIE1QUUZpbGVIZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubWFnaWMgPSBkYXRhLnRvU3RyaW5nKCd1dGY4JywgMCwgNCk7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclNpemUgPSBkYXRhLnJlYWRVSW50MzJMRSg0KTtcbiAgICAgICAgICAgIHRoaXMuYXJjaGl2ZVNpemUgPSBkYXRhLnJlYWRVSW50MzJMRSg4KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0VmVyc2lvbiA9IGRhdGEucmVhZFVJbnQxNkxFKDEyKTtcbiAgICAgICAgICAgIHRoaXMuc2VjdG9yU2l6ZVNoaWZ0ID0gZGF0YS5yZWFkVUludDE2TEUoMTQpO1xuICAgICAgICAgICAgdGhpcy5oYXNoVGFibGVPZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRSgxNik7XG4gICAgICAgICAgICB0aGlzLmJsb2NrVGFibGVPZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRSgyMCk7XG4gICAgICAgICAgICB0aGlzLmhhc2hUYWJsZUVudHJpZXMgPSBkYXRhLnJlYWRVSW50MzJMRSgyNCk7XG4gICAgICAgICAgICB0aGlzLmJsb2NrVGFibGVFbnRyaWVzID0gZGF0YS5yZWFkVUludDMyTEUoMjgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NUFFGaWxlSGVhZGVyID0gTVBRRmlsZUhlYWRlcjtcbmNsYXNzIE1QUUZpbGVIZWFkZXJFeHQgZXh0ZW5kcyBNUFFGaWxlSGVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuICAgICAgICB0aGlzLmV4dGVuZGVkQmxvY2tUYWJsZU9mZnNldCA9IGRhdGEucmVhZEludExFKDAsIDgpO1xuICAgICAgICB0aGlzLmhhc2hUYWJsZU9mZnNldEhpZ2ggPSBkYXRhLnJlYWRJbnQ4KDgpO1xuICAgICAgICB0aGlzLmJsb2NrVGFibGVPZmZzZXRIaWdoID0gZGF0YS5yZWFkSW50OCgxMCk7XG4gICAgfVxufVxuZXhwb3J0cy5NUFFGaWxlSGVhZGVyRXh0ID0gTVBRRmlsZUhlYWRlckV4dDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbVJoZEdFdmFHVmhaR1Z5Y3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVVZCTzBsQlQwa3NXVUZCYlVJc1NVRkJXVHRSUVVNelFpeEpRVUZKTEVOQlFVTXNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZWtNc1NVRkJTU3hEUVVGRExHVkJRV1VzUjBGQlJ5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRelZETEVsQlFVa3NRMEZCUXl4clFrRkJhMElzUjBGQlJ5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRM0JFTEVOQlFVTTdRMEZGU2p0QlFXUkVMRGhEUVdORE8wRkJSVVE3U1VGWlNTeFpRVUZ0UWl4SlFVRlpPMUZCUXpOQ0xFbEJRVWtzU1VGQlNTeEZRVUZGTzFsQlEwNHNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVrTXNTVUZCU1N4RFFVRkRMRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNaRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU40UXl4SlFVRkpMRU5CUVVNc1lVRkJZU3hIUVVGSExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNME1zU1VGQlNTeERRVUZETEdWQlFXVXNSMEZCUnl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6ZERMRWxCUVVrc1EwRkJReXhsUVVGbExFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVNM1F5eEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVNNVF5eEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVNNVF5eEpRVUZKTEVOQlFVTXNhVUpCUVdsQ0xFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVOc1JEdEpRVU5NTEVOQlFVTTdRMEZEU2p0QlFYcENSQ3h6UTBGNVFrTTdRVUZGUkN4elFrRkJPRUlzVTBGQlVTeGhRVUZoTzBsQlN5OURMRmxCUVcxQ0xFbEJRVms3VVVGRE0wSXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMW9zU1VGQlNTeERRVUZETEhkQ1FVRjNRaXhIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pFTEVsQlFVa3NRMEZCUXl4dFFrRkJiVUlzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRelZETEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRMnhFTEVOQlFVTTdRMEZEU2p0QlFWaEVMRFJEUVZkRElpd2labWxzWlNJNkltUmhkR0V2YUdWaFpHVnljeTVxY3lJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltbHRjRzl5ZENCN0lFSjFabVpsY2lCOUlHWnliMjBnSjJKMVptWmxjaWM3WEhKY2JseHlYRzVsZUhCdmNuUWdZMnhoYzNNZ1RWQlJWWE5sY2tSaGRHRklaV0ZrWlhJZ2UxeHlYRzRnSUNBZ2NIVmliR2xqSUcxaFoybGpPaUJ6ZEhKcGJtYzdYSEpjYmlBZ0lDQndkV0pzYVdNZ2RYTmxja1JoZEdGVGFYcGxPaUJ1ZFcxaVpYSTdYSEpjYmlBZ0lDQndkV0pzYVdNZ2JYQnhTR1ZoWkdWeVQyWm1jMlYwT2lCdWRXMWlaWEk3WEhKY2JpQWdJQ0J3ZFdKc2FXTWdkWE5sY2tSaGRHRklaV0ZrWlhKVGFYcGxPaUJ1ZFcxaVpYSTdYSEpjYmlBZ0lDQndkV0pzYVdNZ1kyOXVkR1Z1ZERvZ1FuVm1abVZ5TzF4eVhHNWNjbHh1SUNBZ0lIQjFZbXhwWXlCamIyNXpkSEoxWTNSdmNpaGtZWFJoT2lCQ2RXWm1aWElwSUh0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG0xaFoybGpJRDBnWkdGMFlTNTBiMU4wY21sdVp5Z25kWFJtT0Njc0lEQXNJRFFwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11ZFhObGNrUmhkR0ZUYVhwbElEMGdaR0YwWVM1eVpXRmtWVWx1ZERNeVRFVW9OQ2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTV0Y0hGSVpXRmtaWEpQWm1aelpYUWdQU0JrWVhSaExuSmxZV1JWU1c1ME16Sk1SU2c0S1R0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG5WelpYSkVZWFJoU0dWaFpHVnlVMmw2WlNBOUlHUmhkR0V1Y21WaFpGVkpiblF6TWt4RktERXlLVHRjY2x4dUlDQWdJSDFjY2x4dVhISmNibjFjY2x4dVhISmNibVY0Y0c5eWRDQmpiR0Z6Y3lCTlVGRkdhV3hsU0dWaFpHVnlJSHRjY2x4dUlDQWdJSEIxWW14cFl5QnRZV2RwWXpvZ2MzUnlhVzVuTzF4eVhHNGdJQ0FnY0hWaWJHbGpJR2hsWVdSbGNsTnBlbVU2SUc1MWJXSmxjanRjY2x4dUlDQWdJSEIxWW14cFl5QmhjbU5vYVhabFUybDZaVG9nYm5WdFltVnlPMXh5WEc0Z0lDQWdjSFZpYkdsaklITmxZM1J2Y2xOcGVtVlRhR2xtZERvZ2JuVnRZbVZ5TzF4eVhHNGdJQ0FnY0hWaWJHbGpJR2hoYzJoVVlXSnNaVTltWm5ObGREb2diblZ0WW1WeU8xeHlYRzRnSUNBZ2NIVmliR2xqSUdKc2IyTnJWR0ZpYkdWUFptWnpaWFE2SUc1MWJXSmxjanRjY2x4dUlDQWdJSEIxWW14cFl5Qm9ZWE5vVkdGaWJHVkZiblJ5YVdWek9pQnVkVzFpWlhJN1hISmNiaUFnSUNCd2RXSnNhV01nWW14dlkydFVZV0pzWlVWdWRISnBaWE02SUc1MWJXSmxjanRjY2x4dUlDQWdJSEIxWW14cFl5QnZabVp6WlhRNklHNTFiV0psY2p0Y2NseHVJQ0FnSUhCMVlteHBZeUJtYjNKdFlYUldaWEp6YVc5dU9pQnVkVzFpWlhJN1hISmNiaUFnSUNCd2RXSnNhV01nZFhObGNrUmhkR0ZJWldGa1pYSTZJRTFRVVZWelpYSkVZWFJoU0dWaFpHVnlPMXh5WEc0Z0lDQWdjSFZpYkdsaklHTnZibk4wY25WamRHOXlLR1JoZEdFNklFSjFabVpsY2lrZ2UxeHlYRzRnSUNBZ0lDQWdJR2xtSUNoa1lYUmhLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWJXRm5hV01nUFNCa1lYUmhMblJ2VTNSeWFXNW5LQ2QxZEdZNEp5d2dNQ3dnTkNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVhR1ZoWkdWeVUybDZaU0E5SUdSaGRHRXVjbVZoWkZWSmJuUXpNa3hGS0RRcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUZ5WTJocGRtVlRhWHBsSUQwZ1pHRjBZUzV5WldGa1ZVbHVkRE15VEVVb09DazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11Wm05eWJXRjBWbVZ5YzJsdmJpQTlJR1JoZEdFdWNtVmhaRlZKYm5ReE5reEZLREV5S1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXpaV04wYjNKVGFYcGxVMmhwWm5RZ1BTQmtZWFJoTG5KbFlXUlZTVzUwTVRaTVJTZ3hOQ2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWFHRnphRlJoWW14bFQyWm1jMlYwSUQwZ1pHRjBZUzV5WldGa1ZVbHVkRE15VEVVb01UWXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1Kc2IyTnJWR0ZpYkdWUFptWnpaWFFnUFNCa1lYUmhMbkpsWVdSVlNXNTBNekpNUlNneU1DazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11YUdGemFGUmhZbXhsUlc1MGNtbGxjeUE5SUdSaGRHRXVjbVZoWkZWSmJuUXpNa3hGS0RJMEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTVpYkc5amExUmhZbXhsUlc1MGNtbGxjeUE5SUdSaGRHRXVjbVZoWkZWSmJuUXpNa3hGS0RJNEtUdGNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1WEhKY2JtVjRjRzl5ZENCamJHRnpjeUJOVUZGR2FXeGxTR1ZoWkdWeVJYaDBJR1Y0ZEdWdVpITWdUVkJSUm1sc1pVaGxZV1JsY2lCN1hISmNiaUFnSUNCd2RXSnNhV01nWlhoMFpXNWtaV1JDYkc5amExUmhZbXhsVDJabWMyVjBPaUJ1ZFcxaVpYSTdYSEpjYmlBZ0lDQndkV0pzYVdNZ2FHRnphRlJoWW14bFQyWm1jMlYwU0dsbmFEb2diblZ0WW1WeU8xeHlYRzRnSUNBZ2NIVmliR2xqSUdKc2IyTnJWR0ZpYkdWUFptWnpaWFJJYVdkb09pQnVkVzFpWlhJN1hISmNibHh5WEc0Z0lDQWdjSFZpYkdsaklHTnZibk4wY25WamRHOXlLR1JoZEdFNklFSjFabVpsY2lrZ2UxeHlYRzRnSUNBZ0lDQWdJSE4xY0dWeUtHNTFiR3dwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WlhoMFpXNWtaV1JDYkc5amExUmhZbXhsVDJabWMyVjBJRDBnWkdGMFlTNXlaV0ZrU1c1MFRFVW9NQ3dnT0NrN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1b1lYTm9WR0ZpYkdWUFptWnpaWFJJYVdkb0lEMGdaR0YwWVM1eVpXRmtTVzUwT0NnNEtUdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxtSnNiMk5yVkdGaWJHVlBabVp6WlhSSWFXZG9JRDBnWkdGMFlTNXlaV0ZrU1c1ME9DZ3hNQ2s3WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1SWwxOVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vaGVhZGVyc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90YWJsZXNcIikpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGY4O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltUmhkR0V2YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN1FVRkJRU3dyUWtGQk1FSTdRVUZETVVJc09FSkJRWGxDSWl3aVptbHNaU0k2SW1SaGRHRXZhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpsZUhCdmNuUWdLaUJtY205dElDY3VMMmhsWVdSbGNuTW5PMXh5WEc1bGVIQnZjblFnS2lCbWNtOXRJQ2N1TDNSaFlteGxjeWM3WEhKY2JpSmRmUT09XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE1QUUhhc2hUYWJsZUVudHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuaGFzaEEgPSBkYXRhLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgdGhpcy5oYXNoQiA9IGRhdGEucmVhZFVJbnQzMkJFKDQpO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGRhdGEucmVhZFVJbnQxNkJFKDgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gZGF0YS5yZWFkVUludDE2QkUoMTApO1xuICAgICAgICB0aGlzLmJsb2NrVGFibGVJbmRleCA9IGRhdGEucmVhZFVJbnQzMkJFKDEyKTtcbiAgICB9XG59XG5leHBvcnRzLk1QUUhhc2hUYWJsZUVudHJ5ID0gTVBRSGFzaFRhYmxlRW50cnk7XG5jbGFzcyBNUFFCbG9ja1RhYmxlRW50cnkge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgdGhpcy5hcmNoaXZlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJCRSg0KTtcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5yZWFkVUludDMyQkUoOCk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBkYXRhLnJlYWRVSW50MzJCRSgxMik7XG4gICAgfVxufVxuZXhwb3J0cy5NUFFCbG9ja1RhYmxlRW50cnkgPSBNUFFCbG9ja1RhYmxlRW50cnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zjg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1SaGRHRXZkR0ZpYkdWekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUlVFN1NVRlBTU3haUVVGdFFpeEpRVUZaTzFGQlF6TkNMRWxCUVVrc1EwRkJReXhMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOc1F5eEpRVUZKTEVOQlFVTXNTMEZCU3l4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMjVETEVsQlFVa3NRMEZCUXl4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTjBReXhKUVVGSkxFTkJRVU1zWlVGQlpTeEhRVUZITEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGFrUXNRMEZCUXp0RFFVTktPMEZCWkVRc09FTkJZME03UVVGRlJEdEpRVXRKTEZsQlFXMUNMRWxCUVZrN1VVRkRNMElzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyNURMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtNc1NVRkJTU3hEUVVGRExFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRM1pETEVOQlFVTTdRMEZEU2p0QlFWaEVMR2RFUVZkRElpd2labWxzWlNJNkltUmhkR0V2ZEdGaWJHVnpMbXB6SWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWFXMXdiM0owSUhzZ1FuVm1abVZ5SUgwZ1puSnZiU0FuWW5WbVptVnlKenRjY2x4dVhISmNibVY0Y0c5eWRDQmpiR0Z6Y3lCTlVGRklZWE5vVkdGaWJHVkZiblJ5ZVNCN1hISmNiaUFnSUNCd2RXSnNhV01nYUdGemFFRTZJRzUxYldKbGNqdGNjbHh1SUNBZ0lIQjFZbXhwWXlCb1lYTm9Ram9nYm5WdFltVnlPMXh5WEc0Z0lDQWdjSFZpYkdsaklHeHZZMkZzWlRvZ2JuVnRZbVZ5TzF4eVhHNGdJQ0FnY0hWaWJHbGpJSEJzWVhSbWIzSnRPaUJ1ZFcxaVpYSTdYSEpjYmlBZ0lDQndkV0pzYVdNZ1lteHZZMnRVWVdKc1pVbHVaR1Y0T2lCdWRXMWlaWEk3WEhKY2JseHlYRzRnSUNBZ2NIVmliR2xqSUdOdmJuTjBjblZqZEc5eUtHUmhkR0U2SUVKMVptWmxjaWtnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11YUdGemFFRWdQU0JrWVhSaExuSmxZV1JWU1c1ME16SkNSU2d3S1R0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TG1oaGMyaENJRDBnWkdGMFlTNXlaV0ZrVlVsdWRETXlRa1VvTkNrN1hISmNiaUFnSUNBZ0lDQWdkR2hwY3k1c2IyTmhiR1VnUFNCa1lYUmhMbkpsWVdSVlNXNTBNVFpDUlNnNEtUdGNjbHh1SUNBZ0lDQWdJQ0IwYUdsekxuQnNZWFJtYjNKdElEMGdaR0YwWVM1eVpXRmtWVWx1ZERFMlFrVW9NVEFwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WW14dlkydFVZV0pzWlVsdVpHVjRJRDBnWkdGMFlTNXlaV0ZrVlVsdWRETXlRa1VvTVRJcE8xeHlYRzRnSUNBZ2ZWeHlYRzU5WEhKY2JseHlYRzVsZUhCdmNuUWdZMnhoYzNNZ1RWQlJRbXh2WTJ0VVlXSnNaVVZ1ZEhKNUlIdGNjbHh1SUNBZ0lIQjFZbXhwWXlCdlptWnpaWFE2SUc1MWJXSmxjanRjY2x4dUlDQWdJSEIxWW14cFl5QmhjbU5vYVhabFpGTnBlbVU2SUc1MWJXSmxjanRjY2x4dUlDQWdJSEIxWW14cFl5QnphWHBsT2lCdWRXMWlaWEk3WEhKY2JpQWdJQ0J3ZFdKc2FXTWdabXhoWjNNNklHNTFiV0psY2p0Y2NseHVJQ0FnSUhCMVlteHBZeUJqYjI1emRISjFZM1J2Y2loa1lYUmhPaUJDZFdabVpYSXBJSHRjY2x4dUlDQWdJQ0FnSUNCMGFHbHpMbTltWm5ObGRDQTlJR1JoZEdFdWNtVmhaRlZKYm5Rek1rSkZLREFwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WVhKamFHbDJaV1JUYVhwbElEMGdaR0YwWVM1eVpXRmtWVWx1ZERNeVFrVW9OQ2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTV6YVhwbElEMGdaR0YwWVM1eVpXRmtWVWx1ZERNeVFrVW9PQ2s3WEhKY2JpQWdJQ0FnSUNBZ2RHaHBjeTVtYkdGbmN5QTlJR1JoZEdFdWNtVmhaRlZKYm5Rek1rSkZLREV5S1R0Y2NseHVJQ0FnSUgxY2NseHVmVnh5WEc0aVhYMD1cbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2RhdGFcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbXBxXCIpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbWx1WkdWNExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3TzBGQlFVRXNORUpCUVhWQ08wRkJRM1pDTERKQ1FVRnpRaUlzSW1acGJHVWlPaUpwYm1SbGVDNXFjeUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1WNGNHOXlkQ0FxSUdaeWIyMGdKeTR2WkdGMFlTYzdYSEpjYm1WNGNHOXlkQ0FxSUdaeWIyMGdKeTR2YlhCeEp6c2lYWDA9XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIFRoaXMgaXMgYSBwb3J0IG9mXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL25leHVzLWRldnRvb2xzL2VtcGVla3VcbiAgICB0byB0eXBlc2NyaXB0IGFuZCBtb2RpZmllcyBpdCB0byBydW4gaW4gdGhlIGJyb3dzZXJcblxyXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL25leHVzLWRldnRvb2xzL2VtcGVla3UgaXMgYSBmb3JrIG9mXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL0Zhcm9mL21weXFqcyB3aGljaCBpcyBhIHBvcnQgb2ZcbiAgICBodHRwczovL2dpdGh1Yi5jb20vZWFnbGVmbG8vbXB5cVxuICBcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcbmNvbnN0IGRhdGFfMSA9IHJlcXVpcmUoXCIuL2RhdGFcIik7XG5jb25zdCBjb21wcmVzcyA9IHJlcXVpcmUoXCJrZXliYXNlLWNvbXByZXNzanNcIik7XG5jb25zdCBoYXNoVHlwZXMgPSB7XG4gICAgJ1RBQkxFX09GRlNFVCc6IDAsXG4gICAgJ0hBU0hfQSc6IDEsXG4gICAgJ0hBU0hfQic6IDIsXG4gICAgJ1RBQkxFJzogM1xufTtcbmNvbnN0IE1QUV9GSUxFX0lNUExPREUgPSAweDAwMDAwMTAwO1xuY29uc3QgTVBRX0ZJTEVfQ09NUFJFU1MgPSAweDAwMDAwMjAwO1xuY29uc3QgTVBRX0ZJTEVfRU5DUllQVEVEID0gMHgwMDAxMDAwMDtcbmNvbnN0IE1QUV9GSUxFX0ZJWF9LRVkgPSAweDAwMDIwMDAwO1xuY29uc3QgTVBRX0ZJTEVfU0lOR0xFX1VOSVQgPSAweDAxMDAwMDAwO1xuY29uc3QgTVBRX0ZJTEVfREVMRVRFX01BUktFUiA9IDB4MDIwMDAwMDA7XG5jb25zdCBNUFFfRklMRV9TRUNUT1JfQ1JDID0gMHgwNDAwMDAwMDtcbmNvbnN0IE1QUV9GSUxFX0VYSVNUUyA9IDB4ODAwMDAwMDA7XG5jbGFzcyBNUFFBcmNoaXZlIHtcbiAgICBjb25zdHJ1Y3RvcihtcHFEYXRhLCBsaXN0RmlsZXMgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VuY3J5cHRpb25UYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IHt9O1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgbGV0IHNlZWQgPSBuZXcgTG9uZy5mcm9tVmFsdWUoMHgwMDEwMDAwMSwgdHJ1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZWQgPSBzZWVkLm11bCgxMjUpLmFkZCgzKS5tb2QoMHgyQUFBQUIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0MSA9IHNlZWQuYW5kKDB4RkZGRikuc2hpZnRMZWZ0KDB4MTApO1xuICAgICAgICAgICAgICAgICAgICBzZWVkID0gc2VlZC5tdWwoMTI1KS5hZGQoMykubW9kKDB4MkFBQUFCKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdDIgPSBzZWVkLmFuZCgweEZGRkYpO1xuICAgICAgICAgICAgICAgICAgICB0YWJsZVtpbmRleF0gPSB0MS5vcih0MikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMHgxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IGJ1ZmZlcl8xLkJ1ZmZlcihtcHFEYXRhKTtcbiAgICAgICAgdGhpcy5faGVhZGVyID0gdGhpcy5fcmVhZEhlYWRlcigpO1xuICAgICAgICB0aGlzLl9oYXNoVGFibGUgPSB0aGlzLl9yZWFkVGFibGUoJ2hhc2gnKTtcbiAgICAgICAgdGhpcy5fYmxvY2tUYWJsZSA9IHRoaXMuX3JlYWRUYWJsZSgnYmxvY2snKTtcbiAgICAgICAgaWYgKGxpc3RGaWxlcykge1xuICAgICAgICAgICAgY29uc3QgbGlzdEZpbGUgPSB0aGlzLnJlYWRGaWxlKCcobGlzdGZpbGUpJyk7XG4gICAgICAgICAgICBpZiAobGlzdEZpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlcyA9IGxpc3RGaWxlLnRvU3RyaW5nKCd1dGYtOCcpLnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZXM7XG4gICAgfVxuICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHByaW50SGVhZGVycygpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdNUFEgYXJjaGl2ZSBoZWFkZXInKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5faGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAndXNlckRhdGFIZWFkZXInKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oa2V5ICsgJyAtICcgKyB0aGlzLl9oZWFkZXJba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hlYWRlci51c2VyRGF0YUhlYWRlcikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ01QUSB1c2VyIGRhdGEgaGVhZGVyJyk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oKTtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5faGVhZGVyLnVzZXJEYXRhSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGtleSArICcgLSAnICsgdGhpcy5faGVhZGVyLnVzZXJEYXRhSGVhZGVyW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5pbmZvKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRIYXNoVGFibGUoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnTVBRIGFyY2hpdmUgaGFzaCB0YWJsZScpO1xuICAgICAgICBjb25zb2xlLmluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCdIYXNoIEFcXHRcXHRIYXNoIEJcXHRcXHRMb2NsXFx0UGxhdFxcdEJsb2NrSWR4Jyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IFs4LCA4LCA0LCA0LCA4XTtcbiAgICAgICAgdGhpcy5faGFzaFRhYmxlLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKE9iamVjdC5rZXlzKGVudHJ5KS5tYXAoKGtleSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRXb3JkKGVudHJ5W2tleV0sIGZvcm1hdFtpXSk7XG4gICAgICAgICAgICB9KS5qb2luKCdcXHQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmluZm8oKTtcbiAgICB9XG4gICAgO1xuICAgIHByaW50QmxvY2tUYWJsZSgpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdNUFEgYXJjaGl2ZSBibG9jayB0YWJsZScpO1xuICAgICAgICBjb25zb2xlLmluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnT2Zmc2V0XFx0XFx0QXJjaFNpemVcXHRSZWFsU2l6ZVxcdEZsYWdzJyk7XG4gICAgICAgIHRoaXMuX2Jsb2NrVGFibGUuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oW1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdFdvcmQoZW50cnkub2Zmc2V0LCA4KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWFkaW5nQ2hhcihlbnRyeS5hcmNoaXZlZFNpemUsICcgJywgOCksXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVhZGluZ0NoYXIoZW50cnkuc2l6ZSwgJyAnLCA4KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtYXRXb3JkKGVudHJ5LmZsYWdzLCA4KVxuICAgICAgICAgICAgXS5qb2luKCdcXHQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmluZm8oKTtcbiAgICB9XG4gICAgO1xuICAgIHJlYWRGaWxlKGZpbGVuYW1lLCBmb3JjZURlY29tcHJlc3MgPSBmYWxzZSkge1xuICAgICAgICBmdW5jdGlvbiBkZWNvbXByZXNzKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzaW9uVHlwZSA9IGRhdGEucmVhZFVJbnQ4KDApO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzaW9uVHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcHJlc3Npb25UeXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlIFwiemxpYlwiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcHJlc3Npb25UeXBlID09PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYnVmZmVyXzEuQnVmZmVyKGNvbXByZXNzLkJ6aXAyLmRlY29tcHJlc3NGaWxlKGRhdGEuc2xpY2UoMSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gdHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoRW50cnkgPSB0aGlzLl9nZXRIYXNoVGFibGVFbnRyeShmaWxlbmFtZSk7XG4gICAgICAgIGlmICghaGFzaEVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja0VudHJ5ID0gdGhpcy5fYmxvY2tUYWJsZVtoYXNoRW50cnkuYmxvY2tUYWJsZUluZGV4XTtcbiAgICAgICAgaWYgKGJsb2NrRW50cnkuZmxhZ3MgJiBNUFFfRklMRV9FWElTVFMpIHtcbiAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmFyY2hpdmVkU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYmxvY2tFbnRyeS5vZmZzZXQgKyB0aGlzLl9oZWFkZXIub2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGZpbGVEYXRhID0gdGhpcy5fZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrRW50cnkuYXJjaGl2ZWRTaXplKTtcbiAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfRU5DUllQVEVEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfU0lOR0xFX1VOSVQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdG9yU2l6ZSA9IDUxMiA8PCB0aGlzLl9oZWFkZXIuc2VjdG9yU2l6ZVNoaWZ0O1xuICAgICAgICAgICAgICAgIGxldCBzZWN0b3JzID0gTWF0aC50cnVuYyhibG9ja0VudHJ5LnNpemUgLyBzZWN0b3JTaXplKSArIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNyYztcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbnRyeS5mbGFncyAmIE1QUV9GSUxFX1NFQ1RPUl9DUkMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VjdG9ycyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3JjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlY3RvcnMgKyAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpXSA9IGZpbGVEYXRhLnJlYWRVSW50MzJMRSg0ICogaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxuID0gcG9zaXRpb25zLmxlbmd0aCAtIChjcmMgPyAyIDogMSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBidWZmZXJfMS5CdWZmZXIoMCk7XG4gICAgICAgICAgICAgICAgbGV0IHNlY3RvckJ5dGVzTGVmdCA9IGJsb2NrRW50cnkuc2l6ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlY3RvciA9IGZpbGVEYXRhLnNsaWNlKHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tFbnRyeS5mbGFncyAmIE1QUV9GSUxFX0NPTVBSRVNTKSAmJiAoZm9yY2VEZWNvbXByZXNzIHx8IChzZWN0b3JCeXRlc0xlZnQgPiBzZWN0b3IubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3RvciA9IGRlY29tcHJlc3Moc2VjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWN0b3JCeXRlc0xlZnQgLT0gc2VjdG9yLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbcmVzdWx0LCBzZWN0b3JdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsZURhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKGJsb2NrRW50cnkuZmxhZ3MgJiBNUFFfRklMRV9DT01QUkVTUykgJiYgKGZvcmNlRGVjb21wcmVzcyB8fCAoYmxvY2tFbnRyeS5zaXplID4gYmxvY2tFbnRyeS5hcmNoaXZlZFNpemUpKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlRGF0YSA9IGRlY29tcHJlc3MoZmlsZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlRGF0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbGVhZGluZ0NoYXIoc3RyLCBjaCwgbG4sIGFmdGVyID0gZmFsc2UpIHtcbiAgICAgICAgc3RyID0gJycgKyBzdHI7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbG4pIHtcbiAgICAgICAgICAgIHN0ciA9IGFmdGVyID8gc3RyICsgY2ggOiBjaCArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBfZm9ybWF0V29yZChkYXRhLCBsbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZGluZ0NoYXIoZGF0YS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSwgJzAnLCBsbik7XG4gICAgfVxuICAgIF9nZXRIYXNoVGFibGVFbnRyeShmaWxlbmFtZSkge1xuICAgICAgICBjb25zdCBoYXNoQSA9IHRoaXMuX2hhc2goZmlsZW5hbWUsICdIQVNIX0EnKTtcbiAgICAgICAgY29uc3QgaGFzaEIgPSB0aGlzLl9oYXNoKGZpbGVuYW1lLCAnSEFTSF9CJyk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5faGFzaFRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuaGFzaEEgPT09IGhhc2hBICYmIGVudHJ5Lmhhc2hCID09PSBoYXNoQikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfcmVhZEhlYWRlcigpIHtcbiAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2RhdGEudG9TdHJpbmcoJ3V0Zi04JywgMCwgNCk7XG4gICAgICAgIGlmIChoZWFkID09PSAnTVBRXFx4MWEnKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSB0aGlzLl9yZWFkTVBRSGVhZGVyKCk7XG4gICAgICAgICAgICBoZWFkZXIub2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZWFkID09PSAnTVBRXFx4MWInKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YUhlYWRlciA9IHRoaXMuX3JlYWRNUFFVc2VyRGF0YUhlYWRlcigpO1xuICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5fcmVhZE1QUUhlYWRlcih1c2VyRGF0YUhlYWRlci5tcHFIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgaGVhZGVyLm9mZnNldCA9IHVzZXJEYXRhSGVhZGVyLm1wcUhlYWRlck9mZnNldDtcbiAgICAgICAgICAgIGhlYWRlci51c2VyRGF0YUhlYWRlciA9IHVzZXJEYXRhSGVhZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1QUSBmaWxlIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfVxuICAgIF9yZWFkTVBRVXNlckRhdGFIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IGRhdGFfMS5NUFFVc2VyRGF0YUhlYWRlcihkYXRhKTtcbiAgICAgICAgaGVhZGVyLmNvbnRlbnQgPSB0aGlzLl9kYXRhLnNsaWNlKDE2LCAxNiArIGhlYWRlci51c2VyRGF0YUhlYWRlclNpemUpO1xuICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH1cbiAgICBfcmVhZE1QUUhlYWRlcihvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKTtcbiAgICAgICAgbGV0IGhlYWRlciA9IG5ldyBkYXRhXzEuTVBRRmlsZUhlYWRlcihkYXRhKTtcbiAgICAgICAgaWYgKGhlYWRlci5mb3JtYXRWZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YS5zbGljZShvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyAxMik7XG4gICAgICAgICAgICBoZWFkZXIgPSBPYmplY3QuYXNzaWduKG5ldyBkYXRhXzEuTVBRRmlsZUhlYWRlckV4dChkYXRhKSwgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH1cbiAgICBfcmVhZFRhYmxlKHRhYmxlVHlwZSkge1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgc3dpdGNoICh0YWJsZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgICAgICAgICAgIHR5cGUgPSBkYXRhXzEuTVBRSGFzaFRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgPSBkYXRhXzEuTVBRQmxvY2tUYWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYmxlT2Zmc2V0ID0gdGhpcy5faGVhZGVyW3RhYmxlVHlwZSArICdUYWJsZU9mZnNldCddO1xuICAgICAgICBjb25zdCB0YWJsZUVudHJpZXMgPSB0aGlzLl9oZWFkZXJbdGFibGVUeXBlICsgJ1RhYmxlRW50cmllcyddO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9oYXNoKCcoJyArIHRhYmxlVHlwZSArICcgdGFibGUpJywgJ1RBQkxFJyk7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZSh0YWJsZU9mZnNldCArIHRoaXMuX2hlYWRlci5vZmZzZXQsIHRhYmxlT2Zmc2V0ICsgdGhpcy5faGVhZGVyLm9mZnNldCArIHRhYmxlRW50cmllcyAqIDE2KTtcbiAgICAgICAgZGF0YSA9IHRoaXMuX2RlY3J5cHQoZGF0YSwga2V5KTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlRW50cmllczsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gbmV3IHR5cGUoZGF0YS5zbGljZShpICogMTYsIGkgKiAxNiArIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfVxuICAgIF9oYXNoKHZhbHVlLCBoYXNoVHlwZSkge1xuICAgICAgICBsZXQgc2VlZDEgPSBuZXcgTG9uZy5mcm9tVmFsdWUoMHg3RkVEN0ZFRCwgdHJ1ZSk7XG4gICAgICAgIGxldCBzZWVkMiA9IG5ldyBMb25nLmZyb21WYWx1ZSgweEVFRUVFRUVFLCB0cnVlKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBmb3IgKGNoIG9mIHZhbHVlLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUludChjaCwgMTApKSkge1xuICAgICAgICAgICAgICAgIGNoID0gY2guY29kZVBvaW50QXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgTG9uZy5mcm9tVmFsdWUodGhpcy5fZW5jcnlwdGlvblRhYmxlWyhoYXNoVHlwZXNbaGFzaFR5cGVdIDw8IDgpICsgY2hdLCB0cnVlKTtcbiAgICAgICAgICAgIHNlZWQxID0gcmVzdWx0LnhvcihzZWVkMS5hZGQoc2VlZDIpKS5hbmQoMHhGRkZGRkZGRik7XG4gICAgICAgICAgICBzZWVkMiA9IHNlZWQxLmFkZChzZWVkMikuYWRkKGNoKS5hZGQoc2VlZDIuc2hpZnRMZWZ0KDUpKS5hZGQoMykuYW5kKDB4RkZGRkZGRkYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWVkMS50b051bWJlcigpO1xuICAgIH1cbiAgICBfZGVjcnlwdChkYXRhLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IGJ1ZmZlcl8xLkJ1ZmZlcihkYXRhLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxuID0gZGF0YS5sZW5ndGggLyA0O1xuICAgICAgICBsZXQgc2VlZDEgPSBuZXcgTG9uZy5mcm9tVmFsdWUoa2V5LCB0cnVlKTtcbiAgICAgICAgbGV0IHNlZWQyID0gbmV3IExvbmcuZnJvbVZhbHVlKDB4RUVFRUVFRUUsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgICAgICBzZWVkMiA9IHNlZWQyLmFkZCh0aGlzLl9lbmNyeXB0aW9uVGFibGVbMHg0MDAgKyAoc2VlZDEgJiAweEZGKV0pO1xuICAgICAgICAgICAgc2VlZDIgPSBzZWVkMi5hbmQoMHhGRkZGRkZGRik7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXcgTG9uZy5mcm9tVmFsdWUoZGF0YS5yZWFkVUludDMyTEUoaSAqIDQpLCB0cnVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUueG9yKHNlZWQxLmFkZChzZWVkMikpLmFuZCgweEZGRkZGRkZGKTtcbiAgICAgICAgICAgIHNlZWQxID0gc2VlZDEueG9yKC0xKS5zaGlmdExlZnQoMHgxNSkuYWRkKDB4MTExMTExMTEpLm9yKHNlZWQxLnNoaWZ0UmlnaHQoMHgwQikpO1xuICAgICAgICAgICAgc2VlZDEgPSBzZWVkMS5hbmQoMHhGRkZGRkZGRik7XG4gICAgICAgICAgICBzZWVkMiA9IHZhbHVlLmFkZChzZWVkMikuYWRkKHNlZWQyLnNoaWZ0TGVmdCg1KSkuYWRkKDMpLmFuZCgweEZGRkZGRkZGKTtcbiAgICAgICAgICAgIHJlc3VsdC53cml0ZVVJbnQzMkJFKHZhbHVlLnRvTnVtYmVyKCksIGkgKiA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuTVBRQXJjaGl2ZSA9IE1QUUFyY2hpdmU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zjg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW0xd2NTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN096czdPenM3T3p0cFJVRlRhVVU3TzBGQlJXcEZMRFJDUVVFMFFqdEJRVU0xUWl4dFEwRkJaME03UVVGRGFFTXNOa0pCUVRaQ08wRkJRemRDTEdsRFFVRnRTRHRCUVVOdVNDd3JRMEZCSzBNN1FVRkZMME1zVFVGQlRTeFRRVUZUTEVkQlFVYzdTVUZEWkN4alFVRmpMRVZCUVVVc1EwRkJRenRKUVVOcVFpeFJRVUZSTEVWQlFVVXNRMEZCUXp0SlFVTllMRkZCUVZFc1JVRkJSU3hEUVVGRE8wbEJRMWdzVDBGQlR5eEZRVUZGTEVOQlFVTTdRMEZEWWl4RFFVRkRPMEZCUlVZc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4VlFVRlZMRU5CUVVNN1FVRkRjRU1zVFVGQlRTeHBRa0ZCYVVJc1IwRkJSeXhWUVVGVkxFTkJRVU03UVVGRGNrTXNUVUZCVFN4clFrRkJhMElzUjBGQlJ5eFZRVUZWTEVOQlFVTTdRVUZEZEVNc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4VlFVRlZMRU5CUVVNN1FVRkRjRU1zVFVGQlRTeHZRa0ZCYjBJc1IwRkJSeXhWUVVGVkxFTkJRVU03UVVGRGVFTXNUVUZCVFN4elFrRkJjMElzUjBGQlJ5eFZRVUZWTEVOQlFVTTdRVUZETVVNc1RVRkJUU3h0UWtGQmJVSXNSMEZCUnl4VlFVRlZMRU5CUVVNN1FVRkRka01zVFVGQlRTeGxRVUZsTEVkQlFVY3NWVUZCVlN4RFFVRkRPMEZCUlc1RE8wbEJjVU5KTEZsQlFXMUNMRTlCUVc5Q0xFVkJRVVVzVTBGQlV5eEhRVUZITEVsQlFVazdVVUV6UW1wRUxIRkNRVUZuUWl4SFFVRkhMRU5CUVVNN1dVRkRlRUlzVFVGQlRTeExRVUZMTEVkQlFVY3NSVUZCUlN4RFFVRkRPMWxCUTJwQ0xFbEJRVWtzUzBGQllTeERRVUZETzFsQlEyeENMRWxCUVVrc1NVRkJTU3hIUVVGSExFbEJRVWtzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4VlFVRlZMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRGFFUXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRuUWtGRE1VSXNTMEZCU3l4SFFVRkhMRU5CUVVNc1EwRkJRenRuUWtGRFZpeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMjlDUVVONFFpeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzI5Q1FVTXhReXhOUVVGTkxFVkJRVVVzUjBGQlJ5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkROVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dHZRa0ZETVVNc1RVRkJUU3hGUVVGRkxFZEJRVWNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenR2UWtGRE5VSXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03YjBKQlEzQkRMRXRCUVVzc1NVRkJTU3hMUVVGTExFTkJRVU03YVVKQlEyeENPMkZCUlVvN1dVRkRSQ3hQUVVGUExFdEJRVXNzUTBGQlF6dFJRVU5xUWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRE8xRkJWMFFzU1VGQlNTeERRVUZETEV0QlFVc3NSMEZCUnl4SlFVRkpMR1ZCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU5xUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXp0UlFVVnNReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRE1VTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUlRWRExFbEJRVWtzVTBGQlV5eEZRVUZGTzFsQlExZ3NUVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0WlFVTTNReXhKUVVGSkxGRkJRVkVzUlVGQlJUdG5Ra0ZEVml4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMkZCUTJwRk8xTkJRMG83U1VGRFRDeERRVUZETzBsQmNrSkVMRWxCUVZjc1MwRkJTenRSUVVOYUxFOUJRVThzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJSVVFzU1VGQlZ5eE5RVUZOTzFGQlEySXNUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRE8wbEJRM2hDTEVOQlFVTTdTVUZwUWswc1dVRkJXVHRSUVVObUxFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zUTBGQlF6dFJRVU51UXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRU5CUVVNN1VVRkRia01zUzBGQlN5eE5RVUZOTEVkQlFVY3NTVUZCU1N4SlFVRkpMRU5CUVVNc1QwRkJUeXhGUVVGRk8xbEJRelZDTEVsQlFVa3NSMEZCUnl4TFFVRkxMR2RDUVVGblFpeEZRVUZGTzJkQ1FVRkZMRk5CUVZNN1lVRkJSVHRaUVVNelF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1IwRkJSeXhMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xTkJRMnBFTzFGQlEwUXNTVUZCU1N4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExHTkJRV01zUlVGQlJUdFpRVU0zUWl4UFFVRlBMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU03V1VGRFppeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMSE5DUVVGelFpeERRVUZETEVOQlFVTTdXVUZEY2tNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJReXhEUVVGRE8xbEJRM0pETEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRaUVVObUxHbERRVUZwUXp0WlFVTnFReXhMUVVGTExFMUJRVTBzUjBGQlJ5eEpRVUZKTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1kwRkJZeXhGUVVGRk8yZENRVU16UXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUjBGQlJ5eExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0aFFVTm9SVHRaUVVORUxFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXp0VFFVTnNRanRKUVVOTUxFTkJRVU03U1VGRlRTeGpRVUZqTzFGQlEycENMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1EwRkJRenRSUVVOMlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMSGRDUVVGM1FpeERRVUZETEVOQlFVTTdVVUZEZGtNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5d3dRMEZCTUVNc1EwRkJReXhEUVVGRE8xRkJRM3BFTEUxQlFVMHNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlDTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZGTzFsQlF6VkNMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1owSkJRek5ETEU5QlFVOHNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrUXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYmtJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFNDeFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVUZCTEVOQlFVTTdTVUZGU3l4bFFVRmxPMUZCUTJ4Q0xFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNlVUpCUVhsQ0xFTkJRVU1zUTBGQlF6dFJRVU40UXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExIbENRVUY1UWl4RFFVRkRMRU5CUVVNN1VVRkRlRU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4eFEwRkJjVU1zUTBGQlF5eERRVUZETzFGQlEzQkVMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4RlFVRkZPMWxCUXpkQ0xFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTTdaMEpCUTFRc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRuUWtGRGFrTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhMUVVGTExFTkJRVU1zV1VGQldTeEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRemRETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOeVF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzJGQlEyNURMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFNDeFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVUZCTEVOQlFVTTdTVUZGU3l4UlFVRlJMRU5CUVVNc1VVRkJaMElzUlVGQlJTeGxRVUZsTEVkQlFVY3NTMEZCU3p0UlFVTnlSQ3h2UWtGQmIwSXNTVUZCV1R0WlFVTTFRaXhOUVVGTkxHVkJRV1VzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZETEVsQlFVa3NaVUZCWlN4TFFVRkxMRU5CUVVNc1JVRkJSVHRuUWtGRGRrSXNUMEZCVHl4SlFVRkpMRU5CUVVNN1lVRkRaanRwUWtGQlRTeEpRVUZKTEdWQlFXVXNTMEZCU3l4RFFVRkRMRVZCUVVVN1owSkJRemxDTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2MwTkJRWE5ETEVOQlFVTXNRMEZCUXp0aFFVTXpSRHRwUWtGQlRTeEpRVUZKTEdWQlFXVXNTMEZCU3l4RlFVRkZMRVZCUVVVN1owSkJReTlDTEU5QlFVOHNTVUZCU1N4bFFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdZVUZEYmtVN2FVSkJRVTA3WjBKQlEwZ3NUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXdyUWtGQkswSXNRMEZCUXl4RFFVRkRPMkZCUTNCRU8xRkJRMHdzUTBGQlF6dFJRVVZFTEUxQlFVMHNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVOd1JDeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZPMWxCUVVVc1QwRkJUeXhKUVVGSkxFTkJRVU03VTBGQlJUdFJRVU5vUXl4TlFVRk5MRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEZOQlFWTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJRenRSUVVNdlJDeEpRVUZKTEZWQlFWVXNRMEZCUXl4TFFVRkxMRWRCUVVjc1pVRkJaU3hGUVVGRk8xbEJRM0JETEVsQlFVa3NWVUZCVlN4RFFVRkRMRmxCUVZrc1MwRkJTeXhEUVVGRExFVkJRVVU3WjBKQlFVVXNUMEZCVHl4SlFVRkpMRU5CUVVNN1lVRkJSVHRaUVVOdVJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4VlFVRlZMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUTNaRUxFbEJRVWtzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVkQlFVY3NWVUZCVlN4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRE8xbEJRekZGTEVsQlFVa3NWVUZCVlN4RFFVRkRMRXRCUVVzc1IwRkJSeXhyUWtGQmEwSXNSVUZCUlR0blFrRkRka01zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4cFEwRkJhVU1zUTBGQlF5eERRVUZETzJGQlEzUkVPMWxCUTBRc1NVRkJTU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFVc3NSMEZCUnl4dlFrRkJiMElzUTBGQlF5eEZRVUZGTzJkQ1FVTTFReXhOUVVGTkxGVkJRVlVzUjBGQlJ5eEhRVUZITEVsQlFVa3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhsUVVGbExFTkJRVU03WjBKQlEzWkVMRWxCUVVrc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdaMEpCUXpORUxFbEJRVWtzUjBGQldTeERRVUZETzJkQ1FVTnFRaXhKUVVGSkxGVkJRVlVzUTBGQlF5eExRVUZMTEVkQlFVY3NiVUpCUVcxQ0xFVkJRVVU3YjBKQlEzaERMRWRCUVVjc1IwRkJSeXhKUVVGSkxFTkJRVU03YjBKQlExZ3NUMEZCVHl4SlFVRkpMRU5CUVVNc1EwRkJRenRwUWtGRGFFSTdjVUpCUVUwN2IwSkJRMGdzUjBGQlJ5eEhRVUZITEV0QlFVc3NRMEZCUXp0cFFrRkRaanRuUWtGRFJDeE5RVUZOTEZOQlFWTXNSMEZCUnl4RlFVRkZMRU5CUVVNN1owSkJRM0pDTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdHZRa0ZEY0VNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEZGQlFWRXNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzJsQ1FVTXZRenRuUWtGRFJDeE5RVUZOTEVWQlFVVXNSMEZCUnl4VFFVRlRMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTTFReXhKUVVGSkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEdWQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE0wSXNTVUZCU1N4bFFVRmxMRWRCUVVjc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF6dG5Ra0ZEZEVNc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdHZRa0ZEZWtJc1NVRkJTU3hOUVVGTkxFZEJRVWNzVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU0xUkN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFdEJRVXNzUjBGQlJ5eHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeEpRVUZKTEVOQlFVTXNaVUZCWlN4SFFVRkhMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eEZRVUZGTzNkQ1FVTnNSeXhOUVVGTkxFZEJRVWNzVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPM0ZDUVVNdlFqdHZRa0ZEUkN4bFFVRmxMRWxCUVVrc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dHZRa0ZEYWtNc1RVRkJUU3hIUVVGSExHVkJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dHBRa0ZETlVNN1owSkJRMFFzVVVGQlVTeEhRVUZITEUxQlFVMHNRMEZCUXp0aFFVTnlRanRwUWtGQlRUdG5Ra0ZEU0N4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFdEJRVXNzUjBGQlJ5eHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhWUVVGVkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNSVUZCUlR0dlFrRkROVWNzVVVGQlVTeEhRVUZITEZWQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRwUWtGRGJrTTdZVUZEU2p0WlFVTkVMRTlCUVU4c1VVRkJVU3hEUVVGRE8xTkJRMjVDTzBsQlEwd3NRMEZCUXp0SlFVVlBMRmxCUVZrc1EwRkJReXhIUVVGdlFpeEZRVUZGTEVWQlFWVXNSVUZCUlN4RlFVRlZMRVZCUVVVc1MwRkJTeXhIUVVGSExFdEJRVXM3VVVGRE5VVXNSMEZCUnl4SFFVRkhMRVZCUVVVc1IwRkJSeXhIUVVGSExFTkJRVU03VVVGRFppeFBRVUZQTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJSU3hGUVVGRk8xbEJRM0JDTEVkQlFVY3NSMEZCUnl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhIUVVGSExFTkJRVU03VTBGRGNrTTdVVUZEUkN4UFFVRlBMRWRCUVVjc1EwRkJRenRKUVVObUxFTkJRVU03U1VGRlR5eFhRVUZYTEVOQlFVTXNTVUZCV1N4RlFVRkZMRVZCUVZVN1VVRkRlRU1zVDBGQlR5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4RlFVRkZMRVZCUVVVc1IwRkJSeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzBsQlEzWkZMRU5CUVVNN1NVRkhUeXhyUWtGQmEwSXNRMEZCUXl4UlFVRm5RanRSUVVOMlF5eE5RVUZOTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVTTNReXhOUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU0zUXl4TFFVRkxMRTFCUVUwc1MwRkJTeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVTdXVUZEYWtNc1NVRkJTU3hMUVVGTExFTkJRVU1zUzBGQlN5eExRVUZMTEV0QlFVc3NTVUZCU1N4TFFVRkxMRU5CUVVNc1MwRkJTeXhMUVVGTExFdEJRVXNzUlVGQlJUdG5Ra0ZEYUVRc1QwRkJUeXhMUVVGTExFTkJRVU03WVVGRGFFSTdXVUZCUVN4RFFVRkRPMU5CUTB3N1VVRkRSQ3hQUVVGUExGTkJRVk1zUTBGQlF6dEpRVU55UWl4RFFVRkRPMGxCUlU4c1YwRkJWenRSUVVObUxFbEJRVWtzVFVGQmNVSXNRMEZCUXp0UlFVVXhRaXhOUVVGTkxFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoRUxFbEJRVWtzU1VGQlNTeExRVUZMTEZOQlFWTXNSVUZCUlR0WlFVTndRaXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEdOQlFXTXNSVUZCUlN4RFFVRkRPMWxCUXk5Q0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUTNKQ08yRkJRVTBzU1VGQlNTeEpRVUZKTEV0QlFVc3NVMEZCVXl4RlFVRkZPMWxCUXpOQ0xFMUJRVTBzWTBGQll5eEhRVUZITEVsQlFVa3NRMEZCUXl4elFrRkJjMElzUlVGQlJTeERRVUZETzFsQlEzSkVMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEdOQlFXTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJRenRaUVVNM1JDeE5RVUZOTEVOQlFVTXNUVUZCVFN4SFFVRkhMR05CUVdNc1EwRkJReXhsUVVGbExFTkJRVU03V1VGREwwTXNUVUZCVFN4RFFVRkRMR05CUVdNc1IwRkJSeXhqUVVGakxFTkJRVU03VTBGRE1VTTdZVUZCVFR0WlFVTklMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZVVKQlFYbENMRU5CUVVNc1EwRkJRenRUUVVNNVF6dFJRVU5FTEU5QlFVOHNUVUZCVFN4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03U1VGRlR5eHpRa0ZCYzBJN1VVRkRNVUlzVFVGQlRTeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUTNKRExFMUJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NkMEpCUVdsQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZETTBNc1RVRkJUU3hEUVVGRExFOUJRVThzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeEhRVUZITEUxQlFVMHNRMEZCUXl4clFrRkJhMElzUTBGQlF5eERRVUZETzFGQlEzUkZMRTlCUVU4c1RVRkJUU3hEUVVGRE8wbEJRMnhDTEVOQlFVTTdTVUZGVHl4alFVRmpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU03VVVGRE4wSXNTVUZCU1N4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RlFVRkZMRTFCUVUwc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU5xUkN4SlFVRkpMRTFCUVUwc1IwRkJSeXhKUVVGSkxHOUNRVUZoTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRja01zU1VGQlNTeE5RVUZOTEVOQlFVTXNZVUZCWVN4TFFVRkxMRU5CUVVNc1JVRkJSVHRaUVVNMVFpeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeEhRVUZITEVWQlFVVXNSVUZCUlN4TlFVRk5MRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzWkVMRTFCUVUwc1IwRkJhMElzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMSFZDUVVGblFpeERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xTkJRemRGTzFGQlEwUXNUMEZCVHl4TlFVRk5MRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRVWxQTEZWQlFWVXNRMEZCUXl4VFFVRXlRanRSUVVNeFF5eEpRVUZKTEVsQlFWTXNRMEZCUXp0UlFVTmtMRkZCUVZFc1UwRkJVeXhGUVVGRk8xbEJRMllzUzBGQlN5eE5RVUZOTzJkQ1FVTlFMRWxCUVVrc1IwRkJSeXgzUWtGQmFVSXNRMEZCUXp0blFrRkRla0lzVFVGQlRUdFpRVU5XTEV0QlFVc3NUMEZCVHp0blFrRkRVaXhKUVVGSkxFZEJRVWNzU1VGQlNTeEhRVUZITEhsQ1FVRnJRaXhEUVVGRE8yZENRVU5xUXl4TlFVRk5PMU5CUTJJN1VVRkRSQ3hOUVVGTkxGZEJRVmNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRk5CUVZNc1IwRkJSeXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVU0xUkN4TlFVRk5MRmxCUVZrc1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNSMEZCUnl4alFVRmpMRU5CUVVNc1EwRkJRenRSUVVVNVJDeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUjBGQlJ5eFRRVUZUTEVkQlFVY3NVMEZCVXl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRemRFTEVsQlFVa3NTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFZEJRVWNzV1VGQldTeEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUTNSSUxFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU5vUXl4TlFVRk5MRTlCUVU4c1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRGJrSXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEZsQlFWa3NSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRaUVVOdVF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVNeFJEdFJRVU5FTEU5QlFVOHNUMEZCVHl4RFFVRkRPMGxCUTI1Q0xFTkJRVU03U1VGRlR5eExRVUZMTEVOQlFVTXNTMEZCWVN4RlFVRkZMRkZCUVdkQ08xRkJRM3BETEVsQlFVa3NTMEZCU3l4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eFZRVUZWTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRha1FzU1VGQlNTeExRVUZMTEVkQlFVY3NTVUZCU1N4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGVkJRVlVzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTnFSQ3hKUVVGSkxFMUJRVmNzUTBGQlF6dFJRVU5vUWl4SlFVRkpMRVZCUVU4c1EwRkJRenRSUVVOYUxFdEJRVXNzUlVGQlJTeEpRVUZKTEV0QlFVc3NRMEZCUXl4WFFVRlhMRVZCUVVVc1JVRkJSVHRaUVVNMVFpeEpRVUZKTEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVTdaMEpCUTNwQ0xFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yRkJRekZDTzFsQlEwUXNUVUZCVFN4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRNVVlzUzBGQlN5eEhRVUZITEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFpRVU55UkN4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFOQlEyNUdPMUZCUlVRc1QwRkJUeXhMUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdTVUZETlVJc1EwRkJRenRKUVVWUExGRkJRVkVzUTBGQlF5eEpRVUZaTEVWQlFVVXNSMEZCVnp0UlFVTjBReXhOUVVGTkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEdWQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRGRrTXNUVUZCVFN4RlFVRkZMRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZETTBJc1NVRkJTU3hMUVVGTExFZEJRVWNzU1VGQlNTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU14UXl4SlFVRkpMRXRCUVVzc1IwRkJSeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNWVUZCVlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMnBFTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1dVRkRla0lzYzBOQlFYTkRPMWxCUTNSRExFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TFFVRkxMRWRCUVVjc1EwRkJReXhMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwRkxFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xbEJRemxDTEVsQlFVa3NTMEZCU3l4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTXZSQ3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xbEJRM0JFTEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwR0xFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xbEJRemxDTEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0WlFVTjRSU3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEYWtRN1VVRkRSQ3hQUVVGUExFMUJRVTBzUTBGQlF6dEpRVU5zUWl4RFFVRkRPME5CUTBvN1FVRjBVa1FzWjBOQmMxSkRJaXdpWm1sc1pTSTZJbTF3Y1M1cWN5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLbHh5WEc0Z0lDQWdWR2hwY3lCcGN5QmhJSEJ2Y25RZ2IyWWdJRnh5WEc0Z0lDQWdhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMMjVsZUhWekxXUmxkblJ2YjJ4ekwyVnRjR1ZsYTNVZ1hISmNiaUFnSUNCMGJ5QjBlWEJsYzJOeWFYQjBJR0Z1WkNCdGIyUnBabWxsY3lCcGRDQjBieUJ5ZFc0Z2FXNGdkR2hsSUdKeWIzZHpaWEpjY2x4dVhISmNiaUFnSUNCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdmJtVjRkWE10WkdWMmRHOXZiSE12Wlcxd1pXVnJkU0JwY3lCaElHWnZjbXNnYjJZZ1hISmNiaUFnSUNCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdlJtRnliMll2YlhCNWNXcHpJSGRvYVdOb0lHbHpJR0VnY0c5eWRDQnZabHh5WEc0Z0lDQWdhSFIwY0hNNkx5OW5hWFJvZFdJdVkyOXRMMlZoWjJ4bFpteHZMMjF3ZVhGY2NseHVJQ0JjY2x4dUlDb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpOWNjbHh1WEhKY2JpOHZJSFJ6YkdsdWREcGthWE5oWW14bE9tNXZMV0pwZEhkcGMyVmNjbHh1YVcxd2IzSjBJSHNnUW5WbVptVnlJSDBnWm5KdmJTQW5ZblZtWm1WeUp6dGNjbHh1YVcxd2IzSjBJQ29nWVhNZ1RHOXVaeUJtY205dElDZHNiMjVuSnp0Y2NseHVhVzF3YjNKMElIc2dUVkJSVlhObGNrUmhkR0ZJWldGa1pYSXNJRTFRVVVacGJHVklaV0ZrWlhJc0lFMVFVVVpwYkdWSVpXRmtaWEpGZUhRc0lFMVFVVUpzYjJOclZHRmliR1ZGYm5SeWVTd2dUVkJSU0dGemFGUmhZbXhsUlc1MGNua2dmU0JtY205dElDY3VMMlJoZEdFbk8xeHlYRzVwYlhCdmNuUWdLaUJoY3lCamIyMXdjbVZ6Y3lCbWNtOXRJQ2RyWlhsaVlYTmxMV052YlhCeVpYTnphbk1uTzF4eVhHNWNjbHh1WTI5dWMzUWdhR0Z6YUZSNWNHVnpJRDBnZTF4eVhHNGdJQ0FnSjFSQlFreEZYMDlHUmxORlZDYzZJREFzWEhKY2JpQWdJQ0FuU0VGVFNGOUJKem9nTVN4Y2NseHVJQ0FnSUNkSVFWTklYMEluT2lBeUxGeHlYRzRnSUNBZ0oxUkJRa3hGSnpvZ00xeHlYRzU5TzF4eVhHNWNjbHh1WTI5dWMzUWdUVkJSWDBaSlRFVmZTVTFRVEU5RVJTQTlJREI0TURBd01EQXhNREE3WEhKY2JtTnZibk4wSUUxUVVWOUdTVXhGWDBOUFRWQlNSVk5USUQwZ01IZ3dNREF3TURJd01EdGNjbHh1WTI5dWMzUWdUVkJSWDBaSlRFVmZSVTVEVWxsUVZFVkVJRDBnTUhnd01EQXhNREF3TUR0Y2NseHVZMjl1YzNRZ1RWQlJYMFpKVEVWZlJrbFlYMHRGV1NBOUlEQjRNREF3TWpBd01EQTdYSEpjYm1OdmJuTjBJRTFRVVY5R1NVeEZYMU5KVGtkTVJWOVZUa2xVSUQwZ01IZ3dNVEF3TURBd01EdGNjbHh1WTI5dWMzUWdUVkJSWDBaSlRFVmZSRVZNUlZSRlgwMUJVa3RGVWlBOUlEQjRNREl3TURBd01EQTdYSEpjYm1OdmJuTjBJRTFRVVY5R1NVeEZYMU5GUTFSUFVsOURVa01nUFNBd2VEQTBNREF3TURBd08xeHlYRzVqYjI1emRDQk5VRkZmUmtsTVJWOUZXRWxUVkZNZ1BTQXdlRGd3TURBd01EQXdPMXh5WEc1Y2NseHVaWGh3YjNKMElHTnNZWE56SUUxUVVVRnlZMmhwZG1VZ2UxeHlYRzVjY2x4dUlDQWdJSEJ5YVhaaGRHVWdYMlJoZEdFNklFSjFabVpsY2p0Y2NseHVJQ0FnSUhCeWFYWmhkR1VnWDJobFlXUmxjam9nVFZCUlJtbHNaVWhsWVdSbGNqdGNjbHh1WEhKY2JpQWdJQ0J3Y21sMllYUmxJRjlvWVhOb1ZHRmliR1U2SUUxUVVVaGhjMmhVWVdKc1pVVnVkSEo1VzEwN1hISmNiaUFnSUNCd2NtbDJZWFJsSUY5aWJHOWphMVJoWW14bE9pQk5VRkZDYkc5amExUmhZbXhsUlc1MGNubGJYVHRjY2x4dVhISmNiaUFnSUNCd2NtbDJZWFJsSUY5bWFXeGxjem9nYzNSeWFXNW5XMTA3WEhKY2JseHlYRzRnSUNBZ2NISnBkbUYwWlNCZlpXNWpjbmx3ZEdsdmJsUmhZbXhsSUQwZ0tHWjFibU4wYVc5dUlDZ3BJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0IwWVdKc1pTQTlJSHQ5TzF4eVhHNGdJQ0FnSUNBZ0lHeGxkQ0JwYm1SbGVEb2diblZ0WW1WeU8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCelpXVmtJRDBnYm1WM0lFeHZibWN1Wm5KdmJWWmhiSFZsS0RCNE1EQXhNREF3TURFc0lIUnlkV1VwTzF4eVhHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElHa2dQU0F3T3lCcElEd2dNalUyT3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdhVzVrWlhnZ1BTQnBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnFJRDBnTURzZ2FpQThJRFU3SUdvckt5a2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWbFpDQTlJSE5sWldRdWJYVnNLREV5TlNrdVlXUmtLRE1wTG0xdlpDZ3dlREpCUVVGQlFpazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQjBNU0E5SUhObFpXUXVZVzVrS0RCNFJrWkdSaWt1YzJocFpuUk1aV1owS0RCNE1UQXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYzJWbFpDQTlJSE5sWldRdWJYVnNLREV5TlNrdVlXUmtLRE1wTG0xdlpDZ3dlREpCUVVGQlFpazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQjBNaUE5SUhObFpXUXVZVzVrS0RCNFJrWkdSaWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMFlXSnNaVnRwYm1SbGVGMGdQU0IwTVM1dmNpaDBNaWt1ZEc5T2RXMWlaWElvS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVaR1Y0SUNzOUlEQjRNVEF3TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JseHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdGaWJHVTdYSEpjYmlBZ0lDQjlLU2dwTzF4eVhHNWNjbHh1SUNBZ0lIQjFZbXhwWXlCblpYUWdabWxzWlhNb0tUb2djM1J5YVc1blcxMGdlMXh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxsOW1hV3hsY3p0Y2NseHVJQ0FnSUgxY2NseHVYSEpjYmlBZ0lDQndkV0pzYVdNZ1oyVjBJR2hsWVdSbGNpZ3BPaUJOVUZGR2FXeGxTR1ZoWkdWeUlIdGNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1ZmFHVmhaR1Z5TzF4eVhHNGdJQ0FnZlZ4eVhHNWNjbHh1SUNBZ0lIQjFZbXhwWXlCamIyNXpkSEoxWTNSdmNpaHRjSEZFWVhSaE9pQkJjbkpoZVVKMVptWmxjaXdnYkdsemRFWnBiR1Z6SUQwZ2RISjFaU2tnZTF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJSaGRHRWdQU0J1WlhjZ1FuVm1abVZ5S0cxd2NVUmhkR0VwTzF4eVhHNGdJQ0FnSUNBZ0lIUm9hWE11WDJobFlXUmxjaUE5SUhSb2FYTXVYM0psWVdSSVpXRmtaWElvS1R0Y2NseHVYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZhR0Z6YUZSaFlteGxJRDBnZEdocGN5NWZjbVZoWkZSaFlteGxLQ2RvWVhOb0p5azdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZbXh2WTJ0VVlXSnNaU0E5SUhSb2FYTXVYM0psWVdSVVlXSnNaU2duWW14dlkyc25LVHRjY2x4dVhISmNiaUFnSUNBZ0lDQWdhV1lnS0d4cGMzUkdhV3hsY3lrZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNXpkQ0JzYVhOMFJtbHNaU0E5SUhSb2FYTXVjbVZoWkVacGJHVW9KeWhzYVhOMFptbHNaU2tuS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHeHBjM1JHYVd4bEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxsOW1hV3hsY3lBOUlHeHBjM1JHYVd4bExuUnZVM1J5YVc1bktDZDFkR1l0T0NjcExuUnlhVzBvS1M1emNHeHBkQ2duWEZ4eVhGeHVKeWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNCOVhISmNibHh5WEc0Z0lDQWdjSFZpYkdsaklIQnlhVzUwU0dWaFpHVnljeWdwSUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtbHVabThvSjAxUVVTQmhjbU5vYVhabElHaGxZV1JsY2ljcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OdmJHVXVhVzVtYnlnbkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdEp5azdYSEpjYmlBZ0lDQWdJQ0FnWm05eUlDaGpiMjV6ZENCclpYa2dhVzRnZEdocGN5NWZhR1ZoWkdWeUtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hyWlhrZ1BUMDlJQ2QxYzJWeVJHRjBZVWhsWVdSbGNpY3BJSHNnWTI5dWRHbHVkV1U3SUgxY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVwYm1adktHdGxlU0FySUNjZ0xTQW5JQ3NnZEdocGN5NWZhR1ZoWkdWeVcydGxlVjBwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0JwWmlBb2RHaHBjeTVmYUdWaFpHVnlMblZ6WlhKRVlYUmhTR1ZoWkdWeUtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHTnZibk52YkdVdWFXNW1ieWdwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emIyeGxMbWx1Wm04b0owMVFVU0IxYzJWeUlHUmhkR0VnYUdWaFpHVnlKeWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OdmJHVXVhVzVtYnlnbkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMG5LVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNXBibVp2S0NrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUM4dklIUnpiR2x1ZERwa2FYTmhZbXhsTFc1bGVIUXRiR2x1WlRwbWIzSnBibHh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQm1iM0lnS0dOdmJuTjBJR3RsZVNCcGJpQjBhR2x6TGw5b1pXRmtaWEl1ZFhObGNrUmhkR0ZJWldGa1pYSXBJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOdmJuTnZiR1V1YVc1bWJ5aHJaWGtnS3lBbklDMGdKeUFySUhSb2FYTXVYMmhsWVdSbGNpNTFjMlZ5UkdGMFlVaGxZV1JsY2x0clpYbGRLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtbHVabThvS1R0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQjlYSEpjYmx4eVhHNGdJQ0FnY0hWaWJHbGpJSEJ5YVc1MFNHRnphRlJoWW14bEtDa2dlMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTnZiR1V1YVc1bWJ5Z25UVkJSSUdGeVkyaHBkbVVnYUdGemFDQjBZV0pzWlNjcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OdmJHVXVhVzVtYnlnbkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMU2NwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk52YkdVdWFXNW1ieWduU0dGemFDQkJYRngwWEZ4MFNHRnphQ0JDWEZ4MFhGeDBURzlqYkZ4Y2RGQnNZWFJjWEhSQ2JHOWphMGxrZUNjcE8xeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHWnZjbTFoZENBOUlGczRMQ0E0TENBMExDQTBMQ0E0WFR0Y2NseHVJQ0FnSUNBZ0lDQjBhR2x6TGw5b1lYTm9WR0ZpYkdVdVptOXlSV0ZqYUNobGJuUnllU0E5UGlCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuTnZiR1V1YVc1bWJ5aFBZbXBsWTNRdWEyVjVjeWhsYm5SeWVTa3ViV0Z3S0NoclpYa3NJR2twSUQwK0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TGw5bWIzSnRZWFJYYjNKa0tHVnVkSEo1VzJ0bGVWMHNJR1p2Y20xaGRGdHBYU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSDBwTG1wdmFXNG9KMXhjZENjcEtUdGNjbHh1SUNBZ0lDQWdJQ0I5S1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtbHVabThvS1R0Y2NseHVJQ0FnSUgwN1hISmNibHh5WEc0Z0lDQWdjSFZpYkdsaklIQnlhVzUwUW14dlkydFVZV0pzWlNncElIdGNjbHh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbWx1Wm04b0owMVFVU0JoY21Ob2FYWmxJR0pzYjJOcklIUmhZbXhsSnlrN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNXBibVp2S0NjdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMU2NwTzF4eVhHNGdJQ0FnSUNBZ0lHTnZibk52YkdVdWFXNW1ieWduVDJabWMyVjBYRngwWEZ4MFFYSmphRk5wZW1WY1hIUlNaV0ZzVTJsNlpWeGNkRVpzWVdkekp5azdYSEpjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZbXh2WTJ0VVlXSnNaUzVtYjNKRllXTm9LR1Z1ZEhKNUlEMCtJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1YzI5c1pTNXBibVp2S0Z0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDJadmNtMWhkRmR2Y21Rb1pXNTBjbmt1YjJabWMyVjBMQ0E0S1N4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WDJ4bFlXUnBibWREYUdGeUtHVnVkSEo1TG1GeVkyaHBkbVZrVTJsNlpTd2dKeUFuTENBNEtTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgyeGxZV1JwYm1kRGFHRnlLR1Z1ZEhKNUxuTnBlbVVzSUNjZ0p5d2dPQ2tzWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbDltYjNKdFlYUlhiM0prS0dWdWRISjVMbVpzWVdkekxDQTRLVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQmRMbXB2YVc0b0oxeGNkQ2NwS1R0Y2NseHVJQ0FnSUNBZ0lDQjlLVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG1sdVptOG9LVHRjY2x4dUlDQWdJSDA3WEhKY2JseHlYRzRnSUNBZ2NIVmliR2xqSUhKbFlXUkdhV3hsS0dacGJHVnVZVzFsT2lCemRISnBibWNzSUdadmNtTmxSR1ZqYjIxd2NtVnpjeUE5SUdaaGJITmxLVG9nUW5WbVptVnlJSHRjY2x4dUlDQWdJQ0FnSUNCbWRXNWpkR2x2YmlCa1pXTnZiWEJ5WlhOektHUmhkR0U2SUVKMVptWmxjaWs2SUVKMVptWmxjaUI3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElHTnZiWEJ5WlhOemFXOXVWSGx3WlNBOUlHUmhkR0V1Y21WaFpGVkpiblE0S0RBcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9ZMjl0Y0hKbGMzTnBiMjVVZVhCbElEMDlQU0F3S1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z1pHRjBZVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hqYjIxd2NtVnpjMmx2YmxSNWNHVWdQVDA5SURJcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25WVzV6ZFhCd2IzSjBaV1FnWTI5dGNISmxjM05wYjI0Z2RIbHdaU0JjSW5wc2FXSmNJaTRuS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoamIyMXdjbVZ6YzJsdmJsUjVjR1VnUFQwOUlERTJLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WM0lFSjFabVpsY2loamIyMXdjbVZ6Y3k1Q2VtbHdNaTVrWldOdmJYQnlaWE56Um1sc1pTaGtZWFJoTG5Oc2FXTmxLREVwS1NrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjFWdWMzVndjRzl5ZEdWa0lHTnZiWEJ5WlhOemFXOXVJSFI1Y0dVdUp5azdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JseHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHaGhjMmhGYm5SeWVTQTlJSFJvYVhNdVgyZGxkRWhoYzJoVVlXSnNaVVZ1ZEhKNUtHWnBiR1Z1WVcxbEtUdGNjbHh1SUNBZ0lDQWdJQ0JwWmlBb0lXaGhjMmhGYm5SeWVTa2dleUJ5WlhSMWNtNGdiblZzYkRzZ2ZWeHlYRzRnSUNBZ0lDQWdJR052Ym5OMElHSnNiMk5yUlc1MGNua2dQU0IwYUdsekxsOWliRzlqYTFSaFlteGxXMmhoYzJoRmJuUnllUzVpYkc5amExUmhZbXhsU1c1a1pYaGRPMXh5WEc0Z0lDQWdJQ0FnSUdsbUlDaGliRzlqYTBWdWRISjVMbVpzWVdkeklDWWdUVkJSWDBaSlRFVmZSVmhKVTFSVEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2hpYkc5amEwVnVkSEo1TG1GeVkyaHBkbVZrVTJsNlpTQTlQVDBnTUNrZ2V5QnlaWFIxY200Z2JuVnNiRHNnZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnZabVp6WlhRZ1BTQmliRzlqYTBWdWRISjVMbTltWm5ObGRDQXJJSFJvYVhNdVgyaGxZV1JsY2k1dlptWnpaWFE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR3hsZENCbWFXeGxSR0YwWVNBOUlIUm9hWE11WDJSaGRHRXVjMnhwWTJVb2IyWm1jMlYwTENCdlptWnpaWFFnS3lCaWJHOWphMFZ1ZEhKNUxtRnlZMmhwZG1Wa1UybDZaU2s3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNoaWJHOWphMFZ1ZEhKNUxtWnNZV2R6SUNZZ1RWQlJYMFpKVEVWZlJVNURVbGxRVkVWRUtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMFZ1WTNKNWNIUnBiMjRnYVhNZ2JtOTBJSE4xY0hCdmNuUmxaQ0I1WlhRbktUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9JU2hpYkc5amEwVnVkSEo1TG1ac1lXZHpJQ1lnVFZCUlgwWkpURVZmVTBsT1IweEZYMVZPU1ZRcEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqYjI1emRDQnpaV04wYjNKVGFYcGxJRDBnTlRFeUlEdzhJSFJvYVhNdVgyaGxZV1JsY2k1elpXTjBiM0pUYVhwbFUyaHBablE3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCc1pYUWdjMlZqZEc5eWN5QTlJRTFoZEdndWRISjFibU1vWW14dlkydEZiblJ5ZVM1emFYcGxJQzhnYzJWamRHOXlVMmw2WlNrZ0t5QXhPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHTnlZem9nWW05dmJHVmhianRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDaGliRzlqYTBWdWRISjVMbVpzWVdkeklDWWdUVkJSWDBaSlRFVmZVMFZEVkU5U1gwTlNReWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR055WXlBOUlIUnlkV1U3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjMlZqZEc5eWN5QXJQU0F4TzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqY21NZ1BTQm1ZV3h6WlR0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR052Ym5OMElIQnZjMmwwYVc5dWN5QTlJRnRkTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQW9jMlZqZEc5eWN5QXJJREVwT3lCcEt5c3BJSHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQndiM05wZEdsdmJuTmJhVjBnUFNCbWFXeGxSR0YwWVM1eVpXRmtWVWx1ZERNeVRFVW9OQ0FxSUdrcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdiRzRnUFNCd2IzTnBkR2x2Ym5NdWJHVnVaM1JvSUMwZ0tHTnlZeUEvSURJZ09pQXhLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUd4bGRDQnlaWE4xYkhRZ1BTQnVaWGNnUW5WbVptVnlLREFwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2JHVjBJSE5sWTNSdmNrSjVkR1Z6VEdWbWRDQTlJR0pzYjJOclJXNTBjbmt1YzJsNlpUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJR2tnUFNBd095QnBJRHdnYkc0N0lHa3JLeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3hsZENCelpXTjBiM0lnUFNCbWFXeGxSR0YwWVM1emJHbGpaU2h3YjNOcGRHbHZibk5iYVYwc0lIQnZjMmwwYVc5dWMxdHBJQ3NnTVYwcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdsbUlDZ29ZbXh2WTJ0RmJuUnllUzVtYkdGbmN5QW1JRTFRVVY5R1NVeEZYME5QVFZCU1JWTlRLU0FtSmlBb1ptOXlZMlZFWldOdmJYQnlaWE56SUh4OElDaHpaV04wYjNKQ2VYUmxjMHhsWm5RZ1BpQnpaV04wYjNJdWJHVnVaM1JvS1NrcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjMlZqZEc5eUlEMGdaR1ZqYjIxd2NtVnpjeWh6WldOMGIzSXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCelpXTjBiM0pDZVhSbGMweGxablFnTFQwZ2MyVmpkRzl5TG14bGJtZDBhRHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRZ1BTQkNkV1ptWlhJdVkyOXVZMkYwS0Z0eVpYTjFiSFFzSUhObFkzUnZjbDBwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdabWxzWlVSaGRHRWdQU0J5WlhOMWJIUTdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvS0dKc2IyTnJSVzUwY25rdVpteGhaM01nSmlCTlVGRmZSa2xNUlY5RFQwMVFVa1ZUVXlrZ0ppWWdLR1p2Y21ObFJHVmpiMjF3Y21WemN5QjhmQ0FvWW14dlkydEZiblJ5ZVM1emFYcGxJRDRnWW14dlkydEZiblJ5ZVM1aGNtTm9hWFpsWkZOcGVtVXBLU2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1pwYkdWRVlYUmhJRDBnWkdWamIyMXdjbVZ6Y3lobWFXeGxSR0YwWVNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUdacGJHVkVZWFJoTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1WEhKY2JpQWdJQ0J3Y21sMllYUmxJRjlzWldGa2FXNW5RMmhoY2loemRISTZJSE4wY21sdVp5QjhJRzUxYldKbGNpd2dZMmc2SUhOMGNtbHVaeXdnYkc0NklHNTFiV0psY2l3Z1lXWjBaWElnUFNCbVlXeHpaU2s2SUhOMGNtbHVaeUI3WEhKY2JpQWdJQ0FnSUNBZ2MzUnlJRDBnSnljZ0t5QnpkSEk3WEhKY2JpQWdJQ0FnSUNBZ2QyaHBiR1VnS0hOMGNpNXNaVzVuZEdnZ1BDQnNiaWtnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6ZEhJZ1BTQmhablJsY2lBL0lITjBjaUFySUdOb0lEb2dZMmdnS3lCemRISTdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCemRISTdYSEpjYmlBZ0lDQjlYSEpjYmx4eVhHNGdJQ0FnY0hKcGRtRjBaU0JmWm05eWJXRjBWMjl5WkNoa1lYUmhPaUJ1ZFcxaVpYSXNJR3h1T2lCdWRXMWlaWElwT2lCemRISnBibWNnZTF4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbDlzWldGa2FXNW5RMmhoY2loa1lYUmhMblJ2VTNSeWFXNW5LREUyS1M1MGIxVndjR1Z5UTJGelpTZ3BMQ0FuTUNjc0lHeHVLVHRjY2x4dUlDQWdJSDFjY2x4dVhISmNibHh5WEc0Z0lDQWdjSEpwZG1GMFpTQmZaMlYwU0dGemFGUmhZbXhsUlc1MGNua29abWxzWlc1aGJXVTZJSE4wY21sdVp5azZJRTFRVVVoaGMyaFVZV0pzWlVWdWRISjVJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JvWVhOb1FTQTlJSFJvYVhNdVgyaGhjMmdvWm1sc1pXNWhiV1VzSUNkSVFWTklYMEVuS1R0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCb1lYTm9RaUE5SUhSb2FYTXVYMmhoYzJnb1ptbHNaVzVoYldVc0lDZElRVk5JWDBJbktUdGNjbHh1SUNBZ0lDQWdJQ0JtYjNJZ0tHTnZibk4wSUdWdWRISjVJRzltSUhSb2FYTXVYMmhoYzJoVVlXSnNaU2tnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JwWmlBb1pXNTBjbmt1YUdGemFFRWdQVDA5SUdoaGMyaEJJQ1ltSUdWdWRISjVMbWhoYzJoQ0lEMDlQU0JvWVhOb1Fpa2dlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1Z1ZEhKNU8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOU8xeHlYRzRnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZFc1a1pXWnBibVZrTzF4eVhHNGdJQ0FnZlZ4eVhHNWNjbHh1SUNBZ0lIQnlhWFpoZEdVZ1gzSmxZV1JJWldGa1pYSW9LVG9nVFZCUlJtbHNaVWhsWVdSbGNpQjdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElHaGxZV1JsY2pvZ1RWQlJSbWxzWlVobFlXUmxjanRjY2x4dVhISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2FHVmhaQ0E5SUhSb2FYTXVYMlJoZEdFdWRHOVRkSEpwYm1jb0ozVjBaaTA0Snl3Z01Dd2dOQ2s3WEhKY2JpQWdJQ0FnSUNBZ2FXWWdLR2hsWVdRZ1BUMDlJQ2ROVUZGY1hIZ3hZU2NwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYUdWaFpHVnlJRDBnZEdocGN5NWZjbVZoWkUxUVVVaGxZV1JsY2lncE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCb1pXRmtaWEl1YjJabWMyVjBJRDBnTUR0Y2NseHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLR2hsWVdRZ1BUMDlJQ2ROVUZGY1hIZ3hZaWNwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWMzUWdkWE5sY2tSaGRHRklaV0ZrWlhJZ1BTQjBhR2x6TGw5eVpXRmtUVkJSVlhObGNrUmhkR0ZJWldGa1pYSW9LVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdhR1ZoWkdWeUlEMGdkR2hwY3k1ZmNtVmhaRTFRVVVobFlXUmxjaWgxYzJWeVJHRjBZVWhsWVdSbGNpNXRjSEZJWldGa1pYSlBabVp6WlhRcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCb1pXRmtaWEl1YjJabWMyVjBJRDBnZFhObGNrUmhkR0ZJWldGa1pYSXViWEJ4U0dWaFpHVnlUMlptYzJWME8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCb1pXRmtaWEl1ZFhObGNrUmhkR0ZJWldGa1pYSWdQU0IxYzJWeVJHRjBZVWhsWVdSbGNqdGNjbHh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owbHVkbUZzYVdRZ1RWQlJJR1pwYkdVZ2FHVmhaR1Z5SnlrN1hISmNiaUFnSUNBZ0lDQWdmVnh5WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJvWldGa1pYSTdYSEpjYmlBZ0lDQjlYSEpjYmx4eVhHNGdJQ0FnY0hKcGRtRjBaU0JmY21WaFpFMVFVVlZ6WlhKRVlYUmhTR1ZoWkdWeUtDazZJRTFRVVZWelpYSkVZWFJoU0dWaFpHVnlJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JrWVhSaElEMGdkR2hwY3k1ZlpHRjBZUzV6YkdsalpTZ3dMQ0F4TmlrN1hISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2FHVmhaR1Z5SUQwZ2JtVjNJRTFRVVZWelpYSkVZWFJoU0dWaFpHVnlLR1JoZEdFcE8xeHlYRzRnSUNBZ0lDQWdJR2hsWVdSbGNpNWpiMjUwWlc1MElEMGdkR2hwY3k1ZlpHRjBZUzV6YkdsalpTZ3hOaXdnTVRZZ0t5Qm9aV0ZrWlhJdWRYTmxja1JoZEdGSVpXRmtaWEpUYVhwbEtUdGNjbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdhR1ZoWkdWeU8xeHlYRzRnSUNBZ2ZWeHlYRzVjY2x4dUlDQWdJSEJ5YVhaaGRHVWdYM0psWVdSTlVGRklaV0ZrWlhJb2IyWm1jMlYwSUQwZ01DazZJRTFRVVVacGJHVklaV0ZrWlhJZ2UxeHlYRzRnSUNBZ0lDQWdJR3hsZENCa1lYUmhJRDBnZEdocGN5NWZaR0YwWVM1emJHbGpaU2h2Wm1aelpYUXNJRzltWm5ObGRDQXJJRE15S1R0Y2NseHVJQ0FnSUNBZ0lDQnNaWFFnYUdWaFpHVnlJRDBnYm1WM0lFMVFVVVpwYkdWSVpXRmtaWElvWkdGMFlTazdYSEpjYmlBZ0lDQWdJQ0FnYVdZZ0tHaGxZV1JsY2k1bWIzSnRZWFJXWlhKemFXOXVJRDA5UFNBeEtTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHUmhkR0VnUFNCMGFHbHpMbDlrWVhSaExuTnNhV05sS0c5bVpuTmxkQ0FySURNeUxDQnZabVp6WlhRZ0t5QXpNaUFySURFeUtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2FHVmhaR1Z5SUQwZ1BFMVFVVVpwYkdWSVpXRmtaWEkrVDJKcVpXTjBMbUZ6YzJsbmJpaHVaWGNnVFZCUlJtbHNaVWhsWVdSbGNrVjRkQ2hrWVhSaEtTd2dhR1ZoWkdWeUtUdGNjbHh1SUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdobFlXUmxjanRjY2x4dUlDQWdJSDFjY2x4dVhISmNiaUFnSUNCd2NtbDJZWFJsSUY5eVpXRmtWR0ZpYkdVb2RHRmliR1ZVZVhCbE9pQW5hR0Z6YUNjcE9pQk5VRkZJWVhOb1ZHRmliR1ZGYm5SeWVWdGRPMXh5WEc0Z0lDQWdjSEpwZG1GMFpTQmZjbVZoWkZSaFlteGxLSFJoWW14bFZIbHdaVG9nSjJKc2IyTnJKeWs2SUUxUVVVSnNiMk5yVkdGaWJHVkZiblJ5ZVZ0ZE8xeHlYRzRnSUNBZ2NISnBkbUYwWlNCZmNtVmhaRlJoWW14bEtIUmhZbXhsVkhsd1pUb2dKMmhoYzJnbklId2dKMkpzYjJOckp5a2dlMXh5WEc0Z0lDQWdJQ0FnSUd4bGRDQjBlWEJsT2lCaGJuazdYSEpjYmlBZ0lDQWdJQ0FnYzNkcGRHTm9JQ2gwWVdKc1pWUjVjR1VwSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTJGelpTQW5hR0Z6YUNjNlhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBlWEJsSUQwZ1RWQlJTR0Z6YUZSaFlteGxSVzUwY25rN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnWTJGelpTQW5ZbXh2WTJzbk9seHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkSGx3WlNBOUlIUjVjR1VnUFNCTlVGRkNiRzlqYTFSaFlteGxSVzUwY25rN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmljbVZoYXp0Y2NseHVJQ0FnSUNBZ0lDQjlYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkR0ZpYkdWUFptWnpaWFFnUFNCMGFHbHpMbDlvWldGa1pYSmJkR0ZpYkdWVWVYQmxJQ3NnSjFSaFlteGxUMlptYzJWMEoxMDdYSEpjYmlBZ0lDQWdJQ0FnWTI5dWMzUWdkR0ZpYkdWRmJuUnlhV1Z6SUQwZ2RHaHBjeTVmYUdWaFpHVnlXM1JoWW14bFZIbHdaU0FySUNkVVlXSnNaVVZ1ZEhKcFpYTW5YVHRjY2x4dVhISmNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2EyVjVJRDBnZEdocGN5NWZhR0Z6YUNnbktDY2dLeUIwWVdKc1pWUjVjR1VnS3lBbklIUmhZbXhsS1Njc0lDZFVRVUpNUlNjcE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCa1lYUmhJRDBnZEdocGN5NWZaR0YwWVM1emJHbGpaU2gwWVdKc1pVOW1abk5sZENBcklIUm9hWE11WDJobFlXUmxjaTV2Wm1aelpYUXNJSFJoWW14bFQyWm1jMlYwSUNzZ2RHaHBjeTVmYUdWaFpHVnlMbTltWm5ObGRDQXJJSFJoWW14bFJXNTBjbWxsY3lBcUlERTJLVHRjY2x4dUlDQWdJQ0FnSUNCa1lYUmhJRDBnZEdocGN5NWZaR1ZqY25sd2RDaGtZWFJoTENCclpYa3BPMXh5WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJR1Z1ZEhKcFpYTWdQU0JiWFR0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0d4bGRDQnBJRDBnTURzZ2FTQThJSFJoWW14bFJXNTBjbWxsY3pzZ2FTc3JLU0I3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJR1Z1ZEhKcFpYTmJhVjBnUFNCdVpYY2dkSGx3WlNoa1lYUmhMbk5zYVdObEtHa2dLaUF4Tml3Z2FTQXFJREUySUNzZ01UWXBLVHRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHVnVkSEpwWlhNN1hISmNiaUFnSUNCOVhISmNibHh5WEc0Z0lDQWdjSEpwZG1GMFpTQmZhR0Z6YUNoMllXeDFaVG9nYzNSeWFXNW5MQ0JvWVhOb1ZIbHdaVG9nYzNSeWFXNW5LVG9nYm5WdFltVnlJSHRjY2x4dUlDQWdJQ0FnSUNCc1pYUWdjMlZsWkRFZ1BTQnVaWGNnVEc5dVp5NW1jbTl0Vm1Gc2RXVW9NSGczUmtWRU4wWkZSQ3dnZEhKMVpTazdYSEpjYmlBZ0lDQWdJQ0FnYkdWMElITmxaV1F5SUQwZ2JtVjNJRXh2Ym1jdVpuSnZiVlpoYkhWbEtEQjRSVVZGUlVWRlJVVXNJSFJ5ZFdVcE8xeHlYRzRnSUNBZ0lDQWdJR3hsZENCeVpYTjFiSFE2SUdGdWVUdGNjbHh1SUNBZ0lDQWdJQ0JzWlhRZ1kyZzZJR0Z1ZVR0Y2NseHVJQ0FnSUNBZ0lDQm1iM0lnS0dOb0lHOW1JSFpoYkhWbExuUnZWWEJ3WlhKRFlYTmxLQ2twSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHbHpUbUZPS0hCaGNuTmxTVzUwS0dOb0xDQXhNQ2twS1NCN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmphQ0E5SUdOb0xtTnZaR1ZRYjJsdWRFRjBLREFwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0I5WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSEpsYzNWc2RDQTlJRzVsZHlCTWIyNW5MbVp5YjIxV1lXeDFaU2gwYUdsekxsOWxibU55ZVhCMGFXOXVWR0ZpYkdWYktHaGhjMmhVZVhCbGMxdG9ZWE5vVkhsd1pWMGdQRHdnT0NrZ0t5QmphRjBzSUhSeWRXVXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnpaV1ZrTVNBOUlISmxjM1ZzZEM1NGIzSW9jMlZsWkRFdVlXUmtLSE5sWldReUtTa3VZVzVrS0RCNFJrWkdSa1pHUmtZcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCelpXVmtNaUE5SUhObFpXUXhMbUZrWkNoelpXVmtNaWt1WVdSa0tHTm9LUzVoWkdRb2MyVmxaREl1YzJocFpuUk1aV1owS0RVcEtTNWhaR1FvTXlrdVlXNWtLREI0UmtaR1JrWkdSa1lwTzF4eVhHNGdJQ0FnSUNBZ0lIMWNjbHh1WEhKY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhObFpXUXhMblJ2VG5WdFltVnlLQ2s3WEhKY2JpQWdJQ0I5WEhKY2JseHlYRzRnSUNBZ2NISnBkbUYwWlNCZlpHVmpjbmx3ZENoa1lYUmhPaUJDZFdabVpYSXNJR3RsZVRvZ2JuVnRZbVZ5S1RvZ1FuVm1abVZ5SUh0Y2NseHVJQ0FnSUNBZ0lDQmpiMjV6ZENCeVpYTjFiSFFnUFNCdVpYY2dRblZtWm1WeUtHUmhkR0V1YkdWdVozUm9LVHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0JzYmlBOUlHUmhkR0V1YkdWdVozUm9JQzhnTkR0Y2NseHVJQ0FnSUNBZ0lDQnNaWFFnYzJWbFpERWdQU0J1WlhjZ1RHOXVaeTVtY205dFZtRnNkV1VvYTJWNUxDQjBjblZsS1R0Y2NseHVJQ0FnSUNBZ0lDQnNaWFFnYzJWbFpESWdQU0J1WlhjZ1RHOXVaeTVtY205dFZtRnNkV1VvTUhoRlJVVkZSVVZGUlN3Z2RISjFaU2s3WEhKY2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQnNianNnYVNzcktTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDOHZJSFJ6YkdsdWREcGthWE5oWW14bExXNWxlSFF0YkdsdVpUcHVieTFpYVhSM2FYTmxYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lITmxaV1F5SUQwZ2MyVmxaREl1WVdSa0tIUm9hWE11WDJWdVkzSjVjSFJwYjI1VVlXSnNaVnN3ZURRd01DQXJJQ2h6WldWa01TQW1JREI0UmtZcFhTazdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lITmxaV1F5SUQwZ2MyVmxaREl1WVc1a0tEQjRSa1pHUmtaR1JrWXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaWFFnZG1Gc2RXVWdQU0J1WlhjZ1RHOXVaeTVtY205dFZtRnNkV1VvWkdGMFlTNXlaV0ZrVlVsdWRETXlURVVvYVNBcUlEUXBMQ0IwY25WbEtUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2RtRnNkV1VnUFNCMllXeDFaUzU0YjNJb2MyVmxaREV1WVdSa0tITmxaV1F5S1NrdVlXNWtLREI0UmtaR1JrWkdSa1lwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J6WldWa01TQTlJSE5sWldReExuaHZjaWd0TVNrdWMyaHBablJNWldaMEtEQjRNVFVwTG1Ga1pDZ3dlREV4TVRFeE1URXhLUzV2Y2loelpXVmtNUzV6YUdsbWRGSnBaMmgwS0RCNE1FSXBLVHRjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdjMlZsWkRFZ1BTQnpaV1ZrTVM1aGJtUW9NSGhHUmtaR1JrWkdSaWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJSE5sWldReUlEMGdkbUZzZFdVdVlXUmtLSE5sWldReUtTNWhaR1FvYzJWbFpESXVjMmhwWm5STVpXWjBLRFVwS1M1aFpHUW9NeWt1WVc1a0tEQjRSa1pHUmtaR1JrWXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE4xYkhRdWQzSnBkR1ZWU1c1ME16SkNSU2gyWVd4MVpTNTBiMDUxYldKbGNpZ3BMQ0JwSUNvZ05DazdYSEpjYmlBZ0lDQWdJQ0FnZlZ4eVhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCeVpYTjFiSFE3WEhKY2JpQWdJQ0I5WEhKY2JuMWNjbHh1SWwxOVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICsgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICsgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJ2YXIgY2hhcmVuYyA9IHtcbiAgLy8gVVRGLTggZW5jb2RpbmdcbiAgdXRmODoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gY2hhcmVuYy5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjaGFyZW5jLmJpbi5ieXRlc1RvU3RyaW5nKGJ5dGVzKSkpO1xuICAgIH1cbiAgfSxcblxuICAvLyBCaW5hcnkgZW5jb2RpbmdcbiAgYmluOiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN0ciA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSk7XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyZW5jO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZTY0bWFwXG4gICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcblxuICBjcnlwdCA9IHtcbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiBsZWZ0XG4gICAgcm90bDogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8IGIpIHwgKG4gPj4+ICgzMiAtIGIpKTtcbiAgICB9LFxuXG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gcmlnaHRcbiAgICByb3RyOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgKDMyIC0gYikpIHwgKG4gPj4+IGIpO1xuICAgIH0sXG5cbiAgICAvLyBTd2FwIGJpZy1lbmRpYW4gdG8gbGl0dGxlLWVuZGlhbiBhbmQgdmljZSB2ZXJzYVxuICAgIGVuZGlhbjogZnVuY3Rpb24obikge1xuICAgICAgLy8gSWYgbnVtYmVyIGdpdmVuLCBzd2FwIGVuZGlhblxuICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdC5yb3RsKG4sIDgpICYgMHgwMEZGMDBGRiB8IGNyeXB0LnJvdGwobiwgMjQpICYgMHhGRjAwRkYwMDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxzZSwgYXNzdW1lIGFycmF5IGFuZCBzd2FwIGFsbCBpdGVtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgICAgICBuW2ldID0gY3J5cHQuZW5kaWFuKG5baV0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIGFueSBsZW5ndGggb2YgcmFuZG9tIGJ5dGVzXG4gICAgcmFuZG9tQnl0ZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW107IG4gPiAwOyBuLS0pXG4gICAgICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGJpZy1lbmRpYW4gMzItYml0IHdvcmRzXG4gICAgYnl0ZXNUb1dvcmRzOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgd29yZHMgPSBbXSwgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOClcbiAgICAgICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBiaWctZW5kaWFuIDMyLWJpdCB3b3JkcyB0byBhIGJ5dGUgYXJyYXlcbiAgICB3b3Jkc1RvQnl0ZXM6IGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpXG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAgICBieXRlc1RvSGV4OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBoZXhUb0J5dGVzOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZS02NCBzdHJpbmdcbiAgICBieXRlc1RvQmFzZTY0OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgYmFzZTY0ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPD0gYnl0ZXMubGVuZ3RoICogOClcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopKSAmIDB4M0YpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiYXNlNjQucHVzaCgnPScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJhc2UtNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGJhc2U2NFRvQnl0ZXM6IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgLy8gUmVtb3ZlIG5vbi1iYXNlLTY0IGNoYXJhY3RlcnNcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2lnLCAnJyk7XG5cbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwLCBpbW9kNCA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoO1xuICAgICAgICAgIGltb2Q0ID0gKytpICUgNCkge1xuICAgICAgICBpZiAoaW1vZDQgPT0gMCkgY29udGludWU7XG4gICAgICAgIGJ5dGVzLnB1c2goKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICYgKE1hdGgucG93KDIsIC0yICogaW1vZDQgKyA4KSAtIDEpKSA8PCAoaW1vZDQgKiAyKSlcbiAgICAgICAgICAgIHwgKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpID4+PiAoNiAtIGltb2Q0ICogMikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcnlwdDtcbn0pKCk7XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIGNvbnNvbGUuYXNzZXJ0ICE9PSBcImZ1bmN0aW9uXCIpIHsgY29uc29sZS5hc3NlcnQgPSBmdW5jdGlvbiAoKSB7fSB9O1xuZXhwb3J0cy5CV1QgPSByZXF1aXJlKCcuL291dGxpYi9CV1QnKTtcbmV4cG9ydHMuQldUQyA9IHJlcXVpcmUoJy4vb3V0bGliL0JXVEMnKTtcbmV4cG9ydHMuQml0U3RyZWFtID0gcmVxdWlyZSgnLi9vdXRsaWIvQml0U3RyZWFtJyk7XG5leHBvcnRzLkJ6aXAyID0gcmVxdWlyZSgnLi9vdXRsaWIvQnppcDInKTtcbmV4cG9ydHMuQ1JDMzIgPSByZXF1aXJlKCcuL291dGxpYi9DUkMzMicpO1xuZXhwb3J0cy5Db250ZXh0MU1vZGVsID0gcmVxdWlyZSgnLi9vdXRsaWIvQ29udGV4dDFNb2RlbCcpO1xuZXhwb3J0cy5EZWZTdW1Nb2RlbCA9IHJlcXVpcmUoJy4vb3V0bGliL0RlZlN1bU1vZGVsJyk7XG5leHBvcnRzLkRlZmxhdGVEaXN0YW5jZU1vZGVsID0gcmVxdWlyZSgnLi9vdXRsaWIvRGVmbGF0ZURpc3RhbmNlTW9kZWwnKTtcbmV4cG9ydHMuRG1jID0gcmVxdWlyZSgnLi9vdXRsaWIvRG1jJyk7XG5leHBvcnRzLkR1bW15UmFuZ2VDb2RlciA9IHJlcXVpcmUoJy4vb3V0bGliL0R1bW15UmFuZ2VDb2RlcicpO1xuZXhwb3J0cy5GZW53aWNrTW9kZWwgPSByZXF1aXJlKCcuL291dGxpYi9GZW53aWNrTW9kZWwnKTtcbmV4cG9ydHMuSHVmZm1hbiA9IHJlcXVpcmUoJy4vb3V0bGliL0h1ZmZtYW4nKTtcbmV4cG9ydHMuSHVmZm1hbkFsbG9jYXRvciA9IHJlcXVpcmUoJy4vb3V0bGliL0h1ZmZtYW5BbGxvY2F0b3InKTtcbmV4cG9ydHMuTG9nRGlzdGFuY2VNb2RlbCA9IHJlcXVpcmUoJy4vb3V0bGliL0xvZ0Rpc3RhbmNlTW9kZWwnKTtcbmV4cG9ydHMuTHpqYiA9IHJlcXVpcmUoJy4vb3V0bGliL0x6amInKTtcbmV4cG9ydHMuTHpqYlIgPSByZXF1aXJlKCcuL291dGxpYi9MempiUicpO1xuZXhwb3J0cy5MenAzID0gcmVxdWlyZSgnLi9vdXRsaWIvTHpwMycpO1xuZXhwb3J0cy5NVEZNb2RlbCA9IHJlcXVpcmUoJy4vb3V0bGliL01URk1vZGVsJyk7XG5leHBvcnRzLk5vTW9kZWwgPSByZXF1aXJlKCcuL291dGxpYi9Ob01vZGVsJyk7XG5leHBvcnRzLlBQTSA9IHJlcXVpcmUoJy4vb3V0bGliL1BQTScpO1xuZXhwb3J0cy5SYW5nZUNvZGVyID0gcmVxdWlyZSgnLi9vdXRsaWIvUmFuZ2VDb2RlcicpO1xuZXhwb3J0cy5TaW1wbGUgPSByZXF1aXJlKCcuL291dGxpYi9TaW1wbGUnKTtcbmV4cG9ydHMuU3RyZWFtID0gcmVxdWlyZSgnLi9vdXRsaWIvU3RyZWFtJyk7XG5leHBvcnRzLlV0aWwgPSByZXF1aXJlKCcuL291dGxpYi9VdGlsJyk7XG5leHBvcnRzLmZyZWV6ZSA9IHJlcXVpcmUoJy4vb3V0bGliL2ZyZWV6ZScpO1xuIiwiLyoqIEJ1cnJvd3MtV2hlZWxlciB0cmFuc2Zvcm0sIGNvbXB1dGVkIHdpdGggdGhlIEluZHVjZWQgU29ydGluZyBTdWZmaXggQXJyYXlcbiAqICBjb25zdHJ1Y3Rpb24gbWVjaGFuaXNtIChzYWlzKS4gIENvZGUgaXMgYSBwb3J0IG9mOlxuICogICAgaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL3NpdGUveXV0YTI1Ni9zYWlzXG4gKiAgd2hpY2ggaXM6XG4gKiAgICBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMCBZdXRhIE1vcmkgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqICBhbmQgbGljZW5zZWQgdW5kZXIgYW4gTUlUL1gxMSBsaWNlbnNlLiAgSSBnZW5lcmFsbHkgbG9va2VkIGF0IGJvdGhcbiAqICB0aGUgQyBhbmQgdGhlIEphdmEgaW1wbGVtZW50YXRpb25zIHRvIGd1aWRlIG15IHdvcmsuXG4gKlxuICogVGhpcyBKYXZhU2NyaXB0IHBvcnQgaXM6XG4gKiAgICBDb3B5cmlnaHQgKGMpIDIwMTMgQy4gU2NvdHQgQW5hbmlhblxuICogYW5kIGxpY2Vuc2VkIHVuZGVyIEdQTHYyOyBzZWUgdGhlIFJFQURNRSBhdCB0aGUgdG9wIGxldmVsIG9mIHRoaXMgcGFja2FnZS5cbiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vZnJlZXplJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoZnJlZXplLCBVdGlsKSB7XG4gICAgdmFyIEFTU0VSVCA9IGNvbnNvbGUuYXNzZXJ0LmJpbmQoY29uc29sZSk7XG5cbiAgICAvLyB3ZSdyZSBkaXNwZW5zaW5nIHdpdGggdGhlIFwiYXJiaXRyYXJ5IGFscGhhYmV0XCIgc3R1ZmYgb2YgdGhlIHNvdXJjZVxuICAgIC8vIGFuZCBqdXN0IHVzaW5nIFVpbnQ4QXJyYXlzLlxuXG4gICAgLyoqIEZpbmQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBlYWNoIGJ1Y2tldC4gKi9cbiAgICB2YXIgZ2V0Q291bnRzID0gZnVuY3Rpb24oVCwgQywgbiwgaykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGs7IGkrKykgeyBDW2ldID0gMDsgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7IENbVFtpXV0rKzsgfVxuICAgIH07XG4gICAgdmFyIGdldEJ1Y2tldHMgPSBmdW5jdGlvbihDLCBCLCBrLCBlbmQpIHtcbiAgICAgICAgdmFyIGksIHN1bSA9IDA7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHsgc3VtICs9IENbaV07IEJbaV0gPSBzdW07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHsgc3VtICs9IENbaV07IEJbaV0gPSBzdW0gLSBDW2ldOyB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIFNvcnQgYWxsIHR5cGUgTE1TIHN1ZmZpeGVzICovXG4gICAgdmFyIExNU3NvcnQgPSBmdW5jdGlvbihULCBTQSwgQywgQiwgbiwgaykge1xuICAgICAgICB2YXIgYiwgaSwgajtcbiAgICAgICAgdmFyIGMwLCBjMTtcbiAgICAgICAgLyogY29tcHV0ZSBTQWwgKi9cbiAgICAgICAgaWYgKEMgPT09IEIpIHsgZ2V0Q291bnRzKFQsIEMsIG4sIGspOyB9XG4gICAgICAgIGdldEJ1Y2tldHMoQywgQiwgaywgZmFsc2UpOyAvKiBmaW5kIHN0YXJ0cyBvZiBidWNrZXRzICovXG4gICAgICAgIGogPSBuIC0gMTtcbiAgICAgICAgYiA9IEJbYzEgPSBUW2pdXTtcbiAgICAgICAgai0tO1xuICAgICAgICBTQVtiKytdID0gKFRbal0gPCBjMSkgPyB+aiA6IGo7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoaiA9IFNBW2ldKSA+IDApIHtcbiAgICAgICAgICAgICAgICBBU1NFUlQoVFtqXSA+PSBUW2orMV0pO1xuICAgICAgICAgICAgICAgIGlmICgoYzAgPSBUW2pdKSAhPT0gYzEpIHsgQltjMV0gPSBiOyBiID0gQltjMSA9IGMwXTsgfVxuICAgICAgICAgICAgICAgIEFTU0VSVChpIDwgYik7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIFNBW2IrK10gPSAoVFtqXSA8IGMxKSA/IH5qIDogajtcbiAgICAgICAgICAgICAgICBTQVtpXSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICAgICAgU0FbaV0gPSB+ajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBjb21wdXRlIFNBcyAqL1xuICAgICAgICBpZiAoQyA9PT0gQikgeyBnZXRDb3VudHMoVCwgQywgbiwgayk7IH1cbiAgICAgICAgZ2V0QnVja2V0cyhDLCBCLCBrLCAxKTsgLyogZmluZCBlbmRzIG9mIGJ1Y2tldHMgKi9cbiAgICAgICAgZm9yIChpID0gbi0xLCBiID0gQltjMSA9IDBdOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKChqID0gU0FbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgIEFTU0VSVChUW2pdIDw9IFRbaisxXSk7XG4gICAgICAgICAgICAgICAgaWYgKChjMCA9IFRbal0pICE9PSBjMSkgeyBCW2MxXSA9IGI7IGIgPSBCW2MxID0gYzBdOyB9XG4gICAgICAgICAgICAgICAgQVNTRVJUKGIgPD0gaSk7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIFNBWy0tYl0gPSAoVFtqXSA+IGMxKSA/IH4oaisxKSA6IGo7XG4gICAgICAgICAgICAgICAgU0FbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBMTVNwb3N0cHJvYyA9IGZ1bmN0aW9uKFQsIFNBLCBuLCBtKSB7XG4gICAgICAgIHZhciBpLCBqLCBwLCBxLCBwbGVuLCBxbGVuLCBuYW1lO1xuICAgICAgICB2YXIgYzAsIGMxO1xuICAgICAgICB2YXIgZGlmZjtcblxuICAgICAgICAvKiBjb21wYWN0IGFsbCB0aGUgc29ydGVkIHN1YnN0cmluZ3MgaW50byB0aGUgZmlyc3QgbSBpdGVtcyBvZiBTQVxuICAgICAgICAgKiAyKm0gbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gbiAocHJvdmFibGUpICovXG4gICAgICAgIEFTU0VSVChuID4gMCk7XG4gICAgICAgIGZvciAoaSA9IDA7IChwID0gU0FbaV0pIDwgMDsgaSsrKSB7IFNBW2ldID0gfnA7IEFTU0VSVCgoaSsxKSA8IG4pOyB9XG4gICAgICAgIGlmIChpIDwgbSkge1xuICAgICAgICAgICAgZm9yIChqID0gaSwgaSsrOyA7IGkrKykge1xuICAgICAgICAgICAgICAgIEFTU0VSVChpIDwgbik7XG4gICAgICAgICAgICAgICAgaWYgKChwID0gU0FbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBTQVtqKytdID0gfnA7IFNBW2ldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IG0pIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBzdG9yZSB0aGUgbGVuZ3RoIG9mIGFsbCBzdWJzdHJpbmdzICovXG4gICAgICAgIGMwID0gVFtpID0gaiA9IG4gLSAxXTtcbiAgICAgICAgZG8geyBjMSA9IGMwOyB9IHdoaWxlICggKCgtLWkpID49IDAgKSAmJiAoKGMwPVRbaV0pID49IGMxKSApO1xuICAgICAgICBmb3IgKDsgaSA+PSAwOyApIHtcbiAgICAgICAgICAgIGRvIHsgYzEgPSBjMDsgfSB3aGlsZSAoICgoLS1pKSA+PSAwICkgJiYgKChjMD1UW2ldKSA8PSBjMSkgKTtcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICBTQVttICsgKChpICsgMSkgPj4+IDEpXSA9IGogLSBpOyBqID0gaSArIDE7XG4gICAgICAgICAgICAgICAgZG8geyBjMSA9IGMwOyB9IHdoaWxlICggKCgtLWkpID49IDAgKSAmJiAoKGMwPVRbaV0pID49IGMxKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogZmluZCB0aGUgbGV4aWNvZ3JhcGhpYyBuYW1lcyBvZiBhbGwgc3Vic3RyaW5ncyAqL1xuICAgICAgICBmb3IgKGkgPSAwLCBuYW1lID0gMCwgcSA9IG4sIHFsZW4gPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gU0FbaV07IHBsZW4gPSBTQVttICsgKHAgPj4+IDEpXTsgZGlmZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKHBsZW4gPT09IHFsZW4pICYmICgocSArIHBsZW4pIDwgbikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyAoaiA8IHBsZW4pICYmIChUW3AgKyBqXSA9PT0gVFtxICsgal0pOyApIHsgaisrOyB9XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IHBsZW4pIHsgZGlmZiA9IGZhbHNlOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZikgeyBuYW1lKys7IHEgPSBwOyBxbGVuID0gcGxlbjsgfVxuICAgICAgICAgICAgU0FbbSArIChwID4+PiAxKV0gPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcblxuICAgIC8qIGNvbXB1dGUgU0EgYW5kIEJXVCAqL1xuICAgIHZhciBpbmR1Y2VTQSA9IGZ1bmN0aW9uKFQsIFNBLCBDLCBCLCBuLCBrKSB7XG4gICAgICAgIHZhciBiLCBpLCBqO1xuICAgICAgICB2YXIgYzAsIGMxO1xuICAgICAgICAvKiBjb21wdXRlIFNBbCAqL1xuICAgICAgICBpZiAoQyA9PT0gQikgeyBnZXRDb3VudHMoVCwgQywgbiwgayk7IH1cbiAgICAgICAgZ2V0QnVja2V0cyhDLCBCLCBrLCBmYWxzZSk7IC8qIGZpbmQgc3RhcnRzIG9mIGJ1Y2tldHMgKi9cbiAgICAgICAgaiA9IG4gLSAxO1xuICAgICAgICBiID0gQltjMSA9IFRbal1dO1xuICAgICAgICBTQVtiKytdID0gKChqID4gMCkgJiYgKFRbai0xXSA8IGMxKSkgPyB+aiA6IGo7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGogPSBTQVtpXTsgU0FbaV0gPSB+ajtcbiAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICBBU1NFUlQoIFRbal0gPj0gVFtqICsgMV0gKTtcbiAgICAgICAgICAgICAgICBpZiAoKGMwID0gVFtqXSkgIT09IGMxKSB7IEJbYzFdICA9IGI7IGIgPSBCW2MxPWMwXTsgfVxuICAgICAgICAgICAgICAgIEFTU0VSVCggaSA8IGIgKTtcbiAgICAgICAgICAgICAgICBTQVtiKytdID0gKChqID4gMCkgJiYgKFRbai0xXSA8IGMxKSkgPyB+aiA6IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogY29tcHV0ZSBTQXMgKi9cbiAgICAgICAgaWYgKEMgPT09IEIpIHsgZ2V0Q291bnRzKFQsIEMsIG4sIGspOyB9XG4gICAgICAgIGdldEJ1Y2tldHMoQywgQiwgaywgdHJ1ZSk7IC8qIGZpbmQgZW5kcyBvZiBidWNrZXRzICovXG4gICAgICAgIGZvciAoaSA9IG4tMSwgYiA9IEJbYzEgPSAwXTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgoaiA9IFNBW2ldKSA+IDApIHtcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgQVNTRVJUKCBUW2pdIDw9IFRbaiArIDFdICk7XG4gICAgICAgICAgICAgICAgaWYgKChjMCA9IFRbal0pICE9PSBjMSkgeyBCW2MxXSA9IGI7IGIgPSBCW2MxID0gYzBdOyB9XG4gICAgICAgICAgICAgICAgQVNTRVJUKCBiIDw9IGkgKTtcbiAgICAgICAgICAgICAgICBTQVstLWJdID0gKChqID09PSAwKSB8fCAoVFtqIC0gMV0gPiBjMSkpID8gfmogOiBqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTQVtpXSA9IH5qO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb21wdXRlQldUID0gZnVuY3Rpb24oVCwgU0EsIEMsIEIsIG4sIGspIHtcbiAgICAgICAgdmFyIGIsIGksIGosIHBpZHggPSAtMTtcbiAgICAgICAgdmFyIGMwLCBjMTtcbiAgICAgICAgLyogY29tcHV0ZSBTQWwgKi9cbiAgICAgICAgaWYgKEMgPT09IEIpIHsgZ2V0Q291bnRzKFQsIEMsIG4sIGspOyB9XG4gICAgICAgIGdldEJ1Y2tldHMoQywgQiwgaywgZmFsc2UpOyAvKiBmaW5kIHN0YXJ0cyBvZiBidWNrZXRzICovXG4gICAgICAgIGogPSBuIC0gMTtcbiAgICAgICAgYiA9IEJbYzEgPSBUW2pdXTtcbiAgICAgICAgU0FbYisrXSA9ICgoaiA+IDApICYmIChUW2ogLSAxXSA8IGMxKSkgPyB+aiA6IGo7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoaj1TQVtpXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIEFTU0VSVCggVFtqXSA+PSBUW2orMV0gKTtcbiAgICAgICAgICAgICAgICBTQVtpXSA9IH4oYzAgPSBUW2pdKTtcbiAgICAgICAgICAgICAgICBpZiAoYzAgIT09IGMxKSB7IEJbYzFdID0gYjsgYiA9IEJbYzEgPSBjMF07IH1cbiAgICAgICAgICAgICAgICBBU1NFUlQoIGkgPCBiICk7XG4gICAgICAgICAgICAgICAgU0FbYisrXSA9ICgoaiA+IDApICYmIChUW2ogLSAxXSA8IGMxKSkgPyB+aiA6IGo7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGogIT09IDApIHtcbiAgICAgICAgICAgICAgICBTQVtpXSA9IH5qO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGNvbXB1dGUgU0FzICovXG4gICAgICAgIGlmIChDID09PSBCKSB7IGdldENvdW50cyhULCBDLCBuLCBrKTsgfVxuICAgICAgICBnZXRCdWNrZXRzKEMsIEIsIGssIHRydWUpOyAvKiBmaW5kIGVuZHMgb2YgYnVja2V0cyAqL1xuICAgICAgICBmb3IgKGkgPSBuLTEsIGIgPSBCW2MxID0gMF07IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoKGogPSBTQVtpXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIEFTU0VSVCggVFtqXSA8PSBUW2orMV0gKTtcbiAgICAgICAgICAgICAgICBTQVtpXSA9IGMwID0gVFtqXTtcbiAgICAgICAgICAgICAgICBpZiAoYzAgIT09IGMxKSB7IEJbYzFdID0gYjsgYiA9IEJbYzEgPSBjMF07IH1cbiAgICAgICAgICAgICAgICBBU1NFUlQoIGIgPD0gaSApO1xuICAgICAgICAgICAgICAgIFNBWy0tYl0gPSAoKGogPiAwKSAmJiAoVFtqLTFdID4gYzEpKSA/ICh+VFtqLTFdKSA6IGo7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGogIT09IDApIHtcbiAgICAgICAgICAgICAgICBTQVtpXSA9IH5qO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWR4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlkeDtcbiAgICB9O1xuXG4gICAgLyogZmluZCB0aGUgc3VmZml4IGFycmF5IFNBIG9mIFRbMC4ubi0xXSBpbiB7MC4uay0xfV5uXG4gICAgICAgdXNlIGEgd29ya2luZyBzcGFjZSAoZXhjbHVkaW5nIFQgYW5kIFNBKSBvZiBhdCBtb3N0IDJuK08oMSkgZm9yIGFcbiAgICAgICBjb25zdGFudCBhbHBoYWJldCAqL1xuICAgIHZhciBTQV9JUyA9IGZ1bmN0aW9uKFQsIFNBLCBmcywgbiwgaywgaXNid3QpIHtcbiAgICAgICAgdmFyIEMsIEIsIFJBO1xuICAgICAgICB2YXIgaSwgaiwgYiwgYywgbSwgcCwgcSwgbmFtZSwgcGlkeCA9IDAsIG5ld2ZzO1xuICAgICAgICB2YXIgYzAsIGMxO1xuICAgICAgICB2YXIgZmxhZ3MgPSAwO1xuXG4gICAgICAgIC8vIGFsbG9jYXRlIHRlbXBvcmFyeSBzdG9yYWdlIFtDU0FdXG4gICAgICAgIGlmIChrIDw9IDI1Nikge1xuICAgICAgICAgICAgQyA9IFV0aWwubWFrZVMzMkJ1ZmZlcihrKTtcbiAgICAgICAgICAgIGlmIChrIDw9IGZzKSB7IEIgPSBTQS5zdWJhcnJheShuICsgZnMgLSBrKTsgZmxhZ3MgPSAxOyB9XG4gICAgICAgICAgICBlbHNlIHsgQiA9IFV0aWwubWFrZVMzMkJ1ZmZlcihrKTsgZmxhZ3MgPSAzOyB9XG4gICAgICAgIH0gZWxzZSBpZiAoayA8PSBmcykge1xuICAgICAgICAgICAgQyA9IFNBLnN1YmFycmF5KG4gKyBmcyAtIGspO1xuICAgICAgICAgICAgaWYgKGsgPD0gKGZzIC0gaykpIHsgQiA9IFNBLnN1YmFycmF5KG4gKyBmcyAtIGsgKiAyKTsgZmxhZ3MgPSAwOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDw9IDEwMjQpIHsgQiA9IFV0aWwubWFrZVMzMkJ1ZmZlcihrKTsgZmxhZ3MgPSAyOyB9XG4gICAgICAgICAgICBlbHNlIHsgQiA9IEM7IGZsYWdzID0gODsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQyA9IEIgPSBVdGlsLm1ha2VTMzJCdWZmZXIoayk7XG4gICAgICAgICAgICBmbGFncyA9IDQgfCA4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyogc3RhZ2UgMTogcmVkdWNlIHRoZSBwcm9ibGVtIGJ5IGF0IGxlYXN0IDEvMlxuICAgICAgICAgICBzb3J0IGFsbCB0aGUgTE1TLXN1YnN0cmluZ3MgKi9cbiAgICAgICAgZ2V0Q291bnRzKFQsIEMsIG4sIGspO1xuICAgICAgICBnZXRCdWNrZXRzKEMsIEIsIGssIHRydWUpOyAvKiBmaW5kIGVuZHMgb2YgYnVja2V0cyAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7IFNBW2ldID0gMDsgfVxuICAgICAgICBiID0gLTE7IGkgPSBuIC0gMTsgaiA9IG47IG0gPSAwOyBjMCA9IFRbbiAtIDFdO1xuICAgICAgICBkbyB7IGMxID0gYzA7IH0gd2hpbGUgKCgtLWkgPj0gMCkgJiYgKChjMCA9IFRbaV0pID49IGMxKSk7XG4gICAgICAgIGZvciAoOyBpID49IDAgOykge1xuICAgICAgICAgICAgZG8geyBjMSA9IGMwOyB9IHdoaWxlICgoLS1pID49IDApICYmICgoYzAgPSBUW2ldKSA8PSBjMSkpO1xuICAgICAgICAgICAgaWYgKCBpID49IDAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBiID49IDAgKSB7IFNBW2JdID0gajsgfVxuICAgICAgICAgICAgICAgIGIgPSAtLUJbYzFdO1xuICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICsrbTtcbiAgICAgICAgICAgICAgICBkbyB7IGMxID0gYzA7IH0gd2hpbGUgKCgtLWkgPj0gMCkgJiYgKChjMCA9IFRbaV0pID49IGMxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA+IDEpIHtcbiAgICAgICAgICAgIExNU3NvcnQoVCwgU0EsIEMsIEIsIG4sIGspO1xuICAgICAgICAgICAgbmFtZSA9IExNU3Bvc3Rwcm9jKFQsIFNBLCBuLCBtKTtcbiAgICAgICAgfSBlbHNlIGlmIChtID09PSAxKSB7XG4gICAgICAgICAgICBTQVtiXSA9IGogKyAxO1xuICAgICAgICAgICAgbmFtZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIHN0YWdlIDI6IHNvbHZlIHRoZSByZWR1Y2VkIHByb2JsZW1cbiAgICAgICAgICAgcmVjdXJzZSBpZiBuYW1lcyBhcmUgbm90IHlldCB1bmlxdWUgKi9cbiAgICAgICAgaWYobmFtZSA8IG0pIHtcbiAgICAgICAgICAgIGlmKChmbGFncyAmIDQpICE9PSAwKSB7IEMgPSBudWxsOyBCID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYoKGZsYWdzICYgMikgIT09IDApIHsgQiA9IG51bGw7IH1cbiAgICAgICAgICAgIG5ld2ZzID0gKG4gKyBmcykgLSAobSAqIDIpO1xuICAgICAgICAgICAgaWYoKGZsYWdzICYgKDEgfCA0IHwgOCkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYoKGsgKyBuYW1lKSA8PSBuZXdmcykgeyBuZXdmcyAtPSBrOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IGZsYWdzIHw9IDg7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFTU0VSVCggKG4gPj4+IDEpIDw9IChuZXdmcyArIG0pICk7XG4gICAgICAgICAgICBmb3IgKGkgPSBtICsgKG4gPj4+IDEpIC0gMSwgaiA9IG0gKiAyICsgbmV3ZnMgLSAxOyBtIDw9IGk7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmKFNBW2ldICE9PSAwKSB7IFNBW2otLV0gPSBTQVtpXSAtIDE7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJBID0gU0Euc3ViYXJyYXkobSArIG5ld2ZzKTtcbiAgICAgICAgICAgIFNBX0lTKFJBLCBTQSwgbmV3ZnMsIG0sIG5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIFJBID0gbnVsbDtcblxuICAgICAgICAgICAgaSA9IG4gLSAxOyBqID0gbSAqIDIgLSAxOyBjMCA9IFRbbiAtIDFdO1xuICAgICAgICAgICAgZG8geyBjMSA9IGMwOyB9IHdoaWxlICgoLS1pID49IDApICYmICgoYzAgPSBUW2ldKSA+PSBjMSkpO1xuICAgICAgICAgICAgZm9yICg7IGkgPj0gMCA7KSB7XG4gICAgICAgICAgICAgICAgZG8geyBjMSA9IGMwOyB9IHdoaWxlICgoLS1pID49IDApICYmICgoYzAgPSBUW2ldKSA8PSBjMSkpO1xuICAgICAgICAgICAgICAgIGlmICggaSA+PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBTQVtqLS1dID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGRvIHsgYzEgPSBjMDsgfSB3aGlsZSAoKC0taSA+PSAwKSAmJiAoKGMwID0gVFtpXSkgPj0gYzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHsgU0FbaV0gPSBTQVttICsgU0FbaV1dOyB9XG4gICAgICAgICAgICBpZigoZmxhZ3MgJiA0KSAhPT0gMCkgeyBDID0gQiA9IFV0aWwubWFrZVMzMkJ1ZmZlcihrKTsgfVxuICAgICAgICAgICAgaWYoKGZsYWdzICYgMikgIT09IDApIHsgQiA9IFV0aWwubWFrZVMzMkJ1ZmZlcihrKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogc3RhZ2UgMzogaW5kdWNlIHRoZSByZXN1bHQgZm9yIHRoZSBvcmlnaW5hbCBwcm9ibGVtICovXG4gICAgICAgIGlmKChmbGFncyAmIDgpICE9PSAwKSB7IGdldENvdW50cyhULCBDLCBuLCBrKTsgfVxuICAgICAgICAvKiBwdXQgYWxsIGxlZnQtbW9zdCBTIGNoYXJhY3RlcnMgaW50byB0aGVpciBidWNrZXRzICovXG4gICAgICAgIGlmIChtID4gMSkge1xuICAgICAgICAgICAgZ2V0QnVja2V0cyhDLCBCLCBrLCB0cnVlKTsgLyogZmluZCBlbmRzIG9mIGJ1Y2tldHMgKi9cbiAgICAgICAgICAgIGkgPSBtIC0gMTsgaiA9IG47IHAgPSBTQVttIC0gMV07IGMxID0gVFtwXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBxID0gQltjMCA9IGMxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocSA8IGopIHsgU0FbLS1qXSA9IDA7IH1cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIFNBWy0tal0gPSBwO1xuICAgICAgICAgICAgICAgICAgICBpZigtLWkgPCAwKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIHAgPSBTQVtpXTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlKChjMSA9IFRbcF0pID09PSBjMCk7XG4gICAgICAgICAgICB9IHdoaWxlIChpID49IDAgKTtcbiAgICAgICAgICAgIHdoaWxlICggaiA+IDAgKSB7IFNBWy0tal0gPSAwOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc2J3dCkgeyBpbmR1Y2VTQShULCBTQSwgQywgQiwgbiwgayk7IH1cbiAgICAgICAgZWxzZSB7IHBpZHggPSBjb21wdXRlQldUKFQsIFNBLCBDLCBCLCBuLCBrKTsgfVxuICAgICAgICBDID0gbnVsbDsgQiA9IG51bGw7XG4gICAgICAgIHJldHVybiBwaWR4O1xuICAgIH07XG5cbiAgICB2YXIgQldUID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvKiogU0Egc2hvdWxkIGJlIGEgSW50MzJBcnJheSAoc2lnbmVkISk7IFQgY2FuIGJlIGFueSB0eXBlZCBhcnJheS5cbiAgICAgKiAgYWxwaGFiZXRTaXplIGlzIG9wdGlvbmFsIGlmIFQgaXMgYW4gVWludDhBcnJheSBvciBVaW50MTZBcnJheS4gKi9cbiAgICBCV1Quc3VmZml4c29ydCA9IGZ1bmN0aW9uKFQsIFNBLCBuLCBhbHBoYWJldFNpemUpIHtcbiAgICAgICAgQVNTRVJUKCBUICYmIFNBICYmIFQubGVuZ3RoID49IG4gJiYgU0EubGVuZ3RoID49IG4gKTtcbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHsgU0FbMF0gPSAwOyB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscGhhYmV0U2l6ZSkge1xuICAgICAgICAgICAgaWYgKFQuQllURVNfUEVSX0VMRU1FTlQgPT09IDEpIHsgYWxwaGFiZXRTaXplID0gMjU2OyB9XG4gICAgICAgICAgICBlbHNlIGlmIChULkJZVEVTX1BFUl9FTEVNRU5UID09PSAyKSB7IGFscGhhYmV0U2l6ZSA9IDY1NTM2OyB9XG4gICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignTmVlZCB0byBzcGVjaWZ5IGFscGhhYmV0U2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIEFTU0VSVCggYWxwaGFiZXRTaXplID4gMCApO1xuICAgICAgICBpZiAoVC5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgICAgICAgICAgQVNTRVJUKCBhbHBoYWJldFNpemUgPD0gKDEgPDwgKFQuQllURVNfUEVSX0VMRU1FTlQqOCkgKSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTQV9JUyhULCBTQSwgMCwgbiwgYWxwaGFiZXRTaXplLCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKiogQnVycm93cy1XaGVlbGVyIFRyYW5zZm9ybS5cbiAgICAgICAgQSBzaG91bGQgYmUgSW50MzJBcnJheSAoc2lnbmVkISk7IFQgY2FuIGJlIGFueSB0eXBlZCBhcnJheS5cbiAgICAgICAgVSBpcyB0aGUgc2FtZSB0eXBlIGFzIFQgKGl0IGlzIHVzZWQgZm9yIG91dHB1dCkuXG4gICAgICAgIGFscGhhYmV0U2l6ZSBpcyBvcHRpb25hbCBpZiBUIGlzIGFuIFVpbnQ4QXJyYXkgb3IgVWludDE2QXJyYXkuXG4gICAgICAgIEFTU1VNRVMgU1RSSU5HIElTIFRFUk1JTkFURUQgV0lUSCBBTiBFT0YgQ0hBUkFDVEVSLlxuICAgICovXG4gICAgQldULmJ3dHJhbnNmb3JtID0gZnVuY3Rpb24oVCwgVSwgQSwgbiwgYWxwaGFiZXRTaXplKSB7XG4gICAgICAgIHZhciBpLCBwaWR4O1xuICAgICAgICBBU1NFUlQoIFQgJiYgVSAmJiBBICk7XG4gICAgICAgIEFTU0VSVCggVC5sZW5ndGggPj0gbiAmJiBVLmxlbmd0aCA+PSBuICYmIEEubGVuZ3RoID49IG4gKTtcbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHsgVVswXSA9IFRbMF07IH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxwaGFiZXRTaXplKSB7XG4gICAgICAgICAgICBpZiAoVC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMSkgeyBhbHBoYWJldFNpemUgPSAyNTY7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFQuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHsgYWxwaGFiZXRTaXplID0gNjU1MzY7IH1cbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdOZWVkIHRvIHNwZWNpZnkgYWxwaGFiZXRTaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgQVNTRVJUKCBhbHBoYWJldFNpemUgPiAwICk7XG4gICAgICAgIGlmIChULkJZVEVTX1BFUl9FTEVNRU5UKSB7XG4gICAgICAgICAgICBBU1NFUlQoIGFscGhhYmV0U2l6ZSA8PSAoMSA8PCAoVC5CWVRFU19QRVJfRUxFTUVOVCo4KSApICk7XG4gICAgICAgIH1cbiAgICAgICAgcGlkeCA9IFNBX0lTKFQsIEEsIDAsIG4sIGFscGhhYmV0U2l6ZSwgdHJ1ZSk7XG4gICAgICAgIFVbMF0gPSBUW24gLSAxXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBpZHggOyBpKyspIHsgVVtpICsgMV0gPSBBW2ldOyB9XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgbjsgaSsrKSB7IFVbaV0gPSBBW2ldOyB9XG4gICAgICAgIHJldHVybiBwaWR4ICsgMTtcbiAgICB9O1xuICAgIC8qKiBSZXZlcnNlcyB0cmFuc2Zvcm0gYWJvdmUuIChBU1NVTUVEIFNUUklORyBJUyBURVJNSU5BVEVEIFdJVEggRU9GLikgKi9cbiAgICBCV1QudW5id3RyYW5zZm9ybSA9IGZ1bmN0aW9uKFQsIFUsIExGLCBuLCBwaWR4KSB7XG4gICAgICAgIHZhciBDID0gVXRpbC5tYWtlVTMyQnVmZmVyKDI1Nik7XG4gICAgICAgIHZhciBpLCB0O1xuICAgICAgICBmb3IgKGk9MDsgaTwyNTY7IGkrKykgeyBDW2ldID0gMDsgfVxuICAgICAgICBmb3IgKGk9MDsgaTxuOyBpKyspIHsgTEZbaV0gPSBDW1RbaV1dKys7IH1cbiAgICAgICAgZm9yIChpPTAsIHQ9MDsgaTwyNTY7IGkrKykgeyB0ICs9IENbaV07IENbaV0gPSB0IC0gQ1tpXTsgfVxuICAgICAgICBmb3IgKGk9bi0xLCB0PTA7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgdCA9IExGW3RdICsgQ1tVW2ldPVRbdF1dO1xuICAgICAgICAgICAgdCArPSAodDxwaWR4KSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIEMgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKiogQnVycm93cy1XaGVlbGVyIFRyYW5zZm9ybS5cbiAgICAgICAgQSBzaG91bGQgYmUgSW50MzJBcnJheSAoc2lnbmVkISk7IFQgY2FuIGJlIGFueSB0eXBlZCBhcnJheS5cbiAgICAgICAgVSBpcyB0aGUgc2FtZSB0eXBlIGFzIFQgKGl0IGlzIHVzZWQgZm9yIG91dHB1dCkuXG4gICAgICAgIGFscGhhYmV0U2l6ZSBpcyBvcHRpb25hbCBpZiBUIGlzIGFuIFVpbnQ4QXJyYXkgb3IgVWludDE2QXJyYXkuXG4gICAgICAgIEFTU1VNRVMgU1RSSU5HIElTIENZQ0xJQy5cbiAgICAgICAgKFhYWDogdGhpcyBpcyB0d2ljZSBhcyBpbmVmZmljaWVudCBhcyBJJ2QgbGlrZSEgW0NTQV0pXG4gICAgKi9cbiAgICBCV1QuYnd0cmFuc2Zvcm0yID0gZnVuY3Rpb24oVCwgVSwgbiwgYWxwaGFiZXRTaXplKSB7XG4gICAgICAgIHZhciBpLCBqLCBwaWR4ID0gMDtcbiAgICAgICAgQVNTRVJUKCBUICYmIFUgKTtcbiAgICAgICAgQVNTRVJUKCBULmxlbmd0aCA+PSBuICYmIFUubGVuZ3RoID49IG4gKTtcbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHsgVVswXSA9IFRbMF07IH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxwaGFiZXRTaXplKSB7XG4gICAgICAgICAgICBpZiAoVC5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMSkgeyBhbHBoYWJldFNpemUgPSAyNTY7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFQuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHsgYWxwaGFiZXRTaXplID0gNjU1MzY7IH1cbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdOZWVkIHRvIHNwZWNpZnkgYWxwaGFiZXRTaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgQVNTRVJUKCBhbHBoYWJldFNpemUgPiAwICk7XG4gICAgICAgIGlmIChULkJZVEVTX1BFUl9FTEVNRU5UKSB7XG4gICAgICAgICAgICBBU1NFUlQoIGFscGhhYmV0U2l6ZSA8PSAoMSA8PCAoVC5CWVRFU19QRVJfRUxFTUVOVCo4KSApICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG91YmxlIGxlbmd0aCBvZiBUXG4gICAgICAgIHZhciBUVDtcbiAgICAgICAgaWYgKFQubGVuZ3RoID49IG4qMikge1xuICAgICAgICAgICAgVFQgPSBUOyAvLyBkbyBpdCBpbiBwbGFjZSBpZiBwb3NzaWJsZVxuICAgICAgICB9IGVsc2UgaWYgKGFscGhhYmV0U2l6ZSA8PSAyNTYpIHtcbiAgICAgICAgICAgIFRUID0gVXRpbC5tYWtlVThCdWZmZXIobioyKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbHBoYWJldFNpemUgPD0gNjU1MzYpIHtcbiAgICAgICAgICAgIFRUID0gVXRpbC5tYWtlVTE2QnVmZmVyKG4qMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUVCA9IFV0aWwubWFrZVUzMkJ1ZmZlcihuKjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUVCE9PVQpIHtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPG47IGkrKykgeyBUVFtpXSA9IFRbaV07IH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGk9MDsgaTxuOyBpKyspIHsgVFRbbitpXSA9IFRUW2ldOyB9XG4gICAgICAgIC8vIHNvcnQgZG91YmxlZCBzdHJpbmdcbiAgICAgICAgdmFyIEEgPSBVdGlsLm1ha2VTMzJCdWZmZXIobioyKTtcbiAgICAgICAgU0FfSVMoVFQsIEEsIDAsIG4qMiwgYWxwaGFiZXRTaXplLCBmYWxzZSk7XG4gICAgICAgIGZvciAoaT0wLCBqPTA7IGk8MipuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gQVtpXTtcbiAgICAgICAgICAgIGlmIChzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChzID09PSAwKSB7IHBpZHggPSBqOyB9XG4gICAgICAgICAgICAgICAgaWYgKC0tcyA8IDApIHsgcyA9IG4tMTsgfVxuICAgICAgICAgICAgICAgIFVbaisrXSA9IFRbc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQVNTRVJUKGo9PT1uKTtcbiAgICAgICAgcmV0dXJuIHBpZHg7XG4gICAgfTtcblxuICAgIHJldHVybiBmcmVlemUoQldUKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiBBIHNpbXBsZSBiemlwLWxpa2UgQldUIGNvbXByZXNzb3Igd2l0aCBhIHJhbmdlIGVuY29kZXI7IHdyaXR0ZW4gYXMgYVxuICogc2VsZi10ZXN0IG9mIHRoZSBCV1QgcGFja2FnZS4gKi9cbnZhciBsaWJzID0gW1xuXHRyZXF1aXJlKCcuL2ZyZWV6ZScpLFxuXHRyZXF1aXJlKCcuL0JXVCcpLFxuXHRyZXF1aXJlKCcuL0RlZlN1bU1vZGVsJyksXG5cdHJlcXVpcmUoJy4vRmVud2lja01vZGVsJyksXG5cdHJlcXVpcmUoJy4vTG9nRGlzdGFuY2VNb2RlbCcpLFxuXHRyZXF1aXJlKCcuL05vTW9kZWwnKSxcblx0cmVxdWlyZSgnLi9SYW5nZUNvZGVyJyksXG5cdHJlcXVpcmUoJy4vU3RyZWFtJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoZnJlZXplLCBCV1QsIERlZlN1bU1vZGVsLCBGZW53aWNrTW9kZWwsIExvZ0Rpc3RhbmNlTW9kZWwsIE5vTW9kZWwsIFJhbmdlQ29kZXIsIFN0cmVhbSwgVXRpbCkge1xuICAgIHZhciBFT0YgPSBTdHJlYW0uRU9GO1xuXG4gICAgdmFyIEZfUFJPQl9NQVggID0gMHhGRjAwO1xuICAgIHZhciBGX1BST0JfSU5DUiA9IDB4MDEwMDtcblxuICAgIEJXVEMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIEJXVEMuTUFHSUMgPSBcImJ3dGNcIjtcbiAgICBCV1RDLmNvbXByZXNzRmlsZSA9IFV0aWwuY29tcHJlc3NGaWxlSGVscGVyKEJXVEMuTUFHSUMsIGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIHNpemUsIHByb3BzLCBmaW5hbEJ5dGUpIHtcbiAgICAgICAgdmFyIGVuY29kZXIgPSBuZXcgUmFuZ2VDb2RlcihvdXRwdXQpO1xuICAgICAgICBlbmNvZGVyLmVuY29kZVN0YXJ0KGZpbmFsQnl0ZSwgMSk7XG5cbiAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IDk7XG4gICAgICAgIGlmICh0eXBlb2YocHJvcHMpPT09J251bWJlcicgJiYgcHJvcHMgPj0gMSAmJiBwcm9wcyA8PSA5KSB7XG4gICAgICAgICAgICBibG9ja1NpemUgPSBwcm9wcztcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVyLmVuY29kZUJ5dGUoYmxvY2tTaXplKTtcbiAgICAgICAgdmFyIGZhc3QgPSAoYmxvY2tTaXplIDw9IDUpO1xuICAgICAgICBibG9ja1NpemUgKj0gMTAwMDAwO1xuXG4gICAgICAgIHZhciBibG9jayA9IFV0aWwubWFrZVU4QnVmZmVyKGJsb2NrU2l6ZSk7XG4gICAgICAgIHZhciByZWFkQmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb3M7XG4gICAgICAgICAgICBmb3IgKHBvcz0wOyBwb3MgPCBibG9ja1NpemU7ICkge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IGlucHV0LnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoIDwgMCkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIGJsb2NrW3BvcysrXSA9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFUgPSBVdGlsLm1ha2VVOEJ1ZmZlcihibG9ja1NpemUpO1xuICAgICAgICB2YXIgQSA9IFV0aWwubWFrZVMzMkJ1ZmZlcihibG9ja1NpemUpO1xuICAgICAgICB2YXIgTSA9IFV0aWwubWFrZVU4QnVmZmVyKDI1Nik7IC8vIG1vdmUgdG8gZnJvbnQgYXJyYXlcbiAgICAgICAgdmFyIGJpdE1vZGVsRmFjdG9yeSA9IE5vTW9kZWwuZmFjdG9yeShlbmNvZGVyKTtcbiAgICAgICAgdmFyIGxlbk1vZGVsID0gbmV3IExvZ0Rpc3RhbmNlTW9kZWwoYmxvY2tTaXplLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRNb2RlbEZhY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1vZGVsRmFjdG9yeSk7XG4gICAgICAgIHZhciBsZW5ndGgsIGIsIGMsIHBpZHgsIGksIGo7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRCbG9jaygpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8gaW5kaWNhdGUgdGhhdCB0aGVyZSdzIGFub3RoZXIgYmxvY2sgY29taW4nXG4gICAgICAgICAgICAvLyBhbmQgZW5jb2RlIHRoZSBsZW5ndGggb2YgdGhlIGJsb2NrIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gYmxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rlci5lbmNvZGVGcmVxKDEsIDAsIDMpOyAvLyBcImZ1bGwgc2l6ZSBibG9ja1wiXG4gICAgICAgICAgICAgICAgYiA9IGJsb2NrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVyLmVuY29kZUZyZXEoMSwgMSwgMyk7IC8vIFwic2hvcnQgYmxvY2tcIlxuICAgICAgICAgICAgICAgIGxlbk1vZGVsLmVuY29kZShsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGIgPSBibG9jay5zdWJhcnJheSgwLCBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGlkeCA9IEJXVC5id3RyYW5zZm9ybShiLCBVLCBBLCBsZW5ndGgsIDI1Nik7XG4gICAgICAgICAgICBsZW5Nb2RlbC5lbmNvZGUocGlkeCk7IC8vIHN0YXJ0aW5nIGluZGV4XG4gICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGFscGhhYmV0IHN1YnNldCB1c2VkXG4gICAgICAgICAgICB2YXIgdXNlVHJlZSA9IFV0aWwubWFrZVUxNkJ1ZmZlcig1MTIpO1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjID0gVVtpXTtcbiAgICAgICAgICAgICAgICB1c2VUcmVlWzI1NitjXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGk9MjU1OyBpPjA7IGktLSkgeyAvLyBzdW0gYWxsIHRoZSB3YXkgdXAgdGhlIHRyZWVcbiAgICAgICAgICAgICAgICB1c2VUcmVlW2ldID0gdXNlVHJlZVsyKmldICsgdXNlVHJlZVsyKmkgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZVRyZWVbMF0gPSAxOyAvLyBzZW50aW5lbFxuICAgICAgICAgICAgZm9yIChpPTE7IGk8NTEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaT4+PjE7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGwgPSAxIDw8ICg5LVV0aWwuZmxzKGkpKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlVHJlZVtwYXJlbnRdID09PSAwIHx8IHVzZVRyZWVbcGFyZW50XSA9PT0gKGZ1bGwqMikpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogYWxyZWFkeSBrbm93biBmdWxsL2VtcHR5ICovXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID49IDI1Nikge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVyLmVuY29kZUJpdCh1c2VUcmVlW2ldKTsgLy8gbGVhZiBub2RlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB1c2VUcmVlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2ID0gKHY9PT0wKSA/IDAgOiAodj09PWZ1bGwpID8gMiA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIuZW5jb2RlRnJlcSgxLCB2LCAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1hcCBzeW1ib2xzIHRvIHRoaXMgc3Vic2V0XG4gICAgICAgICAgICB2YXIgYWxwaGFiZXRTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPDI1NjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVRyZWVbMjU2K2ldKSB7IC8vIHN5bWJvbCBpbiB1c2VcbiAgICAgICAgICAgICAgICAgICAgTVthbHBoYWJldFNpemUrK10gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZVRyZWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gTVRGIGVuY29kaW5nIG9mIFVcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IFVbaV07XG4gICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8YWxwaGFiZXRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1bal0gPT09IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGo8YWxwaGFiZXRTaXplKTtcbiAgICAgICAgICAgICAgICBVW2ldID0gajtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIGZyb250XG4gICAgICAgICAgICAgICAgZm9yICg7IGo+MDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIE1bal0gPSBNW2otMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1bMF0gPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUkxFL3JhbmdlIGVuY29kaW5nXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgRmVud2lja01vZGVsKGVuY29kZXIsIGFscGhhYmV0U2l6ZSsxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGX1BST0JfTUFYLCBGX1BST0JfSU5DUik7XG4gICAgICAgICAgICBpZiAoZmFzdCkgeyBtb2RlbCA9IG5ldyBEZWZTdW1Nb2RlbChlbmNvZGVyLCBhbHBoYWJldFNpemUrMSk7IH1cbiAgICAgICAgICAgIHZhciBydW5MZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIGVtaXRMYXN0UnVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gYmluYXJ5IGVuY29kZSBydW5zIG9mIHplcm9zXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bkxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVuTGVuZ3RoJjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmVuY29kZSgwKTsgLy8gUlVOQVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuTGVuZ3RoLT0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZW5jb2RlKDEpOyAvLyBSVU5CXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MZW5ndGgtPTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVuTGVuZ3RoID4+Pj0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjID0gVVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBydW5MZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbWl0TGFzdFJ1bigpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5lbmNvZGUoYysxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgZm9yIG5leHRcbiAgICAgICAgICAgICAgICAgICAgcnVuTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0TGFzdFJ1bigpO1xuICAgICAgICAgICAgLy8gZG9uZSB3aXRoIHRoaXMgYmxvY2shXG4gICAgICAgIH0gd2hpbGUgKGxlbmd0aCA9PT0gYmxvY2subGVuZ3RoKTtcblxuICAgICAgICBlbmNvZGVyLmVuY29kZUZyZXEoMSwgMiwgMyk7IC8vIFwibm8gbW9yZSBibG9ja3NcIlxuICAgICAgICBlbmNvZGVyLmVuY29kZUZpbmlzaCgpO1xuICAgIH0sIHRydWUpO1xuXG4gICAgQldUQy5kZWNvbXByZXNzRmlsZSA9IFV0aWwuZGVjb21wcmVzc0ZpbGVIZWxwZXIoQldUQy5NQUdJQywgZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgc2l6ZSkge1xuICAgICAgICB2YXIgZGVjb2RlciA9IG5ldyBSYW5nZUNvZGVyKGlucHV0KTtcbiAgICAgICAgZGVjb2Rlci5kZWNvZGVTdGFydCh0cnVlLyogYWxyZWFkeSByZWFkIHRoZSBleHRyYSBieXRlICovKTtcbiAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGRlY29kZXIuZGVjb2RlQnl0ZSgpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChibG9ja1NpemUgPj0gMSAmJiBibG9ja1NpemUgPD0gOSk7XG4gICAgICAgIHZhciBmYXN0ID0gKGJsb2NrU2l6ZSA8PSA1KTtcbiAgICAgICAgYmxvY2tTaXplICo9IDEwMDAwMDtcblxuICAgICAgICB2YXIgYmxvY2sgPSBVdGlsLm1ha2VVOEJ1ZmZlcihibG9ja1NpemUpO1xuICAgICAgICB2YXIgVSA9IFV0aWwubWFrZVU4QnVmZmVyKGJsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBBID0gVXRpbC5tYWtlUzMyQnVmZmVyKGJsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBNID0gVXRpbC5tYWtlVThCdWZmZXIoMjU2KTsgLy8gbW92ZSB0byBmcm9udCBhcnJheVxuICAgICAgICB2YXIgYml0TW9kZWxGYWN0b3J5ID0gTm9Nb2RlbC5mYWN0b3J5KGRlY29kZXIpO1xuICAgICAgICB2YXIgbGVuTW9kZWwgPSBuZXcgTG9nRGlzdGFuY2VNb2RlbChibG9ja1NpemUsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdE1vZGVsRmFjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0TW9kZWxGYWN0b3J5KTtcbiAgICAgICAgdmFyIGIsIGxlbmd0aCwgaSwgaiwgYztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBibG9ja0luZGljYXRvciA9IGRlY29kZXIuZGVjb2RlQ3VsRnJlcSgzKTtcbiAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlVXBkYXRlKDEsIGJsb2NrSW5kaWNhdG9yLCAzKTtcbiAgICAgICAgICAgIGlmIChibG9ja0luZGljYXRvciA9PT0gMCkgeyAvLyBmdWxsLWxlbmd0aCBibG9ja1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICBiID0gYmxvY2s7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrSW5kaWNhdG9yID09PSAxKSB7IC8vIHNob3J0IGJsb2NrXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gbGVuTW9kZWwuZGVjb2RlKCk7XG4gICAgICAgICAgICAgICAgYiA9IGJsb2NrLnN1YmFycmF5KDAsIGxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrSW5kaWNhdG9yID09PSAyKSB7IC8vIGFsbCBkb25lLCBubyBtb3JlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVhZCBzdGFydGluZyBpbmRleCBmb3IgdW5CV1RcbiAgICAgICAgICAgIHZhciBwaWR4ID0gbGVuTW9kZWwuZGVjb2RlKCk7XG4gICAgICAgICAgICAvLyBkZWNvZGUgdGhlIGFscGhhYmV0IHN1YnNldCB1c2VkXG4gICAgICAgICAgICB2YXIgdXNlVHJlZSA9IFV0aWwubWFrZVUxNkJ1ZmZlcig1MTIpO1xuICAgICAgICAgICAgdXNlVHJlZVswXSA9IDE7IC8vIHNlbnRpbmVsXG4gICAgICAgICAgICBmb3IgKGk9MTsgaTw1MTI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpPj4+MTtcbiAgICAgICAgICAgICAgICB2YXIgZnVsbCA9IDEgPDwgKDktVXRpbC5mbHMoaSkpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VUcmVlW3BhcmVudF0gPT09IDAgfHwgdXNlVHJlZVtwYXJlbnRdID09PSAoZnVsbCoyKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBhbHJlYWR5IGtub3duIGZ1bGwvZW1wdHkgKi9cbiAgICAgICAgICAgICAgICAgICAgdXNlVHJlZVtpXSA9IHVzZVRyZWVbcGFyZW50XSA+Pj4gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPj0gMjU2KSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVRyZWVbaV0gPSBkZWNvZGVyLmRlY29kZUJpdCgpOyAvLyBsZWFmIG5vZGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGRlY29kZXIuZGVjb2RlQ3VsRnJlcSgzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGVVcGRhdGUoMSwgdiwgMyk7XG4gICAgICAgICAgICAgICAgICAgIHVzZVRyZWVbaV0gPSAodj09PTIpID8gZnVsbCA6IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtYXAgc3ltYm9scyB0byB0aGlzIHN1YnNldFxuICAgICAgICAgICAgdmFyIGFscGhhYmV0U2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTwyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh1c2VUcmVlWzI1NitpXSkgeyAvLyBzeW1ib2wgaW4gdXNlXG4gICAgICAgICAgICAgICAgICAgIE1bYWxwaGFiZXRTaXplKytdID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VUcmVlID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFJMRS9yYW5nZSBkZWNvZGluZ1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEZlbndpY2tNb2RlbChkZWNvZGVyLCBhbHBoYWJldFNpemUrMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRl9QUk9CX01BWCwgRl9QUk9CX0lOQ1IpO1xuICAgICAgICAgICAgaWYgKGZhc3QpIHsgbW9kZWwgPSBuZXcgRGVmU3VtTW9kZWwoZGVjb2RlciwgYWxwaGFiZXRTaXplKzEsIHRydWUpO31cbiAgICAgICAgICAgIHZhciB2YWwgPSAxOyAvLyByZXBlYXQgY291bnRcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgICAgYyA9IG1vZGVsLmRlY29kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjPT09MCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGo9MDsgajx2YWw7IGorKykgeyBiW2krK10gPSAwOyB9XG4gICAgICAgICAgICAgICAgICAgIHZhbCAqPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYz09PTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8dmFsOyBqKyspIHsgYltpKytdID0gMDsgYltpKytdID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICB2YWwgKj0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBiW2krK10gPSBjLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTVRGIGRlY29kZVxuICAgICAgICAgICAgZm9yIChpPTA7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBqID0gYltpXTtcbiAgICAgICAgICAgICAgICBiW2ldID0gYyA9IE1bal07XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBmcm9udFxuICAgICAgICAgICAgICAgIGZvciAoOyBqPjA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBNW2pdID0gTVtqLTFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNWzBdID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuQldUXG4gICAgICAgICAgICBCV1QudW5id3RyYW5zZm9ybShibG9jaywgVSwgQSwgbGVuZ3RoLCBwaWR4KTtcbiAgICAgICAgICAgIC8vIGVtaXQhXG4gICAgICAgICAgICBvdXRwdXQud3JpdGUoVSwgMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVyLmRlY29kZUZpbmlzaCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEJXVEM7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyoqIEJpZy1FbmRpYW4gQml0IFN0cmVhbSwgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGEgKG5vcm1hbCBieXRlKSBzdHJlYW0uICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9TdHJlYW0nKVxuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKFN0cmVhbSkge1xuXG4gICAgdmFyIEJpdFN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyQnl0ZSA9IDB4MTAwOyAvLyBwcml2YXRlIHZhciBmb3IgcmVhZGVyc1xuICAgICAgICAgICAgdGhpcy5yZWFkQml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXJCeXRlICYgMHhGRikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gU3RyZWFtLkVPRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW9mID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaDsgLyogISEhICovXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZSA9IChjaCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiaXQgPSAoYnVmZmVyQnl0ZSAmIDB4MTAwKSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckJ5dGUgPDw9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBzZWVrYWJsZSBpZmYgdGhlIHByb3ZpZGVkIHN0cmVhbSBpc1xuICAgICAgICAgICAgdGhpcy5zZWVrQml0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5fYnl0ZSA9IHBvcyA+Pj4gMztcbiAgICAgICAgICAgICAgICB2YXIgbl9iaXQgPSBwb3MgLSAobl9ieXRlKjgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VlayhuX2J5dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VvZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZEJpdHMobl9iaXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudGVsbEJpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBzdHJlYW0udGVsbCgpICogODtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJ1ZmZlckJ5dGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChiICYgMHhGRikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgIGIgPDw9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gaW1wbGVtZW50IGJ5dGUgc3RyZWFtIGludGVyZmFjZSBhcyB3ZWxsLlxuICAgICAgICAgICAgdGhpcy5yZWFkQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICgoYnVmZmVyQnl0ZSAmIDB4RkYpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZWVrID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnNlZWsocG9zKTtcbiAgICAgICAgICAgICAgICBidWZmZXJCeXRlID0gMHgxMDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyQnl0ZSA9IDE7IC8vIHByaXZhdGUgdmFyIGZvciB3cml0ZXJzXG4gICAgICAgICAgICB0aGlzLndyaXRlQml0ID0gZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckJ5dGUgPDw9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGIpIHsgYnVmZmVyQnl0ZSB8PSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckJ5dGUgJiAweDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKGJ1ZmZlckJ5dGUgJiAweEZGKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGltcGxlbWVudCBieXRlIHN0cmVhbSBpbnRlcmZhY2UgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihfYnl0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJCeXRlPT09MSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGVCeXRlKF9ieXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGVCaXRzKDgsIF9ieXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChidWZmZXJCeXRlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCaXQoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uZmx1c2gpIHsgc3RyZWFtLmZsdXNoKCk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvLyBpbmhlcml0IHJlYWQvd3JpdGUgbWV0aG9kcyBmcm9tIFN0cmVhbS5cbiAgICBCaXRTdHJlYW0uRU9GID0gU3RyZWFtLkVPRjtcbiAgICBCaXRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlKTtcbiAgICAvLyBiaXQgY2h1bmsgcmVhZC93cml0ZVxuICAgIEJpdFN0cmVhbS5wcm90b3R5cGUucmVhZEJpdHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBpLCByID0gMCwgYjtcbiAgICAgICAgaWYgKG4gPiAzMSkge1xuICAgICAgICAgICAgciA9IHRoaXMucmVhZEJpdHMobi0xNikqMHgxMDAwMDsgLy8gZnAgbXVsdGlwbHksIG5vdCBzaGlmdFxuICAgICAgICAgICAgcmV0dXJuIHIgKyB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICByIDw8PSAxOyAvLyB0aGlzIGNvdWxkIG1ha2UgYSBuZWdhdGl2ZSB2YWx1ZSBpZiBuPjMxXG4gICAgICAgICAgICAvLyBiaXRzIHJlYWQgcGFzdCBFT0YgYXJlIGFsbCB6ZXJvcyFcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRCaXQoKSA+IDApIHsgcisrOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBCaXRTdHJlYW0ucHJvdG90eXBlLndyaXRlQml0cyA9IGZ1bmN0aW9uKG4sIHZhbHVlKSB7XG4gICAgICAgIGlmIChuID4gMzIpIHtcbiAgICAgICAgICAgIHZhciBsb3cgPSAodmFsdWUgJiAweEZGRkYpO1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSAodmFsdWUgLSBsb3cpIC8gKDB4MTAwMDApOyAvLyBmcCBkaXZpc2lvbiwgbm90IHNoaWZ0XG4gICAgICAgICAgICB0aGlzLndyaXRlQml0cyhuLTE2LCBoaWdoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCaXRzKDE2LCBsb3cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSBuLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlQml0KCAodmFsdWUgPj4+IGkpICYgMSApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBCaXRTdHJlYW07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLypcbkFuIGltcGxlbWVudGF0aW9uIG9mIEJ6aXAyIGRlL2NvbXByZXNzaW9uLCBpbmNsdWRpbmcgdGhlIGFiaWxpdHkgdG9cbnNlZWsgd2l0aGluIGJ6aXAyIGRhdGEuXG5cbkNvcHlyaWdodCAoQykgMjAxMyBDLiBTY290dCBBbmFuaWFuXG5Db3B5cmlnaHQgKEMpIDIwMTIgRWxpIFNrZWdnc1xuQ29weXJpZ2h0IChDKSAyMDExIEtldmluIEt3b2tcblxuVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxubW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbjsgZWl0aGVyXG52ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5idXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbkxlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbkxpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgc2VlXG5odHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvbGdwbC0yLjEuaHRtbFxuXG5BZGFwdGVkIGZyb20gbm9kZS1iemlwLCBjb3B5cmlnaHQgMjAxMiBFbGkgU2tlZ2dzLlxuQWRhcHRlZCBmcm9tIGJ6aXAyLmpzLCBjb3B5cmlnaHQgMjAxMSBLZXZpbiBLd29rIChhbnRpbWF0dGVyMTVAZ21haWwuY29tKS5cblxuQmFzZWQgb24gbWljcm8tYnVuemlwIGJ5IFJvYiBMYW5kbGV5IChyb2JAbGFuZGxleS5uZXQpLlxuXG5CYXNlZCBvbiBiemlwMiBkZWNvbXByZXNzaW9uIGNvZGUgYnkgSnVsaWFuIFIgU2V3YXJkIChqc2V3YXJkQGFjbS5vcmcpLFxud2hpY2ggYWxzbyBhY2tub3dsZWRnZXMgY29udHJpYnV0aW9ucyBieSBNaWtlIEJ1cnJvd3MsIERhdmlkIFdoZWVsZXIsXG5QZXRlciBGZW53aWNrLCBBbGlzdGFpciBNb2ZmYXQsIFJhZGZvcmQgTmVhbCwgSWFuIEguIFdpdHRlbixcblJvYmVydCBTZWRnZXdpY2ssIGFuZCBKb24gTC4gQmVudGxleS5cblxuQldUIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHdvcmsgYnkgWXV0YSBNb3JpOyBzZWUgQldULmpzIGZvciBkZXRhaWxzLlxuXG5iemlwMiBjb21wcmVzc2lvbiBjb2RlIGluc3BpcmVkIGJ5IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvamJ6aXAyXG4qL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vZnJlZXplJyksXG5cdHJlcXVpcmUoJy4vQml0U3RyZWFtJyksXG5cdHJlcXVpcmUoJy4vQldUJyksXG5cdHJlcXVpcmUoJy4vQ1JDMzInKSxcblx0cmVxdWlyZSgnLi9IdWZmbWFuQWxsb2NhdG9yJyksXG5cdHJlcXVpcmUoJy4vU3RyZWFtJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoZnJlZXplLCBCaXRTdHJlYW0sIEJXVCwgQ1JDMzIsIEh1ZmZtYW5BbGxvY2F0b3IsIFN0cmVhbSwgVXRpbCkge1xuXG52YXIgTUFYX0hVRkNPREVfQklUUyA9IDIwO1xudmFyIE1BWF9TWU1CT0xTID0gMjU4O1xudmFyIFNZTUJPTF9SVU5BID0gMDtcbnZhciBTWU1CT0xfUlVOQiA9IDE7XG52YXIgTUlOX0dST1VQUyA9IDI7XG52YXIgTUFYX0dST1VQUyA9IDY7XG52YXIgR1JPVVBfU0laRSA9IDUwO1xuXG52YXIgV0hPTEVQSSA9IDB4MzE0MTU5MjY1MzU5OyAvLyA0OC1iaXQgaW50ZWdlclxudmFyIFNRUlRQSSA9ICAweDE3NzI0NTM4NTA5MDsgLy8gNDgtYml0IGludGVnZXJcblxudmFyIEVPRiA9IFN0cmVhbS5FT0Y7XG5cbnZhciBtdGYgPSBmdW5jdGlvbihhcnJheSwgaW5kZXgpIHtcbiAgdmFyIHNyYyA9IGFycmF5W2luZGV4XSwgaTtcbiAgZm9yIChpID0gaW5kZXg7IGkgPiAwOyBpLS0pIHtcbiAgICBhcnJheVtpXSA9IGFycmF5W2ktMV07XG4gIH1cbiAgYXJyYXlbMF0gPSBzcmM7XG4gIHJldHVybiBzcmM7XG59O1xuXG52YXIgRXJyID0ge1xuICBPSzogMCxcbiAgTEFTVF9CTE9DSzogLTEsXG4gIE5PVF9CWklQX0RBVEE6IC0yLFxuICBVTkVYUEVDVEVEX0lOUFVUX0VPRjogLTMsXG4gIFVORVhQRUNURURfT1VUUFVUX0VPRjogLTQsXG4gIERBVEFfRVJST1I6IC01LFxuICBPVVRfT0ZfTUVNT1JZOiAtNixcbiAgT0JTT0xFVEVfSU5QVVQ6IC03LFxuICBFTkRfT0ZfQkxPQ0s6IC04XG59O1xudmFyIEVycm9yTWVzc2FnZXMgPSB7fTtcbkVycm9yTWVzc2FnZXNbRXJyLkxBU1RfQkxPQ0tdID0gICAgICAgICAgICBcIkJhZCBmaWxlIGNoZWNrc3VtXCI7XG5FcnJvck1lc3NhZ2VzW0Vyci5OT1RfQlpJUF9EQVRBXSA9ICAgICAgICAgXCJOb3QgYnppcCBkYXRhXCI7XG5FcnJvck1lc3NhZ2VzW0Vyci5VTkVYUEVDVEVEX0lOUFVUX0VPRl0gPSAgXCJVbmV4cGVjdGVkIGlucHV0IEVPRlwiO1xuRXJyb3JNZXNzYWdlc1tFcnIuVU5FWFBFQ1RFRF9PVVRQVVRfRU9GXSA9IFwiVW5leHBlY3RlZCBvdXRwdXQgRU9GXCI7XG5FcnJvck1lc3NhZ2VzW0Vyci5EQVRBX0VSUk9SXSA9ICAgICAgICAgICAgXCJEYXRhIGVycm9yXCI7XG5FcnJvck1lc3NhZ2VzW0Vyci5PVVRfT0ZfTUVNT1JZXSA9ICAgICAgICAgXCJPdXQgb2YgbWVtb3J5XCI7XG5FcnJvck1lc3NhZ2VzW0Vyci5PQlNPTEVURV9JTlBVVF0gPSBcIk9ic29sZXRlIChwcmUgMC45LjUpIGJ6aXAgZm9ybWF0IG5vdCBzdXBwb3J0ZWQuXCI7XG5cbnZhciBfdGhyb3cgPSBmdW5jdGlvbihzdGF0dXMsIG9wdERldGFpbCkge1xuICB2YXIgbXNnID0gRXJyb3JNZXNzYWdlc1tzdGF0dXNdIHx8ICd1bmtub3duIGVycm9yJztcbiAgaWYgKG9wdERldGFpbCkgeyBtc2cgKz0gJzogJytvcHREZXRhaWw7IH1cbiAgdmFyIGUgPSBuZXcgVHlwZUVycm9yKG1zZyk7XG4gIGUuZXJyb3JDb2RlID0gc3RhdHVzO1xuICB0aHJvdyBlO1xufTtcblxudmFyIEJ1bnppcCA9IGZ1bmN0aW9uKGlucHV0U3RyZWFtLCBvdXRwdXRTdHJlYW0pIHtcbiAgdGhpcy53cml0ZVBvcyA9IHRoaXMud3JpdGVDdXJyZW50ID0gdGhpcy53cml0ZUNvdW50ID0gMDtcblxuICB0aGlzLl9zdGFydF9idW56aXAoaW5wdXRTdHJlYW0sIG91dHB1dFN0cmVhbSk7XG59O1xuQnVuemlwLnByb3RvdHlwZS5faW5pdF9ibG9jayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbW9yZUJsb2NrcyA9IHRoaXMuX2dldF9uZXh0X2Jsb2NrKCk7XG4gIGlmICggIW1vcmVCbG9ja3MgKSB7XG4gICAgdGhpcy53cml0ZUNvdW50ID0gLTE7XG4gICAgcmV0dXJuIGZhbHNlOyAvKiBubyBtb3JlIGJsb2NrcyAqL1xuICB9XG4gIHRoaXMuYmxvY2tDUkMgPSBuZXcgQ1JDMzIoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuLyogWFhYIG1pY3JvLWJ1bnppcCB1c2VzIChpbnB1dFN0cmVhbSwgaW5wdXRCdWZmZXIsIGxlbikgYXMgYXJndW1lbnRzICovXG5CdW56aXAucHJvdG90eXBlLl9zdGFydF9idW56aXAgPSBmdW5jdGlvbihpbnB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtKSB7XG4gIC8qIEVuc3VyZSB0aGF0IGZpbGUgc3RhcnRzIHdpdGggXCJCWmhbJzEnLSc5J10uXCIgKi9cbiAgdmFyIGJ1ZiA9IFV0aWwubWFrZVU4QnVmZmVyKDQpO1xuICBpZiAoaW5wdXRTdHJlYW0ucmVhZChidWYsIDAsIDQpICE9PSA0IHx8XG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZlswXSwgYnVmWzFdLCBidWZbMl0pICE9PSAnQlpoJylcbiAgICBfdGhyb3coRXJyLk5PVF9CWklQX0RBVEEsICdiYWQgbWFnaWMnKTtcblxuICB2YXIgbGV2ZWwgPSBidWZbM10gLSAweDMwO1xuICBpZiAobGV2ZWwgPCAxIHx8IGxldmVsID4gOSlcbiAgICBfdGhyb3coRXJyLk5PVF9CWklQX0RBVEEsICdsZXZlbCBvdXQgb2YgcmFuZ2UnKTtcblxuICB0aGlzLnJlYWRlciA9IG5ldyBCaXRTdHJlYW0oaW5wdXRTdHJlYW0pO1xuXG4gIC8qIEZvdXJ0aCBieXRlIChhc2NpaSAnMSctJzknKSwgaW5kaWNhdGVzIGJsb2NrIHNpemUgaW4gdW5pdHMgb2YgMTAwayBvZlxuICAgICB1bmNvbXByZXNzZWQgZGF0YS4gIEFsbG9jYXRlIGludGVybWVkaWF0ZSBidWZmZXIgZm9yIGJsb2NrLiAqL1xuICB0aGlzLmRidWZTaXplID0gMTAwMDAwICogbGV2ZWw7XG4gIHRoaXMubmV4dG91dHB1dCA9IDA7XG4gIHRoaXMub3V0cHV0U3RyZWFtID0gb3V0cHV0U3RyZWFtO1xuICB0aGlzLnN0cmVhbUNSQyA9IDA7XG59O1xuQnVuemlwLnByb3RvdHlwZS5fZ2V0X25leHRfYmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGksIGosIGs7XG4gIHZhciByZWFkZXIgPSB0aGlzLnJlYWRlcjtcbiAgLy8gdGhpcyBpcyBnZXRfbmV4dF9ibG9jaygpIGZ1bmN0aW9uIGZyb20gbWljcm8tYnVuemlwOlxuICAvKiBSZWFkIGluIGhlYWRlciBzaWduYXR1cmUgYW5kIENSQywgdGhlbiB2YWxpZGF0ZSBzaWduYXR1cmUuXG4gICAgIChsYXN0IGJsb2NrIHNpZ25hdHVyZSBtZWFucyBDUkMgaXMgZm9yIHdob2xlIGZpbGUsIHJldHVybiBub3cpICovXG4gIHZhciBoID0gcmVhZGVyLnJlYWRCaXRzKDQ4KTtcbiAgaWYgKGggPT09IFNRUlRQSSkgeyAvLyBsYXN0IGJsb2NrXG4gICAgcmV0dXJuIGZhbHNlOyAvKiBubyBtb3JlIGJsb2NrcyAqL1xuICB9XG4gIGlmIChoICE9PSBXSE9MRVBJKVxuICAgIF90aHJvdyhFcnIuTk9UX0JaSVBfREFUQSk7XG4gIHRoaXMudGFyZ2V0QmxvY2tDUkMgPSByZWFkZXIucmVhZEJpdHMoMzIpO1xuICB0aGlzLnN0cmVhbUNSQyA9ICh0aGlzLnRhcmdldEJsb2NrQ1JDIF5cbiAgICAgICAgICAgICAgICAgICAgKCh0aGlzLnN0cmVhbUNSQyA8PCAxKSB8ICh0aGlzLnN0cmVhbUNSQz4+PjMxKSkpID4+PiAwO1xuICAvKiBXZSBjYW4gYWRkIHN1cHBvcnQgZm9yIGJsb2NrUmFuZG9taXNlZCBpZiBhbnlib2R5IGNvbXBsYWlucy4gIFRoZXJlIHdhc1xuICAgICBzb21lIGNvZGUgZm9yIHRoaXMgaW4gYnVzeWJveCAxLjAuMC1wcmUzLCBidXQgbm9ib2R5IGV2ZXIgbm90aWNlZCB0aGF0XG4gICAgIGl0IGRpZG4ndCBhY3R1YWxseSB3b3JrLiAqL1xuICBpZiAocmVhZGVyLnJlYWRCaXRzKDEpKVxuICAgIF90aHJvdyhFcnIuT0JTT0xFVEVfSU5QVVQpO1xuICB2YXIgb3JpZ1BvaW50ZXIgPSByZWFkZXIucmVhZEJpdHMoMjQpO1xuICBpZiAob3JpZ1BvaW50ZXIgPiB0aGlzLmRidWZTaXplKVxuICAgIF90aHJvdyhFcnIuREFUQV9FUlJPUiwgJ2luaXRpYWwgcG9zaXRpb24gb3V0IG9mIGJvdW5kcycpO1xuICAvKiBtYXBwaW5nIHRhYmxlOiBpZiBzb21lIGJ5dGUgdmFsdWVzIGFyZSBuZXZlciB1c2VkIChlbmNvZGluZyB0aGluZ3NcbiAgICAgbGlrZSBBU0NJSSB0ZXh0KSwgdGhlIGNvbXByZXNzaW9uIGNvZGUgcmVtb3ZlcyB0aGUgZ2FwcyB0byBoYXZlIGZld2VyXG4gICAgIHN5bWJvbHMgdG8gZGVhbCB3aXRoLCBhbmQgd3JpdGVzIGEgc3BhcnNlIGJpdGZpZWxkIGluZGljYXRpbmcgd2hpY2hcbiAgICAgdmFsdWVzIHdlcmUgcHJlc2VudC4gIFdlIG1ha2UgYSB0cmFuc2xhdGlvbiB0YWJsZSB0byBjb252ZXJ0IHRoZSBzeW1ib2xzXG4gICAgIGJhY2sgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYnl0ZXMuICovXG4gIHZhciB0ID0gcmVhZGVyLnJlYWRCaXRzKDE2KTtcbiAgdmFyIHN5bVRvQnl0ZSA9IFV0aWwubWFrZVU4QnVmZmVyKDI1NiksIHN5bVRvdGFsID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBpZiAodCAmICgxIDw8ICgweEYgLSBpKSkpIHtcbiAgICAgIHZhciBvID0gaSAqIDE2O1xuICAgICAgayA9IHJlYWRlci5yZWFkQml0cygxNik7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgMTY7IGorKylcbiAgICAgICAgaWYgKGsgJiAoMSA8PCAoMHhGIC0gaikpKVxuICAgICAgICAgIHN5bVRvQnl0ZVtzeW1Ub3RhbCsrXSA9IG8gKyBqO1xuICAgIH1cbiAgfVxuXG4gIC8qIEhvdyBtYW55IGRpZmZlcmVudCBIdWZmbWFuIGNvZGluZyBncm91cHMgZG9lcyB0aGlzIGJsb2NrIHVzZT8gKi9cbiAgdmFyIGdyb3VwQ291bnQgPSByZWFkZXIucmVhZEJpdHMoMyk7XG4gIGlmIChncm91cENvdW50IDwgTUlOX0dST1VQUyB8fCBncm91cENvdW50ID4gTUFYX0dST1VQUylcbiAgICBfdGhyb3coRXJyLkRBVEFfRVJST1IpO1xuICAvKiBuU2VsZWN0b3JzOiBFdmVyeSBHUk9VUF9TSVpFIG1hbnkgc3ltYm9scyB3ZSBzZWxlY3QgYSBuZXcgSHVmZm1hbiBjb2RpbmdcbiAgICAgZ3JvdXAuICBSZWFkIGluIHRoZSBncm91cCBzZWxlY3RvciBsaXN0LCB3aGljaCBpcyBzdG9yZWQgYXMgTVRGIGVuY29kZWRcbiAgICAgYml0IHJ1bnMuICAoTVRGPU1vdmUgVG8gRnJvbnQsIGFzIGVhY2ggdmFsdWUgaXMgdXNlZCBpdCdzIG1vdmVkIHRvIHRoZVxuICAgICBzdGFydCBvZiB0aGUgbGlzdC4pICovXG4gIHZhciBuU2VsZWN0b3JzID0gcmVhZGVyLnJlYWRCaXRzKDE1KTtcbiAgaWYgKG5TZWxlY3RvcnMgPT09IDApXG4gICAgX3Rocm93KEVyci5EQVRBX0VSUk9SKTtcblxuICB2YXIgbXRmU3ltYm9sID0gVXRpbC5tYWtlVThCdWZmZXIoMjU2KTtcbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkrKylcbiAgICBtdGZTeW1ib2xbaV0gPSBpO1xuXG4gIHZhciBzZWxlY3RvcnMgPSBVdGlsLm1ha2VVOEJ1ZmZlcihuU2VsZWN0b3JzKTsgLy8gd2FzIDMyNzY4Li4uXG5cbiAgZm9yIChpID0gMDsgaSA8IG5TZWxlY3RvcnM7IGkrKykge1xuICAgIC8qIEdldCBuZXh0IHZhbHVlICovXG4gICAgZm9yIChqID0gMDsgcmVhZGVyLnJlYWRCaXRzKDEpOyBqKyspXG4gICAgICBpZiAoaiA+PSBncm91cENvdW50KSBfdGhyb3coRXJyLkRBVEFfRVJST1IpO1xuICAgIC8qIERlY29kZSBNVEYgdG8gZ2V0IHRoZSBuZXh0IHNlbGVjdG9yICovXG4gICAgc2VsZWN0b3JzW2ldID0gbXRmKG10ZlN5bWJvbCwgaik7XG4gIH1cblxuICAvKiBSZWFkIHRoZSBIdWZmbWFuIGNvZGluZyB0YWJsZXMgZm9yIGVhY2ggZ3JvdXAsIHdoaWNoIGNvZGUgZm9yIHN5bVRvdGFsXG4gICAgIGxpdGVyYWwgc3ltYm9scywgcGx1cyB0d28gcnVuIHN5bWJvbHMgKFJVTkEsIFJVTkIpICovXG4gIHZhciBzeW1Db3VudCA9IHN5bVRvdGFsICsgMjtcbiAgdmFyIGdyb3VwcyA9IFtdLCBodWZHcm91cDtcbiAgZm9yIChqID0gMDsgaiA8IGdyb3VwQ291bnQ7IGorKykge1xuICAgIHZhciBsZW5ndGggPSBVdGlsLm1ha2VVOEJ1ZmZlcihzeW1Db3VudCksIHRlbXAgPSBVdGlsLm1ha2VVOEJ1ZmZlcihNQVhfSFVGQ09ERV9CSVRTICsgMSk7XG4gICAgLyogUmVhZCBIdWZmbWFuIGNvZGUgbGVuZ3RocyBmb3IgZWFjaCBzeW1ib2wuICBUaGV5J3JlIHN0b3JlZCBpblxuICAgICAgIGEgd2F5IHNpbWlsYXIgdG8gTVRGOyByZWNvcmQgYSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIGZpcnN0IHN5bWJvbCxcbiAgICAgICBhbmQgYW4gb2Zmc2V0IGZyb20gdGhlIHByZXZpb3VzIHZhbHVlIGZvciBldmVyeSBzeW1ib2wgYWZ0ZXIgdGhhdC4gKi9cbiAgICB0ID0gcmVhZGVyLnJlYWRCaXRzKDUpOyAvLyBsZW5ndGhzXG4gICAgZm9yIChpID0gMDsgaSA8IHN5bUNvdW50OyBpKyspIHtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHQgPCAxIHx8IHQgPiBNQVhfSFVGQ09ERV9CSVRTKSBfdGhyb3coRXJyLkRBVEFfRVJST1IpO1xuICAgICAgICAvKiBJZiBmaXJzdCBiaXQgaXMgMCwgc3RvcC4gIEVsc2Ugc2Vjb25kIGJpdCBpbmRpY2F0ZXMgd2hldGhlclxuICAgICAgICAgICB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSB2YWx1ZS4gKi9cbiAgICAgICAgaWYoIXJlYWRlci5yZWFkQml0cygxKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYoIXJlYWRlci5yZWFkQml0cygxKSlcbiAgICAgICAgICB0Kys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0LS07XG4gICAgICB9XG4gICAgICBsZW5ndGhbaV0gPSB0O1xuICAgIH1cblxuICAgIC8qIEZpbmQgbGFyZ2VzdCBhbmQgc21hbGxlc3QgbGVuZ3RocyBpbiB0aGlzIGdyb3VwICovXG4gICAgdmFyIG1pbkxlbiwgIG1heExlbjtcbiAgICBtaW5MZW4gPSBtYXhMZW4gPSBsZW5ndGhbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IHN5bUNvdW50OyBpKyspIHtcbiAgICAgIGlmIChsZW5ndGhbaV0gPiBtYXhMZW4pXG4gICAgICAgIG1heExlbiA9IGxlbmd0aFtpXTtcbiAgICAgIGVsc2UgaWYgKGxlbmd0aFtpXSA8IG1pbkxlbilcbiAgICAgICAgbWluTGVuID0gbGVuZ3RoW2ldO1xuICAgIH1cblxuICAgIC8qIENhbGN1bGF0ZSBwZXJtdXRlW10sIGJhc2VbXSwgYW5kIGxpbWl0W10gdGFibGVzIGZyb20gbGVuZ3RoW10uXG4gICAgICpcbiAgICAgKiBwZXJtdXRlW10gaXMgdGhlIGxvb2t1cCB0YWJsZSBmb3IgY29udmVydGluZyBIdWZmbWFuIGNvZGVkIHN5bWJvbHNcbiAgICAgKiBpbnRvIGRlY29kZWQgc3ltYm9scy4gIGJhc2VbXSBpcyB0aGUgYW1vdW50IHRvIHN1YnRyYWN0IGZyb20gdGhlXG4gICAgICogdmFsdWUgb2YgYSBIdWZmbWFuIHN5bWJvbCBvZiBhIGdpdmVuIGxlbmd0aCB3aGVuIHVzaW5nIHBlcm11dGVbXS5cbiAgICAgKlxuICAgICAqIGxpbWl0W10gaW5kaWNhdGVzIHRoZSBsYXJnZXN0IG51bWVyaWNhbCB2YWx1ZSBhIHN5bWJvbCB3aXRoIGEgZ2l2ZW5cbiAgICAgKiBudW1iZXIgb2YgYml0cyBjYW4gaGF2ZS4gIFRoaXMgaXMgaG93IHRoZSBIdWZmbWFuIGNvZGVzIGNhbiB2YXJ5IGluXG4gICAgICogbGVuZ3RoOiBlYWNoIGNvZGUgd2l0aCBhIHZhbHVlPmxpbWl0W2xlbmd0aF0gbmVlZHMgYW5vdGhlciBiaXQuXG4gICAgICovXG4gICAgaHVmR3JvdXAgPSB7fTtcbiAgICBncm91cHMucHVzaChodWZHcm91cCk7XG4gICAgaHVmR3JvdXAucGVybXV0ZSA9IFV0aWwubWFrZVUxNkJ1ZmZlcihNQVhfU1lNQk9MUyk7XG4gICAgaHVmR3JvdXAubGltaXQgPSBVdGlsLm1ha2VVMzJCdWZmZXIoTUFYX0hVRkNPREVfQklUUyArIDIpO1xuICAgIGh1Zkdyb3VwLmJhc2UgPSBVdGlsLm1ha2VVMzJCdWZmZXIoTUFYX0hVRkNPREVfQklUUyArIDEpO1xuICAgIGh1Zkdyb3VwLm1pbkxlbiA9IG1pbkxlbjtcbiAgICBodWZHcm91cC5tYXhMZW4gPSBtYXhMZW47XG4gICAgLyogQ2FsY3VsYXRlIHBlcm11dGVbXS4gIENvbmN1cnJlbnRseSwgaW5pdGlhbGl6ZSB0ZW1wW10gYW5kIGxpbWl0W10uICovXG4gICAgdmFyIHBwID0gMDtcbiAgICBmb3IgKGkgPSBtaW5MZW47IGkgPD0gbWF4TGVuOyBpKyspIHtcbiAgICAgIHRlbXBbaV0gPSBodWZHcm91cC5saW1pdFtpXSA9IDA7XG4gICAgICBmb3IgKHQgPSAwOyB0IDwgc3ltQ291bnQ7IHQrKylcbiAgICAgICAgaWYgKGxlbmd0aFt0XSA9PT0gaSlcbiAgICAgICAgICBodWZHcm91cC5wZXJtdXRlW3BwKytdID0gdDtcbiAgICB9XG4gICAgLyogQ291bnQgc3ltYm9scyBjb2RlZCBmb3IgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN5bUNvdW50OyBpKyspXG4gICAgICB0ZW1wW2xlbmd0aFtpXV0rKztcbiAgICAvKiBDYWxjdWxhdGUgbGltaXRbXSAodGhlIGxhcmdlc3Qgc3ltYm9sLWNvZGluZyB2YWx1ZSBhdCBlYWNoIGJpdFxuICAgICAqIGxlbmd0aCwgd2hpY2ggaXMgKHByZXZpb3VzIGxpbWl0PDwxKStzeW1ib2xzIGF0IHRoaXMgbGV2ZWwpLCBhbmRcbiAgICAgKiBiYXNlW10gKG51bWJlciBvZiBzeW1ib2xzIHRvIGlnbm9yZSBhdCBlYWNoIGJpdCBsZW5ndGgsIHdoaWNoIGlzXG4gICAgICogbGltaXQgbWludXMgdGhlIGN1bXVsYXRpdmUgY291bnQgb2Ygc3ltYm9scyBjb2RlZCBmb3IgYWxyZWFkeSkuICovXG4gICAgcHAgPSB0ID0gMDtcbiAgICBmb3IgKGkgPSBtaW5MZW47IGkgPCBtYXhMZW47IGkrKykge1xuICAgICAgcHAgKz0gdGVtcFtpXTtcbiAgICAgIC8qIFdlIHJlYWQgdGhlIGxhcmdlc3QgcG9zc2libGUgc3ltYm9sIHNpemUgYW5kIHRoZW4gdW5nZXQgYml0c1xuICAgICAgICAgYWZ0ZXIgZGV0ZXJtaW5pbmcgaG93IG1hbnkgd2UgbmVlZCwgYW5kIHRob3NlIGV4dHJhIGJpdHMgY291bGRcbiAgICAgICAgIGJlIHNldCB0byBhbnl0aGluZy4gIChUaGV5J3JlIG5vaXNlIGZyb20gZnV0dXJlIHN5bWJvbHMuKSAgQXRcbiAgICAgICAgIGVhY2ggbGV2ZWwgd2UncmUgcmVhbGx5IG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgZmlyc3QgZmV3IGJpdHMsXG4gICAgICAgICBzbyBoZXJlIHdlIHNldCBhbGwgdGhlIHRyYWlsaW5nIHRvLWJlLWlnbm9yZWQgYml0cyB0byAxIHNvIHRoZXlcbiAgICAgICAgIGRvbid0IGFmZmVjdCB0aGUgdmFsdWU+bGltaXRbbGVuZ3RoXSBjb21wYXJpc29uLiAqL1xuICAgICAgaHVmR3JvdXAubGltaXRbaV0gPSBwcCAtIDE7XG4gICAgICBwcCA8PD0gMTtcbiAgICAgIHQgKz0gdGVtcFtpXTtcbiAgICAgIGh1Zkdyb3VwLmJhc2VbaSArIDFdID0gcHAgLSB0O1xuICAgIH1cbiAgICBodWZHcm91cC5saW1pdFttYXhMZW4gKyAxXSA9IE51bWJlci5NQVhfVkFMVUU7IC8qIFNlbnRpbmVsIHZhbHVlIGZvciByZWFkaW5nIG5leHQgc3ltLiAqL1xuICAgIGh1Zkdyb3VwLmxpbWl0W21heExlbl0gPSBwcCArIHRlbXBbbWF4TGVuXSAtIDE7XG4gICAgaHVmR3JvdXAuYmFzZVttaW5MZW5dID0gMDtcbiAgfVxuICAvKiBXZSd2ZSBmaW5pc2hlZCByZWFkaW5nIGFuZCBkaWdlc3RpbmcgdGhlIGJsb2NrIGhlYWRlci4gIE5vdyByZWFkIHRoaXNcbiAgICAgYmxvY2sncyBIdWZmbWFuIGNvZGVkIHN5bWJvbHMgZnJvbSB0aGUgZmlsZSBhbmQgdW5kbyB0aGUgSHVmZm1hbiBjb2RpbmdcbiAgICAgYW5kIHJ1biBsZW5ndGggZW5jb2RpbmcsIHNhdmluZyB0aGUgcmVzdWx0IGludG8gZGJ1ZltkYnVmQ291bnQrK109dWMgKi9cblxuICAvKiBJbml0aWFsaXplIHN5bWJvbCBvY2N1cnJlbmNlIGNvdW50ZXJzIGFuZCBzeW1ib2wgTW92ZSBUbyBGcm9udCB0YWJsZSAqL1xuICB2YXIgYnl0ZUNvdW50ID0gVXRpbC5tYWtlVTMyQnVmZmVyKDI1Nik7XG4gIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKylcbiAgICBtdGZTeW1ib2xbaV0gPSBpO1xuICAvKiBMb29wIHRocm91Z2ggY29tcHJlc3NlZCBzeW1ib2xzLiAqL1xuICB2YXIgcnVuUG9zID0gMCwgZGJ1ZkNvdW50ID0gMCwgc2VsZWN0b3IgPSAwLCB1YztcbiAgdmFyIGRidWYgPSB0aGlzLmRidWYgPSBVdGlsLm1ha2VVMzJCdWZmZXIodGhpcy5kYnVmU2l6ZSk7XG4gIHN5bUNvdW50ID0gMDtcbiAgZm9yICg7Oykge1xuICAgIC8qIERldGVybWluZSB3aGljaCBIdWZmbWFuIGNvZGluZyBncm91cCB0byB1c2UuICovXG4gICAgaWYgKCEoc3ltQ291bnQtLSkpIHtcbiAgICAgIHN5bUNvdW50ID0gR1JPVVBfU0laRSAtIDE7XG4gICAgICBpZiAoc2VsZWN0b3IgPj0gblNlbGVjdG9ycykgeyBfdGhyb3coRXJyLkRBVEFfRVJST1IpOyB9XG4gICAgICBodWZHcm91cCA9IGdyb3Vwc1tzZWxlY3RvcnNbc2VsZWN0b3IrK11dO1xuICAgIH1cbiAgICAvKiBSZWFkIG5leHQgSHVmZm1hbi1jb2RlZCBzeW1ib2wuICovXG4gICAgaSA9IGh1Zkdyb3VwLm1pbkxlbjtcbiAgICBqID0gcmVhZGVyLnJlYWRCaXRzKGkpO1xuICAgIGZvciAoOztpKyspIHtcbiAgICAgIGlmIChpID4gaHVmR3JvdXAubWF4TGVuKSB7IF90aHJvdyhFcnIuREFUQV9FUlJPUik7IH1cbiAgICAgIGlmIChqIDw9IGh1Zkdyb3VwLmxpbWl0W2ldKVxuICAgICAgICBicmVhaztcbiAgICAgIGogPSAoaiA8PCAxKSB8IHJlYWRlci5yZWFkQml0cygxKTtcbiAgICB9XG4gICAgLyogSHVmZm1hbiBkZWNvZGUgdmFsdWUgdG8gZ2V0IG5leHRTeW0gKHdpdGggYm91bmRzIGNoZWNraW5nKSAqL1xuICAgIGogLT0gaHVmR3JvdXAuYmFzZVtpXTtcbiAgICBpZiAoaiA8IDAgfHwgaiA+PSBNQVhfU1lNQk9MUykgeyBfdGhyb3coRXJyLkRBVEFfRVJST1IpOyB9XG4gICAgdmFyIG5leHRTeW0gPSBodWZHcm91cC5wZXJtdXRlW2pdO1xuICAgIC8qIFdlIGhhdmUgbm93IGRlY29kZWQgdGhlIHN5bWJvbCwgd2hpY2ggaW5kaWNhdGVzIGVpdGhlciBhIG5ldyBsaXRlcmFsXG4gICAgICAgYnl0ZSwgb3IgYSByZXBlYXRlZCBydW4gb2YgdGhlIG1vc3QgcmVjZW50IGxpdGVyYWwgYnl0ZS4gIEZpcnN0LFxuICAgICAgIGNoZWNrIGlmIG5leHRTeW0gaW5kaWNhdGVzIGEgcmVwZWF0ZWQgcnVuLCBhbmQgaWYgc28gbG9vcCBjb2xsZWN0aW5nXG4gICAgICAgaG93IG1hbnkgdGltZXMgdG8gcmVwZWF0IHRoZSBsYXN0IGxpdGVyYWwuICovXG4gICAgaWYgKG5leHRTeW0gPT09IFNZTUJPTF9SVU5BIHx8IG5leHRTeW0gPT09IFNZTUJPTF9SVU5CKSB7XG4gICAgICAvKiBJZiB0aGlzIGlzIHRoZSBzdGFydCBvZiBhIG5ldyBydW4sIHplcm8gb3V0IGNvdW50ZXIgKi9cbiAgICAgIGlmICghcnVuUG9zKXtcbiAgICAgICAgcnVuUG9zID0gMTtcbiAgICAgICAgdCA9IDA7XG4gICAgICB9XG4gICAgICAvKiBOZWF0IHRyaWNrIHRoYXQgc2F2ZXMgMSBzeW1ib2w6IGluc3RlYWQgb2Ygb3ItaW5nIDAgb3IgMSBhdFxuICAgICAgICAgZWFjaCBiaXQgcG9zaXRpb24sIGFkZCAxIG9yIDIgaW5zdGVhZC4gIEZvciBleGFtcGxlLFxuICAgICAgICAgMTAxMSBpcyAxPDwwICsgMTw8MSArIDI8PDIuICAxMDEwIGlzIDI8PDAgKyAyPDwxICsgMTw8Mi5cbiAgICAgICAgIFlvdSBjYW4gbWFrZSBhbnkgYml0IHBhdHRlcm4gdGhhdCB3YXkgdXNpbmcgMSBsZXNzIHN5bWJvbCB0aGFuXG4gICAgICAgICB0aGUgYmFzaWMgb3IgMC8xIG1ldGhvZCAoZXhjZXB0IGFsbCBiaXRzIDAsIHdoaWNoIHdvdWxkIHVzZSBub1xuICAgICAgICAgc3ltYm9scywgYnV0IGEgcnVuIG9mIGxlbmd0aCAwIGRvZXNuJ3QgbWVhbiBhbnl0aGluZyBpbiB0aGlzXG4gICAgICAgICBjb250ZXh0KS4gIFRodXMgc3BhY2UgaXMgc2F2ZWQuICovXG4gICAgICBpZiAobmV4dFN5bSA9PT0gU1lNQk9MX1JVTkEpXG4gICAgICAgIHQgKz0gcnVuUG9zO1xuICAgICAgZWxzZVxuICAgICAgICB0ICs9IDIgKiBydW5Qb3M7XG4gICAgICBydW5Qb3MgPDw9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLyogV2hlbiB3ZSBoaXQgdGhlIGZpcnN0IG5vbi1ydW4gc3ltYm9sIGFmdGVyIGEgcnVuLCB3ZSBub3cga25vd1xuICAgICAgIGhvdyBtYW55IHRpbWVzIHRvIHJlcGVhdCB0aGUgbGFzdCBsaXRlcmFsLCBzbyBhcHBlbmQgdGhhdCBtYW55XG4gICAgICAgY29waWVzIHRvIG91ciBidWZmZXIgb2YgZGVjb2RlZCBzeW1ib2xzIChkYnVmKSBub3cuICAoVGhlIGxhc3RcbiAgICAgICBsaXRlcmFsIHVzZWQgaXMgdGhlIG9uZSBhdCB0aGUgaGVhZCBvZiB0aGUgbXRmU3ltYm9sIGFycmF5LikgKi9cbiAgICBpZiAocnVuUG9zKXtcbiAgICAgIHJ1blBvcyA9IDA7XG4gICAgICBpZiAoZGJ1ZkNvdW50ICsgdCA+PSB0aGlzLmRidWZTaXplKSB7IF90aHJvdyhFcnIuREFUQV9FUlJPUik7IH1cbiAgICAgIHVjID0gc3ltVG9CeXRlW210ZlN5bWJvbFswXV07XG4gICAgICBieXRlQ291bnRbdWNdICs9IHQ7XG4gICAgICB3aGlsZSAodC0tKVxuICAgICAgICBkYnVmW2RidWZDb3VudCsrXSA9IHVjO1xuICAgIH1cbiAgICAvKiBJcyB0aGlzIHRoZSB0ZXJtaW5hdGluZyBzeW1ib2w/ICovXG4gICAgaWYgKG5leHRTeW0gPiBzeW1Ub3RhbClcbiAgICAgIGJyZWFrO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG5leHRTeW0gaW5kaWNhdGVzIGEgbmV3IGxpdGVyYWwgY2hhcmFjdGVyLiAgU3VidHJhY3RcbiAgICAgICBvbmUgdG8gZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgTVRGIGFycmF5IGF0IHdoaWNoIHRoaXMgbGl0ZXJhbCBpc1xuICAgICAgIGN1cnJlbnRseSB0byBiZSBmb3VuZC4gIChOb3RlIHRoYXQgdGhlIHJlc3VsdCBjYW4ndCBiZSAtMSBvciAwLFxuICAgICAgIGJlY2F1c2UgMCBhbmQgMSBhcmUgUlVOQSBhbmQgUlVOQi4gIEJ1dCBhbm90aGVyIGluc3RhbmNlIG9mIHRoZVxuICAgICAgIGZpcnN0IHN5bWJvbCBpbiB0aGUgTVRGIGFycmF5LCBwb3NpdGlvbiAwLCB3b3VsZCBoYXZlIGJlZW4gaGFuZGxlZFxuICAgICAgIGFzIHBhcnQgb2YgYSBydW4gYWJvdmUuICBUaGVyZWZvcmUgMSB1bnVzZWQgTVRGIHBvc2l0aW9uIG1pbnVzXG4gICAgICAgMiBub24tbGl0ZXJhbCBuZXh0U3ltIHZhbHVlcyBlcXVhbHMgLTEuKSAqL1xuICAgIGlmIChkYnVmQ291bnQgPj0gdGhpcy5kYnVmU2l6ZSkgeyBfdGhyb3coRXJyLkRBVEFfRVJST1IpOyB9XG4gICAgaSA9IG5leHRTeW0gLSAxO1xuICAgIHVjID0gbXRmKG10ZlN5bWJvbCwgaSk7XG4gICAgdWMgPSBzeW1Ub0J5dGVbdWNdO1xuICAgIC8qIFdlIGhhdmUgb3VyIGxpdGVyYWwgYnl0ZS4gIFNhdmUgaXQgaW50byBkYnVmLiAqL1xuICAgIGJ5dGVDb3VudFt1Y10rKztcbiAgICBkYnVmW2RidWZDb3VudCsrXSA9IHVjO1xuICB9XG4gIC8qIEF0IHRoaXMgcG9pbnQsIHdlJ3ZlIHJlYWQgYWxsIHRoZSBIdWZmbWFuLWNvZGVkIHN5bWJvbHMgKGFuZCByZXBlYXRlZFxuICAgICBydW5zKSBmb3IgdGhpcyBibG9jayBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIGFuZCBkZWNvZGVkIHRoZW0gaW50byB0aGVcbiAgICAgaW50ZXJtZWRpYXRlIGJ1ZmZlci4gIFRoZXJlIGFyZSBkYnVmQ291bnQgbWFueSBkZWNvZGVkIGJ5dGVzIGluIGRidWZbXS5cbiAgICAgTm93IHVuZG8gdGhlIEJ1cnJvd3MtV2hlZWxlciB0cmFuc2Zvcm0gb24gZGJ1Zi5cbiAgICAgU2VlIGh0dHA6Ly9kb2dtYS5uZXQvbWFya24vYXJ0aWNsZXMvYnd0L2J3dC5odG1cbiAgKi9cbiAgaWYgKG9yaWdQb2ludGVyIDwgMCB8fCBvcmlnUG9pbnRlciA+PSBkYnVmQ291bnQpIHsgX3Rocm93KEVyci5EQVRBX0VSUk9SKTsgfVxuICAvKiBUdXJuIGJ5dGVDb3VudCBpbnRvIGN1bXVsYXRpdmUgb2NjdXJyZW5jZSBjb3VudHMgb2YgMCB0byBuLTEuICovXG4gIGogPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBrID0gaiArIGJ5dGVDb3VudFtpXTtcbiAgICBieXRlQ291bnRbaV0gPSBqO1xuICAgIGogPSBrO1xuICB9XG4gIC8qIEZpZ3VyZSBvdXQgd2hhdCBvcmRlciBkYnVmIHdvdWxkIGJlIGluIGlmIHdlIHNvcnRlZCBpdC4gKi9cbiAgZm9yIChpID0gMDsgaSA8IGRidWZDb3VudDsgaSsrKSB7XG4gICAgdWMgPSBkYnVmW2ldICYgMHhmZjtcbiAgICBkYnVmW2J5dGVDb3VudFt1Y11dIHw9IChpIDw8IDgpO1xuICAgIGJ5dGVDb3VudFt1Y10rKztcbiAgfVxuICAvKiBEZWNvZGUgZmlyc3QgYnl0ZSBieSBoYW5kIHRvIGluaXRpYWxpemUgXCJwcmV2aW91c1wiIGJ5dGUuICBOb3RlIHRoYXQgaXRcbiAgICAgZG9lc24ndCBnZXQgb3V0cHV0LCBhbmQgaWYgdGhlIGZpcnN0IHRocmVlIGNoYXJhY3RlcnMgYXJlIGlkZW50aWNhbFxuICAgICBpdCBkb2Vzbid0IHF1YWxpZnkgYXMgYSBydW4gKGhlbmNlIHdyaXRlUnVuQ291bnRkb3duPTUpLiAqL1xuICB2YXIgcG9zID0gMCwgY3VycmVudCA9IDAsIHJ1biA9IDA7XG4gIGlmIChkYnVmQ291bnQpIHtcbiAgICBwb3MgPSBkYnVmW29yaWdQb2ludGVyXTtcbiAgICBjdXJyZW50ID0gKHBvcyAmIDB4ZmYpO1xuICAgIHBvcyA+Pj0gODtcbiAgICBydW4gPSAtMTtcbiAgfVxuICB0aGlzLndyaXRlUG9zID0gcG9zO1xuICB0aGlzLndyaXRlQ3VycmVudCA9IGN1cnJlbnQ7XG4gIHRoaXMud3JpdGVDb3VudCA9IGRidWZDb3VudDtcbiAgdGhpcy53cml0ZVJ1biA9IHJ1bjtcblxuICByZXR1cm4gdHJ1ZTsgLyogbW9yZSBibG9ja3MgdG8gY29tZSAqL1xufTtcbi8qIFVuZG8gYnVycm93cy13aGVlbGVyIHRyYW5zZm9ybSBvbiBpbnRlcm1lZGlhdGUgYnVmZmVyIHRvIHByb2R1Y2Ugb3V0cHV0LlxuICAgSWYgc3RhcnRfYnVuemlwIHdhcyBpbml0aWFsaXplZCB3aXRoIG91dF9mZD0tMSwgdGhlbiB1cCB0byBsZW4gYnl0ZXMgb2ZcbiAgIGRhdGEgYXJlIHdyaXR0ZW4gdG8gb3V0YnVmLiAgUmV0dXJuIHZhbHVlIGlzIG51bWJlciBvZiBieXRlcyB3cml0dGVuIG9yXG4gICBlcnJvciAoYWxsIGVycm9ycyBhcmUgbmVnYXRpdmUgbnVtYmVycykuICBJZiBvdXRfZmQhPS0xLCBvdXRidWYgYW5kIGxlblxuICAgYXJlIGlnbm9yZWQsIGRhdGEgaXMgd3JpdHRlbiB0byBvdXRfZmQgYW5kIHJldHVybiBpcyBSRVRWQUxfT0sgb3IgZXJyb3IuXG4qL1xuQnVuemlwLnByb3RvdHlwZS5fcmVhZF9idW56aXAgPSBmdW5jdGlvbihvdXRwdXRCdWZmZXIsIGxlbikge1xuICAgIHZhciBjb3BpZXMsIHByZXZpb3VzLCBvdXRieXRlO1xuICAgIC8qIGphbWVzQGphbWVzdGF5bG9yLm9yZzogd3JpdGVDb3VudCBnb2VzIHRvIC0xIHdoZW4gdGhlIGJ1ZmZlciBpcyBmdWxseVxuICAgICAgIGRlY29kZWQsIHdoaWNoIHJlc3VsdHMgaW4gdGhpcyByZXR1cm5pbmcgUkVUVkFMX0xBU1RfQkxPQ0ssIGFsc29cbiAgICAgICBlcXVhbCB0byAtMS4uLiBDb25mdXNpbmcsIEknbSByZXR1cm5pbmcgMCBoZXJlIHRvIGluZGljYXRlIG5vXG4gICAgICAgYnl0ZXMgd3JpdHRlbiBpbnRvIHRoZSBidWZmZXIgKi9cbiAgaWYgKHRoaXMud3JpdGVDb3VudCA8IDApIHsgcmV0dXJuIDA7IH1cblxuICB2YXIgZ290Y291bnQgPSAwO1xuICB2YXIgZGJ1ZiA9IHRoaXMuZGJ1ZiwgcG9zID0gdGhpcy53cml0ZVBvcywgY3VycmVudCA9IHRoaXMud3JpdGVDdXJyZW50O1xuICB2YXIgZGJ1ZkNvdW50ID0gdGhpcy53cml0ZUNvdW50LCBvdXRwdXRzaXplID0gdGhpcy5vdXRwdXRzaXplO1xuICB2YXIgcnVuID0gdGhpcy53cml0ZVJ1bjtcblxuICB3aGlsZSAoZGJ1ZkNvdW50KSB7XG4gICAgZGJ1ZkNvdW50LS07XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIHBvcyA9IGRidWZbcG9zXTtcbiAgICBjdXJyZW50ID0gcG9zICYgMHhmZjtcbiAgICBwb3MgPj49IDg7XG4gICAgaWYgKHJ1bisrID09PSAzKXtcbiAgICAgIGNvcGllcyA9IGN1cnJlbnQ7XG4gICAgICBvdXRieXRlID0gcHJldmlvdXM7XG4gICAgICBjdXJyZW50ID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcGllcyA9IDE7XG4gICAgICBvdXRieXRlID0gY3VycmVudDtcbiAgICB9XG4gICAgdGhpcy5ibG9ja0NSQy51cGRhdGVDUkNSdW4ob3V0Ynl0ZSwgY29waWVzKTtcbiAgICB3aGlsZSAoY29waWVzLS0pIHtcbiAgICAgIHRoaXMub3V0cHV0U3RyZWFtLndyaXRlQnl0ZShvdXRieXRlKTtcbiAgICAgIHRoaXMubmV4dG91dHB1dCsrO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCAhPSBwcmV2aW91cylcbiAgICAgIHJ1biA9IDA7XG4gIH1cbiAgdGhpcy53cml0ZUNvdW50ID0gZGJ1ZkNvdW50O1xuICAvLyBjaGVjayBDUkNcbiAgaWYgKHRoaXMuYmxvY2tDUkMuZ2V0Q1JDKCkgIT09IHRoaXMudGFyZ2V0QmxvY2tDUkMpIHtcbiAgICBfdGhyb3coRXJyLkRBVEFfRVJST1IsIFwiQmFkIGJsb2NrIENSQyBcIitcbiAgICAgICAgICAgXCIoZ290IFwiK3RoaXMuYmxvY2tDUkMuZ2V0Q1JDKCkudG9TdHJpbmcoMTYpK1xuICAgICAgICAgICBcIiBleHBlY3RlZCBcIit0aGlzLnRhcmdldEJsb2NrQ1JDLnRvU3RyaW5nKDE2KStcIilcIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMubmV4dG91dHB1dDtcbn07XG5cbi8qIFN0YXRpYyBoZWxwZXIgZnVuY3Rpb25zICovXG5CdW56aXAuRXJyID0gRXJyO1xuLy8gJ2lucHV0JyBjYW4gYmUgYSBzdHJlYW0gb3IgYSBidWZmZXJcbi8vICdvdXRwdXQnIGNhbiBiZSBhIHN0cmVhbSBvciBhIGJ1ZmZlciBvciBhIG51bWJlciAoYnVmZmVyIHNpemUpXG5CdW56aXAuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgbXVsdGlzdHJlYW0pIHtcbiAgLy8gbWFrZSBhIHN0cmVhbSBmcm9tIGEgYnVmZmVyLCBpZiBuZWNlc3NhcnlcbiAgdmFyIGlucHV0U3RyZWFtID0gVXRpbC5jb2VyY2VJbnB1dFN0cmVhbShpbnB1dCk7XG4gIHZhciBvID0gVXRpbC5jb2VyY2VPdXRwdXRTdHJlYW0ob3V0cHV0LCBvdXRwdXQpO1xuICB2YXIgb3V0cHV0U3RyZWFtID0gby5zdHJlYW07XG5cbiAgdmFyIGJ6ID0gbmV3IEJ1bnppcChpbnB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoJ2VvZicgaW4gaW5wdXRTdHJlYW0gJiYgaW5wdXRTdHJlYW0uZW9mKCkpIGJyZWFrO1xuICAgIGlmIChiei5faW5pdF9ibG9jaygpKSB7XG4gICAgICBiei5fcmVhZF9idW56aXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldFN0cmVhbUNSQyA9IGJ6LnJlYWRlci5yZWFkQml0cygzMik7XG4gICAgICBpZiAodGFyZ2V0U3RyZWFtQ1JDICE9PSBiei5zdHJlYW1DUkMpIHtcbiAgICAgICAgX3Rocm93KEVyci5EQVRBX0VSUk9SLCBcIkJhZCBzdHJlYW0gQ1JDIFwiK1xuICAgICAgICAgICAgICAgXCIoZ290IFwiK2J6LnN0cmVhbUNSQy50b1N0cmluZygxNikrXG4gICAgICAgICAgICAgICBcIiBleHBlY3RlZCBcIit0YXJnZXRTdHJlYW1DUkMudG9TdHJpbmcoMTYpK1wiKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtdWx0aXN0cmVhbSAmJlxuICAgICAgICAgICdlb2YnIGluIGlucHV0U3RyZWFtICYmXG4gICAgICAgICAgIWlucHV0U3RyZWFtLmVvZigpKSB7XG4gICAgICAgIC8vIG5vdGUgdGhhdCBzdGFydF9idW56aXAgd2lsbCBhbHNvIHJlc3luYyB0aGUgYml0IHJlYWRlciB0byBuZXh0IGJ5dGVcbiAgICAgICAgYnouX3N0YXJ0X2J1bnppcChpbnB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtKTtcbiAgICAgIH0gZWxzZSBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG8ucmV0dmFsO1xufTtcbkJ1bnppcC5kZWNvZGVCbG9jayA9IGZ1bmN0aW9uKGlucHV0LCBwb3MsIG91dHB1dCkge1xuICAvLyBtYWtlIGEgc3RyZWFtIGZyb20gYSBidWZmZXIsIGlmIG5lY2Vzc2FyeVxuICB2YXIgaW5wdXRTdHJlYW0gPSBVdGlsLmNvZXJjZUlucHV0U3RyZWFtKGlucHV0KTtcbiAgdmFyIG8gPSBVdGlsLmNvZXJjZU91dHB1dFN0cmVhbShvdXRwdXQsIG91dHB1dCk7XG4gIHZhciBvdXRwdXRTdHJlYW0gPSBvLnN0cmVhbTtcbiAgdmFyIGJ6ID0gbmV3IEJ1bnppcChpbnB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtKTtcbiAgYnoucmVhZGVyLnNlZWtCaXQocG9zKTtcbiAgLyogRmlsbCB0aGUgZGVjb2RlIGJ1ZmZlciBmb3IgdGhlIGJsb2NrICovXG4gIHZhciBtb3JlQmxvY2tzID0gYnouX2dldF9uZXh0X2Jsb2NrKCk7XG4gIGlmIChtb3JlQmxvY2tzKSB7XG4gICAgLyogSW5pdCB0aGUgQ1JDIGZvciB3cml0aW5nICovXG4gICAgYnouYmxvY2tDUkMgPSBuZXcgQ1JDMzIoKTtcblxuICAgIC8qIFplcm8gdGhpcyBzbyB0aGUgY3VycmVudCBieXRlIGZyb20gYmVmb3JlIHRoZSBzZWVrIGlzIG5vdCB3cml0dGVuICovXG4gICAgYnoud3JpdGVDb3BpZXMgPSAwO1xuXG4gICAgLyogRGVjb21wcmVzcyB0aGUgYmxvY2sgYW5kIHdyaXRlIHRvIHN0ZG91dCAqL1xuICAgIGJ6Ll9yZWFkX2J1bnppcCgpO1xuICAgIC8vIFhYWCBrZWVwIHdyaXRpbmc/XG4gIH1cbiAgcmV0dXJuIG8ucmV0dmFsO1xufTtcbi8qIFJlYWRzIGJ6aXAyIGZpbGUgZnJvbSBzdHJlYW0gb3IgYnVmZmVyIGBpbnB1dGAsIGFuZCBpbnZva2VcbiAqIGBjYWxsYmFjayhwb3NpdGlvbiwgc2l6ZSlgIG9uY2UgZm9yIGVhY2ggYnppcDIgYmxvY2ssXG4gKiB3aGVyZSBwb3NpdGlvbiBnaXZlcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gKGluICpiaXRzKilcbiAqIGFuZCBzaXplIGdpdmVzIHVuY29tcHJlc3NlZCBzaXplIG9mIHRoZSBibG9jayAoaW4gKmJ5dGVzKikuICovXG5CdW56aXAudGFibGUgPSBmdW5jdGlvbihpbnB1dCwgY2FsbGJhY2ssIG11bHRpc3RyZWFtKSB7XG4gIC8vIG1ha2UgYSBzdHJlYW0gZnJvbSBhIGJ1ZmZlciwgaWYgbmVjZXNzYXJ5XG4gIHZhciBpbnB1dFN0cmVhbSA9IG5ldyBTdHJlYW0oKTtcbiAgaW5wdXRTdHJlYW0uZGVsZWdhdGUgPSBVdGlsLmNvZXJjZUlucHV0U3RyZWFtKGlucHV0KTtcbiAgaW5wdXRTdHJlYW0ucG9zID0gMDtcbiAgaW5wdXRTdHJlYW0ucmVhZEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBvcysrO1xuICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlYWRCeXRlKCk7XG4gIH07XG4gIGlucHV0U3RyZWFtLnRlbGwgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucG9zOyB9O1xuICBpZiAoaW5wdXRTdHJlYW0uZGVsZWdhdGUuZW9mKSB7XG4gICAgaW5wdXRTdHJlYW0uZW9mID0gaW5wdXRTdHJlYW0uZGVsZWdhdGUuZW9mLmJpbmQoaW5wdXRTdHJlYW0uZGVsZWdhdGUpO1xuICB9XG4gIHZhciBvdXRwdXRTdHJlYW0gPSBuZXcgU3RyZWFtKCk7XG4gIG91dHB1dFN0cmVhbS5wb3MgPSAwO1xuICBvdXRwdXRTdHJlYW0ud3JpdGVCeXRlID0gZnVuY3Rpb24oKSB7IHRoaXMucG9zKys7IH07XG5cbiAgdmFyIGJ6ID0gbmV3IEJ1bnppcChpbnB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtKTtcbiAgdmFyIGJsb2NrU2l6ZSA9IGJ6LmRidWZTaXplO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICgnZW9mJyBpbiBpbnB1dFN0cmVhbSAmJiBpbnB1dFN0cmVhbS5lb2YoKSkgYnJlYWs7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBiei5yZWFkZXIudGVsbEJpdCgpO1xuXG4gICAgaWYgKGJ6Ll9pbml0X2Jsb2NrKCkpIHtcbiAgICAgIHZhciBzdGFydCA9IG91dHB1dFN0cmVhbS5wb3M7XG4gICAgICBiei5fcmVhZF9idW56aXAoKTtcbiAgICAgIGNhbGxiYWNrKHBvc2l0aW9uLCBvdXRwdXRTdHJlYW0ucG9zIC0gc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3JjID0gYnoucmVhZGVyLnJlYWRCaXRzKDMyKTsgLy8gKGJ1dCB3ZSBpZ25vcmUgdGhlIGNyYylcbiAgICAgIGlmIChtdWx0aXN0cmVhbSAmJlxuICAgICAgICAgICdlb2YnIGluIGlucHV0U3RyZWFtICYmXG4gICAgICAgICAgIWlucHV0U3RyZWFtLmVvZigpKSB7XG4gICAgICAgIC8vIG5vdGUgdGhhdCBzdGFydF9idW56aXAgd2lsbCBhbHNvIHJlc3luYyB0aGUgYml0IHJlYWRlciB0byBuZXh0IGJ5dGVcbiAgICAgICAgYnouX3N0YXJ0X2J1bnppcChpbnB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoYnouZGJ1ZlNpemUgPT09IGJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgXCJzaG91bGRuJ3QgY2hhbmdlIGJsb2NrIHNpemUgd2l0aGluIG11bHRpc3RyZWFtIGZpbGVcIik7XG4gICAgICB9IGVsc2UgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjcmVhdGUgYSBIdWZmbWFuIHRyZWUgZnJvbSB0aGUgdGFibGUgb2YgZnJlcXVlbmNpZXNcbnZhciBTdGF0aWNIdWZmbWFuID0gZnVuY3Rpb24oZnJlcSwgYWxwaGFiZXRTaXplKSB7XG4gIC8vIEFzIGluIEJaaXAySHVmZm1hblN0YWdlRW5jb2Rlci5qYXZhIChmcm9tIGpiemlwMik6XG4gIC8vIFRoZSBIdWZmbWFuIGFsbG9jYXRvciBuZWVkcyBpdHMgaW5wdXQgc3ltYm9sIGZyZXF1ZW5jaWVzIHRvIGJlXG4gIC8vIHNvcnRlZCwgYnV0IHdlIG5lZWQgdG8gcmV0dXJuIGNvZGUgbGVuZ3RocyBpbiB0aGUgc2FtZSBvcmRlciBhc1xuICAvLyB0aGUgY29ycmVzcG9uZGluZyBmcmVxdWVuY2llcyBhcmUgcGFzc2VkIGluLlxuICAvLyBUaGUgc3ltYm9sIGZyZXF1ZW5jeSBhbmQgaW5kZXggYXJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIGFycmF5IG9mXG4gIC8vIGludGVnZXJzIC0gZnJlcXVlbmN5IGluIHRoZSBoaWdoIDIzIGJpdHMsIGluZGV4IGluIHRoZSBsb3cgOVxuICAvLyBiaXRzLlxuICAvLyAgICAgMl4yMyA9IDgsMzg4LDYwOCB3aGljaCBpcyBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZVxuICAvLyAgICAgICAgICAgIGZyZXF1ZW5jeSBmb3Igb25lIHN5bWJvbCBpbiBhIGJsb2NrXG4gIC8vICAgICAyXjkgPSA1MTIgd2hpY2ggaXMgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGVcbiAgLy8gICAgICAgICAgICBhbHBoYWJldCBzaXplICg9PSAyNTgpXG4gIC8vIFNvcnRpbmcgdGhpcyBhcnJheSBzaW11bHRhbmVvdXNseSBzb3J0cyB0aGUgZnJlcXVlbmNpZXMgYW5kXG4gIC8vIGxlYXZlcyBhIGxvb2t1cCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWFwbHkgaW52ZXJ0IHRoZSBzb3J0XG4gIHZhciBpLCBtZXJnZWRGcmVxID0gW107XG4gIGZvciAoaT0wOyBpPGFscGhhYmV0U2l6ZTsgaSsrKSB7XG4gICAgbWVyZ2VkRnJlcVtpXSA9IChmcmVxW2ldIDw8IDkpIHwgaTtcbiAgfVxuICBtZXJnZWRGcmVxLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhLWI7IH0pO1xuICB2YXIgc29ydGVkRnJlcSA9IG1lcmdlZEZyZXEubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHY+Pj45OyB9KTtcbiAgLy8gYWxsb2NhdGUgY29kZSBsZW5ndGhzIGluIHBsYWNlLiAocmVzdWx0IGluIHNvcnRlZEZyZXEgYXJyYXkpXG4gIEh1ZmZtYW5BbGxvY2F0b3IuYWxsb2NhdGVIdWZmbWFuQ29kZUxlbmd0aHMoc29ydGVkRnJlcSwgTUFYX0hVRkNPREVfQklUUyk7XG4gIC8vIHJldmVyc2UgdGhlIHNvcnQgdG8gcHV0IGNvZGVzICYgY29kZSBsZW5ndGhzIGluIG9yZGVyIG9mIGlucHV0IHN5bWJvbHNcbiAgdGhpcy5jb2RlTGVuZ3RocyA9IFV0aWwubWFrZVU4QnVmZmVyKGFscGhhYmV0U2l6ZSk7XG4gIGZvciAoaT0wOyBpPGFscGhhYmV0U2l6ZTsgaSsrKSB7XG4gICAgdmFyIHN5bSA9IG1lcmdlZEZyZXFbaV0gJiAweDFGRjtcbiAgICB0aGlzLmNvZGVMZW5ndGhzW3N5bV0gPSBzb3J0ZWRGcmVxW2ldO1xuICB9XG59O1xuLy8gY29tcHV0ZSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlcywgZ2l2ZW4gY29kZSBsZW5ndGhzXG5TdGF0aWNIdWZmbWFuLnByb3RvdHlwZS5jb21wdXRlQ2Fub25pY2FsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbHBoYWJldFNpemUgPSB0aGlzLmNvZGVMZW5ndGhzLmxlbmd0aDtcbiAgLy8gbWVyZ2UgYXJyYXlzOyBzb3J0IGZpcnN0IGJ5IGxlbmd0aCB0aGVuIGJ5IHN5bWJvbC5cbiAgdmFyIGksIG1lcmdlZCA9IFtdO1xuICBmb3IgKGk9MDsgaTxhbHBoYWJldFNpemU7IGkrKykge1xuICAgIG1lcmdlZFtpXSA9ICh0aGlzLmNvZGVMZW5ndGhzW2ldIDw8IDkpIHwgaTtcbiAgfVxuICBtZXJnZWQuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEtYjsgfSk7XG4gIC8vIHVzZSBzb3J0ZWQgbGVuZ3RocyB0byBhc3NpZ24gY29kZXNcbiAgdGhpcy5jb2RlID0gVXRpbC5tYWtlVTMyQnVmZmVyKGFscGhhYmV0U2l6ZSk7XG4gIHZhciBjb2RlID0gMCwgcHJldkxlbiA9IDA7XG4gIGZvciAoaT0wOyBpPGFscGhhYmV0U2l6ZTsgaSsrKSB7XG4gICAgdmFyIGN1ckxlbiA9IG1lcmdlZFtpXSA+Pj4gOTtcbiAgICB2YXIgc3ltID0gbWVyZ2VkW2ldICYgMHgxRkY7XG4gICAgY29uc29sZS5hc3NlcnQocHJldkxlbiA8PSBjdXJMZW4pO1xuICAgIGNvZGUgPDw9IChjdXJMZW4gLSBwcmV2TGVuKTtcbiAgICB0aGlzLmNvZGVbc3ltXSA9IGNvZGUrKztcbiAgICBwcmV2TGVuID0gY3VyTGVuO1xuICB9XG59O1xuLy8gY29tcHV0ZSB0aGUgY29zdCBvZiBlbmNvZGluZyB0aGUgZ2l2ZW4gcmFuZ2Ugb2Ygc3ltYm9scyB3LyB0aGlzIEh1ZmZtYW4gY29kZVxuU3RhdGljSHVmZm1hbi5wcm90b3R5cGUuY29zdCA9IGZ1bmN0aW9uKGFycmF5LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgaSwgY29zdCA9IDA7XG4gIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgY29zdCArPSB0aGlzLmNvZGVMZW5ndGhzW2FycmF5W29mZnNldCtpXV07XG4gIH1cbiAgcmV0dXJuIGNvc3Q7XG59O1xuLy8gZW1pdCB0aGUgYml0IGxlbmd0aHMgdXNlZCBieSB0aGlzIEh1ZmZtYW4gY29kZVxuU3RhdGljSHVmZm1hbi5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKG91dFN0cmVhbSkge1xuICAvLyB3cml0ZSB0aGUgc3RhcnRpbmcgbGVuZ3RoXG4gIHZhciBpLCBjdXJyZW50TGVuZ3RoID0gdGhpcy5jb2RlTGVuZ3Roc1swXTtcbiAgb3V0U3RyZWFtLndyaXRlQml0cyg1LCBjdXJyZW50TGVuZ3RoKTtcbiAgZm9yIChpPTA7IGk8dGhpcy5jb2RlTGVuZ3Rocy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlTGVuZ3RoID0gdGhpcy5jb2RlTGVuZ3Roc1tpXTtcbiAgICB2YXIgdmFsdWUsIGRlbHRhO1xuICAgIGNvbnNvbGUuYXNzZXJ0KGNvZGVMZW5ndGggPiAwICYmIGNvZGVMZW5ndGggPD0gTUFYX0hVRkNPREVfQklUUyk7XG4gICAgaWYgKGN1cnJlbnRMZW5ndGggPCBjb2RlTGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IDI7IGRlbHRhID0gY29kZUxlbmd0aCAtIGN1cnJlbnRMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gMzsgZGVsdGEgPSBjdXJyZW50TGVuZ3RoIC0gY29kZUxlbmd0aDtcbiAgICB9XG4gICAgd2hpbGUgKGRlbHRhLS0gPiAwKSB7XG4gICAgICBvdXRTdHJlYW0ud3JpdGVCaXRzKDIsIHZhbHVlKTtcbiAgICB9XG4gICAgb3V0U3RyZWFtLndyaXRlQml0KDApO1xuICAgIGN1cnJlbnRMZW5ndGggPSBjb2RlTGVuZ3RoO1xuICB9XG59O1xuLy8gZW5jb2RlIHRoZSBnaXZlbiBzeW1ib2wgd2l0aCB0aGlzIEh1ZmZtYW4gY29kZVxuU3RhdGljSHVmZm1hbi5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob3V0U3RyZWFtLCBzeW1ib2wpIHtcbiAgb3V0U3RyZWFtLndyaXRlQml0cyh0aGlzLmNvZGVMZW5ndGhzW3N5bWJvbF0sIHRoaXMuY29kZVtzeW1ib2xdKTtcbn07XG5cbi8vIHJlYWQgYSBibG9jayBmb3IgYnppcDIgY29tcHJlc3Npb24uXG52YXIgcmVhZEJsb2NrID0gZnVuY3Rpb24oaW5TdHJlYW0sIGJsb2NrLCBsZW5ndGgsIGNyYykge1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGxhc3RDaGFyID0gLTE7XG4gIHZhciBydW5MZW5ndGggPSAwO1xuICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgaWYgKHJ1bkxlbmd0aD09PTQpIHtcbiAgICAgIGJsb2NrW3BvcysrXSA9IDA7XG4gICAgICBpZiAocG9zID49IGxlbmd0aCkgeyBicmVhazsgfVxuICAgIH1cbiAgICB2YXIgY2ggPSBpblN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIGlmIChjaCA9PT0gRU9GKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY3JjLnVwZGF0ZUNSQyhjaCk7XG4gICAgaWYgKGNoICE9PSBsYXN0Q2hhcikge1xuICAgICAgbGFzdENoYXIgPSBjaDtcbiAgICAgIHJ1bkxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bkxlbmd0aCsrO1xuICAgICAgaWYgKHJ1bkxlbmd0aCA+IDQpIHtcbiAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IDI1Nikge1xuICAgICAgICAgIGJsb2NrW3Bvcy0xXSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bkxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tbcG9zKytdID0gY2g7XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGRpdmlkZSB0aGUgaW5wdXQgaW50byBncm91cHMgYXQgbW9zdCBHUk9VUF9TSVpFIHN5bWJvbHMgbG9uZy5cbi8vIGFzc2lnbiBlYWNoIGdyb3VwIHRvIHRoZSBIdWZmbWFuIHRhYmxlIHdoaWNoIGNvbXByZXNzZXMgaXQgYmVzdC5cbnZhciBhc3NpZ25TZWxlY3RvcnMgPSBmdW5jdGlvbihzZWxlY3RvcnMsIGdyb3VwcywgaW5wdXQpIHtcbiAgdmFyIGksIGosIGs7XG4gIGZvciAoaT0wLCBrPTA7IGk8aW5wdXQubGVuZ3RoOyBpKz1HUk9VUF9TSVpFKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IE1hdGgubWluKEdST1VQX1NJWkUsIGlucHV0Lmxlbmd0aCAtIGkpO1xuICAgIHZhciBiZXN0ID0gMCwgYmVzdENvc3QgPSBncm91cHNbMF0uY29zdChpbnB1dCwgaSwgZ3JvdXBTaXplKTtcbiAgICBmb3IgKGo9MTsgajxncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBncm91cENvc3QgPSBncm91cHNbal0uY29zdChpbnB1dCwgaSwgZ3JvdXBTaXplKTtcbiAgICAgIGlmIChncm91cENvc3QgPCBiZXN0Q29zdCkge1xuICAgICAgICBiZXN0ID0gajsgYmVzdENvc3QgPSBncm91cENvc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdG9yc1trKytdID0gYmVzdDtcbiAgfVxufTtcbnZhciBvcHRpbWl6ZUh1ZmZtYW5Hcm91cHMgPSBmdW5jdGlvbihncm91cHMsIHRhcmdldEdyb3VwcywgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLCBhbHBoYWJldFNpemUpIHtcbiAgLy8gdW50aWwgd2UndmUgZ290IFwidGFyZ2V0R3JvdXBzXCIgSHVmZm1hbiBjb2RlcywgcGljayB0aGUgSHVmZm1hbiBjb2RlIHdoaWNoXG4gIC8vIG1hdGNoZXMgdGhlIGxhcmdlc3QgIyBvZiBncm91cHMgYW5kIHNwbGl0IGl0IGJ5IHBpY2tpbmcgdGhlIGdyb3Vwc1xuICAvLyB3aGljaCByZXF1aXJlIG1vcmUgdGhhbiB0aGUgbWVkaWFuIG51bWJlciBvZiBiaXRzIHRvIGVuY29kZS5cbiAgLy8gdGhlbiByZWNvbXB1dGUgZnJlcXVlbmNpZXMgYW5kIHJlYXNzaWduIEh1ZmZtYW4gY29kZXMuXG4gIHZhciBpLCBqLCBrLCBncm91cENvdW50cyA9IFtdO1xuICB3aGlsZSAoZ3JvdXBzLmxlbmd0aCA8IHRhcmdldEdyb3Vwcykge1xuICAgIGFzc2lnblNlbGVjdG9ycyhzZWxlY3RvcnMsIGdyb3VwcywgaW5wdXQpO1xuICAgIC8vIHdoaWNoIGNvZGUgZ2V0cyB1c2VkIHRoZSBtb3N0P1xuICAgIGZvciAoaT0wOyBpPGdyb3Vwcy5sZW5ndGg7IGkrKykgeyBncm91cENvdW50c1tpXSA9IDA7IH1cbiAgICBmb3IgKGk9MDsgaTxzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyb3VwQ291bnRzW3NlbGVjdG9yc1tpXV0rKztcbiAgICB9XG4gICAgdmFyIHdoaWNoID0gZ3JvdXBDb3VudHMuaW5kZXhPZihNYXRoLm1heC5hcHBseShNYXRoLCBncm91cENvdW50cykpO1xuICAgIC8vIG9rLCBsZXQncyBsb29rIGF0IHRoZSBzaXplIG9mIHRob3NlIGJsb2Nrc1xuICAgIHZhciBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGk9MCwgaj0wOyBpPHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNlbGVjdG9yc1tpXSAhPT0gd2hpY2gpIHsgY29udGludWU7IH1cbiAgICAgIHZhciBzdGFydCA9IGkqR1JPVVBfU0laRTtcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihzdGFydCArIEdST1VQX1NJWkUsIGlucHV0Lmxlbmd0aCk7XG4gICAgICBzcGxpdHMucHVzaCh7aW5kZXg6IGksIGNvc3Q6Z3JvdXBzW3doaWNoXS5jb3N0KGlucHV0LCBzdGFydCwgZW5kLXN0YXJ0KX0pO1xuICAgIH1cbiAgICAvLyBmaW5kIHRoZSBtZWRpYW4uICB0aGVyZSBhcmUgTyhuKSBhbGdvcml0aG1zIHRvIGRvIHRoaXMsIGJ1dCB3ZSdsbFxuICAgIC8vIGJlIGxhenkgYW5kIHVzZSBhIGZ1bGwgTyhuIGxuIG4pIHNvcnQuXG4gICAgc3BsaXRzLnNvcnQoZnVuY3Rpb24oczEsIHMyKSB7IHJldHVybiBzMS5jb3N0IC0gczIuY29zdDsgfSk7XG4gICAgLy8gYXNzaWduIHRoZSBncm91cHMgaW4gdGhlIHRvcCBoYWxmIHRvIHRoZSBcIm5ld1wiIHNlbGVjdG9yXG4gICAgZm9yIChpPShzcGxpdHMubGVuZ3RoPj4+MSk7IGk8c3BsaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RvcnNbc3BsaXRzW2ldLmluZGV4XSA9IGdyb3Vwcy5sZW5ndGg7XG4gICAgfVxuICAgIGdyb3Vwcy5wdXNoKG51bGwpO1xuICAgIC8vIHJlY29tcHV0ZSBmcmVxdWVuY2llc1xuICAgIHZhciBmcmVxID0gW10sIGY7XG4gICAgZm9yIChpPTA7IGk8Z3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmID0gZnJlcVtpXSA9IFtdO1xuICAgICAgZm9yIChqPTA7IGo8YWxwaGFiZXRTaXplOyBqKyspIHsgZltqXSA9IDA7IH1cbiAgICB9XG4gICAgZm9yIChpPTAsIGo9MDsgaTxpbnB1dC5sZW5ndGg7ICkge1xuICAgICAgZiA9IGZyZXFbc2VsZWN0b3JzW2orK11dO1xuICAgICAgZm9yIChrPTA7IGs8R1JPVVBfU0laRSAmJiBpPGlucHV0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGZbaW5wdXRbaSsrXV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVjb25zdHJ1Y3QgSHVmZm1hbiBjb2Rlc1xuICAgIGZvciAoaT0wOyBpPGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXBzW2ldID0gbmV3IFN0YXRpY0h1ZmZtYW4oZnJlcVtpXSwgYWxwaGFiZXRTaXplKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb21wcmVzc0Jsb2NrID0gZnVuY3Rpb24oYmxvY2ssIGxlbmd0aCwgb3V0U3RyZWFtKSB7XG4gIHZhciBjLCBpLCBqLCBrO1xuICAvLyBkbyBCV1QgdHJhbnNmb3JtXG4gIHZhciBVID0gVXRpbC5tYWtlVThCdWZmZXIobGVuZ3RoKTtcbiAgdmFyIHBpZHggPSBCV1QuYnd0cmFuc2Zvcm0yKGJsb2NrLCBVLCBsZW5ndGgsIDI1Nik7XG4gIG91dFN0cmVhbS53cml0ZUJpdCgwKTsgLy8gbm90IHJhbmRvbWl6ZWRcbiAgb3V0U3RyZWFtLndyaXRlQml0cygyNCwgcGlkeCk7XG4gIC8vIHRyYWNrIHZhbHVlcyB1c2VkOyB3cml0ZSBiaXRtYXBcbiAgdmFyIHVzZWQgPSBbXSwgY29tcGFjdCA9IFtdO1xuICBmb3IgKGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICAgIGMgPSBibG9ja1tpXTtcbiAgICB1c2VkW2NdID0gdHJ1ZTtcbiAgICBjb21wYWN0W2M+Pj40XSA9IHRydWU7XG4gIH1cbiAgZm9yIChpPTA7IGk8MTY7IGkrKykge1xuICAgIG91dFN0cmVhbS53cml0ZUJpdCghIWNvbXBhY3RbaV0pO1xuICB9XG4gIGZvciAoaT0wOyBpPDE2OyBpKyspIHtcbiAgICBpZiAoY29tcGFjdFtpXSkge1xuICAgICAgZm9yIChqPTA7IGo8MTY7IGorKykge1xuICAgICAgICBvdXRTdHJlYW0ud3JpdGVCaXQoISF1c2VkWyhpPDw0KXxqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBhbHBoYWJldFNpemUgPSAwO1xuICBmb3IgKGk9MDsgaTwyNTY7IGkrKykge1xuICAgIGlmICh1c2VkW2ldKSB7XG4gICAgICBhbHBoYWJldFNpemUrKztcbiAgICB9XG4gIH1cbiAgLy8gbm93IE1URiBhbmQgUkxFLzIgZW5jb2RpbmcsIHdoaWxlIHRyYWNraW5nIHN5bWJvbCBzdGF0aXN0aWNzLlxuICAvLyBvdXRwdXQgY2FuIGJlIG9uZSBsb25nZXIgdGhhbiBsZW5ndGgsIGJlY2F1c2Ugd2UgaW5jbHVkZSB0aGVcbiAgLy8gZW5kLW9mLWJsb2NrIGNoYXJhY3RlciBhdCB0aGUgZW5kLiBTaW1pbGFybHksIHdlIG5lZWQgYSBVMTZcbiAgLy8gYXJyYXkgYmVjYXVzZSB0aGUgZW5kLW9mLWJsb2NrIGNoYXJhY3RlciBjYW4gYmUgMjU2LlxuICB2YXIgQSA9IFV0aWwubWFrZVUxNkJ1ZmZlcihsZW5ndGgrMSk7XG4gIHZhciBlbmRPZkJsb2NrID0gYWxwaGFiZXRTaXplICsgMTtcbiAgdmFyIGZyZXEgPSBbXTtcbiAgZm9yIChpPTA7IGk8PWVuZE9mQmxvY2s7IGkrKykgeyBmcmVxW2ldID0gMDsgfVxuICB2YXIgTSA9IFV0aWwubWFrZVU4QnVmZmVyKGFscGhhYmV0U2l6ZSk7XG4gIGZvciAoaT0wLCBqPTA7IGk8MjU2OyBpKyspIHtcbiAgICBpZiAodXNlZFtpXSkgeyBNW2orK10gPSBpOyB9XG4gIH1cbiAgdXNlZCA9IG51bGw7IGNvbXBhY3QgPSBudWxsO1xuICB2YXIgcG9zID0gMCwgcnVuTGVuZ3RoID0gMDtcbiAgdmFyIGVtaXQgPSBmdW5jdGlvbihjKSB7XG4gICAgQVtwb3MrK10gPSBjO1xuICAgIGZyZXFbY10rKztcbiAgfTtcbiAgdmFyIGVtaXRMYXN0UnVuID0gZnVuY3Rpb24oKSB7XG4gICAgd2hpbGUgKHJ1bkxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKHJ1bkxlbmd0aCAmIDEpIHtcbiAgICAgICAgZW1pdCgwKTsgLy8gUlVOQVxuICAgICAgICBydW5MZW5ndGggLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXQoMSk7IC8vIFJVTkJcbiAgICAgICAgcnVuTGVuZ3RoIC09IDI7XG4gICAgICB9XG4gICAgICBydW5MZW5ndGggPj4+PSAxO1xuICAgIH1cbiAgfTtcbiAgZm9yIChpPTA7IGk8VS5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBVW2ldO1xuICAgIC8vIGxvb2sgZm9yIEMgaW4gTVxuICAgIGZvciAoaj0wOyBqPGFscGhhYmV0U2l6ZTsgaisrKSB7XG4gICAgICBpZiAoTVtqXT09PWMpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgY29uc29sZS5hc3NlcnQoaiE9PWFscGhhYmV0U2l6ZSk7XG4gICAgLy8gc2hpZnQgTVRGIGFycmF5XG4gICAgbXRmKE0sIGopO1xuICAgIC8vIGVtaXQgalxuICAgIGlmIChqPT09MCkge1xuICAgICAgcnVuTGVuZ3RoKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRMYXN0UnVuKCk7XG4gICAgICBlbWl0KGorMSk7XG4gICAgICBydW5MZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICBlbWl0TGFzdFJ1bigpO1xuICBlbWl0KGVuZE9mQmxvY2spOyAvLyBlbmQgb2YgYmxvY2sgc3ltYm9sXG4gIEEgPSBBLnN1YmFycmF5KDAsIHBvcyk7XG4gIC8vIG5vdyBBWzAuLi5wb3MpIGhhcyB0aGUgZW5jb2RlZCBvdXRwdXQsIGFuZCBmcmVxWzAtYWxwaGFiZXRTaXplXSBoYXMgdGhlXG4gIC8vIGZyZXF1ZW5jaWVzLiAgVXNlIHRoZXNlIHRvIGNvbnN0cnVjdCBIdWZmbWFuIHRhYmxlcy5cbiAgLy8gdGhlIGNhbm9uaWNhbCBiemlwMiBlbmNvZGVyIGRvZXMgc29tZSBjb21wbGljYXRlZCBvcHRpbWl6YXRpb25cbiAgLy8gdG8gYXR0ZW1wdCB0byBzZWxlY3QgdGhlIGJlc3QgdGFibGVzLiAgV2UncmUgZ29pbmcgdG8gc2ltcGxpZnkgdGhpbmdzOlxuICAvLyAodW5sZXNzIHRoZSBibG9jayBpcyB2ZXJ5IHNob3J0KSB3ZSdyZSBhbHdheXMgZ29pbmcgdG8gY3JlYXRlIE1BWF9HUk9VUFNcbiAgLy8gdGFibGVzOyAxIGJhc2VkIG9uIGdsb2JhbCBmcmVxdWVuY2llcywgYW5kIHRoZSByZXN0IGJhc2VkIG9uIGRpdmlkaW5nIHRoZVxuICAvLyBibG9jayBpbnRvIE1BWF9HUk9VUFMtMSBwaWVjZXMuXG4gIHZhciBncm91cHMgPSBbXTtcbiAgdmFyIHRhcmdldEdyb3VwczsgLy8gaG93IG1hbnkgSHVmZm1hbiBncm91cHMgc2hvdWxkIHdlIGNyZWF0ZT9cbiAgLy8gbG9vayBhdCBsZW5ndGggb2YgTVRGLWVuY29kZWQgYmxvY2sgdG8gcGljayBhIGdvb2QgbnVtYmVyIG9mIGdyb3Vwc1xuICBpZiAocG9zID49IDI0MDApIHsgdGFyZ2V0R3JvdXBzID0gNjsgfVxuICBlbHNlIGlmIChwb3MgPj0gMTIwMCkgeyB0YXJnZXRHcm91cHMgPSA1OyB9XG4gIGVsc2UgaWYgKHBvcyA+PSA2MDApIHsgdGFyZ2V0R3JvdXBzID0gNDsgfVxuICBlbHNlIGlmIChwb3MgPj0gMjAwKSB7IHRhcmdldEdyb3VwcyA9IDM7IH1cbiAgZWxzZSB7IHRhcmdldEdyb3VwcyA9IDI7IH1cbiAgLy8gc3RhcnQgd2l0aCB0d28gSHVmZm1hbiBncm91cHM6IG9uZSB3aXRoIHRoZSBnbG9iYWwgZnJlcXVlbmNpZXMsIGFuZFxuICAvLyBhIHNlY29uZCB3aXRoIGEgZmxhdCBmcmVxdWVuY3kgZGlzdHJpYnV0aW9uICh3aGljaCBpcyBhbHNvIHRoZSBzbWFsbGVzdFxuICAvLyBwb3NzaWJsZSBIdWZmbWFuIHRhYmxlIHRvIGVuY29kZSwgd2hpY2ggaXMgaGFuZHkgdG8gcHJldmVudCBleGNlc3NpdmVcbiAgLy8gYmxvYXQgaWYgdGhlIGlucHV0IGZpbGUgc2l6ZSBpcyB2ZXJ5IHNtYWxsKVxuICBncm91cHMucHVzaChuZXcgU3RhdGljSHVmZm1hbihmcmVxLCBlbmRPZkJsb2NrKzEpKTtcbiAgZm9yIChpPTA7IGk8PWVuZE9mQmxvY2s7IGkrKykgeyBmcmVxW2ldID0gMTsgfVxuICBncm91cHMucHVzaChuZXcgU3RhdGljSHVmZm1hbihmcmVxLCBlbmRPZkJsb2NrKzEpKTtcbiAgZnJlcSA9IG51bGw7XG4gIC8vIE5vdyBvcHRpbWl6ZSB0aGUgSHVmZm1hbiBncm91cHMhICB0aGlzIGlzIGEgYmxhY2sgYXJ0LlxuICAvLyB3ZSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHdhc3RlIHRvbyBtdWNoIHRpbWUgb24gaXQsIHRob3VnaC5cbiAgdmFyIHNlbGVjdG9ycyA9IFV0aWwubWFrZVU4QnVmZmVyKE1hdGguY2VpbChwb3MgLyBHUk9VUF9TSVpFKSk7XG4gIG9wdGltaXplSHVmZm1hbkdyb3Vwcyhncm91cHMsIHRhcmdldEdyb3VwcywgQSwgc2VsZWN0b3JzLCBlbmRPZkJsb2NrKzEpO1xuICBhc3NpZ25TZWxlY3RvcnMoc2VsZWN0b3JzLCBncm91cHMsIEEpO1xuXG4gIC8vIG9rYXksIGxldCdzIHN0YXJ0IHdyaXRpbmcgb3V0IG91ciBIdWZmbWFuIHRhYmxlc1xuICBjb25zb2xlLmFzc2VydChncm91cHMubGVuZ3RoID49IE1JTl9HUk9VUFMgJiYgZ3JvdXBzLmxlbmd0aCA8PSBNQVhfR1JPVVBTKTtcbiAgb3V0U3RyZWFtLndyaXRlQml0cygzLCBncm91cHMubGVuZ3RoKTtcbiAgLy8gYW5kIHdyaXRlIG91dCB0aGUgYmVzdCBzZWxlY3RvciBmb3IgZWFjaCBncm91cFxuICBvdXRTdHJlYW0ud3JpdGVCaXRzKDE1LCBzZWxlY3RvcnMubGVuZ3RoKTtcbiAgZm9yIChpPTA7IGk8Z3JvdXBzLmxlbmd0aDsgaSsrKSB7IE1baV0gPSBpOyB9IC8vIGluaXRpYWxpemUgTVRGIHRhYmxlLlxuICBmb3IgKGk9MDsgaTxzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IHNlbGVjdG9yc1tpXTtcbiAgICAvLyBmaW5kIHNlbGVjdG9yIGluIE1URiBsaXN0XG4gICAgZm9yIChqPTA7IGo8Z3JvdXBzLmxlbmd0aDsgaisrKSB7IGlmIChNW2pdPT09cykgeyBicmVhazsgfSB9XG4gICAgY29uc29sZS5hc3NlcnQoajxncm91cHMubGVuZ3RoKTtcbiAgICBtdGYoTSwgaik7XG4gICAgLy8gZW1pdCAnaicgYXMgYSB1bmFyeSBudW1iZXJcbiAgICBmb3IgKDtqPjA7IGotLSkge1xuICAgICAgb3V0U3RyZWFtLndyaXRlQml0KDEpO1xuICAgIH1cbiAgICBvdXRTdHJlYW0ud3JpdGVCaXQoMCk7XG4gIH1cbiAgLy8gb2theSwgbm93IGVtaXQgdGhlIEh1ZmZtYW4gdGFibGVzIGluIG9yZGVyLlxuICBmb3IgKGk9MDsgaTxncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICBncm91cHNbaV0uZW1pdChvdXRTdHJlYW0pO1xuICAgIGdyb3Vwc1tpXS5jb21wdXRlQ2Fub25pY2FsKCk7IC8vIGdldCByZWFkeSBmb3IgbmV4dCBzdGVwIHdoaWxlIHdlJ3JlIGF0IGl0XG4gIH1cbiAgLy8gb2theSwgbm93IChmaW5hbGx5ISkgZW1pdCB0aGUgYWN0dWFsIGRhdGEhXG4gIGZvciAoaT0wLCBrPTA7IGk8cG9zOyApIHtcbiAgICB2YXIgaHVmZiA9IGdyb3Vwc1tzZWxlY3RvcnNbaysrXV07XG4gICAgZm9yIChqPTA7IGo8R1JPVVBfU0laRSAmJiBpPHBvczsgaisrKSB7XG4gICAgICBodWZmLmVuY29kZShvdXRTdHJlYW0sIEFbaSsrXSk7XG4gICAgfVxuICB9XG4gIC8vIGRvbmUuXG59O1xuXG52YXIgQnppcDIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuQnppcDIuY29tcHJlc3NGaWxlID0gZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgcHJvcHMpIHtcbiAgaW5TdHJlYW0gPSBVdGlsLmNvZXJjZUlucHV0U3RyZWFtKGluU3RyZWFtKTtcbiAgdmFyIG8gPSBVdGlsLmNvZXJjZU91dHB1dFN0cmVhbShvdXRTdHJlYW0sIG91dFN0cmVhbSk7XG4gIG91dFN0cmVhbSA9IG5ldyBCaXRTdHJlYW0oby5zdHJlYW0pO1xuXG4gIHZhciBibG9ja1NpemVNdWx0aXBsaWVyID0gOTtcbiAgaWYgKHR5cGVvZihwcm9wcyk9PT0nbnVtYmVyJykge1xuICAgIGJsb2NrU2l6ZU11bHRpcGxpZXIgPSBwcm9wcztcbiAgfVxuICBpZiAoYmxvY2tTaXplTXVsdGlwbGllciA8IDEgfHwgYmxvY2tTaXplTXVsdGlwbGllciA+IDkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvY2sgc2l6ZSBtdWx0aXBsaWVyJyk7XG4gIH1cblxuICB2YXIgYmxvY2tTaXplID0gYmxvY2tTaXplTXVsdGlwbGllciAqIDEwMDAwMDtcbiAgLy8gdGhlIEMgaW1wbGVtZW50YXRpb24gYWx3YXlzIHdyaXRlcyBhdCBsZWFzdCBsZW5ndGgtMTkgY2hhcmFjdGVycyxcbiAgLy8gYnV0IGl0IHJlYWRzIGFoZWFkIGVub3VnaCB0aGF0IGlmIHRoZSBsYXN0IGNoYXJhY3RlciB3cml0dGVuIHdhcyBwYXJ0XG4gIC8vIG9mIGEgcnVuLCBpdCB3cml0ZXMgb3V0IHRoZSBmdWxsIHJ1bi5cbiAgLy8gVGhhdCdzIHJlYWxseSBhbm5veWluZyB0byBpbXBsZW1lbnQuXG4gIC8vIFNvIGluc3RlYWQganVzdCBzdWJ0cmFjdCAxOSBmcm9tIHRoZSBibG9ja1NpemU7IGluIG1vc3QgY2FzZXMgKHVubGVzc1xuICAvLyB0aGVyZSdzIGEgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGJsb2NrKSB0aGlzIHdpbGwgeWllbGQgYmxvY2sgZGl2aXNpb25zXG4gIC8vIG1hdGNoaW5nIHRoZSBDIGltcGxlbWVudGF0aW9uLlxuICBibG9ja1NpemUgLT0gMTk7XG5cbiAgLy8gd3JpdGUgZmlsZSBtYWdpY1xuICBvdXRTdHJlYW0ud3JpdGVCeXRlKCdCJy5jaGFyQ29kZUF0KDApKTtcbiAgb3V0U3RyZWFtLndyaXRlQnl0ZSgnWicuY2hhckNvZGVBdCgwKSk7XG4gIG91dFN0cmVhbS53cml0ZUJ5dGUoJ2gnLmNoYXJDb2RlQXQoMCkpOyAvLyBIdWZmbWFuLWNvZGVkIGJ6aXBcbiAgb3V0U3RyZWFtLndyaXRlQnl0ZSgnMCcuY2hhckNvZGVBdCgwKSArIGJsb2NrU2l6ZU11bHRpcGxpZXIpO1xuXG4gIC8vIGFsbG9jYXRlIGEgYnVmZmVyIGZvciB0aGUgYmxvY2tcbiAgdmFyIGJsb2NrID0gVXRpbC5tYWtlVThCdWZmZXIoYmxvY2tTaXplKTtcbiAgdmFyIHN0cmVhbUNSQyA9IDA7XG4gIHZhciBsZW5ndGg7XG5cbiAgZG8ge1xuICAgIHZhciBjcmMgPSBuZXcgQ1JDMzIoKTtcbiAgICBsZW5ndGggPSByZWFkQmxvY2soaW5TdHJlYW0sIGJsb2NrLCBibG9ja1NpemUsIGNyYyk7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHN0cmVhbUNSQyA9ICgoKHN0cmVhbUNSQyA8PCAxKSB8IChzdHJlYW1DUkM+Pj4zMSkpIF4gY3JjLmdldENSQygpKSA+Pj4gMDtcbiAgICAgIG91dFN0cmVhbS53cml0ZUJpdHMoNDgsIFdIT0xFUEkpO1xuICAgICAgb3V0U3RyZWFtLndyaXRlQml0cygzMiwgY3JjLmdldENSQygpKTtcbiAgICAgIGNvbXByZXNzQmxvY2soYmxvY2ssIGxlbmd0aCwgb3V0U3RyZWFtKTtcbiAgICB9XG4gIH0gd2hpbGUgKGxlbmd0aCA9PT0gYmxvY2tTaXplKTtcblxuICAvLyBmaW5pc2ggdXBcbiAgb3V0U3RyZWFtLndyaXRlQml0cyg0OCwgU1FSVFBJKTtcbiAgb3V0U3RyZWFtLndyaXRlQml0cygzMiwgc3RyZWFtQ1JDKTtcbiAgb3V0U3RyZWFtLmZsdXNoKCk7IC8vIGdldCB0aGUgbGFzdCBiaXRzIGZsdXNoZWQgb3V0XG4gIHJldHVybiBvLnJldHZhbDtcbn07XG5cbkJ6aXAyLmRlY29tcHJlc3NGaWxlID0gQnVuemlwLmRlY29kZTtcbkJ6aXAyLmRlY29tcHJlc3NCbG9jayA9IEJ1bnppcC5kZWNvZGVCbG9jaztcbkJ6aXAyLnRhYmxlID0gQnVuemlwLnRhYmxlO1xuXG5yZXR1cm4gQnppcDI7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyogQ1JDMzIsIHVzZWQgaW4gQnppcDIgaW1wbGVtZW50YXRpb24uXG4gKiBUaGlzIGlzIGEgcG9ydCBvZiBDUkMzMi5qYXZhIGZyb20gdGhlIGpiemlwMiBpbXBsZW1lbnRhdGlvbiBhdFxuICogICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2piemlwMlxuICogd2hpY2ggaXM6XG4gKiAgIENvcHlyaWdodCAoYykgMjAxMSBNYXR0aGV3IEZyYW5jaXNcbiAqXG4gKiAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiAgIGNvbmRpdGlvbnM6XG4gKlxuICogICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICogVGhpcyBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIGlzOlxuICogICBDb3B5cmlnaHQgKGMpIDIwMTMgQy4gU2NvdHQgQW5hbmlhblxuICogd2l0aCB0aGUgc2FtZSBsaWNlbnNpbmcgdGVybXMgYXMgTWF0dGhldyBGcmFuY2lzJyBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoVXRpbCkge1xuXG4gIC8qKlxuICAgKiBBIHN0YXRpYyBDUkMgbG9va3VwIHRhYmxlXG4gICAqL1xuICAgIHZhciBjcmMzMkxvb2t1cCA9IFV0aWwuYXJyYXljb3B5KFV0aWwubWFrZVUzMkJ1ZmZlcigyNTYpLCBbXG4gICAgMHgwMDAwMDAwMCwgMHgwNGMxMWRiNywgMHgwOTgyM2I2ZSwgMHgwZDQzMjZkOSwgMHgxMzA0NzZkYywgMHgxN2M1NmI2YiwgMHgxYTg2NGRiMiwgMHgxZTQ3NTAwNSxcbiAgICAweDI2MDhlZGI4LCAweDIyYzlmMDBmLCAweDJmOGFkNmQ2LCAweDJiNGJjYjYxLCAweDM1MGM5YjY0LCAweDMxY2Q4NmQzLCAweDNjOGVhMDBhLCAweDM4NGZiZGJkLFxuICAgIDB4NGMxMWRiNzAsIDB4NDhkMGM2YzcsIDB4NDU5M2UwMWUsIDB4NDE1MmZkYTksIDB4NWYxNWFkYWMsIDB4NWJkNGIwMWIsIDB4NTY5Nzk2YzIsIDB4NTI1NjhiNzUsXG4gICAgMHg2YTE5MzZjOCwgMHg2ZWQ4MmI3ZiwgMHg2MzliMGRhNiwgMHg2NzVhMTAxMSwgMHg3OTFkNDAxNCwgMHg3ZGRjNWRhMywgMHg3MDlmN2I3YSwgMHg3NDVlNjZjZCxcbiAgICAweDk4MjNiNmUwLCAweDljZTJhYjU3LCAweDkxYTE4ZDhlLCAweDk1NjA5MDM5LCAweDhiMjdjMDNjLCAweDhmZTZkZDhiLCAweDgyYTVmYjUyLCAweDg2NjRlNmU1LFxuICAgIDB4YmUyYjViNTgsIDB4YmFlYTQ2ZWYsIDB4YjdhOTYwMzYsIDB4YjM2ODdkODEsIDB4YWQyZjJkODQsIDB4YTllZTMwMzMsIDB4YTRhZDE2ZWEsIDB4YTA2YzBiNWQsXG4gICAgMHhkNDMyNmQ5MCwgMHhkMGYzNzAyNywgMHhkZGIwNTZmZSwgMHhkOTcxNGI0OSwgMHhjNzM2MWI0YywgMHhjM2Y3MDZmYiwgMHhjZWI0MjAyMiwgMHhjYTc1M2Q5NSxcbiAgICAweGYyM2E4MDI4LCAweGY2ZmI5ZDlmLCAweGZiYjhiYjQ2LCAweGZmNzlhNmYxLCAweGUxM2VmNmY0LCAweGU1ZmZlYjQzLCAweGU4YmNjZDlhLCAweGVjN2RkMDJkLFxuICAgIDB4MzQ4NjcwNzcsIDB4MzA0NzZkYzAsIDB4M2QwNDRiMTksIDB4MzljNTU2YWUsIDB4Mjc4MjA2YWIsIDB4MjM0MzFiMWMsIDB4MmUwMDNkYzUsIDB4MmFjMTIwNzIsXG4gICAgMHgxMjhlOWRjZiwgMHgxNjRmODA3OCwgMHgxYjBjYTZhMSwgMHgxZmNkYmIxNiwgMHgwMThhZWIxMywgMHgwNTRiZjZhNCwgMHgwODA4ZDA3ZCwgMHgwY2M5Y2RjYSxcbiAgICAweDc4OTdhYjA3LCAweDdjNTZiNmIwLCAweDcxMTU5MDY5LCAweDc1ZDQ4ZGRlLCAweDZiOTNkZGRiLCAweDZmNTJjMDZjLCAweDYyMTFlNmI1LCAweDY2ZDBmYjAyLFxuICAgIDB4NWU5ZjQ2YmYsIDB4NWE1ZTViMDgsIDB4NTcxZDdkZDEsIDB4NTNkYzYwNjYsIDB4NGQ5YjMwNjMsIDB4NDk1YTJkZDQsIDB4NDQxOTBiMGQsIDB4NDBkODE2YmEsXG4gICAgMHhhY2E1YzY5NywgMHhhODY0ZGIyMCwgMHhhNTI3ZmRmOSwgMHhhMWU2ZTA0ZSwgMHhiZmExYjA0YiwgMHhiYjYwYWRmYywgMHhiNjIzOGIyNSwgMHhiMmUyOTY5MixcbiAgICAweDhhYWQyYjJmLCAweDhlNmMzNjk4LCAweDgzMmYxMDQxLCAweDg3ZWUwZGY2LCAweDk5YTk1ZGYzLCAweDlkNjg0MDQ0LCAweDkwMmI2NjlkLCAweDk0ZWE3YjJhLFxuICAgIDB4ZTBiNDFkZTcsIDB4ZTQ3NTAwNTAsIDB4ZTkzNjI2ODksIDB4ZWRmNzNiM2UsIDB4ZjNiMDZiM2IsIDB4Zjc3MTc2OGMsIDB4ZmEzMjUwNTUsIDB4ZmVmMzRkZTIsXG4gICAgMHhjNmJjZjA1ZiwgMHhjMjdkZWRlOCwgMHhjZjNlY2IzMSwgMHhjYmZmZDY4NiwgMHhkNWI4ODY4MywgMHhkMTc5OWIzNCwgMHhkYzNhYmRlZCwgMHhkOGZiYTA1YSxcbiAgICAweDY5MGNlMGVlLCAweDZkY2RmZDU5LCAweDYwOGVkYjgwLCAweDY0NGZjNjM3LCAweDdhMDg5NjMyLCAweDdlYzk4Yjg1LCAweDczOGFhZDVjLCAweDc3NGJiMGViLFxuICAgIDB4NGYwNDBkNTYsIDB4NGJjNTEwZTEsIDB4NDY4NjM2MzgsIDB4NDI0NzJiOGYsIDB4NWMwMDdiOGEsIDB4NThjMTY2M2QsIDB4NTU4MjQwZTQsIDB4NTE0MzVkNTMsXG4gICAgMHgyNTFkM2I5ZSwgMHgyMWRjMjYyOSwgMHgyYzlmMDBmMCwgMHgyODVlMWQ0NywgMHgzNjE5NGQ0MiwgMHgzMmQ4NTBmNSwgMHgzZjliNzYyYywgMHgzYjVhNmI5YixcbiAgICAweDAzMTVkNjI2LCAweDA3ZDRjYjkxLCAweDBhOTdlZDQ4LCAweDBlNTZmMGZmLCAweDEwMTFhMGZhLCAweDE0ZDBiZDRkLCAweDE5OTM5Yjk0LCAweDFkNTI4NjIzLFxuICAgIDB4ZjEyZjU2MGUsIDB4ZjVlZTRiYjksIDB4ZjhhZDZkNjAsIDB4ZmM2YzcwZDcsIDB4ZTIyYjIwZDIsIDB4ZTZlYTNkNjUsIDB4ZWJhOTFiYmMsIDB4ZWY2ODA2MGIsXG4gICAgMHhkNzI3YmJiNiwgMHhkM2U2YTYwMSwgMHhkZWE1ODBkOCwgMHhkYTY0OWQ2ZiwgMHhjNDIzY2Q2YSwgMHhjMGUyZDBkZCwgMHhjZGExZjYwNCwgMHhjOTYwZWJiMyxcbiAgICAweGJkM2U4ZDdlLCAweGI5ZmY5MGM5LCAweGI0YmNiNjEwLCAweGIwN2RhYmE3LCAweGFlM2FmYmEyLCAweGFhZmJlNjE1LCAweGE3YjhjMGNjLCAweGEzNzlkZDdiLFxuICAgIDB4OWIzNjYwYzYsIDB4OWZmNzdkNzEsIDB4OTJiNDViYTgsIDB4OTY3NTQ2MWYsIDB4ODgzMjE2MWEsIDB4OGNmMzBiYWQsIDB4ODFiMDJkNzQsIDB4ODU3MTMwYzMsXG4gICAgMHg1ZDhhOTA5OSwgMHg1OTRiOGQyZSwgMHg1NDA4YWJmNywgMHg1MGM5YjY0MCwgMHg0ZThlZTY0NSwgMHg0YTRmZmJmMiwgMHg0NzBjZGQyYiwgMHg0M2NkYzA5YyxcbiAgICAweDdiODI3ZDIxLCAweDdmNDM2MDk2LCAweDcyMDA0NjRmLCAweDc2YzE1YmY4LCAweDY4ODYwYmZkLCAweDZjNDcxNjRhLCAweDYxMDQzMDkzLCAweDY1YzUyZDI0LFxuICAgIDB4MTE5YjRiZTksIDB4MTU1YTU2NWUsIDB4MTgxOTcwODcsIDB4MWNkODZkMzAsIDB4MDI5ZjNkMzUsIDB4MDY1ZTIwODIsIDB4MGIxZDA2NWIsIDB4MGZkYzFiZWMsXG4gICAgMHgzNzkzYTY1MSwgMHgzMzUyYmJlNiwgMHgzZTExOWQzZiwgMHgzYWQwODA4OCwgMHgyNDk3ZDA4ZCwgMHgyMDU2Y2QzYSwgMHgyZDE1ZWJlMywgMHgyOWQ0ZjY1NCxcbiAgICAweGM1YTkyNjc5LCAweGMxNjgzYmNlLCAweGNjMmIxZDE3LCAweGM4ZWEwMGEwLCAweGQ2YWQ1MGE1LCAweGQyNmM0ZDEyLCAweGRmMmY2YmNiLCAweGRiZWU3NjdjLFxuICAgIDB4ZTNhMWNiYzEsIDB4ZTc2MGQ2NzYsIDB4ZWEyM2YwYWYsIDB4ZWVlMmVkMTgsIDB4ZjBhNWJkMWQsIDB4ZjQ2NGEwYWEsIDB4ZjkyNzg2NzMsIDB4ZmRlNjliYzQsXG4gICAgMHg4OWI4ZmQwOSwgMHg4ZDc5ZTBiZSwgMHg4MDNhYzY2NywgMHg4NGZiZGJkMCwgMHg5YWJjOGJkNSwgMHg5ZTdkOTY2MiwgMHg5MzNlYjBiYiwgMHg5N2ZmYWQwYyxcbiAgICAweGFmYjAxMGIxLCAweGFiNzEwZDA2LCAweGE2MzIyYmRmLCAweGEyZjMzNjY4LCAweGJjYjQ2NjZkLCAweGI4NzU3YmRhLCAweGI1MzY1ZDAzLCAweGIxZjc0MGI0XG4gIF0pO1xuXG4gIHZhciBDUkMzMiA9IGZ1bmN0aW9uKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IENSQ1xuICAgICAqL1xuICAgIHZhciBjcmMgPSAweGZmZmZmZmZmO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgY3VycmVudCBDUkNcbiAgICAgKi9cbiAgICB0aGlzLmdldENSQyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICh+Y3JjKSA+Pj4gMDsgLy8gcmV0dXJuIGFuIHVuc2lnbmVkIHZhbHVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgQ1JDIHdpdGggYSBzaW5nbGUgYnl0ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdXBkYXRlIHRoZSBDUkMgd2l0aFxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQ1JDID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNyYyA9IChjcmMgPDwgOCkgXiBjcmMzMkxvb2t1cFsoKGNyYyA+Pj4gMjQpIF4gdmFsdWUpICYgMHhmZl07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgQ1JDIHdpdGggYSBzZXF1ZW5jZSBvZiBpZGVudGljYWwgYnl0ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVwZGF0ZSB0aGUgQ1JDIHdpdGhcbiAgICAgKiBAcGFyYW0gY291bnQgVGhlIG51bWJlciBvZiBieXRlc1xuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQ1JDUnVuID0gZnVuY3Rpb24odmFsdWUsIGNvdW50KSB7XG4gICAgICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICAgICAgY3JjID0gKGNyYyA8PCA4KSBeIGNyYzMyTG9va3VwWygoY3JjID4+PiAyNCkgXiB2YWx1ZSkgJiAweGZmXTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gQ1JDMzI7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyoqIEEgc2ltcGxlIGNvbnRleHQtMSBtb2RlbC4gKi9cbnZhciBsaWJzID0gW1xuXHRyZXF1aXJlKCcuL0JpdFN0cmVhbScpLFxuXHRyZXF1aXJlKCcuL0h1ZmZtYW4nKSxcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChCaXRTdHJlYW0sSHVmZm1hbixVdGlsKSB7XG5cbnZhciBDb250ZXh0MU1vZGVsID0gZnVuY3Rpb24obW9kZWxGYWN0b3J5LCBjb250ZXh0U2l6ZSwgYWxwaGFiZXRTaXplKSB7XG4gIHZhciBpO1xuICB0aGlzLmxpdGVyYWxNb2RlbCA9IFtdO1xuICAvLyBldmVuIGlmIHRoZXJlJ3MgYW4gRU9GIHN5bWJvbCwgd2UgZG9uJ3QgbmVlZCBhIGNvbnRleHQgZm9yIGl0IVxuICBmb3IgKGk9MDsgaTxjb250ZXh0U2l6ZTsgaSsrKSB7XG4gICAgdGhpcy5saXRlcmFsTW9kZWxbaV0gPSBtb2RlbEZhY3RvcnkoYWxwaGFiZXRTaXplKTtcbiAgfVxufTtcbkNvbnRleHQxTW9kZWwucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKGNoLCBjb250ZXh0KSB7XG4gIHRoaXMubGl0ZXJhbE1vZGVsW2NvbnRleHRdLmVuY29kZShjaCk7XG59O1xuQ29udGV4dDFNb2RlbC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5saXRlcmFsTW9kZWxbY29udGV4dF0uZGVjb2RlKCk7XG59O1xuXG4vKiogU2ltcGxlIHNlbGYtdGVzdC4gKi9cbkNvbnRleHQxTW9kZWwuTUFHSUM9J2N0eDEnO1xuQ29udGV4dDFNb2RlbC5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihDb250ZXh0MU1vZGVsLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSwgcHJvcHMpIHtcbiAgdmFyIGJpdHN0cmVhbSA9IG5ldyBCaXRTdHJlYW0ob3V0U3RyZWFtKTtcbiAgdmFyIGFscGhhYmV0U2l6ZSA9IDI1NjtcbiAgaWYgKGZpbGVTaXplIDwgMCkgeyBhbHBoYWJldFNpemUrKzsgfVxuICB2YXIgY29kZXIgPSBIdWZmbWFuLmZhY3RvcnkoYml0c3RyZWFtLCA4MTkxKTtcbiAgdmFyIG1vZGVsID0gbmV3IENvbnRleHQxTW9kZWwoY29kZXIsIDI1NiwgYWxwaGFiZXRTaXplKTtcbiAgdmFyIGxhc3RjaGFyID0gMHgyMDtcbiAgdmFyIG1vZGVscCA9IHtcbiAgICBlbmNvZGU6IGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgbW9kZWwuZW5jb2RlKHN5bWJvbCwgbGFzdGNoYXIpO1xuICAgICAgbGFzdGNoYXIgPSBzeW1ib2w7XG4gICAgfVxuICB9O1xuICBVdGlsLmNvbXByZXNzV2l0aE1vZGVsKGluU3RyZWFtLCBmaWxlU2l6ZSwgbW9kZWxwKTtcbiAgYml0c3RyZWFtLmZsdXNoKCk7XG59KTtcbkNvbnRleHQxTW9kZWwuZGVjb21wcmVzc0ZpbGUgPSBVdGlsLmRlY29tcHJlc3NGaWxlSGVscGVyKENvbnRleHQxTW9kZWwuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplKSB7XG4gIHZhciBiaXRzdHJlYW0gPSBuZXcgQml0U3RyZWFtKGluU3RyZWFtKTtcbiAgdmFyIGFscGhhYmV0U2l6ZSA9IDI1NjtcbiAgaWYgKGZpbGVTaXplIDwgMCkgeyBhbHBoYWJldFNpemUrKzsgfVxuICB2YXIgY29kZXIgPSBIdWZmbWFuLmZhY3RvcnkoYml0c3RyZWFtLCA4MTkxKTtcbiAgdmFyIG1vZGVsID0gbmV3IENvbnRleHQxTW9kZWwoY29kZXIsIDI1NiwgYWxwaGFiZXRTaXplKTtcbiAgdmFyIGxhc3RjaGFyID0gMHgyMDtcbiAgdmFyIG1vZGVscCA9IHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IG1vZGVsLmRlY29kZShsYXN0Y2hhcik7XG4gICAgICBsYXN0Y2hhciA9IHN5bWJvbDtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfVxuICB9O1xuICBVdGlsLmRlY29tcHJlc3NXaXRoTW9kZWwob3V0U3RyZWFtLCBmaWxlU2l6ZSwgbW9kZWxwKTtcbn0pO1xuXG5yZXR1cm4gQ29udGV4dDFNb2RlbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiogRGVmZXJyZWQtc3VtIG1vZGVsLCBzdWl0YWJsZSBmb3Igc21hbGwgKCB+IDI1NiApIHJhbmdlcy4gKi9cbnZhciBsaWJzID0gW1xuXHRyZXF1aXJlKCcuL1JhbmdlQ29kZXInKSxcblx0cmVxdWlyZSgnLi9TdHJlYW0nKSxcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChSYW5nZUNvZGVyLFN0cmVhbSxVdGlsKXtcblxudmFyIExPR19QUk9CX1RPVEFMID0gODtcbnZhciBQUk9CX1RPVEFMID0gMSA8PCBMT0dfUFJPQl9UT1RBTDtcbnZhciBNQVhfRVNDQVBFX0NPVU5UID0gNDA7XG5cbnZhciBEZWZTdW1Nb2RlbCA9IGZ1bmN0aW9uKGNvZGVyLCBzaXplLCBpc0RlY29kZXIpIHtcbiAgdmFyIGk7XG4gIGNvbnNvbGUuYXNzZXJ0KHNpemUgPCAzMDApOyAvLyBub3QgbWVhbnQgZm9yIHNwYXJzZVxuICB2YXIgRVNDQVBFID0gdGhpcy5udW1TeW1zID0gc2l6ZTtcbiAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICB0aGlzLnByb2IgPSBVdGlsLm1ha2VVMTZCdWZmZXIoc2l6ZSsyKTsgLyogc2l6ZSArIEVTQyArIDEgKi9cbiAgdGhpcy5lc2NhcGUgPSBVdGlsLm1ha2VVMTZCdWZmZXIoc2l6ZSsxKTsgIC8qIHNpemUgKyAxKi9cbiAgdGhpcy51cGRhdGUgPSBVdGlsLm1ha2VVMTZCdWZmZXIoc2l6ZSsxKTsgLyogc2l6ZSArIEVTQyAqL1xuICB0aGlzLnByb2JbRVNDQVBFKzFdID0gUFJPQl9UT1RBTDtcbiAgZm9yIChpPTA7IGk8PXRoaXMubnVtU3ltczsgaSsrKSB7XG4gICAgdGhpcy5lc2NhcGVbaV0gPSBpO1xuICB9XG4gIHRoaXMudXBkYXRlQ291bnQgPSAwO1xuICB0aGlzLnVwZGF0ZVRocmVzaCA9IFBST0JfVE9UQUwgLSBNYXRoLmZsb29yKFBST0JfVE9UQUwgLyAyKTtcbiAgaWYgKCFpc0RlY29kZXIpIHsgcmV0dXJuOyB9XG4gIC8vIGV4dHJhIHRhYmxlcyBmb3IgZmFzdCBkZWNvZGluZ1xuICB0aGlzLnByb2JUb1N5bSA9IFV0aWwubWFrZVUxNkJ1ZmZlcihQUk9CX1RPVEFMKTtcbiAgdGhpcy5lc2NQcm9iVG9TeW0gPSBVdGlsLm1ha2VVMTZCdWZmZXIodGhpcy5udW1TeW1zKTtcbiAgZm9yIChpPTA7IGk8UFJPQl9UT1RBTDsgaSsrKSB7XG4gICAgdGhpcy5wcm9iVG9TeW1baV0gPSBFU0NBUEU7XG4gIH1cbiAgZm9yIChpPTA7IGk8dGhpcy5udW1TeW1zOyBpKyspIHtcbiAgICB0aGlzLmVzY1Byb2JUb1N5bVtpXSA9IGk7XG4gIH1cbn07XG5EZWZTdW1Nb2RlbC5mYWN0b3J5ID0gZnVuY3Rpb24oY29kZXIsIGlzRGVjb2Rlcikge1xuICByZXR1cm4gZnVuY3Rpb24oc2l6ZSkgeyByZXR1cm4gbmV3IERlZlN1bU1vZGVsKGNvZGVyLCBzaXplLCBpc0RlY29kZXIpOyB9O1xufTtcbkRlZlN1bU1vZGVsLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oc3ltYm9sLCBpc0RlY29kZXIpIHtcbiAgaWYgKHN5bWJvbCA9PT0gdGhpcy5udW1TeW1zKSB7XG4gICAgLy8gc29tZSBzcGVjaWFsIGNhc2VzIGZvciB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgIGlmICh0aGlzLnVwZGF0ZVtzeW1ib2xdID49IE1BWF9FU0NBUEVfQ09VTlQpIHsgcmV0dXJuOyB9IC8vIGhhcmQgbGltaXRcbiAgICAvLyBkb24ndCBsZXQgYW4gZXNjYXBlIGNoYXJhY3RlciB0cmlnZ2VyIGFuIHVwZGF0ZSwgYmVjYXVzZSB0aGVuIHRoZVxuICAgIC8vIGVzY2FwZWQgY2hhcmFjdGVyIG1pZ2h0IGZpbmQgaXRzZWxmIHVuZXNjYXBlZCBhZnRlciB0aGUgdGFibGVzIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQhXG4gICAgaWYgKHRoaXMudXBkYXRlQ291bnQgPj0gKHRoaXMudXBkYXRlVGhyZXNoIC0gMSkpIHsgcmV0dXJuOyB9XG4gIH1cbiAgdGhpcy51cGRhdGVbc3ltYm9sXSsrO1xuICB0aGlzLnVwZGF0ZUNvdW50Kys7XG4gIC8vIGlzIGl0IHRpbWUgdG8gdHJhbnNmZXIgdGhlIHVwZGF0ZWQgcHJvYmFiaWxpdGllcz9cbiAgaWYgKHRoaXMudXBkYXRlQ291bnQgPCB0aGlzLnVwZGF0ZVRocmVzaCkge1xuICAgIHJldHVybjsgLy9kZWZlciB1cGRhdGVcbiAgfVxuICB2YXIgY3VtUHJvYiwgY3VtRXNjUHJvYiwgb2RkLCBpLCBqLCBrO1xuICB0aGlzLmVzY2FwZVswXSA9IHRoaXMucHJvYlswXSA9IGN1bVByb2IgPSBjdW1Fc2NQcm9iID0gb2RkID0gMDtcbiAgZm9yIChpPTA7IGkgPCB0aGlzLm51bVN5bXMrMTsgaSsrKSB7XG4gICAgdmFyIG5ld1Byb2IgPSAoKHRoaXMucHJvYltpKzFdLXRoaXMucHJvYltpXSkgPj4+IDEpICsgdGhpcy51cGRhdGVbaV07XG4gICAgaWYgKG5ld1Byb2IpIHtcbiAgICAgIC8vIGxpdmUgJ3VuXG4gICAgICB0aGlzLnByb2JbaV0gPSBjdW1Qcm9iO1xuICAgICAgY3VtUHJvYiArPSBuZXdQcm9iO1xuICAgICAgaWYgKG5ld1Byb2IgJiAxKSB7IG9kZCsrOyB9XG4gICAgICB0aGlzLmVzY2FwZVtpXSA9IGN1bUVzY1Byb2I7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgc3ltYm9sIHdpbGwgZXNjYXBlXG4gICAgICB0aGlzLnByb2JbaV0gPSBjdW1Qcm9iO1xuICAgICAgdGhpcy5lc2NhcGVbaV0gPSBjdW1Fc2NQcm9iO1xuICAgICAgY3VtRXNjUHJvYisrO1xuICAgIH1cbiAgfVxuICB0aGlzLnByb2JbaV0gPSBjdW1Qcm9iO1xuICBjb25zb2xlLmFzc2VydChjdW1Qcm9iID09PSBQUk9CX1RPVEFMKTtcbiAgLyogaG93IG1hbnkgdXBkYXRlcyB3aWxsIGJlIHJlcXVpcmVkIGFmdGVyIGN1cnJlbnQgcHJvYnMgYXJlIGhhbHZlZD8gKi9cbiAgdGhpcy51cGRhdGVUaHJlc2ggPSBQUk9CX1RPVEFMIC0gTWF0aC5mbG9vcigoY3VtUHJvYi1vZGQpIC8gMik7XG4gIC8qIHJlc2V0IHRoZSB1cGRhdGUgdGFibGUgKi9cbiAgZm9yIChpPTA7IGkgPCAodGhpcy5udW1TeW1zICsgMSk7IGkrKykge1xuICAgIHRoaXMudXBkYXRlW2ldID0gMDtcbiAgfVxuICB0aGlzLnVwZGF0ZVt0aGlzLm51bVN5bXNdID0gMTsgLy8gZW5zdXJlIHRoYXQgZXNjYXBlIG5ldmVyIGdvZXMgYXdheVxuICB0aGlzLnVwZGF0ZUNvdW50ID0gMTtcbiAgLyogY29tcHV0ZSBkZWNvZGUgdGFibGUsIGlmIHRoaXMgaXMgYSBkZWNvZGVyICovXG4gIGlmICghaXNEZWNvZGVyKSB7IHJldHVybjsgfVxuICBmb3IgKGk9MCwgaj0wLCBrPTA7IGk8KHRoaXMubnVtU3ltcysxKTsgaSsrKSB7XG4gICAgdmFyIHByb2JMaW1pdCA9IHRoaXMucHJvYltpKzFdO1xuICAgIGZvciAoOyBqPHByb2JMaW1pdDsgaisrKSB7XG4gICAgICB0aGlzLnByb2JUb1N5bVtqXSA9IGk7XG4gICAgfVxuICAgIHZhciBlc2NQcm9iTGltaXQgPSB0aGlzLmVzY2FwZVtpKzFdO1xuICAgIGZvciAoOyBrPGVzY1Byb2JMaW1pdDsgaysrKSB7XG4gICAgICB0aGlzLmVzY1Byb2JUb1N5bVtrXSA9IGk7XG4gICAgfVxuICB9XG59O1xuRGVmU3VtTW9kZWwucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuICB2YXIgbHRfZiA9IHRoaXMucHJvYltzeW1ib2xdO1xuICB2YXIgc3lfZiA9IHRoaXMucHJvYltzeW1ib2wrMV0gLSBsdF9mO1xuICBjb25zb2xlLmFzc2VydCh0aGlzLnByb2JbdGhpcy5udW1TeW1zKzFdID09PSBQUk9CX1RPVEFMKTtcbiAgaWYgKHN5X2YpIHtcbiAgICB0aGlzLmNvZGVyLmVuY29kZVNoaWZ0KHN5X2YsIGx0X2YsIExPR19QUk9CX1RPVEFMKTtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlKHN5bWJvbCk7XG4gIH1cbiAgLy8gZXNjYXBlIVxuICBjb25zb2xlLmFzc2VydChzeW1ib2wgIT09IHRoaXMubnVtU3ltcyk7IC8vIGNhdGNoIGluZmluaXRlIHJlY3Vyc2lvblxuICB0aGlzLmVuY29kZSh0aGlzLm51bVN5bXMpOyAvLyBndWFyYW50ZWVkIG5vbi16ZXJvIHByb2JhYmlsaXR5XG4gIC8vIGNvZGUgc3ltYm9sIGFzIGxpdGVyYWwsIHRha2luZyBhZHZhbnRhZ2Ugb2YgcmVkdWNlZCBlc2NhcGUgcmFuZ2UuXG4gIGx0X2YgPSB0aGlzLmVzY2FwZVtzeW1ib2xdO1xuICBzeV9mID0gdGhpcy5lc2NhcGVbc3ltYm9sKzFdIC0gbHRfZjtcbiAgdmFyIHRvdF9mID0gdGhpcy5lc2NhcGVbdGhpcy5udW1TeW1zXTtcbiAgdGhpcy5jb2Rlci5lbmNvZGVGcmVxKHN5X2YsIGx0X2YsIHRvdF9mKTtcbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZShzeW1ib2wpO1xufTtcbkRlZlN1bU1vZGVsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByb2IgPSB0aGlzLmNvZGVyLmRlY29kZUN1bFNoaWZ0KExPR19QUk9CX1RPVEFMKTtcbiAgdmFyIHN5bWJvbCA9IHRoaXMucHJvYlRvU3ltW3Byb2JdO1xuICB2YXIgbHRfZiA9IHRoaXMucHJvYltzeW1ib2xdO1xuICB2YXIgc3lfZiA9IHRoaXMucHJvYltzeW1ib2wrMV0gLSBsdF9mO1xuICB0aGlzLmNvZGVyLmRlY29kZVVwZGF0ZShzeV9mLCBsdF9mLCBQUk9CX1RPVEFMKTtcbiAgdGhpcy5fdXBkYXRlKHN5bWJvbCwgdHJ1ZSk7XG4gIGlmIChzeW1ib2wgIT09IHRoaXMubnVtU3ltcykge1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cbiAgLy8gZXNjYXBlIVxuICB2YXIgdG90X2YgPSB0aGlzLmVzY2FwZVt0aGlzLm51bVN5bXNdO1xuICBwcm9iID0gdGhpcy5jb2Rlci5kZWNvZGVDdWxGcmVxKHRvdF9mKTtcbiAgc3ltYm9sID0gdGhpcy5lc2NQcm9iVG9TeW1bcHJvYl07XG4gIGx0X2YgPSB0aGlzLmVzY2FwZVtzeW1ib2xdO1xuICBzeV9mID0gdGhpcy5lc2NhcGVbc3ltYm9sKzFdIC0gbHRfZjtcbiAgdGhpcy5jb2Rlci5kZWNvZGVVcGRhdGUoc3lfZiwgbHRfZiwgdG90X2YpO1xuICB0aGlzLl91cGRhdGUoc3ltYm9sLCB0cnVlKTtcbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbkRlZlN1bU1vZGVsLk1BR0lDPSdkZnNtJztcbi8qKiBTaW1wbGUgb3JkZXItMCBjb21wcmVzc29yLCBhcyBzZWxmLXRlc3QuICovXG5EZWZTdW1Nb2RlbC5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihEZWZTdW1Nb2RlbC5NQUdJQywgZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgZmlsZVNpemUsIHByb3BzLCBmaW5hbEJ5dGUpIHtcbiAgdmFyIHJhbmdlID0gbmV3IFJhbmdlQ29kZXIob3V0U3RyZWFtKTtcbiAgcmFuZ2UuZW5jb2RlU3RhcnQoZmluYWxCeXRlLCAxKTtcbiAgdmFyIG1vZGVsID0gbmV3IERlZlN1bU1vZGVsKHJhbmdlLCAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICBVdGlsLmNvbXByZXNzV2l0aE1vZGVsKGluU3RyZWFtLCBmaWxlU2l6ZSwgbW9kZWwpO1xuICByYW5nZS5lbmNvZGVGaW5pc2goKTtcbn0sdHJ1ZSk7XG4vKiogU2ltcGxlIG9yZGVyLTAgZGVjb21wcmVzc2VyLCBhcyBzZWxmLXRlc3QuICovXG5EZWZTdW1Nb2RlbC5kZWNvbXByZXNzRmlsZSA9IFV0aWwuZGVjb21wcmVzc0ZpbGVIZWxwZXIoRGVmU3VtTW9kZWwuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplKSB7XG4gIHZhciByYW5nZSA9IG5ldyBSYW5nZUNvZGVyKGluU3RyZWFtKTtcbiAgcmFuZ2UuZGVjb2RlU3RhcnQodHJ1ZS8qYWxyZWFkeSByZWFkIHRoZSBmaW5hbCBieXRlKi8pO1xuICB2YXIgbW9kZWwgPSBuZXcgRGVmU3VtTW9kZWwocmFuZ2UsIChmaWxlU2l6ZTwwKSA/IDI1NyA6IDI1NiwgdHJ1ZSk7XG4gIFV0aWwuZGVjb21wcmVzc1dpdGhNb2RlbChvdXRTdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gIHJhbmdlLmRlY29kZUZpbmlzaCgpO1xufSk7XG5cbnJldHVybiBEZWZTdW1Nb2RlbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiogRGlzdGFuY2UgbW9kZWwgdXNlZCBieSBnemlwL2RlZmxhdGUuXG4gKiAgRW5jb2RlcyBkaXN0YW5jZXMgc3RhcnRpbmcgYXQgMCAoZm9yIGRlZmxhdGUgY29tcGF0aWJpbGl0eSwgc3VidHJhY3RcbiAqICBvbmUgZnJvbSBkaXN0YW5jZSB0byBlbmNvZGUpLlxuICogIFVzZXMgfjMyLWVudHJ5IG1vZGVsIHRvIHByZWRpY3QgbG4yKGRpc3RhbmNlKSAobW9yZS1vci1sZXNzKSBhbmQgdGhlblxuICogIGVuY29kZXMgYSBmZXcgbW9yZSBiaXRzIGZvciB0aGUgYWN0dWFsIGRpc3RhbmNlLiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoVXRpbCl7XG5cbiAgICAvLyBsZW5ndGhCaXRzTW9kZWxGYWN0b3J5IHdpbGwgYmUgY2FsbGVkIHdpdGggYXJndW1lbnRzIDIsIDQsIDgsIDE2LCBldGNcbiAgICAvLyBhbmQgbXVzdCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgbW9kZWwgb3IgY29kZXIuXG4gICAgdmFyIERlZmxhdGVEaXN0YW5jZU1vZGVsID0gZnVuY3Rpb24oc2l6ZSwgZXh0cmFTdGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGdEaXN0YW5jZU1vZGVsRmFjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhCaXRzTW9kZWxGYWN0b3J5KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgYml0cyA9IFV0aWwuZmxzKHNpemUtMSk7XG4gICAgICAgIHRoaXMuZXh0cmFTdGF0ZXMgPSArZXh0cmFTdGF0ZXMgfHwgMDtcbiAgICAgICAgdGhpcy5sZ0Rpc3RhbmNlTW9kZWwgPSBsZ0Rpc3RhbmNlTW9kZWxGYWN0b3J5KDIqYml0cyArIGV4dHJhU3RhdGVzKTtcbiAgICAgICAgLy8gdGhpcy5kaXN0YW5jZU1vZGVsW25dIHVzZWQgZm9yIGRpc3RhbmNlcyB3aGljaCBhcmUgbi1iaXRzIGxvbmcsXG4gICAgICAgIC8vIGJ1dCBvbmx5IG4tMiBiaXRzIGFyZSBlbmNvZGVkOiB0aGUgdG9wIGJpdCBpcyBrbm93biB0byBiZSBvbmUsXG4gICAgICAgIC8vIGFuZCB0aGUgbmV4dCBiaXQgaXMgZW5jb2RlZCBieSB0aGUgbGdEaXN0YW5jZU1vZGVsLlxuICAgICAgICB0aGlzLmRpc3RhbmNlTW9kZWwgPSBbXTtcbiAgICAgICAgZm9yIChpPTMgOyBpIDw9IGJpdHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIG51bUJpdHMgPSBpIC0gMjtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VNb2RlbFtpXSA9IGxlbmd0aEJpdHNNb2RlbEZhY3RvcnkoMTw8bnVtQml0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIHlvdSBjYW4gZ2l2ZSB0aGlzIG1vZGVsIGFyZ3VtZW50cyBiZXR3ZWVuIDAgYW5kIChzaXplLTEpLCBvciBlbHNlXG4gICAgICAgYSBuZWdhdGl2ZSBhcmd1bWVudCB3aGljaCBpcyBvbmUgb2YgdGhlICdleHRyYSBzdGF0ZXMnLiAqL1xuICAgIERlZmxhdGVEaXN0YW5jZU1vZGVsLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihkaXN0YW5jZSkge1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCA0KSB7IC8vIHNtYWxsIGRpc3RhbmNlIG9yIGFuICdleHRyYSBzdGF0ZSdcbiAgICAgICAgICAgIHRoaXMubGdEaXN0YW5jZU1vZGVsLmVuY29kZShkaXN0YW5jZSArIHRoaXMuZXh0cmFTdGF0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZ0Rpc3RhbmNlID0gVXRpbC5mbHMoZGlzdGFuY2UpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChkaXN0YW5jZSAmICgxPDwobGdEaXN0YW5jZS0xKSkpOyAvLyB0b3AgYml0IGlzIHNldFxuICAgICAgICBjb25zb2xlLmFzc2VydChsZ0Rpc3RhbmNlID49IDMpO1xuICAgICAgICB2YXIgbmV4dEJpdCA9IChkaXN0YW5jZSAmICgxIDw8IChsZ0Rpc3RhbmNlLTIpKSkgPyAxIDogMDtcbiAgICAgICAgdmFyIGwgPSA0ICsgKChsZ0Rpc3RhbmNlLTMpKjIpICsgbmV4dEJpdDtcbiAgICAgICAgdGhpcy5sZ0Rpc3RhbmNlTW9kZWwuZW5jb2RlKGwgKyB0aGlzLmV4dHJhU3RhdGVzKTtcbiAgICAgICAgLy8gbm93IGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cy5cbiAgICAgICAgdmFyIHJlc3QgPSBkaXN0YW5jZSAmICgoMSA8PCAobGdEaXN0YW5jZS0yKSkgLSAxKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZU1vZGVsW2xnRGlzdGFuY2VdLmVuY29kZShyZXN0KTtcbiAgICB9O1xuICAgIERlZmxhdGVEaXN0YW5jZU1vZGVsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLmxnRGlzdGFuY2VNb2RlbC5kZWNvZGUoKSAtIHRoaXMuZXh0cmFTdGF0ZXM7XG4gICAgICAgIGlmIChsIDwgNCkge1xuICAgICAgICAgICAgcmV0dXJuIGw7IC8vIHRoaXMgaXMgYSBzbWFsbCBkaXN0YW5jZSBvciBhbiAnZXh0cmEgc3RhdGUnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRCaXQgPSAobCYxKTtcbiAgICAgICAgdmFyIGxnRGlzdGFuY2UgPSAoKGwtNCkgPj4+IDEpICsgMztcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLmRpc3RhbmNlTW9kZWxbbGdEaXN0YW5jZV0uZGVjb2RlKCk7XG4gICAgICAgIHJldHVybiAoKDIrbmV4dEJpdCkgPDwgKGxnRGlzdGFuY2UtMikpICsgcmVzdDtcbiAgICB9O1xuICAgIHJldHVybiBEZWZsYXRlRGlzdGFuY2VNb2RlbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIER5bmFtaWMgTWFya292IENvbXByZXNzaW9uLCB1c2luZyBieXRlLW9yaWVudGVkXG4gKiBub2Rlcy90cmFuc2l0aW9ucy5cbiAqXG4gKiBDdXJyZW50bHkgbm8gbW9kZWwtc2hyaW5raW5nIGlzIGRvbmUsIHNvIGJlIGNhcmVmdWwgdHJ5aW5nIHRvIHVzZVxuICogdGhpcyBvbiBsYXJnZSBpbnB1dHMhXG4gKlxuICogTm90ZXMgZm9yIHRoZSBmdXR1cmUgLyBUTyBETzpcbiAqXG4gKiBBZGQgbm9kZSBtZXJnaW5nIHRvIERtYzpcbiAqICAtIG9uY2UgKHRvdGFsIHN0YXRlcyB0cmF2ZXJzZWQgLyB0b3RhbCBub2RlIGNvdW50KSBleGNlZWRzIGEgY2VydGFpbiB2YWx1ZVxuICogICAgLSBmaW5kIHRoZSBtZWRpYW4gbm9kZSB3L3J0IHRvdGFsIHZpc2l0c1xuICogICAgLSBjb21iaW5lIGFsbCBub2RlcyB3LyBsZXNzIHZpc2l0cyBpbnRvIGEgc2luZ2xlIG5vZGUsIHdpdGggdHJhbnNpdGlvbnNcbiAqICAgICAgdG8gbm9kZVswXSAtIG5vZGVbMjU1XSAoaW5pdGlhbCBjb250ZXh0LTEgc3RhdGVzKVxuICogICAgICAtIGluaXRpYWxseSB0cmFuc2l0aW9uIGNvdW50cyBhcmUgemVybz8gIG9yIHN1bW1lZCBmcm9tIGNvbXBvbmVudHM/XG4gKiAgICAgICAgbmVlZHMgdG8gYmUgc3VtbWVkIHNvIGtpcmNob2ZmIHByaW5jaXBsZSBob2xkc1xuICogICAgLSBoYWx2ZSB0aGUgZWRnZSBjb3VudHMgb2YgYWxsIG5vZGVzLCB0byBwcm92aWRlIGZvciBhZGFwdGF0aW9uXG4gKiAgICAgIC0gZW5mb3JjZSBwcm9wZXJ0eSB0aGF0IGFsbCBub2RlcyBwb2ludCBcImhpZ2hlclwiIGV4Y2VwdCBmb3JcbiAqICAgICAgICBsaW5rcyB0byBub2RlcyAwLTI1NS4gIFNvIHdlIGNhbiByZXN1bSBhbGwgbm9kZXMgaW4gb25lIHBhc3MsXG4gKiAgICAgICAgYWZ0ZXIgcmVzZXR0aW5nIGFsbCBub2RlLnN1bSB0byB6ZXJvLiBYIFlFUyBiZWNhdXNlIHdlIGtub3dcbiAqICAgICAgICB3aGF0IHRoZSB0b3RhbCBzdW0gbXVzdCBiZSwgc28gd2UgY2FuIGFycmFuZ2UgdG8gc2NhbGUgdG8gbWFpbnRhaW5cbiAqICAgICAgICBwcm9wZXIgc3VtLiBYWFggd2hhdCBhYm91dCBub2RlIDAtMjU1PyBYWFggbWF5YmUganVzdCBjbGVhciBhbGxcbiAqICAgICAgICBlZGdlIGNvdW50cyBYWFhcbiAqXG4gKiBGaXggYnVnbGV0OiBlbnN1cmUgdGhhdCBraXJjaG9mZiBwcmluY2lwbGUgKmV4YWN0bHkqIGhvbGRzIGJ5XG4gKiBwYXlpbmcgYXR0ZW50aW9uIHRvIHJvdW5kaW5nIHdoZW4gd2UgZGlzdHJpYnV0ZSBlZGdlIGNvdW50cy4gIHRyYWNrXG4gKiBoaWdoZXN0IGVkZ2UgYW5kIGdpdmUgKGRlc2lyZWRTdW0gLSBuZXdTdW0pIGV4dHJhIGNvdW50cyB0byB0aGF0XG4gKiBvdXRnb2luZyBlZGdlPyBhZGQgb25lIHRvIGVhY2ggbm9uemVybyBlZGdlIHVudGlsIGFsbCBnb25lP1xuICpcbiAqIFNwbGl0ICd0bycgbm9kZXMgd2hlbiB0by5zdW0gZ3Jvd3MgdG9vIGhpZ2ggLS0gb25seSBpZiB3ZSdyZVxuICogaGlnaGVzdCBpbmNvbWluZyBlZGdlPyAgRml4IGJ1ZyBhZ2FpbiBoZXJlIHdpdGggc2F0dXJhdGluZyBjb3VudHM7XG4gKiB3ZSBjYW4ndCBpZ25vcmUgY291bnRzIHcvbyB2aW9sYXRpbmcga2lyY2hvZmYgcHJpbmNpcGxlLCBzbyB3ZSBuZWVkXG4gKiB0byBjbG9uZSBpdC4gIE1heWJlIHN0YXJ0IHRyeWluZyB0byBjbG9uZSBlYXJseSAoYmVmb3JlIG91ciBjb3VudGVyXG4gKiBzYXR1cmF0ZXMpIHNvIHdlIGhhdmUgYSBiZXR0ZXIgY2hhbmNlIG9mIGNsb25pbmcgb24gdGhlIGhpZ2hcbiAqIGluY29taW5nIGVkZ2U/IFhYWCB3ZSBkb24ndCB0cmFjayBpbmNvbWluZyBlZGdlcy4gIFhYWCBzbyBqdXN0XG4gKiBjbG9uZSB3aGVuIHdlIHZpc2l0LlxuICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9NVEZNb2RlbCcpLFxuXHRyZXF1aXJlKCcuL1JhbmdlQ29kZXInKSxcblx0cmVxdWlyZSgnLi9TdHJlYW0nKSxcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChNVEZNb2RlbCwgUmFuZ2VDb2RlciwgU3RyZWFtLCBVdGlsKXtcblxuLy8gbm0gPSBubyBtb2RlbCBjbG9uaW5nLCBNQVhfVFJBTlNfQ05UPTB4RkYsIE1BWF9NT0RFTF9QUk9CPTB4RkZGRlxuLy8gbm0yID0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhGRkZGICAgICAgICAgICAgICAgICAweEZGRkZcbi8vIG5tMyA9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweEZGRiAgICAgICAgICAgICAgICAgMHgwRkZGXG4vLyBubTQgPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweEZGRkYgICAgICAgICAgICAgICAgICAgMHhGRlxuLy8gY2wxID0gbW9kZWwgY2xvbmluZywgTUFYX1RSQU5TX0NOVD0weEZGRkYgIE1BWF9NT0RFTF9QUk9CPTB4RkZcbi8vIGNsMiA9IG1vZGVsIGNsb25pbmcsIE1BWF9UUkFOU19DTlQ9ICAweEZGICBNQVhfTU9ERUxfUFJPQj0weEZGXG4vLyBjbDMgPSBtb2RlbCBjbG9uaW5nLCBNQVhfVFJBTlNfQ05UPTB4RkZGRiAgTUFYX01PREVMX1BST0I9MHhGRkZGXG52YXIgTUFYX1RSQU5TX0NOVCA9IDB4RkZGRjtcbnZhciBERUZBVUxUX01JTl9DTlQxID0gODtcbnZhciBERUZBVUxUX01JTl9DTlQyID0gMTI4O1xudmFyIE1PREVMX1BST0JfTUFYID0gMHhGRjAwO1xudmFyIE1PREVMX1BST0JfSU5DUj0gMHgwMTAwO1xudmFyIENMT05FX01PREVMUz1mYWxzZTtcbnZhciBQUklOVF9TVEFUUz1mYWxzZTsgLy8gZm9yIHF1aWNrIGJlbmNobWFya2luZ1xuXG4vLyBYWFggbmVlZCB0byBsaW1pdCBncm93dGggb2YgbW9kZWwgKHRocm93IGF3YXkgYW5kIHJldHJhaW4gaWYgbW9kZWxcbi8vICAgICBnZXRzIHRvbyBsYXJnZSlcblxudmFyIERtYyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5EbWMuTUFHSUMgPSAnZG1jISc7XG5cbnZhciBNYXJrb3ZOb2RlID0gZnVuY3Rpb24oY29kZXIsIHNpemUsIG9wdE1vZGVsKSB7XG4gIHRoaXMub3V0ID0gW107XG4gIHRoaXMubW9kZWwgPSBvcHRNb2RlbCA/IG9wdE1vZGVsLmNsb25lKCkgOlxuICAgIG5ldyBNVEZNb2RlbChjb2Rlciwgc2l6ZSwgTU9ERUxfUFJPQl9NQVgsIE1PREVMX1BST0JfSU5DUik7XG4gIHRoaXMuY291bnQgPSBVdGlsLm1ha2VVMTZCdWZmZXIoc2l6ZSk7XG4gIHRoaXMuc3VtID0gMDtcbn07XG5NYXJrb3ZOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGNvZGVyLCBzaXplKSB7XG4gIHZhciBpO1xuICB2YXIgbmV3Tm9kZSA9IG5ldyBNYXJrb3ZOb2RlKGNvZGVyLCBzaXplLCBDTE9ORV9NT0RFTFMgPyB0aGlzLm1vZGVsIDogbnVsbCk7XG4gIGZvciAoaT0wOyBpPHNpemU7IGkrKykge1xuICAgIG5ld05vZGUub3V0W2ldID0gdGhpcy5vdXRbaV07XG4gIH1cbiAgcmV0dXJuIG5ld05vZGU7XG59O1xuXG52YXIgTWFya292TW9kZWwgPSBmdW5jdGlvbihjb2Rlciwgc2l6ZSwgTUlOX0NOVDEsIE1JTl9DTlQyKSB7XG4gIHZhciBpLCBqO1xuICAvLyBpbml0aWFsIG1vZGVsIGlzICdzaXplJyBzdGF0ZXMsIGNvbXBsZXRlbHkgbGlua2VkLlxuICB0aGlzLmNvZGVyID0gY29kZXI7XG4gIHRoaXMuc2l6ZSA9IHNpemU7XG4gIHRoaXMuTUlOX0NOVDEgPSBNSU5fQ05UMSB8fCBERUZBVUxUX01JTl9DTlQxO1xuICB0aGlzLk1JTl9DTlQyID0gTUlOX0NOVDIgfHwgREVGQVVMVF9NSU5fQ05UMjtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICBmb3IgKGk9MDsgaTxzaXplOyBpKyspIHtcbiAgICB0aGlzLm5vZGVzW2ldID0gbmV3IE1hcmtvdk5vZGUoY29kZXIsIHNpemUpO1xuICB9XG4gIC8vIG5vdyBsaW5rIG5vZGVzXG4gIGZvciAoaT0wOyBpPHNpemU7IGkrKykge1xuICAgIGZvciAoaj0wOyBqPHNpemU7IGorKykge1xuICAgICAgdGhpcy5ub2Rlc1tpXS5vdXRbal0gPSB0aGlzLm5vZGVzW2pdO1xuICAgIH1cbiAgfVxuICAvLyBzZWxlY3QgYW4gYXJiaXRyYXJ5IG5vZGUgYXMgdGhlIHN0YXJ0IHN0YXRlLlxuICB0aGlzLmN1cnJlbnQgPSB0aGlzLm5vZGVzWzBdO1xufTtcbk1hcmtvdk1vZGVsLnByb3RvdHlwZS5tYXliZVNwbGl0ID0gZnVuY3Rpb24oZnJvbSwgc3ltYm9sLCB0bykge1xuICB2YXIgdHJhbnNfY250ID0gZnJvbS5jb3VudFtzeW1ib2xdO1xuICB2YXIgbmV4dF9jbnQgPSB0by5zdW07XG4gIHZhciBpO1xuICBpZiAoICh0cmFuc19jbnQgPD0gdGhpcy5NSU5fQ05UMSkgfHxcbiAgICAgICAobmV4dF9jbnQgLSB0cmFuc19jbnQgPD0gdGhpcy5NSU5fQ05UMikgKSB7XG4gICAgcmV0dXJuIHRvOyAvLyBubyBzcGxpdFxuICB9XG5cbiAgLy8gc3BsaXQgdGhpcyBndXkhXG4gIHZhciBuZXdOb2RlID0gdG8uY2xvbmUodGhpcy5jb2RlciwgdGhpcy5zaXplKTtcbiAgdGhpcy5ub2Rlcy5wdXNoKG5ld05vZGUpO1xuICBmcm9tLm91dFtzeW1ib2xdID0gbmV3Tm9kZTtcbiAgLy8gZGlzdHJpYnV0ZSB0cmFuc2l0aW9uIGNvdW50cyBhbW9uZyBuZXcgYW5kIGNsb25lZCBub2RlXG4gIG5ld05vZGUuc3VtID0gdG8uc3VtID0gMDtcbiAgZm9yIChpPTA7IGk8dGhpcy5zaXplOyBpKyspIHtcbiAgICBuZXdOb2RlLmNvdW50W2ldID0gdG8uY291bnRbaV0gKiB0cmFuc19jbnQgLyBuZXh0X2NudDtcbiAgICBuZXdOb2RlLnN1bSArPSBuZXdOb2RlLmNvdW50W2ldO1xuICAgIHRvLmNvdW50W2ldIC09IG5ld05vZGUuY291bnRbaV07XG4gICAgdG8uc3VtICs9IHRvLmNvdW50W2ldO1xuICB9XG5cbiAgcmV0dXJuIG5ld05vZGU7XG59O1xuTWFya292TW9kZWwucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuICB2YXIgZnJvbSA9IHRoaXMuY3VycmVudDtcbiAgZnJvbS5tb2RlbC5lbmNvZGUoc3ltYm9sKTtcbiAgdmFyIHRvID0gZnJvbS5vdXRbc3ltYm9sXTtcbiAgaWYgKGZyb20uY291bnRbc3ltYm9sXSAhPT0gTUFYX1RSQU5TX0NOVCkge1xuICAgICAgZnJvbS5jb3VudFtzeW1ib2xdKys7XG4gICAgICBmcm9tLnN1bSsrO1xuICB9XG4gIHRoaXMuY3VycmVudCA9IHRoaXMubWF5YmVTcGxpdChmcm9tLCBzeW1ib2wsIHRvKTtcbn07XG5NYXJrb3ZNb2RlbC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmcm9tID0gdGhpcy5jdXJyZW50O1xuICB2YXIgc3ltYm9sID0gZnJvbS5tb2RlbC5kZWNvZGUoKTtcbiAgdmFyIHRvID0gZnJvbS5vdXRbc3ltYm9sXTtcbiAgaWYgKGZyb20uY291bnRbc3ltYm9sXSAhPT0gTUFYX1RSQU5TX0NOVCkge1xuICAgICAgZnJvbS5jb3VudFtzeW1ib2xdKys7XG4gICAgICBmcm9tLnN1bSsrO1xuICB9XG4gIHRoaXMuY3VycmVudCA9IHRoaXMubWF5YmVTcGxpdChmcm9tLCBzeW1ib2wsIHRvKTtcbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbkRtYy5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihEbWMuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplLCBwcm9wcykge1xuXG4gIHByb3BzID0gcHJvcHMgfHwge307XG4gIHZhciBNSU5fQ05UMSA9ICgrcHJvcHMubSkgfHwgREVGQVVMVF9NSU5fQ05UMTtcbiAgdmFyIE1JTl9DTlQyID0gKCtwcm9wcy5uKSB8fCBERUZBVUxUX01JTl9DTlQyO1xuICBVdGlsLndyaXRlVW5zaWduZWROdW1iZXIob3V0U3RyZWFtLCBNSU5fQ05UMSk7XG4gIFV0aWwud3JpdGVVbnNpZ25lZE51bWJlcihvdXRTdHJlYW0sIE1JTl9DTlQyKTtcblxuICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2VDb2RlcihvdXRTdHJlYW0pO1xuICByYW5nZS5lbmNvZGVTdGFydCgweENBLCAwKTtcblxuICB2YXIgbW0gPSBuZXcgTWFya292TW9kZWwocmFuZ2UsIChmaWxlU2l6ZTwwKSA/IDI1NyA6IDI1NixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIE1JTl9DTlQxLCBNSU5fQ05UMik7XG4gIHZhciBpblNpemUgPSAwO1xuICB3aGlsZSAoaW5TaXplICE9PSBmaWxlU2l6ZSkge1xuICAgIHZhciBjaCA9IGluU3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgaWYgKGNoPT09U3RyZWFtLkVPRikge1xuICAgICAgbW0uZW5jb2RlKDI1Nik7IC8vIGVuZCBvZiBzdHJlYW1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtbS5lbmNvZGUoY2gpO1xuICAgIGluU2l6ZSsrO1xuICB9XG4gIHZhciBvdXRTaXplID0gcmFuZ2UuZW5jb2RlRmluaXNoKCk7XG4gIGlmIChQUklOVF9TVEFUUykge1xuICAgIGNvbnNvbGUubG9nKCdNMScsIG1tLk1JTl9DTlQxLCAnTTInLCBtbS5NSU5fQ05UMixcbiAgICAgICAgICAgICAgICAnc3RhdGVzJywgbW0ubm9kZXMubGVuZ3RoLCAnc2l6ZScsIG91dFNpemUpO1xuICB9XG59KTtcblxuRG1jLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihEbWMuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplKSB7XG5cbiAgdmFyIE1JTl9DTlQxID0gVXRpbC5yZWFkVW5zaWduZWROdW1iZXIoaW5TdHJlYW0pO1xuICB2YXIgTUlOX0NOVDIgPSBVdGlsLnJlYWRVbnNpZ25lZE51bWJlcihpblN0cmVhbSk7XG5cbiAgdmFyIHJhbmdlID0gbmV3IFJhbmdlQ29kZXIoaW5TdHJlYW0pO1xuICByYW5nZS5kZWNvZGVTdGFydCgpO1xuXG4gIHZhciBtbSA9IG5ldyBNYXJrb3ZNb2RlbChyYW5nZSwgKGZpbGVTaXplPDApID8gMjU3IDogMjU2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgTUlOX0NOVDEsIE1JTl9DTlQyKTtcbiAgdmFyIG91dFNpemUgPSAwO1xuICB3aGlsZSAob3V0U2l6ZSAhPT0gZmlsZVNpemUpIHtcbiAgICB2YXIgY2ggPSBtbS5kZWNvZGUoKTtcbiAgICBpZiAoY2g9PT0yNTYpIHtcbiAgICAgIGJyZWFrOyAvLyBFT0ZcbiAgICB9XG4gICAgb3V0U3RyZWFtLndyaXRlQnl0ZShjaCk7XG4gICAgb3V0U2l6ZSsrO1xuICB9XG4gIHJhbmdlLmRlY29kZUZpbmlzaCgpO1xufSk7XG5cbnJldHVybiBEbWM7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyogRHVtbXkgUmFuZ2UgQ29kZXIsIGZvciBkZWJ1Z2dpbmcuXG4gKiBUaGlzIGhhcyB0aGUgc2FtZSBpbnRlcmZhY2UgYXMgUmFuZ2VDb2RlciwgYnV0IGp1c3QgZHVtcHMgdGhlIGZyZXF1ZW5jeVxuICogcGFyYW1ldGVycyBnaXZlbiB0byB0aGUgZmlsZS4gIFRoaXMgaGVscHMgZGVidWcgcHJvYmxlbXMgd2l0aCB0aGUgbW9kZWxcbiAqIGRyaXZpbmcgdGhlIHJhbmdlIGNvZGVyLlxuICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9SYW5nZUNvZGVyJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoUmFuZ2VDb2RlcixVdGlsKXtcbiAgICB2YXIgRHVtbXkgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgUmFuZ2VDb2Rlci5jYWxsKHRoaXMsIHN0cmVhbSk7XG4gICAgfTtcbiAgICBEdW1teS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJhbmdlQ29kZXIucHJvdG90eXBlKTtcbiAgICBEdW1teS5wcm90b3R5cGUuX3dyaXRlOCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgVXRpbC53cml0ZVVuc2lnbmVkTnVtYmVyKHRoaXMuc3RyZWFtLCBiKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGVCeXRlKGIpO1xuICAgIH07XG4gICAgRHVtbXkucHJvdG90eXBlLl93cml0ZTE2ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZUJ5dGUoKHMgPj4+IDgpICYgMHhGRik7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlQnl0ZShzICYgMHhGRik7XG4gICAgfTtcbiAgICBEdW1teS5wcm90b3R5cGUuX3JlYWQ4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIH07XG4gICAgRHVtbXkucHJvdG90eXBlLl9yZWFkMTYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhpID0gdGhpcy5zdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgdmFyIGxvID0gdGhpcy5zdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChoaTw8OCkgfCBsbztcbiAgICB9O1xuICAgIER1bW15LnByb3RvdHlwZS5lbmNvZGVTdGFydCA9IGZ1bmN0aW9uKGMsIGluaXRsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGVCeXRlKGMpO1xuICAgIH07XG4gICAgRHVtbXkucHJvdG90eXBlLmVuY29kZUZyZXEgPSBmdW5jdGlvbihzeV9mLCBsdF9mLCB0b3RfZikge1xuICAgICAgICBjb25zb2xlLmFzc2VydChzeV9mID4gMCk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRvdF9mID4gMCk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRvdF9mIDw9ICgxPDwyMykpO1xuICAgICAgICBpZiAoKHN5X2YgKyBsdF9mKSA+IHRvdF9mKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdkdW1teSBjb2RlcjogbHRfZiArIHN5X2YgPiB0b3RfZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN5X2YsIGx0X2YsIHRvdF9mKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLndyaXRlVW5zaWduZWROdW1iZXIodGhpcy5zdHJlYW0sIHN5X2YpO1xuICAgICAgICBVdGlsLndyaXRlVW5zaWduZWROdW1iZXIodGhpcy5zdHJlYW0sIGx0X2YpO1xuICAgICAgICBVdGlsLndyaXRlVW5zaWduZWROdW1iZXIodGhpcy5zdHJlYW0sIHRvdF9mKTtcbiAgICB9O1xuICAgIER1bW15LnByb3RvdHlwZS5lbmNvZGVTaGlmdCA9IGZ1bmN0aW9uKHN5X2YsIGx0X2YsIHNoaWZ0KSB7XG4gICAgICAgIHRoaXMuZW5jb2RlRnJlcShzeV9mLCBsdF9mLCAxIDw8IHNoaWZ0KTtcbiAgICB9O1xuICAgIER1bW15LnByb3RvdHlwZS5lbmNvZGVGaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBEdW1teS5wcm90b3R5cGUuZGVjb2RlU3RhcnQgPSBmdW5jdGlvbihza2lwSW5pdGlhbFJlYWQpIHtcbiAgICAgICAgcmV0dXJuIHNraXBJbml0aWFsUmVhZCA/IDAgOiB0aGlzLnN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIH07XG4gICAgRHVtbXkucHJvdG90eXBlLmRlY29kZUN1bEZyZXEgPSBmdW5jdGlvbih0b3RfZikge1xuICAgICAgICBjb25zb2xlLmFzc2VydCh0b3RfZiA+IDApO1xuICAgICAgICB0aGlzLnN5X2YgPSBVdGlsLnJlYWRVbnNpZ25lZE51bWJlcih0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMubHRfZiA9IFV0aWwucmVhZFVuc2lnbmVkTnVtYmVyKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy50b3RfZj0gVXRpbC5yZWFkVW5zaWduZWROdW1iZXIodGhpcy5zdHJlYW0pO1xuICAgICAgICBpZiAodG90X2YgIT09IHRoaXMudG90X2YpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RlY29kZUN1bCogd3JvbmcgdG90YWw6IGdvdCcsIHRvdF9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZXhwZWN0ZWQnLCB0aGlzLnRvdF9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuc3lfZj4+PjEpICsgdGhpcy5sdF9mO1xuICAgIH07XG4gICAgRHVtbXkucHJvdG90eXBlLmRlY29kZUN1bFNoaWZ0ID0gZnVuY3Rpb24oc2hpZnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQ3VsRnJlcSgxPDxzaGlmdCk7XG4gICAgfTtcbiAgICBEdW1teS5wcm90b3R5cGUuZGVjb2RlVXBkYXRlID0gZnVuY3Rpb24oc3lfZiwgbHRfZiwgdG90X2YpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoc3lfZiA+IDApO1xuICAgICAgICBjb25zb2xlLmFzc2VydCh0b3RfZiA+IDApO1xuICAgICAgICBpZiAoc3lfZiAhPT0gdGhpcy5zeV9mIHx8XG4gICAgICAgICAgICBsdF9mICE9PSB0aGlzLmx0X2YgfHxcbiAgICAgICAgICAgIHRvdF9mIT09IHRoaXMudG90X2YpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RlY29kZVVwZGF0ZSB3cm9uZyBwYXJhbWV0ZXJzOyBnb3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzeV9mLCBsdF9mLCB0b3RfZiwgJ2V4cGVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeV9mLCB0aGlzLmx0X2YsIHRoaXMudG90X2YpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEdW1teS5wcm90b3R5cGUuZGVjb2RlRmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcblxuICAgIHJldHVybiBEdW1teTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiogUmFuZ2UgY29kaW5nIG1vZGVsIGJhc2VkIG9uIEZlbndpY2sgdHJlZXMgZm9yIE8obG4gTikgcXVlcnkvdXBkYXRlLiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vUmFuZ2VDb2RlcicpLFxuXHRyZXF1aXJlKCcuL1N0cmVhbScpLFxuXHRyZXF1aXJlKCcuL1V0aWwnKVxuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKFJhbmdlQ29kZXIsU3RyZWFtLFV0aWwpe1xuXG4vKiogV2Ugc3RvcmUgdHdvIHByb2JhYmlsaXRpZXMgaW4gYSBVMzIsIHNvIG1heCBwcm9iIGlzIGdvaW5nIHRvIGJlIDB4RkZGRiAqL1xudmFyIERFRkFVTFRfTUFYX1BST0IgPSAweEZGMDA7XG52YXIgREVGQVVMVF9JTkNSRU1FTlQ9IDB4MDEwMDtcblxudmFyIEVTQ19NQVNLID0gMHgwMDAwRkZGRiwgRVNDX1NISUZUID0gMDtcbnZhciBTWU1fTUFTSyA9IDB4RkZGRjAwMDAsIFNZTV9TSElGVCA9IDE2O1xudmFyIFNDQUxFX01BU0s9MHhGRkZFRkZGRTtcblxudmFyIEZlbndpY2tNb2RlbCA9IGZ1bmN0aW9uKGNvZGVyLCBzaXplLCBtYXhfcHJvYiwgaW5jcmVtZW50KSB7XG4gICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgIHRoaXMubnVtU3ltcyA9IHNpemUgKyAxOyAvLyBzYXZlIHNwYWNlIGZvciBhbiBlc2NhcGUgc3ltYm9sXG4gICAgdGhpcy50cmVlID0gVXRpbC5tYWtlVTMyQnVmZmVyKHRoaXMubnVtU3ltcyoyKTtcbiAgICB0aGlzLmluY3JlbWVudCA9ICgraW5jcmVtZW50KSB8fCBERUZBVUxUX0lOQ1JFTUVOVDtcbiAgICB0aGlzLm1heF9wcm9iID0gKCttYXhfcHJvYikgfHwgREVGQVVMVF9NQVhfUFJPQjtcbiAgICAvLyBzYW5pdHktY2hlY2sgdG8gcHJldmVudCBvdmVyZmxvdy5cbiAgICBjb25zb2xlLmFzc2VydCgodGhpcy5tYXhfcHJvYiArICh0aGlzLmluY3JlbWVudC0xKSkgPD0gMHhGRkZGKTtcbiAgICBjb25zb2xlLmFzc2VydChzaXplIDw9IDB4RkZGRik7XG4gICAgLy8gcmVjb3JkIGVzY2FwZSBwcm9iYWJpbGl0eSBhcyAxLlxuICAgIHZhciBpO1xuICAgIGZvciAoaT0wOyBpPHNpemU7IGkrKykge1xuICAgICAgICB0aGlzLnRyZWVbdGhpcy5udW1TeW1zICsgaV0gPSAvLyBlc2NhcGUgcHJvYj0xLCBzeW0gcHJvYiA9IDBcbiAgICAgICAgICAgICgxIDw8IEVTQ19TSElGVCkgfCAoMCA8PCBTWU1fU0hJRlQpO1xuICAgIH1cbiAgICB0aGlzLnRyZWVbdGhpcy5udW1TeW1zICsgaV0gPSAvLyBlc2NhcGUgcHJvYiA9IDAsIHN5bSBwcm9iID0gMVxuICAgICAgICAoMCA8PCBFU0NfU0hJRlQpIHwgKHRoaXMuaW5jcmVtZW50IDw8IFNZTV9TSElGVCk7XG4gICAgdGhpcy5fc3VtVHJlZSgpO1xuICAgIC8vIHByb2JhYmlsaXR5IHN1bXMgYXJlIGluIHRoaXMudHJlZVsxXS4gIHRoaXMudHJlZVswXSBpcyB1bnVzZWQuXG59O1xuRmVud2lja01vZGVsLmZhY3RvcnkgPSBmdW5jdGlvbihjb2RlciwgbWF4X3Byb2IsIGluY3JlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmVud2lja01vZGVsKGNvZGVyLCBzaXplLCBtYXhfcHJvYiwgaW5jcmVtZW50KTtcbiAgICB9O1xufTtcbkZlbndpY2tNb2RlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3TW9kZWwgPSBuZXcgRmVud2lja01vZGVsKHRoaXMuY29kZXIsIHRoaXMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4X3Byb2IsIHRoaXMuaW5jcmVtZW50KTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGk9MTsgaTx0aGlzLnRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3TW9kZWwudHJlZVtpXSA9IHRoaXMudHJlZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01vZGVsO1xufTtcbkZlbndpY2tNb2RlbC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgdmFyIGkgPSB0aGlzLm51bVN5bXMgKyBzeW1ib2w7XG4gICAgdmFyIHN5X2YgPSB0aGlzLnRyZWVbaV07XG4gICAgdmFyIG1hc2sgPSBTWU1fTUFTSywgc2hpZnQgPSBTWU1fU0hJRlQ7XG4gICAgdmFyIHVwZGF0ZSA9ICh0aGlzLmluY3JlbWVudCA8PCBTWU1fU0hJRlQpO1xuXG4gICAgaWYgKChzeV9mICYgU1lNX01BU0spID09PSAwKSB7IC8vIGVzY2FwZSFcbiAgICAgICAgdGhpcy5lbmNvZGUodGhpcy5udW1TeW1zLTEpO1xuICAgICAgICBtYXNrID0gRVNDX01BU0s7XG4gICAgICAgIHVwZGF0ZSAtPSAoMTw8RVNDX1NISUZUKTsgLy8gbm90IGdvaW5nIHRvIGVzY2FwZSBubyBtbydcbiAgICAgICAgc2hpZnQgPSBFU0NfU0hJRlQ7XG4gICAgfSBlbHNlIGlmIChzeW1ib2wgPT09ICh0aGlzLm51bVN5bXMtMSkgJiZcbiAgICAgICAgICAgICAgICgodGhpcy50cmVlWzFdICYgRVNDX01BU0spID4+PiBFU0NfU0hJRlQpID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3QgZXNjYXBlLCB6ZXJvIGl0IG91dFxuICAgICAgICB1cGRhdGUgPSAtdGhpcy50cmVlW2ldO1xuICAgIH1cbiAgICAvLyBzdW0gdXAgdGhlIHByb3BlciBsdF9mXG4gICAgdmFyIGx0X2YgPSAwO1xuICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICB2YXIgaXNSaWdodCA9IChpICYgMSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSAoaSA+Pj4gMSk7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHRoZSByaWdodCBjaGlsZCwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgdGhlIHByb2IgZnJvbSB0aGUgbGVmdCBjaGlsZFxuICAgICAgICBpZiAoaXNSaWdodCkge1xuICAgICAgICAgICAgbHRfZiArPSB0aGlzLnRyZWVbMipwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBzdW1zXG4gICAgICAgIHRoaXMudHJlZVtpXSArPSB1cGRhdGU7IC8vIGluY3JlYXNlIHN5bSAvIGRlY3JlYXNlIGVzY1xuICAgICAgICBpID0gcGFyZW50O1xuICAgIH1cbiAgICB2YXIgdG90X2YgPSB0aGlzLnRyZWVbMV07XG4gICAgdGhpcy50cmVlWzFdICs9IHVwZGF0ZTsgLy8gdXBkYXRlIHByb2IgaW4gcm9vdFxuICAgIHN5X2YgPSAoc3lfZiAmIG1hc2spID4+PiBzaGlmdDtcbiAgICBsdF9mID0gKGx0X2YgJiBtYXNrKSA+Pj4gc2hpZnQ7XG4gICAgdG90X2YgPSh0b3RfZiYgbWFzaykgPj4+IHNoaWZ0O1xuICAgIHRoaXMuY29kZXIuZW5jb2RlRnJlcShzeV9mLCBsdF9mLCB0b3RfZik7XG4gICAgLy8gcmVzY2FsZT9cbiAgICBpZiAoKCggdGhpcy50cmVlWzFdICYgU1lNX01BU0sgKSA+Pj4gU1lNX1NISUZUKSA+PSB0aGlzLm1heF9wcm9iKSB7XG4gICAgICAgIHRoaXMuX3Jlc2NhbGUoKTtcbiAgICB9XG59O1xuRmVud2lja01vZGVsLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oaXNFc2NhcGUpIHtcbiAgICB2YXIgbWFzayA9IFNZTV9NQVNLLCBzaGlmdCA9IFNZTV9TSElGVDtcbiAgICB2YXIgdXBkYXRlID0gKHRoaXMuaW5jcmVtZW50IDw8IFNZTV9TSElGVCk7XG4gICAgaWYgKGlzRXNjYXBlKSB7XG4gICAgICAgIG1hc2sgPSBFU0NfTUFTSztcbiAgICAgICAgdXBkYXRlIC09ICgxIDw8IEVTQ19TSElGVCk7XG4gICAgICAgIHNoaWZ0ID0gRVNDX1NISUZUO1xuICAgIH1cbiAgICB2YXIgdG90X2YgPSAodGhpcy50cmVlWzFdICYgbWFzaykgPj4+IHNoaWZ0O1xuICAgIHZhciBwcm9iID0gdGhpcy5jb2Rlci5kZWNvZGVDdWxGcmVxKHRvdF9mKTtcbiAgICAvLyB0cmF2ZWwgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciB0aGlzXG4gICAgdmFyIGkgPSAxLCBsdF9mID0gMDtcbiAgICB3aGlsZSAoaSA8IHRoaXMubnVtU3ltcykge1xuICAgICAgICB0aGlzLnRyZWVbaV0gKz0gdXBkYXRlO1xuICAgICAgICAvLyBsb29rIGF0IHByb2JhYmlsaXR5IGluIGxlZnQgY2hpbGQuXG4gICAgICAgIHZhciBsZWZ0UHJvYiA9ICh0aGlzLnRyZWVbMippXSAmIG1hc2spID4+PiBzaGlmdDtcbiAgICAgICAgaSAqPSAyO1xuICAgICAgICBpZiAoKHByb2ItbHRfZikgPj0gbGVmdFByb2IpIHtcbiAgICAgICAgICAgIGx0X2YgKz0gbGVmdFByb2I7XG4gICAgICAgICAgICBpKys7IC8vIHRha2UgdGhlIHJpZ2h0IGNoaWxkLlxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzeW1ib2wgPSBpIC0gdGhpcy5udW1TeW1zO1xuICAgIHZhciBzeV9mID0gKHRoaXMudHJlZVtpXSAmIG1hc2spID4+PiBzaGlmdDtcbiAgICB0aGlzLnRyZWVbaV0gKz0gdXBkYXRlO1xuICAgIHRoaXMuY29kZXIuZGVjb2RlVXBkYXRlKHN5X2YsIGx0X2YsIHRvdF9mKTtcbiAgICAvLyB3YXMgdGhpcyB0aGUgbGFzdCBlc2NhcGU/XG4gICAgaWYgKHN5bWJvbCA9PT0gKHRoaXMubnVtU3ltcy0xKSAmJlxuICAgICAgICAoKHRoaXMudHJlZVsxXSAmIEVTQ19NQVNLKSA+Pj4gRVNDX1NISUZUKSA9PT0gMSkge1xuICAgICAgICB1cGRhdGUgPSAtdGhpcy50cmVlW2ldOyAvLyB6ZXJvIGl0IG91dFxuICAgICAgICB3aGlsZSAoaSA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVbaV0gKz0gdXBkYXRlO1xuICAgICAgICAgICAgaSA9IChpID4+PiAxKTsgLy8gcGFyZW50XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVzY2FsZT9cbiAgICBpZiAoKCggdGhpcy50cmVlWzFdICYgU1lNX01BU0sgKSA+Pj4gU1lNX1NISUZUKSA+PSB0aGlzLm1heF9wcm9iKSB7XG4gICAgICAgIHRoaXMuX3Jlc2NhbGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbDtcbn07XG5GZW53aWNrTW9kZWwucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzeW1ib2wgPSB0aGlzLl9kZWNvZGUoZmFsc2UpOyAvLyBub3QgZXNjYXBlXG4gICAgaWYgKHN5bWJvbCA9PT0gKHRoaXMubnVtU3ltcy0xKSkge1xuICAgICAgICAvLyB0aGlzIHdhcyBhbiBlc2NhcGUhXG4gICAgICAgIHN5bWJvbCA9IHRoaXMuX2RlY29kZSh0cnVlKTsgLy8gYW4gZXNjYXBlIVxuICAgIH1cbiAgICByZXR1cm4gc3ltYm9sO1xufTtcbkZlbndpY2tNb2RlbC5wcm90b3R5cGUuX3Jlc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgcHJvYiwgbm9Fc2NhcGUgPSB0cnVlO1xuICAgIC8vIHNjYWxlIHN5bWJvbHMgKHBvc3NpYmxlIGNhdXNpbmcgdGhlbSB0byBlc2NhcGUpXG4gICAgZm9yIChpPTA7IGkgPCB0aGlzLm51bVN5bXMtMTsgaSsrKSB7XG4gICAgICAgIHByb2IgPSB0aGlzLnRyZWVbdGhpcy5udW1TeW1zICsgaV07XG4gICAgICAgIGlmICgocHJvYiAmIEVTQ19NQVNLKSAhPT0gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyBzeW1ib2wgZXNjYXBlc1xuICAgICAgICAgICAgbm9Fc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHByb2IgPSAocHJvYiAmIFNDQUxFX01BU0spID4+PiAxO1xuICAgICAgICBpZiAocHJvYiA9PT0gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyBzeW1ib2wgbmV3bHkgZXNjYXBlc1xuICAgICAgICAgICAgcHJvYiA9ICgxIDw8IEVTQ19TSElGVCk7XG4gICAgICAgICAgICBub0VzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJlZVt0aGlzLm51bVN5bXMgKyBpXSA9IHByb2I7XG4gICAgfVxuICAgIC8vIHNjYWxlIHRoZSBlc2NhcGUgc3ltYm9sXG4gICAgcHJvYiA9IHRoaXMudHJlZVt0aGlzLm51bVN5bXMgKyBpXTtcbiAgICBwcm9iID0gKHByb2IgJiBTQ0FMRV9NQVNLKSA+Pj4gMTtcbiAgICAvLyBwcm9iIHNob3VsZCBiZSB6ZXJvIGlmIHRoZXJlIGFyZSBubyBlc2NhcGluZyBzeW1ib2xzLCBvdGhlcndpc2VcbiAgICAvLyBpdCBtdXN0IGJlIGF0IGxlYXN0IDEuXG4gICAgaWYgKG5vRXNjYXBlKSB7IHByb2IgPSAwOyB9XG4gICAgZWxzZSBpZiAocHJvYiA9PT0gMCkgeyBwcm9iID0gKDEgPDwgU1lNX1NISUZUKTsgfVxuICAgIHRoaXMudHJlZVt0aGlzLm51bVN5bXMgKyBpXSA9IHByb2I7XG4gICAgLy8gc3VtIGl0IGFsbCB1cCBhZnJlc2hcbiAgICB0aGlzLl9zdW1UcmVlKCk7XG59O1xuRmVud2lja01vZGVsLnByb3RvdHlwZS5fc3VtVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpO1xuICAgIC8vIHN1bSBpdCBhbGwuICh3ZSBrbm93IHdlIHdvbid0IG92ZXJmbG93KVxuICAgIGZvciAoaT10aGlzLm51bVN5bXMgLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMudHJlZVtpXSA9IHRoaXMudHJlZVsyKmldICsgdGhpcy50cmVlWzIqaSArIDFdO1xuICAgIH1cbn07XG5cbkZlbndpY2tNb2RlbC5NQUdJQyA9ICdmZW53Jztcbi8qKiBTaW1wbGUgb3JkZXItMCBjb21wcmVzc29yLCBhcyBzZWxmLXRlc3QuICovXG5GZW53aWNrTW9kZWwuY29tcHJlc3NGaWxlID0gVXRpbC5jb21wcmVzc0ZpbGVIZWxwZXIoRmVud2lja01vZGVsLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSwgcHJvcHMsIGZpbmFsQnl0ZSkge1xuICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZUNvZGVyKG91dFN0cmVhbSk7XG4gICAgcmFuZ2UuZW5jb2RlU3RhcnQoZmluYWxCeXRlLCAxKTtcbiAgICB2YXIgbW9kZWwgPSBuZXcgRmVud2lja01vZGVsKHJhbmdlLCAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICAgIFV0aWwuY29tcHJlc3NXaXRoTW9kZWwoaW5TdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gICAgcmFuZ2UuZW5jb2RlRmluaXNoKCk7XG59LCB0cnVlKTtcblxuLyoqIFNpbXBsZSBvcmRlci0wIGRlY29tcHJlc3NlciwgYXMgc2VsZi10ZXN0LiAqL1xuRmVud2lja01vZGVsLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihGZW53aWNrTW9kZWwuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplKSB7XG4gICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlQ29kZXIoaW5TdHJlYW0pO1xuICAgIHJhbmdlLmRlY29kZVN0YXJ0KHRydWUvKmFscmVhZHkgcmVhZCB0aGUgZmluYWwgYnl0ZSovKTtcbiAgICB2YXIgbW9kZWwgPSBuZXcgRmVud2lja01vZGVsKHJhbmdlLCAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICAgIFV0aWwuZGVjb21wcmVzc1dpdGhNb2RlbChvdXRTdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gICAgcmFuZ2UuZGVjb2RlRmluaXNoKCk7XG59KTtcblxucmV0dXJuIEZlbndpY2tNb2RlbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiBBZGFwdGl2ZSBIdWZmbWFuIGNvZGUsIHVzaW5nIFZpdHRlcidzIGFsZ29yaXRobSBwb3J0ZWQgZnJvbVxuICogdml0dGVyLmMgYXQgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2NvbXByZXNzaW9uLWNvZGUvZG93bmxvYWRzL2xpc3RcbiAqIFRoZSBvcmlnaW5hbCBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4sIGFuZCBzbyBJXG4gKiBhbHNvIHBsYWNlIHRoaXMgSmF2YVNjcmlwdCBwb3J0IGluIHRoZSBwdWJsaWMgZG9tYWluLlxuICogICAtLSBDLiBTY290dCBBbmFuaWFuIDxjc2NvdHRAY3Njb3R0Lm5ldD4sIDIwMTNcbiAqIHBzLiBzb21lIHRydWx5IGdyb3R0eSBDIGNvZGUgaW4gdGhlIG9yaWdpbmFsbHksIGZhaXRoZnVsbHkgcG9ydGVkIHRvXG4gKiAgICAgZXZpbCBjb21tYS1vcGVyYXRvci11c2luZywgYXNzaWdubWVudC1pbi1pZi1jb25kaXRpb24gSmF2YVNjcmlwdC5cbiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vQml0U3RyZWFtJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoQml0U3RyZWFtLFV0aWwpIHtcbi8vICBUaGlzIGNvZGUgaXMgYWRhcHRlZCBmcm9tIFByb2Zlc3NvciBWaXR0ZXInc1xuLy8gIGFydGljbGUsIERlc2lnbiBhbmQgQW5hbHlzaXMgb2YgRHluYW1pYyBIdWZmbWFuIENvZGVzLFxuLy8gIHdoaWNoIGFwcGVhcmVkIGluIEpBQ00gT2N0b2JlciAxOTg3XG5cbi8vICBBIGRlc2lnbiB0cmFkZS1vZmYgaGFzIGJlZW4gbWFkZSB0byBzaW1wbGlmeSB0aGVcbi8vICBjb2RlOiAgYSBub2RlJ3MgYmxvY2sgaXMgZGV0ZXJtaW5lZCBkeW5hbWljYWxseSxcbi8vICBhbmQgdGhlIGltcGxpY2l0IHRyZWUgc3RydWN0dXJlIGlzIG1haW50YWluZWQsXG4vLyAgZS5nLiBleHBsaWNpdCBub2RlIG51bWJlcnMgYXJlIGFsc28gaW1wbGljaXQuXG5cbi8vICBEeW5hbWljIEh1ZmZtYW4gdGFibGUgd2VpZ2h0IHJhbmtpbmdcbi8vICBpcyBtYWludGFpbmVkIHBlciBQcm9mZXNzb3IgVml0dGVyJ3Ncbi8vICBpbnZhcmlhbnQgKCopIGZvciBhbGdvcml0aG0gRkdLOlxuXG4vLyAgbGVhdmVzIHByZWNlZGUgaW50ZXJuYWwgbm9kZXMgb2YgdGhlXG4vLyAgc2FtZSB3ZWlnaHQgaW4gYSBub24tZGVjcmVhc2luZyByYW5raW5nXG4vLyAgb2Ygd2VpZ2h0cyB1c2luZyBpbXBsaWNpdCBub2RlIG51bWJlcnM6XG5cbi8vICAxKSBsZWF2ZXMgc2xpZGUgb3ZlciBpbnRlcm5hbCBub2RlcywgaW50ZXJuYWwgbm9kZXNcbi8vICBzd2FwIG92ZXIgZ3JvdXBzIG9mIGxlYXZlcywgbGVhdmVzIGFyZSBzd2FwcGVkXG4vLyAgaW50byBncm91cCBsZWFkZXIgcG9zaXRpb24sIGJ1dCB0d28gaW50ZXJuYWxcbi8vICBub2RlcyBuZXZlciBjaGFuZ2UgcG9zaXRpb25zIHJlbGF0aXZlXG4vLyAgdG8gb25lIGFub3RoZXIuXG5cbi8vICAyKSB3ZWlnaHRzIGFyZSBpbmNyZW1lbnRlZCBieSAyOlxuLy8gIGxlYXZlcyBhbHdheXMgaGF2ZSBldmVuIHdlaWdodCB2YWx1ZXM7XG4vLyAgaW50ZXJuYWwgbm9kZXMgYWx3YXlzIGhhdmUgb2RkIHZhbHVlcy5cblxuLy8gIDMpIGV2ZW4gbm9kZSBudW1iZXJzIGFyZSBhbHdheXMgcmlnaHQgY2hpbGRyZW47XG4vLyAgb2RkIG51bWJlcnMgYXJlIGxlZnQgY2hpbGRyZW4gaW4gdGhlIHRyZWUuXG5cbi8vICBub2RlIDIgKiBIdWZmU2l6ZSAtIDEgaXMgYWx3YXlzIHRoZSB0cmVlIHJvb3Q7XG4vLyAgbm9kZSBIdWZmRXNjIGlzIHRoZSBlc2NhcGUgbm9kZTtcblxuLy8gIHRoZSB0cmVlIGlzIGluaXRpYWxpemVkIGJ5IGNyZWF0aW5nIGFuXG4vLyAgZXNjYXBlIG5vZGUgYXMgdGhlIHJvb3QuXG5cbi8vICBlYWNoIG5ldyBsZWFmIHN5bWJvbCBpcyBwYWlyZWQgd2l0aCBhIG5ldyBlc2NhcGVcbi8vICBub2RlIGludG8gdGhlIHByZXZpb3VzIGVzY2FwZSBub2RlIGluIHRoZSB0cmVlLFxuLy8gIHVudGlsIHRoZSBsYXN0IHN5bWJvbCB3aGljaCB0YWtlcyBvdmVyIHRoZVxuLy8gIHRyZWUgcG9zaXRpb24gb2YgdGhlIGVzY2FwZSBub2RlLCBhbmRcbi8vICBIdWZmRXNjIGlzIGxlZnQgYXQgemVyby5cblxuLy8gIG92ZXJhbGwgdGFibGUgc2l6ZTogMiAqIEh1ZmZTaXplXG5cbi8vICBodWZmX2luaXQoYWxwaGFiZXRfc2l6ZSwgcG90ZW50aWFsIHN5bWJvbHMgdXNlZClcbi8vICBodWZmX2VuY29kZShuZXh0X3N5bWJvbClcbi8vICBuZXh0X3N5bWJvbCA9IGh1ZmZfZGVjb2RlKClcblxuLy8gIGh1ZmZfc2NhbGUoYnlfYml0cykgLS0gc2NhbGUgd2VpZ2h0cyBhbmQgcmUtYmFsYW5jZSB0cmVlXG5cbnZhciBIVGFibGUgPSBmdW5jdGlvbih1cCwgZG93biwgc3ltYm9sLCB3ZWlnaHQpIHtcbiAgICB0aGlzLnVwID0gdXA7IC8vIG5leHQgbm9kZSB1cCB0aGUgdHJlZVxuICAgIHRoaXMuZG93biA9IGRvd247IC8vIHBhaXIgb2YgZG93biBub2Rlc1xuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sOyAgICAgICAvLyBub2RlIHN5bWJvbCB2YWx1ZVxuICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0OyAgICAgICAvLyBub2RlIHdlaWdodFxufTtcbkhUYWJsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBIVGFibGUodGhpcy51cCwgdGhpcy5kb3duLCB0aGlzLnN5bWJvbCwgdGhpcy53ZWlnaHQpO1xufTtcbkhUYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaHRhYmxlKSB7XG4gIHRoaXMudXAgPSBodGFibGUudXA7XG4gIHRoaXMuZG93biA9IGh0YWJsZS5kb3duO1xuICB0aGlzLnN5bWJvbCA9IGh0YWJsZS5zeW1ib2w7XG4gIHRoaXMud2VpZ2h0ID0gaHRhYmxlLndlaWdodDtcbn07XG5cbi8vICBpbml0aWFsaXplIGFuIGFkYXB0aXZlIGNvZGVyXG4vLyAgZm9yIGFscGhhYmV0IHNpemUsIGFuZCBjb3VudFxuLy8gIG9mIG5vZGVzIHRvIGJlIHVzZWRcbnZhciBIdWZmbWFuID0gZnVuY3Rpb24oc2l6ZSwgcm9vdCwgYml0c3RyZWFtLCBtYXhfd2VpZ2h0KSB7XG4gIHZhciBpO1xuICAvLyAgZGVmYXVsdDogYWxsIGFscGhhYmV0IHN5bWJvbHMgYXJlIHVzZWRcblxuICBjb25zb2xlLmFzc2VydChzaXplICYmIHR5cGVvZihzaXplKT09PSdudW1iZXInKTtcbiAgaWYoICFyb290IHx8IHJvb3QgPiBzaXplIClcbiAgICAgIHJvb3QgPSBzaXplO1xuXG4gIC8vICBjcmVhdGUgdGhlIGluaXRpYWwgZXNjYXBlIG5vZGVcbiAgLy8gIGF0IHRoZSB0cmVlIHJvb3RcblxuICBpZiAoIHJvb3QgPDw9IDEgKSB7XG4gICAgICByb290LS07XG4gIH1cblxuICAvLyBjcmVhdGUgcm9vdCsxIGh0YWJsZXMgKGNvZGluZyB0YWJsZSlcbiAgLy8gWFhYIHRoaXMgY291bGQgYmUgdmlld3Mgb24gYSBiYWNraW5nIFVpbnQzMiBhcnJheT9cbiAgdGhpcy50YWJsZSA9IFtdO1xuICBmb3IgKGk9MDsgaTw9cm9vdDsgaSsrKSB7XG4gICAgdGhpcy50YWJsZVtpXSA9IG5ldyBIVGFibGUoMCwwLDAsMCk7XG4gIH1cblxuICAvLyB0aGlzLm1hcCA9PiBtYXBwaW5nIGZvciBzeW1ib2xzIHRvIG5vZGVzXG4gIHRoaXMubWFwID0gW107XG4gIC8vIHRoaXMuc2l6ZSA9PiB0aGUgYWxwaGFiZXQgc2l6ZVxuICBpZiggdGhpcy5zaXplID0gc2l6ZSApIHtcbiAgICBmb3IgKGk9MDsgaTxzaXplOyBpKyspIHtcbiAgICAgIHRoaXMubWFwW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzLmVzYyAgPT4gdGhlIGN1cnJlbnQgdHJlZSBoZWlnaHRcbiAgLy8gdGhpcy5yb290ID0+IHRoZSByb290IG9mIHRoZSB0cmVlXG4gIHRoaXMuZXNjID0gdGhpcy5yb290ID0gcm9vdDtcblxuICBpZiAoYml0c3RyZWFtKSB7XG4gICAgdGhpcy5yZWFkQml0ID0gYml0c3RyZWFtLnJlYWRCaXQuYmluZChiaXRzdHJlYW0pO1xuICAgIHRoaXMud3JpdGVCaXQgPSBiaXRzdHJlYW0ud3JpdGVCaXQuYmluZChiaXRzdHJlYW0pO1xuICB9XG4gIHRoaXMubWF4X3dlaWdodCA9IG1heF93ZWlnaHQ7IC8vIG1heSBiZSBudWxsIG9yIHVuZGVmaW5lZFxufVxuLy8gZmFjdG9yeSBpbnRlcmZhY2Vcbkh1ZmZtYW4uZmFjdG9yeSA9IGZ1bmN0aW9uKGJpdHN0cmVhbSwgbWF4X3dlaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBuZXcgSHVmZm1hbihzaXplLCBzaXplLCBiaXRzdHJlYW0sIG1heF93ZWlnaHQpO1xuICB9O1xufTtcblxuXG4vLyBzcGxpdCBlc2NhcGUgbm9kZSB0byBpbmNvcnBvcmF0ZSBuZXcgc3ltYm9sXG5cbkh1ZmZtYW4ucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24oc3ltYm9sKSB7XG4gIHZhciBwYWlyLCBub2RlO1xuXG4gIC8vICBpcyB0aGUgdHJlZSBhbHJlYWR5IGZ1bGw/Pz9cblxuICBpZiggcGFpciA9IHRoaXMuZXNjICkge1xuICAgIHRoaXMuZXNjLS07XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ltYm9sLCBpdCBtb3ZlcyBpbnRvXG4gIC8vICB0aGUgZXNjYXBlIG5vZGUncyBvbGQgcG9zaXRpb24sIGFuZFxuICAvLyAgdGhpcy5lc2MgaXMgc2V0IHRvIHplcm8uXG5cbiAgLy8gIG90aGVyd2lzZSwgdGhlIGVzY2FwZSBub2RlIGlzIHByb21vdGVkIHRvXG4gIC8vICBwYXJlbnQgYSBuZXcgZXNjYXBlIG5vZGUgYW5kIHRoZSBuZXcgc3ltYm9sLlxuXG4gIGlmKCBub2RlID0gdGhpcy5lc2MgKSB7XG4gICAgdGhpcy50YWJsZVtwYWlyXS5kb3duID0gbm9kZTtcbiAgICB0aGlzLnRhYmxlW3BhaXJdLndlaWdodCA9IDE7XG4gICAgdGhpcy50YWJsZVtub2RlXS51cCA9IHBhaXI7XG4gICAgdGhpcy5lc2MtLTtcbiAgfSBlbHNlIHtcbiAgICBwYWlyID0gMDtcbiAgICBub2RlID0gMTtcbiAgfVxuXG4gIC8vICBpbml0aWFsaXplIHRoZSBuZXcgc3ltYm9sIG5vZGVcblxuICB0aGlzLnRhYmxlW25vZGVdLnN5bWJvbCA9IHN5bWJvbDtcbiAgdGhpcy50YWJsZVtub2RlXS53ZWlnaHQgPSAwO1xuICB0aGlzLnRhYmxlW25vZGVdLmRvd24gPSAwO1xuICB0aGlzLm1hcFtzeW1ib2xdID0gbm9kZTtcblxuICAvLyAgaW5pdGlhbGl6ZSBhIG5ldyBlc2NhcGUgbm9kZS5cblxuICB0aGlzLnRhYmxlW3RoaXMuZXNjXS53ZWlnaHQgPSAwO1xuICB0aGlzLnRhYmxlW3RoaXMuZXNjXS5kb3duID0gMDtcbiAgdGhpcy50YWJsZVt0aGlzLmVzY10udXAgPSBwYWlyO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbi8vICBzd2FwIGxlYWYgdG8gZ3JvdXAgbGVhZGVyIHBvc2l0aW9uXG4vLyAgcmV0dXJuIHN5bWJvbCdzIG5ldyBub2RlXG5cbkh1ZmZtYW4ucHJvdG90eXBlLmxlYWRlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHdlaWdodCA9IHRoaXMudGFibGVbbm9kZV0ud2VpZ2h0O1xuICB2YXIgbGVhZGVyID0gbm9kZSwgcHJldiwgc3ltYm9sO1xuXG4gIHdoaWxlKCB3ZWlnaHQgPT09IHRoaXMudGFibGVbbGVhZGVyICsgMV0ud2VpZ2h0ICkge1xuICAgIGxlYWRlcisrO1xuICB9XG5cbiAgaWYoIGxlYWRlciA9PT0gbm9kZSApIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIHN3YXAgdGhlIGxlYWYgbm9kZXNcblxuICBzeW1ib2wgPSB0aGlzLnRhYmxlW25vZGVdLnN5bWJvbDtcbiAgcHJldiA9IHRoaXMudGFibGVbbGVhZGVyXS5zeW1ib2w7XG5cbiAgdGhpcy50YWJsZVtsZWFkZXJdLnN5bWJvbCA9IHN5bWJvbDtcbiAgdGhpcy50YWJsZVtub2RlXS5zeW1ib2wgPSBwcmV2O1xuICB0aGlzLm1hcFtzeW1ib2xdID0gbGVhZGVyO1xuICB0aGlzLm1hcFtwcmV2XSA9IG5vZGU7XG4gIHJldHVybiBsZWFkZXI7XG59O1xuXG4vLyAgc2xpZGUgaW50ZXJuYWwgbm9kZSB1cCBvdmVyIGFsbCBsZWF2ZXMgb2YgZXF1YWwgd2VpZ2h0O1xuLy8gIG9yIGV4Y2hhbmdlIGxlYWYgd2l0aCBuZXh0IHNtYWxsZXIgd2VpZ2h0IGludGVybmFsIG5vZGVcblxuLy8gIHJldHVybiBub2RlJ3MgbmV3IHBvc2l0aW9uXG5cbkh1ZmZtYW4ucHJvdG90eXBlLnNsaWRlID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgbmV4dCA9IG5vZGU7XG4gIHZhciBzd2FwO1xuXG4gIHN3YXAgPSB0aGlzLnRhYmxlW25leHQrK10uY2xvbmUoKTtcblxuICAvLyBpZiB3ZSdyZSBzbGlkaW5nIGFuIGludGVybmFsIG5vZGUsIGZpbmQgdGhlXG4gIC8vIGhpZ2hlc3QgcG9zc2libGUgbGVhZiB0byBleGNoYW5nZSB3aXRoXG5cbiAgaWYoIHN3YXAud2VpZ2h0ICYgMSApIHtcbiAgICB3aGlsZSggc3dhcC53ZWlnaHQgPiB0aGlzLnRhYmxlW25leHQgKyAxXS53ZWlnaHQgKSB7XG4gICAgICBuZXh0Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gIHN3YXAgdGhlIHR3byBub2Rlc1xuXG4gIHRoaXMudGFibGVbbm9kZV0uc2V0KHRoaXMudGFibGVbbmV4dF0pO1xuICB0aGlzLnRhYmxlW25leHRdLnNldChzd2FwKTtcblxuICB0aGlzLnRhYmxlW25leHRdLnVwID0gdGhpcy50YWJsZVtub2RlXS51cDtcbiAgdGhpcy50YWJsZVtub2RlXS51cCA9IHN3YXAudXA7XG5cbiAgLy8gIHJlcGFpciB0aGUgc3ltYm9sIG1hcCBhbmQgdHJlZSBzdHJ1Y3R1cmVcblxuICBpZiggc3dhcC53ZWlnaHQgJiAxICkge1xuICAgIHRoaXMudGFibGVbc3dhcC5kb3duXS51cCA9IG5leHQ7XG4gICAgdGhpcy50YWJsZVtzd2FwLmRvd24gLSAxXS51cCA9IG5leHQ7XG4gICAgdGhpcy5tYXBbdGhpcy50YWJsZVtub2RlXS5zeW1ib2xdID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhYmxlW3RoaXMudGFibGVbbm9kZV0uZG93biAtIDFdLnVwID0gbm9kZTtcbiAgICB0aGlzLnRhYmxlW3RoaXMudGFibGVbbm9kZV0uZG93bl0udXAgPSBub2RlO1xuICAgIHRoaXMubWFwW3N3YXAuc3ltYm9sXSA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gbmV4dDtcbn07XG5cbi8vICBpbmNyZW1lbnQgc3ltYm9sIHdlaWdodCBhbmQgcmUgYmFsYW5jZSB0aGUgdHJlZS5cblxuSHVmZm1hbi5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgdXA7XG5cbiAgLy8gIG9idmlhdGUgc3dhcHBpbmcgYSBwYXJlbnQgd2l0aCBpdHMgY2hpbGQ6XG4gIC8vICAgIGluY3JlbWVudCB0aGUgbGVhZiBhbmQgcHJvY2VlZFxuICAvLyAgICBkaXJlY3RseSB0byBpdHMgcGFyZW50LlxuXG4gIC8vICBvdGhlcndpc2UsIHByb21vdGUgbGVhZiB0byBncm91cCBsZWFkZXIgcG9zaXRpb24gaW4gdGhlIHRyZWVcblxuICBpZiggdGhpcy50YWJsZVtub2RlXS51cCA9PT0gbm9kZSArIDEgKSB7XG4gICAgdGhpcy50YWJsZVtub2RlXS53ZWlnaHQgKz0gMjtcbiAgICBub2RlKys7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IHRoaXMubGVhZGVyIChub2RlKTtcbiAgfVxuXG4gIC8vICBpbmNyZWFzZSB0aGUgd2VpZ2h0IG9mIGVhY2ggbm9kZSBhbmQgc2xpZGVcbiAgLy8gIG92ZXIgYW55IHNtYWxsZXIgd2VpZ2h0cyBhaGVhZCBvZiBpdFxuICAvLyAgdW50aWwgcmVhY2hpbmcgdGhlIHJvb3RcblxuICAvLyAgaW50ZXJuYWwgbm9kZXMgd29yayB1cHdhcmRzIGZyb21cbiAgLy8gIHRoZWlyIGluaXRpYWwgcG9zaXRpb25zOyB3aGlsZVxuICAvLyAgc3ltYm9sIG5vZGVzIHNsaWRlIG92ZXIgZmlyc3QsXG4gIC8vICB0aGVuIHdvcmsgdXAgZnJvbSB0aGVpciBmaW5hbFxuICAvLyAgcG9zaXRpb25zLlxuXG4gIHdoaWxlKCB0aGlzLnRhYmxlW25vZGVdLndlaWdodCArPSAyLCB1cCA9IHRoaXMudGFibGVbbm9kZV0udXAgKSB7XG4gICAgd2hpbGUoIHRoaXMudGFibGVbbm9kZV0ud2VpZ2h0ID4gdGhpcy50YWJsZVtub2RlICsgMV0ud2VpZ2h0ICkge1xuICAgICAgICBub2RlID0gdGhpcy5zbGlkZSAobm9kZSk7XG4gICAgfVxuXG4gICAgaWYoIHRoaXMudGFibGVbbm9kZV0ud2VpZ2h0ICYgMSApIHtcbiAgICAgICAgbm9kZSA9IHVwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLnRhYmxlW25vZGVdLnVwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFJlLXNjYWxlIGlmIG5lY2Vzc2FyeS4gKi9cbiAgaWYgKHRoaXMubWF4X3dlaWdodCkge1xuICAgIGlmICh0aGlzLnRhYmxlW3RoaXMucm9vdF0ud2VpZ2h0ID49IHRoaXMubWF4X3dlaWdodCkge1xuICAgICAgdGhpcy5zY2FsZSgxKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vICBzY2FsZSBhbGwgd2VpZ2h0cyBhbmQgcmUtYmFsYW5jZSB0aGUgdHJlZVxuXG4vLyAgemVybyB3ZWlnaHQgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgdHJlZVxuLy8gIGJ5IHNsaWRpbmcgdGhlbSBvdXQgdGhlIGxlZnQgb2YgdGhlIHJhbmsgbGlzdFxuXG5IdWZmbWFuLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKGJpdHMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLmVzYywgd2VpZ2h0LCBwcmV2O1xuXG4gIC8vICB3b3JrIHVwIHRoZSB0cmVlIGZyb20gdGhlIGVzY2FwZSBub2RlXG4gIC8vICBzY2FsaW5nIHdlaWdodHMgYnkgdGhlIHZhbHVlIG9mIGJpdHNcblxuICB3aGlsZSggKytub2RlIDw9IHRoaXMucm9vdCApIHtcbiAgICAvLyAgcmVjb21wdXRlIHRoZSB3ZWlnaHQgb2YgaW50ZXJuYWwgbm9kZXM7XG4gICAgLy8gIHNsaWRlIGRvd24gYW5kIG91dCBhbnkgdW51c2VkIG9uZXNcblxuICAgIGlmKCB0aGlzLnRhYmxlW25vZGVdLndlaWdodCAmIDEgKSB7XG4gICAgICBpZiggd2VpZ2h0ID0gdGhpcy50YWJsZVt0aGlzLnRhYmxlW25vZGVdLmRvd25dLndlaWdodCAmIH4xICkge1xuICAgICAgICB3ZWlnaHQgKz0gdGhpcy50YWJsZVt0aGlzLnRhYmxlW25vZGVdLmRvd24gLSAxXS53ZWlnaHQgfCAxO1xuICAgICAgfVxuXG4gICAgICAvLyAgcmVtb3ZlIHplcm8gd2VpZ2h0IGxlYXZlcyBieSBpbmNyZW1lbnRpbmcgSHVmZkVzY1xuICAgICAgLy8gIGFuZCByZW1vdmluZyB0aGVtIGZyb20gdGhlIHN5bWJvbCBtYXAuICB0YWtlIGNhcmVcblxuICAgIH0gZWxzZSBpZiggISh3ZWlnaHQgPSB0aGlzLnRhYmxlW25vZGVdLndlaWdodCA+PiBiaXRzICYgfjEpICkge1xuICAgICAgaWYoIHRoaXMubWFwW3RoaXMudGFibGVbbm9kZV0uc3ltYm9sXSA9IDAsIHRoaXMuZXNjKysgKSB7XG4gICAgICAgIHRoaXMuZXNjKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2xpZGUgdGhlIHNjYWxlZCBub2RlIGJhY2sgZG93biBvdmVyIGFueVxuICAgIC8vIHByZXZpb3VzIG5vZGVzIHdpdGggbGFyZ2VyIHdlaWdodHNcblxuICAgIHRoaXMudGFibGVbbm9kZV0ud2VpZ2h0ID0gd2VpZ2h0O1xuICAgIHByZXYgPSBub2RlO1xuXG4gICAgd2hpbGUoIHdlaWdodCA8IHRoaXMudGFibGVbLS1wcmV2XS53ZWlnaHQgKSB7XG4gICAgICB0aGlzLnNsaWRlKHByZXYpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByZXBhcmUgYSBuZXcgZXNjYXBlIG5vZGVcblxuICB0aGlzLnRhYmxlW3RoaXMuZXNjXS5kb3duID0gMDtcbn07XG5cbi8vICBzZW5kIHRoZSBiaXRzIGZvciBhbiBlc2NhcGVkIHN5bWJvbFxuXG5IdWZmbWFuLnByb3RvdHlwZS5zZW5kaWQgPSBmdW5jdGlvbihzeW1ib2wpIHtcbiAgdmFyIGVtcHR5ID0gMCwgbWF4O1xuXG4gIC8vICBjb3VudCB0aGUgbnVtYmVyIG9mIGVtcHR5IHN5bWJvbHNcbiAgLy8gIGJlZm9yZSB0aGUgc3ltYm9sIGluIHRoZSB0YWJsZVxuXG4gIHdoaWxlKCBzeW1ib2wtLSApIHtcbiAgICBpZiggIXRoaXMubWFwW3N5bWJvbF0gKSB7XG4gICAgICBlbXB0eSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vICBzZW5kIExTQiBvZiB0aGlzIGNvdW50IGZpcnN0LCB1c2luZ1xuICAvLyAgYXMgbWFueSBiaXRzIGFzIGFyZSByZXF1aXJlZCBmb3JcbiAgLy8gIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGNvdW50XG5cbiAgaWYoIG1heCA9IHRoaXMuc2l6ZSAtIE1hdGguZmxvb3IoKHRoaXMucm9vdCAtIHRoaXMuZXNjKSAvIDIpIC0gMSApIHtcbiAgICBkbyB7XG4gICAgICB0aGlzLndyaXRlQml0KGVtcHR5ICYgMSk7XG4gICAgICBlbXB0eSA+Pj0gMTtcbiAgICB9IHdoaWxlKCBtYXggPj49IDEgKTtcbiAgfVxufTtcblxuLy8gIGVuY29kZSB0aGUgbmV4dCBzeW1ib2xcblxuSHVmZm1hbi5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3ltYm9sKSB7XG4gIHZhciBlbWl0ID0gMSwgYml0O1xuICB2YXIgdXAsIGlkeCwgbm9kZTtcblxuICBpZiggc3ltYm9sIDwgdGhpcy5zaXplICkge1xuICAgIG5vZGUgPSB0aGlzLm1hcFtzeW1ib2xdO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyAgZm9yIGEgbmV3IHN5bWJvbCwgZGlyZWN0IHRoZSByZWNlaXZlciB0byB0aGUgZXNjYXBlIG5vZGVcbiAgLy8gIGJ1dCByZWZ1c2UgaW5wdXQgaWYgdGFibGUgaXMgYWxyZWFkeSBmdWxsLlxuXG4gIGlmKCAhKGlkeCA9IG5vZGUpICkge1xuICAgIGlmKCAhKGlkeCA9IHRoaXMuZXNjKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyAgYWNjdW11bGF0ZSB0aGUgY29kZSBiaXRzIGJ5XG4gIC8vICB3b3JraW5nIHVwIHRoZSB0cmVlIGZyb21cbiAgLy8gIHRoZSBub2RlIHRvIHRoZSByb290XG5cbiAgd2hpbGUoIHVwID0gdGhpcy50YWJsZVtpZHhdLnVwICkge1xuICAgIGVtaXQgPDw9IDE7IGVtaXQgfD0gaWR4ICYgMTsgaWR4ID0gdXA7XG4gIH1cblxuICAvLyAgc2VuZCB0aGUgY29kZSwgcm9vdCBzZWxlY3RvciBiaXQgZmlyc3RcblxuICB3aGlsZSggYml0ID0gZW1pdCAmIDEsIGVtaXQgPj49IDEgKSB7XG4gICAgdGhpcy53cml0ZUJpdChiaXQpO1xuICB9XG5cbiAgLy8gIHNlbmQgaWRlbnRpZmljYXRpb24gYW5kIGluY29ycG9yYXRlXG4gIC8vICBuZXcgc3ltYm9scyBpbnRvIHRoZSB0cmVlXG5cbiAgaWYoICFub2RlICkge1xuICAgIHRoaXMuc2VuZGlkKHN5bWJvbCk7XG4gICAgbm9kZSA9IHRoaXMuc3BsaXQoc3ltYm9sKTtcbiAgfVxuXG4gIC8vICBhZGp1c3QgYW5kIHJlLWJhbGFuY2UgdGhlIHRyZWVcblxuICB0aGlzLmluY3JlbWVudChub2RlKTtcbn07XG5cbi8vICByZWFkIHRoZSBpZGVudGlmaWNhdGlvbiBiaXRzXG4vLyAgZm9yIGFuIGVzY2FwZWQgc3ltYm9sXG5cbkh1ZmZtYW4ucHJvdG90eXBlLnJlYWRpZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW1wdHkgPSAwLCBiaXQgPSAxLCBtYXgsIHN5bWJvbDtcblxuICAvLyAgcmVjZWl2ZSB0aGUgc3ltYm9sLCBMU0IgZmlyc3QsIHJlYWRpbmdcbiAgLy8gIG9ubHkgdGhlIG51bWJlciBvZiBiaXRzIG5lY2Vzc2FyeSB0b1xuICAvLyAgdHJhbnNtaXQgdGhlIG1heGltdW0gcG9zc2libGUgc3ltYm9sIHZhbHVlXG5cbiAgaWYoIG1heCA9IHRoaXMuc2l6ZSAtIE1hdGguZmxvb3IoKHRoaXMucm9vdCAtIHRoaXMuZXNjKSAvIDIpIC0gMSApIHtcbiAgICBkbyB7XG4gICAgICBlbXB0eSB8PSB0aGlzLnJlYWRCaXQoKSA/IGJpdCA6IDA7XG4gICAgICBiaXQgPDw9IDE7XG4gICAgfSB3aGlsZSggbWF4ID4+PSAxICk7XG4gIH1cblxuICAvLyAgdGhlIGNvdW50IGlzIG9mIHVubWFwcGVkIHN5bWJvbHNcbiAgLy8gIGluIHRoZSB0YWJsZSBiZWZvcmUgdGhlIG5ldyBvbmVcblxuICBmb3IoIHN5bWJvbCA9IDA7IHN5bWJvbCA8IHRoaXMuc2l6ZTsgc3ltYm9sKysgKSB7XG4gICAgaWYoICF0aGlzLm1hcFtzeW1ib2xdICkge1xuICAgICAgaWYoICFlbXB0eS0tICkge1xuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vICBvb3BzISAgb3VyIGNvdW50IGlzIHRvbyBiaWcsIGVpdGhlciBkdWVcbiAgLy8gIHRvIGEgYml0IGVycm9yLCBvciBhIHNob3J0IG5vZGUgY291bnRcbiAgLy8gIGdpdmVuIHRvIGh1ZmZfaW5pdC5cblxuICBjb25zb2xlLmFzc2VydChmYWxzZSk7XG4gIHJldHVybiAwO1xufTtcblxuLy8gIGRlY29kZSB0aGUgbmV4dCBzeW1ib2xcblxuSHVmZm1hbi5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5yb290O1xuICB2YXIgc3ltYm9sLCBkb3duO1xuXG4gIC8vICB3b3JrIGRvd24gdGhlIHRyZWUgZnJvbSB0aGUgcm9vdFxuICAvLyAgdW50aWwgcmVhY2hpbmcgZWl0aGVyIGEgbGVhZlxuICAvLyAgb3IgdGhlIGVzY2FwZSBub2RlLiAgQSBvbmVcbiAgLy8gIGJpdCBtZWFucyBnbyBsZWZ0LCBhIHplcm9cbiAgLy8gIG1lYW5zIGdvIHJpZ2h0LlxuXG4gIHdoaWxlKCBkb3duID0gdGhpcy50YWJsZVtub2RlXS5kb3duICkge1xuICAgIGlmKCB0aGlzLnJlYWRCaXQoKSApIHtcbiAgICAgIG5vZGUgPSBkb3duIC0gMTsgIC8vIHRoZSBsZWZ0IGNoaWxkIHByZWNlZGVzIHRoZSByaWdodCBjaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gZG93bjtcbiAgICB9XG4gIH1cblxuICAvLyAgc2VudCB0byB0aGUgZXNjYXBlIG5vZGU/Pz9cbiAgLy8gIHJlZnVzZSB0byBhZGQgdG8gYSBmdWxsIHRyZWVcblxuICBpZiggbm9kZSA9PT0gdGhpcy5lc2MgKSB7XG4gICAgaWYoIHRoaXMuZXNjICkge1xuICAgICAgc3ltYm9sID0gdGhpcy5yZWFkaWQgKCk7XG4gICAgICBub2RlID0gdGhpcy5zcGxpdCAoc3ltYm9sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN5bWJvbCA9IHRoaXMudGFibGVbbm9kZV0uc3ltYm9sO1xuICB9XG5cbiAgLy8gIGluY3JlbWVudCB3ZWlnaHRzIGFuZCByZS1iYWxhbmNlXG4gIC8vICB0aGUgY29kaW5nIHRyZWVcblxuICB0aGlzLmluY3JlbWVudCAobm9kZSk7XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG4vLyBzdGFuZCBhbG9uZSBjb21wcmVzc29yLCBtb3N0bHkgZm9yIHRlc3Rpbmdcbkh1ZmZtYW4uTUFHSUMgPSAnaHVmZic7XG5IdWZmbWFuLmNvbXByZXNzRmlsZSA9IFV0aWwuY29tcHJlc3NGaWxlSGVscGVyKEh1ZmZtYW4uTUFHSUMsIGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIHNpemUsIHByb3BzKSB7XG4gIHZhciBiaXRzdHJlYW0gPSBuZXcgQml0U3RyZWFtKG91dHB1dCk7XG5cbiAgdmFyIGFscGhhYmV0U2l6ZSA9IDI1NjtcbiAgaWYgKHNpemUgPCAwKSB7IGFscGhhYmV0U2l6ZSsrOyB9XG4gIHZhciBodWZmID0gbmV3IEh1ZmZtYW4oMjU3LCBhbHBoYWJldFNpemUsIGJpdHN0cmVhbSwgODE5MSk7XG4gIFV0aWwuY29tcHJlc3NXaXRoTW9kZWwoaW5wdXQsIHNpemUsIGh1ZmYpO1xuICBiaXRzdHJlYW0uZmx1c2goKTtcbn0pO1xuXG4vLyBzdGFuZCBhbG9uZSBkZWNvbXByZXNzZXIsIGFnYWluIGZvciB0ZXN0aW5nXG5IdWZmbWFuLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihIdWZmbWFuLk1BR0lDLCBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBzaXplKSB7XG4gIHZhciBiaXRzdHJlYW0gPSBuZXcgQml0U3RyZWFtKGlucHV0KTtcblxuICB2YXIgYWxwaGFiZXRTaXplID0gMjU2O1xuICBpZiAoc2l6ZSA8IDApIHsgYWxwaGFiZXRTaXplKys7IH1cbiAgdmFyIGh1ZmYgPSBuZXcgSHVmZm1hbigyNTcsIGFscGhhYmV0U2l6ZSwgYml0c3RyZWFtLCA4MTkxKTtcbiAgVXRpbC5kZWNvbXByZXNzV2l0aE1vZGVsKG91dHB1dCwgc2l6ZSwgaHVmZik7XG59KTtcblxucmV0dXJuIEh1ZmZtYW47XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyoqXG4gKiBBbiBpbi1wbGFjZSwgbGVuZ3RoIHJlc3RyaWN0ZWQgQ2Fub25pY2FsIEh1ZmZtYW4gY29kZSBsZW5ndGggYWxsb2NhdG9yXG4gKlxuICogQmFzZWQgb24gdGhlIGFsZ29yaXRobSBwcm9wb3NlZCBieSBSLiBMLiBNaWxpZGnDuiwgQS4gQS4gUGVzc29hIGFuZFxuICogRS4gUy4gTGFiZXIgaW4gXCJJbi1wbGFjZSBMZW5ndGgtUmVzdHJpY3RlZCBQcmVmaXggQ29kaW5nXCIgKHNlZTpcbiAqIGh0dHA6Ly93d3ctZGkuaW5mLnB1Yy1yaW8uYnIvfmxhYmVyL3B1YmxpYy9zcGlyZTk4LnBzKSBhbmRcbiAqIGluY29ycG9yYXRpbmcgYWRkaXRpb25hbCBpZGVhcyBmcm9tIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBcInNoY29kZWNcIlxuICogYnkgU2ltYWtvdiBBbGV4YW5kZXIgKHNlZTogaHR0cDovL3dlYmNlbnRlci5ydS9+eGFuZGVyLylcbiAqXG4gKiBUaGlzIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gcG9ydGVkIGZyb20gSHVmZm1hbkFsbG9jYXRvci5qYXZhIGZyb21cbiAqICAgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9qYnppcDJcbiAqIHdoaWNoIGlzOlxuICpcbiAqICAgQ29weXJpZ2h0IChjKSAyMDExIE1hdHRoZXcgRnJhbmNpc1xuICpcbiAqICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqICAgY29uZGl0aW9uczpcbiAqXG4gKiAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIGlzOlxuICogICBDb3B5cmlnaHQgKGMpIDIwMTMgQy4gU2NvdHQgQW5hbmlhblxuICogd2l0aCB0aGUgc2FtZSBsaWNlbnNpbmcgdGVybXMgYXMgTWF0dGhldyBGcmFuY2lzJyBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vZnJlZXplJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoZnJlZXplLCBVdGlsKSB7XG5cbiAgLyoqXG4gICAqIEZJUlNUKCkgZnVuY3Rpb25cbiAgICogQHBhcmFtIGFycmF5IFRoZSBjb2RlIGxlbmd0aCBhcnJheVxuICAgKiBAcGFyYW0gaSBUaGUgaW5wdXQgcG9zaXRpb25cbiAgICogQHBhcmFtIG5vZGVzVG9Nb3ZlIFRoZSBudW1iZXIgb2YgaW50ZXJuYWwgbm9kZXMgdG8gYmUgcmVsb2NhdGVkXG4gICAqIEByZXR1cm4gVGhlIHNtYWxsZXN0IHtAY29kZSBrfSBzdWNoIHRoYXQge0Bjb2RlIG5vZGVzVG9Nb3ZlIDw9IGsgPD0gaX0gYW5kXG4gICAqICAgICAgICAge0Bjb2RlIGkgPD0gKGFycmF5W2tdICUgYXJyYXkubGVuZ3RoKX1cbiAgICovXG4gIHZhciBmaXJzdCA9IGZ1bmN0aW9uKGFycmF5LCBpLCBub2Rlc1RvTW92ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGxpbWl0ID0gaTtcbiAgICB2YXIgayA9IGFycmF5Lmxlbmd0aCAtIDI7XG5cbiAgICB3aGlsZSAoKGkgPj0gbm9kZXNUb01vdmUpICYmICgoYXJyYXlbaV0gJSBsZW5ndGgpID4gbGltaXQpKSB7XG4gICAgICBrID0gaTtcbiAgICAgIGkgLT0gKGxpbWl0IC0gaSArIDEpO1xuICAgIH1cbiAgICBpID0gTWF0aC5tYXggKG5vZGVzVG9Nb3ZlIC0gMSwgaSk7XG5cbiAgICB3aGlsZSAoayA+IChpICsgMSkpIHtcbiAgICAgIHZhciB0ZW1wID0gKGkgKyBrKSA+PiAxO1xuICAgICAgaWYgKChhcnJheVt0ZW1wXSAlIGxlbmd0aCkgPiBsaW1pdCkge1xuICAgICAgICBrID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxscyB0aGUgY29kZSBhcnJheSB3aXRoIGV4dGVuZGVkIHBhcmVudCBwb2ludGVyc1xuICAgKiBAcGFyYW0gYXJyYXkgVGhlIGNvZGUgbGVuZ3RoIGFycmF5XG4gICAqL1xuICB2YXIgc2V0RXh0ZW5kZWRQYXJlbnRQb2ludGVycyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5WzBdICs9IGFycmF5WzFdO1xuXG4gICAgdmFyIGhlYWROb2RlLCB0YWlsTm9kZSwgdG9wTm9kZSwgdGVtcDtcbiAgICBmb3IgKGhlYWROb2RlID0gMCwgdGFpbE5vZGUgPSAxLCB0b3BOb2RlID0gMjtcbiAgICAgICAgIHRhaWxOb2RlIDwgKGxlbmd0aCAtIDEpO1xuICAgICAgICAgdGFpbE5vZGUrKykge1xuICAgICAgaWYgKCh0b3BOb2RlID49IGxlbmd0aCkgfHwgKGFycmF5W2hlYWROb2RlXSA8IGFycmF5W3RvcE5vZGVdKSkge1xuICAgICAgICB0ZW1wID0gYXJyYXlbaGVhZE5vZGVdO1xuICAgICAgICBhcnJheVtoZWFkTm9kZSsrXSA9IHRhaWxOb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGFycmF5W3RvcE5vZGUrK107XG4gICAgICB9XG5cbiAgICAgIGlmICgodG9wTm9kZSA+PSBsZW5ndGgpIHx8XG4gICAgICAgICAgKChoZWFkTm9kZSA8IHRhaWxOb2RlKSAmJiAoYXJyYXlbaGVhZE5vZGVdIDwgYXJyYXlbdG9wTm9kZV0pKSkge1xuICAgICAgICB0ZW1wICs9IGFycmF5W2hlYWROb2RlXTtcbiAgICAgICAgYXJyYXlbaGVhZE5vZGUrK10gPSB0YWlsTm9kZSArIGxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXAgKz0gYXJyYXlbdG9wTm9kZSsrXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbdGFpbE5vZGVdID0gdGVtcDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBudW1iZXIgb2Ygbm9kZXMgdG8gcmVsb2NhdGUgaW4gb3JkZXIgdG8gYWNoaWV2ZSBhIGdpdmVuIGNvZGVcbiAgICogbGVuZ3RoIGxpbWl0XG4gICAqIEBwYXJhbSBhcnJheSBUaGUgY29kZSBsZW5ndGggYXJyYXlcbiAgICogQHBhcmFtIG1heGltdW1MZW5ndGggVGhlIG1heGltdW0gYml0IGxlbmd0aCBmb3IgdGhlIGdlbmVyYXRlZCBjb2Rlc1xuICAgKiBAcmV0dXJuIFRoZSBudW1iZXIgb2Ygbm9kZXMgdG8gcmVsb2NhdGVcbiAgICovXG4gIHZhciBmaW5kTm9kZXNUb1JlbG9jYXRlID0gZnVuY3Rpb24oYXJyYXksIG1heGltdW1MZW5ndGgpIHtcbiAgICB2YXIgY3VycmVudE5vZGUgPSBhcnJheS5sZW5ndGggLSAyO1xuICAgIHZhciBjdXJyZW50RGVwdGg7XG4gICAgZm9yIChjdXJyZW50RGVwdGggPSAxO1xuICAgICAgICAgKGN1cnJlbnREZXB0aCA8IChtYXhpbXVtTGVuZ3RoIC0gMSkpICYmIChjdXJyZW50Tm9kZSA+IDEpO1xuICAgICAgICAgY3VycmVudERlcHRoKyspIHtcbiAgICAgIGN1cnJlbnROb2RlID0gIGZpcnN0IChhcnJheSwgY3VycmVudE5vZGUgLSAxLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gIH07XG5cblxuICAvKipcbiAgICogQSBmaW5hbCBhbGxvY2F0aW9uIHBhc3Mgd2l0aCBubyBjb2RlIGxlbmd0aCBsaW1pdFxuICAgKiBAcGFyYW0gYXJyYXkgVGhlIGNvZGUgbGVuZ3RoIGFycmF5XG4gICAqL1xuICB2YXIgYWxsb2NhdGVOb2RlTGVuZ3RocyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGZpcnN0Tm9kZSA9IGFycmF5Lmxlbmd0aCAtIDI7XG4gICAgdmFyIG5leHROb2RlID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB2YXIgY3VycmVudERlcHRoLCBhdmFpbGFibGVOb2RlcywgbGFzdE5vZGUsIGk7XG5cbiAgICBmb3IgKGN1cnJlbnREZXB0aCA9IDEsIGF2YWlsYWJsZU5vZGVzID0gMjtcbiAgICAgICAgIGF2YWlsYWJsZU5vZGVzID4gMDtcbiAgICAgICAgIGN1cnJlbnREZXB0aCsrKSB7XG4gICAgICBsYXN0Tm9kZSA9IGZpcnN0Tm9kZTtcbiAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0IChhcnJheSwgbGFzdE5vZGUgLSAxLCAwKTtcblxuICAgICAgZm9yIChpID0gYXZhaWxhYmxlTm9kZXMgLSAobGFzdE5vZGUgLSBmaXJzdE5vZGUpOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGFycmF5W25leHROb2RlLS1dID0gY3VycmVudERlcHRoO1xuICAgICAgfVxuXG4gICAgICBhdmFpbGFibGVOb2RlcyA9IChsYXN0Tm9kZSAtIGZpcnN0Tm9kZSkgPDwgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZmluYWwgYWxsb2NhdGlvbiBwYXNzIHRoYXQgcmVsb2NhdGVzIG5vZGVzIGluIG9yZGVyIHRvIGFjaGlldmUgYVxuICAgKiBtYXhpbXVtIGNvZGUgbGVuZ3RoIGxpbWl0XG4gICAqIEBwYXJhbSBhcnJheSBUaGUgY29kZSBsZW5ndGggYXJyYXlcbiAgICogQHBhcmFtIG5vZGVzVG9Nb3ZlIFRoZSBudW1iZXIgb2YgaW50ZXJuYWwgbm9kZXMgdG8gYmUgcmVsb2NhdGVkXG4gICAqIEBwYXJhbSBpbnNlcnREZXB0aCBUaGUgZGVwdGggYXQgd2hpY2ggdG8gaW5zZXJ0IHJlbG9jYXRlZCBub2Rlc1xuICAgKi9cbiAgdmFyIGFsbG9jYXRlTm9kZUxlbmd0aHNXaXRoUmVsb2NhdGlvbiA9IGZ1bmN0aW9uKGFycmF5LCBub2Rlc1RvTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydERlcHRoKSB7XG4gICAgdmFyIGZpcnN0Tm9kZSA9IGFycmF5Lmxlbmd0aCAtIDI7XG4gICAgdmFyIG5leHROb2RlID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB2YXIgY3VycmVudERlcHRoID0gKGluc2VydERlcHRoID09IDEpID8gMiA6IDE7XG4gICAgdmFyIG5vZGVzTGVmdFRvTW92ZSA9IChpbnNlcnREZXB0aCA9PSAxKSA/IG5vZGVzVG9Nb3ZlIC0gMiA6IG5vZGVzVG9Nb3ZlO1xuICAgIHZhciBhdmFpbGFibGVOb2RlcywgbGFzdE5vZGUsIG9mZnNldCwgaTtcblxuICAgIGZvciAoYXZhaWxhYmxlTm9kZXMgPSBjdXJyZW50RGVwdGggPDwgMTtcbiAgICAgICAgIGF2YWlsYWJsZU5vZGVzID4gMDtcbiAgICAgICAgIGN1cnJlbnREZXB0aCsrKSB7XG4gICAgICBsYXN0Tm9kZSA9IGZpcnN0Tm9kZTtcbiAgICAgIGZpcnN0Tm9kZSA9IChmaXJzdE5vZGUgPD0gbm9kZXNUb01vdmUpID8gZmlyc3ROb2RlIDogZmlyc3QgKGFycmF5LCBsYXN0Tm9kZSAtIDEsIG5vZGVzVG9Nb3ZlKTtcblxuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGlmIChjdXJyZW50RGVwdGggPj0gaW5zZXJ0RGVwdGgpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4gKG5vZGVzTGVmdFRvTW92ZSwgMSA8PCAoY3VycmVudERlcHRoIC0gaW5zZXJ0RGVwdGgpKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudERlcHRoID09IChpbnNlcnREZXB0aCAtIDEpKSB7XG4gICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIGlmICgoYXJyYXlbZmlyc3ROb2RlXSkgPT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICBmaXJzdE5vZGUrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBhdmFpbGFibGVOb2RlcyAtIChsYXN0Tm9kZSAtIGZpcnN0Tm9kZSArIG9mZnNldCk7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbbmV4dE5vZGUtLV0gPSBjdXJyZW50RGVwdGg7XG4gICAgICB9XG5cbiAgICAgIG5vZGVzTGVmdFRvTW92ZSAtPSBvZmZzZXQ7XG4gICAgICBhdmFpbGFibGVOb2RlcyA9IChsYXN0Tm9kZSAtIGZpcnN0Tm9kZSArIG9mZnNldCkgPDwgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG9jYXRlcyBDYW5vbmljYWwgSHVmZm1hbiBjb2RlIGxlbmd0aHMgaW4gcGxhY2UgYmFzZWQgb24gYSBzb3J0ZWRcbiAgICogZnJlcXVlbmN5IGFycmF5XG4gICAqIEBwYXJhbSBhcnJheSBPbiBpbnB1dCwgYSBzb3J0ZWQgYXJyYXkgb2Ygc3ltYm9sIGZyZXF1ZW5jaWVzOyBPbiBvdXRwdXQsXG4gICAqICAgICAgICAgICAgICBhbiBhcnJheSBvZiBDYW5vbmljYWwgSHVmZm1hbiBjb2RlIGxlbmd0aHNcbiAgICogQHBhcmFtIG1heGltdW1MZW5ndGggVGhlIG1heGltdW0gY29kZSBsZW5ndGguIE11c3QgYmUgYXQgbGVhc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAge0Bjb2RlIGNlaWwobG9nMihhcnJheS5sZW5ndGgpKX1cbiAgICovXG4gIC8vIHB1YmxpY1xuICB2YXIgYWxsb2NhdGVIdWZmbWFuQ29kZUxlbmd0aHMgPSBmdW5jdGlvbihhcnJheSwgbWF4aW11bUxlbmd0aCkge1xuICAgIHN3aXRjaCAoYXJyYXkubGVuZ3RoKSB7XG4gICAgY2FzZSAyOlxuICAgICAgYXJyYXlbMV0gPSAxO1xuICAgIGNhc2UgMTpcbiAgICAgIGFycmF5WzBdID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBQYXNzIDEgOiBTZXQgZXh0ZW5kZWQgcGFyZW50IHBvaW50ZXJzICovXG4gICAgc2V0RXh0ZW5kZWRQYXJlbnRQb2ludGVycyAoYXJyYXkpO1xuXG4gICAgLyogUGFzcyAyIDogRmluZCBudW1iZXIgb2Ygbm9kZXMgdG8gcmVsb2NhdGUgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICAgICAqICAgICAgICAgIG1heGltdW0gY29kZSBsZW5ndGggKi9cbiAgICB2YXIgbm9kZXNUb1JlbG9jYXRlID0gZmluZE5vZGVzVG9SZWxvY2F0ZSAoYXJyYXksIG1heGltdW1MZW5ndGgpO1xuXG4gICAgLyogUGFzcyAzIDogR2VuZXJhdGUgY29kZSBsZW5ndGhzICovXG4gICAgaWYgKChhcnJheVswXSAlIGFycmF5Lmxlbmd0aCkgPj0gbm9kZXNUb1JlbG9jYXRlKSB7XG4gICAgICBhbGxvY2F0ZU5vZGVMZW5ndGhzIChhcnJheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbnNlcnREZXB0aCA9IG1heGltdW1MZW5ndGggLSAoVXRpbC5mbHMobm9kZXNUb1JlbG9jYXRlIC0gMSkpO1xuICAgICAgYWxsb2NhdGVOb2RlTGVuZ3Roc1dpdGhSZWxvY2F0aW9uIChhcnJheSwgbm9kZXNUb1JlbG9jYXRlLCBpbnNlcnREZXB0aCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBmcmVlemUoe1xuICAgIGFsbG9jYXRlSHVmZm1hbkNvZGVMZW5ndGhzOiBhbGxvY2F0ZUh1ZmZtYW5Db2RlTGVuZ3Roc1xuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiogU2ltcGxlIChsb2cgbikobikgZGlzdGFuY2UgbW9kZWwuICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChVdGlsKXtcblxuICAgIC8vIGxlbmd0aEJpdHNNb2RlbEZhY3Rvcnkgd2lsbCBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgMiwgNCwgOCwgMTYsIGV0Y1xuICAgIC8vIGFuZCBtdXN0IHJldHVybiBhbiBhcHByb3ByaWF0ZSBtb2RlbCBvciBjb2Rlci5cbiAgICB2YXIgTG9nRGlzdGFuY2VNb2RlbCA9IGZ1bmN0aW9uKHNpemUsIGV4dHJhU3RhdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGdEaXN0YW5jZU1vZGVsRmFjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aEJpdHNNb2RlbEZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBiaXRzID0gVXRpbC5mbHMoc2l6ZS0xKTtcbiAgICAgICAgdGhpcy5leHRyYVN0YXRlcyA9ICtleHRyYVN0YXRlcyB8fCAwO1xuICAgICAgICB0aGlzLmxnRGlzdGFuY2VNb2RlbCA9IGxnRGlzdGFuY2VNb2RlbEZhY3RvcnkoMSArIGJpdHMgKyBleHRyYVN0YXRlcyk7XG4gICAgICAgIC8vIHRoaXMuZGlzdGFuY2VNb2RlbFtuXSB1c2VkIGZvciBkaXN0YW5jZXMgd2hpY2ggYXJlIG4tYml0cyBsb25nLFxuICAgICAgICAvLyBidXQgb25seSBuLTEgYml0cyBhcmUgZW5jb2RlZDogdGhlIHRvcCBiaXQgaXMga25vd24gdG8gYmUgb25lLlxuICAgICAgICB0aGlzLmRpc3RhbmNlTW9kZWwgPSBbXTtcbiAgICAgICAgZm9yIChpPTIgOyBpIDw9IGJpdHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIG51bUJpdHMgPSBpIC0gMTtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VNb2RlbFtpXSA9IGxlbmd0aEJpdHNNb2RlbEZhY3RvcnkoMTw8bnVtQml0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIHlvdSBjYW4gZ2l2ZSB0aGlzIG1vZGVsIGFyZ3VtZW50cyBiZXR3ZWVuIDAgYW5kIChzaXplLTEpLCBvciBlbHNlXG4gICAgICAgYSBuZWdhdGl2ZSBhcmd1bWVudCB3aGljaCBpcyBvbmUgb2YgdGhlICdleHRyYSBzdGF0ZXMnLiAqL1xuICAgIExvZ0Rpc3RhbmNlTW9kZWwucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDIpIHsgLy8gc21hbGwgZGlzdGFuY2Ugb3IgYW4gJ2V4dHJhIHN0YXRlJ1xuICAgICAgICAgICAgdGhpcy5sZ0Rpc3RhbmNlTW9kZWwuZW5jb2RlKGRpc3RhbmNlICsgdGhpcy5leHRyYVN0YXRlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxnRGlzdGFuY2UgPSBVdGlsLmZscyhkaXN0YW5jZSk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGRpc3RhbmNlICYgKDE8PChsZ0Rpc3RhbmNlLTEpKSk7IC8vIHRvcCBiaXQgaXMgc2V0XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGxnRGlzdGFuY2UgPj0gMik7XG4gICAgICAgIHRoaXMubGdEaXN0YW5jZU1vZGVsLmVuY29kZShsZ0Rpc3RhbmNlICsgdGhpcy5leHRyYVN0YXRlcyk7XG4gICAgICAgIC8vIG5vdyBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIGJpdHMuXG4gICAgICAgIHZhciByZXN0ID0gZGlzdGFuY2UgJiAoKDEgPDwgKGxnRGlzdGFuY2UtMSkpIC0gMSk7XG4gICAgICAgIHRoaXMuZGlzdGFuY2VNb2RlbFtsZ0Rpc3RhbmNlXS5lbmNvZGUocmVzdCk7XG4gICAgfTtcbiAgICBMb2dEaXN0YW5jZU1vZGVsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxnRGlzdGFuY2UgPSB0aGlzLmxnRGlzdGFuY2VNb2RlbC5kZWNvZGUoKSAtIHRoaXMuZXh0cmFTdGF0ZXM7XG4gICAgICAgIGlmIChsZ0Rpc3RhbmNlIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIGxnRGlzdGFuY2U7IC8vIHRoaXMgaXMgYSBzbWFsbCBkaXN0YW5jZSBvciBhbiAnZXh0cmEgc3RhdGUnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLmRpc3RhbmNlTW9kZWxbbGdEaXN0YW5jZV0uZGVjb2RlKCk7XG4gICAgICAgIHJldHVybiAoMSA8PCAobGdEaXN0YW5jZS0xKSkgKyByZXN0O1xuICAgIH07XG4gICAgcmV0dXJuIExvZ0Rpc3RhbmNlTW9kZWw7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyogTFpKQiBjb21wcmVzc2lvbjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MWkpCICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9TdHJlYW0nKSxcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChTdHJlYW0sVXRpbCkge1xuLyoqXG4kSWQ6IEl1cHBpdGVyLmpzIDMwMjYgMjAxMC0wNi0yMyAxMDowMzoxM1ogQmVhciAkXG5cbkNvcHlyaWdodCAoYykgMjAxMCBOdXdhIEluZm9ybWF0aW9uIENvLiwgTHRkLCBhbmQgaW5kaXZpZHVhbCBjb250cmlidXRvcnMuXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBOdXdhIEluZm9ybWF0aW9uIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG5BTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG5JTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbkRBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG5TRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxuQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSxcbk9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG5PRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG4kQXV0aG9yOiBCZWFyICRcbiREYXRlOiAyMDEwLTA2LTIzIDE4OjAzOjEzICswODAwICjmmJ/mnJ/kuIksIDIzIOWFreaciCAyMDEwKSAkXG4kUmV2aXNpb246IDMwMjYgJFxuKi9cblxudmFyIEx6amIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuTHpqYi5NQUdJQyA9ICdsempiJztcblxuLy8gQ29uc3RhbnRzIHdhcyB1c2VkIGZvciBjb21wcmVzcy9kZWNvbXByZXNzIGZ1bmN0aW9uLlxudmFyIE5CQlkgPSA4LFxuICAgIE1BVENIX0JJVFMgPSA2LFxuICAgIE1BVENIX01JTiA9IDMsXG4gICAgTUFUQ0hfTUFYID0gKCgxIDw8IE1BVENIX0JJVFMpICsgKE1BVENIX01JTiAtIDEpKSxcbiAgICBPRkZTRVRfTUFTSyA9ICgoMSA8PCAoMTYgLSBNQVRDSF9CSVRTKSkgLSAxKSxcbiAgICBMRU1QRUxfU0laRV9CQVNFID0gMTAyNDtcbnZhciBFT0YgPSBTdHJlYW0uRU9GO1xuXG4vLyBzZXQgQ19DT01QQVQgdG8gdHJ1ZSBpZiB5b3UgbmVlZCB0byBkZWNvbXByZXNzIHdpdGggdGhlICh1bnR3ZWFrZWQpIEMgbHpqYlxuLy8gaW1wbGVtZW50YXRpb24sIHdoaWNoIGJyZWFrcyBpZiBvZmZzZXQ9PTA7IHRoZSBqYXZhc2NyaXB0XG4vLyBpbXBsZW1lbnRhdGlvbiB1c2VzIDAgdG8gaW5kaWNhdGUgYW4gb2Zmc2V0IG9mIE9GRlNFVF9NQVNLKzEuXG52YXIgQ19DT01QQVQgPSB0cnVlO1xuXG4vKipcbiAqIENvbXByZXNzIHN0cmluZyBvciBieXRlIGFycmF5IHVzaW5nIGZhc3QgYW5kIGVmZmljaWVudCBhbGdvcml0aG0uXG4gKlxuICogQmVjYXVzZSBvZiB3ZWFrIG9mIGphdmFzY3JpcHQncyBuYXR1cmFsLCBtYW55IGNvbXByZXNzaW9uIGFsZ29yaXRobVxuICogYmVjb21lIHVzZWxlc3MgaW4gamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbi4gVGhlIG1haW4gcHJvYmxlbSBpc1xuICogcGVyZm9ybWFuY2UsIGV2ZW4gdGhlIHNpbXBsZSBIdWZmbWFuLCBMWjc3Lzc4IGFsZ29yaXRobSB3aWxsIHRha2UgbWFueVxuICogbWFueSB0aW1lIHRvIG9wZXJhdGUuIFdlIHVzZSBMWkpCIGFsZ29yaXRobSB0byBkbyB0aGF0LCBpdCBzdXByaXNpbmdseVxuICogZnVsZmlsbHMgb3VyIHJlcXVpcmVtZW50IHRvIGNvbXByZXNzIHN0cmluZyBmYXN0bHkgYW5kIGVmZmljaWVudGx5LlxuICpcbiAqIE91ciBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvblxuICogaHR0cDovL3NyYy5vcGVuc29sYXJpcy5vcmcvc291cmNlL3Jhdy9vbm52L29ubnYtZ2F0ZS91c3Ivc3JjL3V0cy9jb21tb24vZnMvemZzL2x6amIuY1xuICogYW5kXG4gKiBodHRwOi8vc3JjLm9wZW5zb2xhcmlzLm9yZy9zb3VyY2UvcmF3L29ubnYvb25udi1nYXRlL3Vzci9zcmMvdXRzL2NvbW1vbi9vcy9jb21wcmVzcy5jXG4gKiBJdCBpcyBsaWNlbnNlZCB1bmRlciBDRERMLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ8c3RyZWFtfSBpbnB1dCBUaGUgc3RyZWFtIG9yIGJ5dGUgYXJyYXlcbiAqICAgICAgICB0aGF0IHlvdSB3YW50IHRvIGNvbXByZXNzLlxuICogQHBhcmFtIHtzdHJlYW19IG91dHB1dCBPcHRpb25hbCBvdXRwdXQgc3RyZWFtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IENvbXByZXNzZWQgYnl0ZSBhcnJheSwgb3IgJ291dHB1dCdcbiAqL1xuTHpqYi5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihMempiLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSwgcHJvcHMpIHtcbiAgICB2YXIgc3N0YXJ0LCBkc3RhcnQgPSBbXSwgc2xlbixcbiAgICAgICAgc3JjID0gMCwgZHN0ID0gMCxcbiAgICAgICAgY3B5LCBjb3B5bWFwLFxuICAgICAgICBtbGVuLCBvZmZzZXQsXG4gICAgICAgIGhhc2gsIGhwLFxuICAgICAgICBsZW1wZWwsXG4gICAgICAgIGksIGo7XG4gICAgdmFyIHJldHZhbDtcblxuICAgIC8vIGluIGFuIGltcHJvdmVtZW50IG92ZXIgdGhlIG9yaWdpbmFsIEMgaW1wbGVtZW50YXRpb24sIHdlIGV4cGFuZFxuICAgIC8vIHRoZSBoYXNoIHRhYmxlIHRvIHRyYWNrIGEgbnVtYmVyIG9mIHBvdGVudGlhbCBtYXRjaGVzLCBub3QganVzdCB0aGVcbiAgICAvLyBtb3N0IHJlY2VudC4gIFRoaXMgZG9lc24ndCByZXF1aXJlIGFueSBjaGFuZ2VzIHRvIHRoZSBkZWNvZGVyLlxuICAgIC8vIFNhbXBsZSBpbXBhY3Qgb24gY29tcHJlc3Npb24gc2l6ZSAob24gd2lraXBlZGlhIGRhdGEpOlxuICAgIC8vICBFWFBBTkQgIFRpbWUgICAgIFNpemUgICAgICBPcHRpb25cbiAgICAvLyAgICAxICAgMG0yMC4zMjFzICA1MDE4NTYxMyAgICAtMVxuICAgIC8vICAgIDIgICAwbTIyLjQzN3MgIDQ2NTAzMzAxICAgIC0yXG4gICAgLy8gICAgMyAgIDBtMjMuNzczcyAgNDU3NDQ1NjQgICAgLTNcbiAgICAvLyAgICA0ICAgMG0yNS42NjZzICA0NTE5OTg2NiAgICAtNFxuICAgIC8vICAgIDUgICAwbTM1LjgxMHMgIDQ0ODIxNDEzICAgIC01XG4gICAgLy8gICAgNiAgIDBtNDAuOTQ3cyAgNDQ2NjY2MzggICAgLTZcbiAgICAvLyAgICA4ICAgMG00OS42MzlzICA0NDQxMzg2NSAgICAtN1xuICAgIC8vICAgMTIgICAwbTQ5LjkyN3MgIDQ0MTI0ODI1ICAgIC04XG4gICAgLy8gICAxNiAgIDFtMDEuMTgwcyAgNDM5NzI1MTUgICAgLTlcbiAgICAvLyAgIDMyICAgMW0zMC41MzBzICA0MzU1NDA5OVxuICAgIC8vICAgNjQgICAybTE0LjUwNHMgIDQzMDA1NTMwXG4gICAgLy8gIDEyOCAgIDNtNDMuNTcwcyAgNDIzNjE3MThcbiAgICAvLyAgMjU2ICAgNm0zOC42ODFzICA0MTY4NDg1M1xuICAgIHZhciBMRU1QRUxfU0laRSA9IExFTVBFTF9TSVpFX0JBU0U7XG4gICAgdmFyIEVYUEFORCA9IDE7IC8vIGRlZmF1bHQgdG8gb3JpZ2luYWwgQyBpbXBsXG4gICAgaWYgKHR5cGVvZihwcm9wcyk9PT0nbnVtYmVyJykge1xuICAgICAgICBMRU1QRUxfU0laRSAqPSAyO1xuICAgICAgICBwcm9wcyA9IE1hdGgubWF4KDEsIE1hdGgubWluKDksIHByb3BzKSkgLSAxO1xuICAgICAgICBFWFBBTkQgPSAxPDxNYXRoLmZsb29yKHByb3BzLzIpO1xuICAgICAgICBpZiAocHJvcHMmMSkgRVhQQU5EID0gTWF0aC5yb3VuZChFWFBBTkQgKiAxLjUpO1xuICAgICAgICBpZiAocHJvcHMgPj0yICYmIHByb3BzIDw9IDQpIEVYUEFORCsrO1xuICAgIH1cblxuICAgIC8vIHVzZSBVaW50MTZBcnJheSBpZiBhdmFpbGFibGUgKHplcm8tZmlsbGVkKVxuICAgIGxlbXBlbCA9IFV0aWwubWFrZVUxNkJ1ZmZlcihMRU1QRUxfU0laRSAqIEVYUEFORCk7XG5cbiAgICB2YXIgd2luZG93ID0gVXRpbC5tYWtlVThCdWZmZXIoT0ZGU0VUX01BU0srMSk7XG4gICAgdmFyIHdpbmRvd3BvcyA9IDA7XG4gICAgdmFyIHdpbnB1dCA9IGZ1bmN0aW9uKF9ieXRlKSB7XG4gICAgICAgIHdpbmRvd1t3aW5kb3dwb3MrK10gPSBfYnl0ZTtcbiAgICAgICAgaWYgKHdpbmRvd3BvcyA+PSB3aW5kb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aW5kb3dwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYnl0ZTtcbiAgICB9O1xuXG4gICAgdmFyIG91dHdpbmRvdyA9IFV0aWwubWFrZVU4QnVmZmVyKDE3KTtcbiAgICB2YXIgb3V0cG9zID0gMDtcbiAgICB2YXIgZHVtcG91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpPTA7IGk8b3V0cG9zOyBpKyspIHtcbiAgICAgICAgICAgIG91dFN0cmVhbS53cml0ZUJ5dGUob3V0d2luZG93W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwb3MgPSAwO1xuICAgIH07XG5cbiAgICB2YXIgdW5idWZmZXIgPSBbXTtcbiAgICB2YXIgZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh1bmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5idWZmZXIucG9wKCk7XG4gICAgICAgIHJldHVybiBpblN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgIH07XG4gICAgdmFyIHVuZ2V0ID0gZnVuY3Rpb24oX2J5dGUpIHtcbiAgICAgICAgdW5idWZmZXIucHVzaChfYnl0ZSk7XG4gICAgfTtcblxuICAgIHZhciBjb3B5bWFzayA9IDEgPDwgKE5CQlkgLSAxKTtcbiAgICB2YXIgbWF0Y2hwb3NzaWJpbGl0eSA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBjMSA9IGdldCgpO1xuICAgICAgICBpZiAoYzEgPT09IEVPRikgYnJlYWs7XG5cbiAgICAgICAgaWYgKChjb3B5bWFzayA8PD0gMSkgPT0gKDEgPDwgTkJCWSkpIHtcbiAgICAgICAgICAgIGR1bXBvdXQoKTtcbiAgICAgICAgICAgIGNvcHltYXNrID0gMTtcbiAgICAgICAgICAgIG91dHdpbmRvd1swXSA9IDA7XG4gICAgICAgICAgICBvdXRwb3MgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMyID0gZ2V0KCk7XG4gICAgICAgIGlmIChjMiA9PT0gRU9GKSB7XG4gICAgICAgICAgICBvdXR3aW5kb3dbb3V0cG9zKytdID0gd2lucHV0KGMxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjMyA9IGdldCgpO1xuICAgICAgICBpZiAoYzMgPT09IEVPRikge1xuICAgICAgICAgICAgb3V0d2luZG93W291dHBvcysrXSA9IHdpbnB1dChjMSk7XG4gICAgICAgICAgICB1bmdldChjMik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc2ggPSAoYzEgPDwgMTYpICsgKGMyIDw8IDgpICsgYzM7XG4gICAgICAgIGhhc2ggXj0gKGhhc2ggPj4gOSk7XG4gICAgICAgIGhhc2ggKz0gKGhhc2ggPj4gNSk7XG4gICAgICAgIGhhc2ggXj0gYzE7XG4gICAgICAgIGhwID0gKGhhc2ggJiAoTEVNUEVMX1NJWkUgLSAxKSkgKiBFWFBBTkQ7XG4gICAgICAgIG1hdGNocG9zc2liaWxpdHkubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChqPTA7IGo8RVhQQU5EOyBqKyspIHtcbiAgICAgICAgICAgIG9mZnNldCA9ICh3aW5kb3dwb3MgLSBsZW1wZWxbaHAral0pICYgT0ZGU0VUX01BU0s7XG4gICAgICAgICAgICBjcHkgPSB3aW5kb3cubGVuZ3RoICsgd2luZG93cG9zIC0gb2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHcxID0gd2luZG93W2NweSAmIE9GRlNFVF9NQVNLXTtcbiAgICAgICAgICAgIHZhciB3MiA9IHdpbmRvd1soY3B5KzEpICYgT0ZGU0VUX01BU0tdO1xuICAgICAgICAgICAgdmFyIHczID0gd2luZG93WyhjcHkrMikgJiBPRkZTRVRfTUFTS107XG4gICAgICAgICAgICAvLyBpZiBvZmZzZXQgaXMgc21hbGwsIHdlIG1pZ2h0IG5vdCBoYXZlIGNvcGllZCB0aGUgdGVudGF0aXZlXG4gICAgICAgICAgICAvLyBieXRlcyBpbnRvIHRoZSB3aW5kb3cgeWV0LiAgKE5vdGUgdGhhdCBvZmZzZXQ9MCByZWFsbHkgbWVhbnNcbiAgICAgICAgICAgIC8vIG9mZnNldD0oT0ZGU0VUX01BU0srMSkuKVxuICAgICAgICAgICAgaWYgKENfQ09NUEFUICYmIG9mZnNldD09PTApIHtcbiAgICAgICAgICAgICAgICB3MSA9IGMxIF4gMTsgLy8gZW5zdXJlIG1hdGNoIHdpbGwgZmFpbFxuICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQ9PTEpIHsgdzIgPSBjMTsgdzMgPSBjMjsgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2Zmc2V0PT0yKSB7IHczID0gYzE7IH1cbiAgICAgICAgICAgIGlmIChjMSA9PT0gdzEgJiYgYzIgPT09IHcyICYmIGMzID09PSB3Mykge1xuICAgICAgICAgICAgICAgIG1hdGNocG9zc2liaWxpdHkucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRoaXMgbG9jYXRpb24gaW4gdGhlIGhhc2gsIG1vdmUgdGhlIG90aGVycyBvdmVyIHRvIG1ha2Ugcm9vbVxuICAgICAgICAvLyBvbGRlc3QgbWF0Y2ggZHJvcHMgb2ZmXG4gICAgICAgIGZvciAoaj1FWFBBTkQtMTsgaj4wOyBqLS0pXG4gICAgICAgICAgICBsZW1wZWxbaHAral0gPSBsZW1wZWxbaHArai0xXTtcbiAgICAgICAgbGVtcGVsW2hwXSA9IHdpbmRvd3BvcztcbiAgICAgICAgLy8gZGlkIHdlIGZpbmQgYW55IG1hdGNoZXM/XG4gICAgICAgIGlmIChtYXRjaHBvc3NpYmlsaXR5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3V0d2luZG93W291dHBvcysrXSA9IHdpbnB1dChjMSk7XG4gICAgICAgICAgICB1bmdldChjMyk7XG4gICAgICAgICAgICB1bmdldChjMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBsb25nZXN0IG9mIHRoZSBwb3NzaWJsZSBtYXRjaGVzXG4gICAgICAgICAgICBvdXR3aW5kb3dbMF0gfD0gY29weW1hc2s7XG4gICAgICAgICAgICB3aW5wdXQoYzEpOyB3aW5wdXQoYzIpOyB3aW5wdXQoYzMpO1xuICAgICAgICAgICAgdmFyIGM0ID0gZ2V0KCksIGxhc3QgPSBtYXRjaHBvc3NpYmlsaXR5WzBdO1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB3aW5kb3cubGVuZ3RoICsgd2luZG93cG9zO1xuICAgICAgICAgICAgZm9yIChtbGVuID0gTUFUQ0hfTUlOOyBtbGVuIDwgTUFUQ0hfTUFYOyBtbGVuKyssIGJhc2UrKykge1xuICAgICAgICAgICAgICAgIGlmIChjNCA9PT0gRU9GKSBicmVhaztcbiAgICAgICAgICAgICAgICBmb3IgKGo9MDsgaiA8IG1hdGNocG9zc2liaWxpdHkubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHc0ID0gd2luZG93WyhiYXNlIC0gbWF0Y2hwb3NzaWJpbGl0eVtqXSkgJiBPRkZTRVRfTUFTS107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjNCAhPT0gdzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBtYXRjaHBvc3NpYmlsaXR5W2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hwb3NzaWJpbGl0eS5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNocG9zc2liaWxpdHkubGVuZ3RoPT09MCkgYnJlYWs7IC8vIG5vIG1vcmUgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIHdpbnB1dChjNCk7XG4gICAgICAgICAgICAgICAgYzQgPSBnZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaHBvc3NpYmlsaXR5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG1heGltdW0gbGVuZ3RoIG1hdGNoLCByb2NrIG9uIVxuICAgICAgICAgICAgICAgIGxhc3QgPSBtYXRjaHBvc3NpYmlsaXR5WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5nZXQoYzQpO1xuXG4gICAgICAgICAgICBvdXR3aW5kb3dbb3V0cG9zKytdID0gKChtbGVuIC0gTUFUQ0hfTUlOKSA8PCAoTkJCWSAtIE1BVENIX0JJVFMpKSB8XG4gICAgICAgICAgICAgICAgKGxhc3QgPj4gTkJCWSk7XG4gICAgICAgICAgICBvdXR3aW5kb3dbb3V0cG9zKytdID0gbGFzdCAmIDB4RkY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHVtcG91dCgpO1xufSk7XG5cbi8qKlxuICogRGVjb21wcmVzcyBzdHJpbmcgb3IgYnl0ZSBhcnJheSB1c2luZyBmYXN0IGFuZCBlZmZpY2llbnQgYWxnb3JpdGhtLlxuICpcbiAqIE91ciBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvblxuICogaHR0cDovL3NyYy5vcGVuc29sYXJpcy5vcmcvc291cmNlL3Jhdy9vbm52L29ubnYtZ2F0ZS91c3Ivc3JjL3V0cy9jb21tb24vZnMvemZzL2x6amIuY1xuICogYW5kXG4gKiBodHRwOi8vc3JjLm9wZW5zb2xhcmlzLm9yZy9zb3VyY2UvcmF3L29ubnYvb25udi1nYXRlL3Vzci9zcmMvdXRzL2NvbW1vbi9vcy9jb21wcmVzcy5jXG4gKiBJdCBpcyBsaWNlbnNlZCB1bmRlciBDRERMLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ8c3RyZWFtfSBpbnB1dCBUaGUgc3RyZWFtIG9yIGJ5dGUgYXJyYXlcbiAqICAgICAgICB0aGF0IHlvdSB3YW50IHRvIGRlY29tcHJlc3MuXG4gKiBAcGFyYW0ge3N0cmVhbX0gb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBzdHJlYW0uXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gRGVjb21wcmVzc2VkIGJ5dGUgYXJyYXksIG9yICdvdXRwdXQnXG4gKi9cbkx6amIuZGVjb21wcmVzc0ZpbGUgPSBVdGlsLmRlY29tcHJlc3NGaWxlSGVscGVyKEx6amIuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIG91dFNpemUpIHtcbiAgICB2YXIgc3N0YXJ0LCBkc3RhcnQgPSBbXSwgc2xlbixcbiAgICAgICAgc3JjID0gMCwgZHN0ID0gMCxcbiAgICAgICAgY3B5LCBjb3B5bWFwLFxuICAgICAgICBtbGVuLCBvZmZzZXQsXG4gICAgICAgIGksIGM7XG4gICAgdmFyIHJldHZhbDtcblxuICAgIHZhciB3aW5kb3cgPSBVdGlsLm1ha2VVOEJ1ZmZlcihPRkZTRVRfTUFTSysxKTtcbiAgICB2YXIgd2luZG93cG9zID0gMDtcblxuICAgIHZhciBjb3B5bWFzayA9IDEgPDwgKE5CQlkgLSAxKTtcblxuICAgIHdoaWxlIChvdXRTaXplICE9PSAwKSB7XG4gICAgICAgIGMgPSBpblN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICBpZiAoYyA9PT0gRU9GKSBicmVhaztcblxuICAgICAgICBpZiAoKGNvcHltYXNrIDw8PSAxKSA9PSAoMSA8PCBOQkJZKSkge1xuICAgICAgICAgICAgY29weW1hc2sgPSAxO1xuICAgICAgICAgICAgY29weW1hcCA9IGM7XG4gICAgICAgICAgICBjID0gaW5TdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weW1hcCAmIGNvcHltYXNrKSB7XG4gICAgICAgICAgICBtbGVuID0gKGMgPj4gKE5CQlkgLSBNQVRDSF9CSVRTKSkgKyBNQVRDSF9NSU47XG4gICAgICAgICAgICBvZmZzZXQgPSAoKGMgPDwgTkJCWSkgfCBpblN0cmVhbS5yZWFkQnl0ZSgpKSAmIE9GRlNFVF9NQVNLO1xuICAgICAgICAgICAgY3B5ID0gd2luZG93cG9zIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGNweSA8IDApIGNweSArPSB3aW5kb3cubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG91dFNpemUgPj0gMCkgb3V0U2l6ZSAtPSBtbGVuO1xuICAgICAgICAgICAgd2hpbGUgKC0tbWxlbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IHdpbmRvd1t3aW5kb3dwb3MrK10gPSB3aW5kb3dbY3B5KytdO1xuICAgICAgICAgICAgICAgIG91dFN0cmVhbS53cml0ZUJ5dGUoYyk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvd3BvcyA+PSB3aW5kb3cubGVuZ3RoKSB7IHdpbmRvd3Bvcz0wOyB9XG4gICAgICAgICAgICAgICAgaWYgKGNweSA+PSB3aW5kb3cubGVuZ3RoKSB7IGNweSA9IDA7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dFN0cmVhbS53cml0ZUJ5dGUoYyk7XG4gICAgICAgICAgICB3aW5kb3dbd2luZG93cG9zKytdID0gYztcbiAgICAgICAgICAgIGlmICh3aW5kb3dwb3MgPj0gd2luZG93Lmxlbmd0aCkgeyB3aW5kb3dwb3M9MDsgfVxuICAgICAgICAgICAgaWYgKG91dFNpemUgPj0gMCkgb3V0U2l6ZS0tO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxucmV0dXJuIEx6amI7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyogVHdlYWtlZCB2ZXJzaW9uIG9mIExaSkIsIHVzaW5nIHJhbmdlIGNvZGVyLiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vQ29udGV4dDFNb2RlbCcpLFxuXHRyZXF1aXJlKCcuL0ZlbndpY2tNb2RlbCcpLFxuXHRyZXF1aXJlKCcuL0xvZ0Rpc3RhbmNlTW9kZWwnKSxcblx0cmVxdWlyZSgnLi9Ob01vZGVsJyksXG5cdHJlcXVpcmUoJy4vUmFuZ2VDb2RlcicpLFxuXHRyZXF1aXJlKCcuL1N0cmVhbScpLFxuXHRyZXF1aXJlKCcuL1V0aWwnKVxuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKENvbnRleHQxTW9kZWwsRmVud2lja01vZGVsLExvZ0Rpc3RhbmNlTW9kZWwsTm9Nb2RlbCxSYW5nZUNvZGVyLFN0cmVhbSxVdGlsKXtcblxudmFyIEx6amJSID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbkx6amJSLk1BR0lDID0gJ2x6alInO1xuXG4vLyBDb25zdGFudHMgd2FzIHVzZWQgZm9yIGNvbXByZXNzL2RlY29tcHJlc3MgZnVuY3Rpb24uXG52YXIgTkJCWSA9IDgsXG4gICAgTUFUQ0hfQklUUyA9IDYsXG4gICAgTUFUQ0hfTUlOID0gMyxcbiAgICBNQVRDSF9NQVggPSAoKDEgPDwgTUFUQ0hfQklUUykgKyAoTUFUQ0hfTUlOIC0gMSkpLFxuICAgIE9GRlNFVF9NQVNLID0gKCgxIDw8ICgxNiAtIE1BVENIX0JJVFMpKSAtIDEpLFxuICAgIExFTVBFTF9TSVpFX0JBU0UgPSAxMDI0O1xudmFyIExFTkdUSF9NT0RFTF9DVVRPRkYgPSAzMjtcblxuXG4vKipcbiAqIENvbXByZXNzIHVzaW5nIG1vZGlmaWVkIExaSkIgYWxnb3JpdGhtLiAgSW5zdGVhZCBvZiB1c2luZyB0aGUgc2ltcGxlXG4gKiA5LWJpdCBsaXRlcmFsIC8gMTctYml0IG1hdGNoIGZvcm1hdCBvZiB0aGUgb3JpZ2luYWwsIHVzZSBhIHJhbmdlXG4gKiBjb2RlciBmb3IgdGhlIGxpdGVyYWwvbWF0Y2ggYml0IGFuZCBmb3IgdGhlIG9mZnNldCBhbmQgbGVuZ3RoLlxuICovXG5MempiUi5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihMempiUi5NQUdJQywgZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgZmlsZVNpemUsIHByb3BzLCBmaW5hbEJ5dGUpIHtcbiAgICB2YXIgc3N0YXJ0LCBkc3RhcnQgPSBbXSwgc2xlbixcbiAgICAgICAgc3JjID0gMCwgZHN0ID0gMCxcbiAgICAgICAgY3B5LCBjb3B5bWFwLFxuICAgICAgICBtbGVuLCBvZmZzZXQsXG4gICAgICAgIGhhc2gsIGhwLFxuICAgICAgICBsZW1wZWwsXG4gICAgICAgIGksIGo7XG5cbiAgICAvLyBpbiBhbiBpbXByb3ZlbWVudCBvdmVyIHRoZSBvcmlnaW5hbCBDIGltcGxlbWVudGF0aW9uIG9mIExaSkIsIHdlIGV4cGFuZFxuICAgIC8vIHRoZSBoYXNoIHRhYmxlIHRvIHRyYWNrIGEgbnVtYmVyIG9mIHBvdGVudGlhbCBtYXRjaGVzLCBub3QganVzdCB0aGVcbiAgICAvLyBtb3N0IHJlY2VudC4gIFRoaXMgZG9lc24ndCByZXF1aXJlIGFueSBjaGFuZ2VzIHRvIHRoZSBkZWNvZGVyLlxuICAgIHZhciBMRU1QRUxfU0laRSA9IExFTVBFTF9TSVpFX0JBU0U7XG4gICAgdmFyIEVYUEFORCA9IDE7IC8vIGRlZmF1bHQgdG8gb3JpZ2luYWwgQyBpbXBsXG4gICAgaWYgKHR5cGVvZihwcm9wcyk9PT0nbnVtYmVyJykge1xuICAgICAgICBMRU1QRUxfU0laRSAqPSAyO1xuICAgICAgICBwcm9wcyA9IE1hdGgubWF4KDEsIE1hdGgubWluKDksIHByb3BzKSkgLSAxO1xuICAgICAgICBFWFBBTkQgPSAxPDxNYXRoLmZsb29yKHByb3BzLzIpO1xuICAgICAgICBpZiAocHJvcHMmMSkgRVhQQU5EID0gTWF0aC5yb3VuZChFWFBBTkQgKiAxLjUpO1xuICAgICAgICBpZiAocHJvcHMgPj0yICYmIHByb3BzIDw9IDQpIEVYUEFORCsrO1xuICAgIH1cblxuICAgIHZhciBlbmNvZGVyID0gbmV3IFJhbmdlQ29kZXIob3V0U3RyZWFtKTtcbiAgICBlbmNvZGVyLmVuY29kZVN0YXJ0KGZpbmFsQnl0ZSwgMSk7XG5cbiAgICAvLyB1c2UgVWludDE2QXJyYXkgaWYgYXZhaWxhYmxlICh6ZXJvLWZpbGxlZClcbiAgICBsZW1wZWwgPSBVdGlsLm1ha2VVMTZCdWZmZXIoTEVNUEVMX1NJWkUgKiBFWFBBTkQpO1xuXG4gICAgdmFyIHdpbmRvdyA9IFV0aWwubWFrZVU4QnVmZmVyKE9GRlNFVF9NQVNLKzEpO1xuICAgIHZhciB3aW5kb3dwb3MgPSAwO1xuICAgIHZhciB3aW5wdXQgPSBmdW5jdGlvbihfYnl0ZSkge1xuICAgICAgICB3aW5kb3dbd2luZG93cG9zKytdID0gX2J5dGU7XG4gICAgICAgIGlmICh3aW5kb3dwb3MgPj0gd2luZG93Lmxlbmd0aCkge1xuICAgICAgICAgICAgd2luZG93cG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2J5dGU7XG4gICAgfTtcblxuICAgIHZhciB1bmJ1ZmZlciA9IFtdO1xuICAgIHZhciBnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHVuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmJ1ZmZlci5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGluU3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgfTtcbiAgICB2YXIgdW5nZXQgPSBmdW5jdGlvbihfYnl0ZSkge1xuICAgICAgICB1bmJ1ZmZlci5wdXNoKF9ieXRlKTtcbiAgICB9O1xuXG4gICAgdmFyIG1hdGNocG9zc2liaWxpdHkgPSBbXTtcbiAgICB2YXIgTUFUQ0ggPSAyNTY7XG4gICAgdmFyIEVPRl9TWU0gPSAyNTc7XG4gICAgdmFyIG5vTW9kZWxGYWN0b3J5ID0gTm9Nb2RlbC5mYWN0b3J5KGVuY29kZXIpO1xuICAgIHZhciBtb2RlbEZhY3RvcnkgPSBGZW53aWNrTW9kZWwuZmFjdG9yeShlbmNvZGVyLCAweEZGMDAsIDB4MTAwKTtcbiAgICB2YXIgbGl0ZXJhbE1vZGVsID0gbmV3IENvbnRleHQxTW9kZWwobW9kZWxGYWN0b3J5LCAyNTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZmlsZVNpemU8MCkgPyBFT0ZfU1lNIDogTUFUQ0gpICsgMSk7XG4gICAgdmFyIHNwYXJzZU1vZGVsRmFjdG9yeSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgaWYgKHNpemUgPD0gTEVOR1RIX01PREVMX0NVVE9GRikgeyByZXR1cm4gbW9kZWxGYWN0b3J5KHNpemUpOyB9XG4gICAgICAgIHJldHVybiBub01vZGVsRmFjdG9yeShzaXplKTtcbiAgICB9O1xuICAgIHZhciBsZW5Nb2RlbCA9IG5ldyBMb2dEaXN0YW5jZU1vZGVsKChNQVRDSF9NQVgtTUFUQ0hfTUlOKSsxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsRmFjdG9yeSwgc3BhcnNlTW9kZWxGYWN0b3J5KTtcbiAgICB2YXIgcG9zTW9kZWwgPSBuZXcgTG9nRGlzdGFuY2VNb2RlbChPRkZTRVRfTUFTSysxLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsRmFjdG9yeSwgc3BhcnNlTW9kZWxGYWN0b3J5KTtcbiAgICB2YXIgbGFzdENoYXIgPSAweDIwLCBsYXN0T2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgaW5pdGlhbFBvcyA9IHdpbmRvd3BvcztcbiAgICAgICAgdmFyIGMxID0gZ2V0KCk7XG4gICAgICAgIGlmIChjMSA9PT0gU3RyZWFtLkVPRikgYnJlYWs7XG5cbiAgICAgICAgdmFyIGMyID0gZ2V0KCk7XG4gICAgICAgIGlmIChjMiA9PT0gU3RyZWFtLkVPRikge1xuICAgICAgICAgICAgbGl0ZXJhbE1vZGVsLmVuY29kZSh3aW5wdXQoYzEpLCBsYXN0Q2hhcik7IC8vIGxpdGVyYWwsIG5vdCBhIG1hdGNoXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYzMgPSBnZXQoKTtcbiAgICAgICAgaWYgKGMzID09PSBTdHJlYW0uRU9GKSB7XG4gICAgICAgICAgICBsaXRlcmFsTW9kZWwuZW5jb2RlKHdpbnB1dChjMSksIGxhc3RDaGFyKTsgLy8gbGl0ZXJhbCwgbm90IGEgbWF0Y2hcbiAgICAgICAgICAgIHVuZ2V0KGMyKTsgbGFzdENoYXIgPSBjMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzaCA9IChjMSA8PCAxNikgKyAoYzIgPDwgOCkgKyBjMztcbiAgICAgICAgaGFzaCBePSAoaGFzaCA+PiA5KTtcbiAgICAgICAgaGFzaCArPSAoaGFzaCA+PiA1KTtcbiAgICAgICAgaGFzaCBePSBjMTtcbiAgICAgICAgaHAgPSAoaGFzaCAmIChMRU1QRUxfU0laRSAtIDEpKSAqIEVYUEFORDtcbiAgICAgICAgbWF0Y2hwb3NzaWJpbGl0eS5sZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGo9MDsgajxFWFBBTkQ7IGorKykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKHdpbmRvd3BvcyAtIGxlbXBlbFtocCtqXSkgJiBPRkZTRVRfTUFTSztcbiAgICAgICAgICAgIGNweSA9IHdpbmRvdy5sZW5ndGggKyB3aW5kb3dwb3MgLSBvZmZzZXQ7XG4gICAgICAgICAgICB2YXIgdzEgPSB3aW5kb3dbY3B5ICYgT0ZGU0VUX01BU0tdO1xuICAgICAgICAgICAgdmFyIHcyID0gd2luZG93WyhjcHkrMSkgJiBPRkZTRVRfTUFTS107XG4gICAgICAgICAgICB2YXIgdzMgPSB3aW5kb3dbKGNweSsyKSAmIE9GRlNFVF9NQVNLXTtcbiAgICAgICAgICAgIC8vIGlmIG9mZnNldCBpcyBzbWFsbCwgd2UgbWlnaHQgbm90IGhhdmUgY29waWVkIHRoZSB0ZW50YXRpdmVcbiAgICAgICAgICAgIC8vIGJ5dGVzIGludG8gdGhlIHdpbmRvdyB5ZXQuICAoTm90ZSB0aGF0IG9mZnNldD0wIHJlYWxseSBtZWFuc1xuICAgICAgICAgICAgLy8gb2Zmc2V0PShPRkZTRVRfTUFTSysxKS4pXG4gICAgICAgICAgICBpZiAob2Zmc2V0PT0xKSB7IHcyID0gYzE7IHczID0gYzI7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldD09MikgeyB3MyA9IGMxOyB9XG4gICAgICAgICAgICBpZiAoYzEgPT09IHcxICYmIGMyID09PSB3MiAmJiBjMyA9PT0gdzMpIHtcbiAgICAgICAgICAgICAgICBtYXRjaHBvc3NpYmlsaXR5LnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9yZSB0aGlzIGxvY2F0aW9uIGluIHRoZSBoYXNoLCBtb3ZlIHRoZSBvdGhlcnMgb3ZlciB0byBtYWtlIHJvb21cbiAgICAgICAgLy8gb2xkZXN0IG1hdGNoIGRyb3BzIG9mZlxuICAgICAgICBmb3IgKGo9RVhQQU5ELTE7IGo+MDsgai0tKVxuICAgICAgICAgICAgbGVtcGVsW2hwK2pdID0gbGVtcGVsW2hwK2otMV07XG4gICAgICAgIGxlbXBlbFtocF0gPSB3aW5kb3dwb3M7XG4gICAgICAgIC8vIGRpZCB3ZSBmaW5kIGFueSBtYXRjaGVzP1xuICAgICAgICBpZiAobWF0Y2hwb3NzaWJpbGl0eS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpdGVyYWxNb2RlbC5lbmNvZGUod2lucHV0KGMxKSwgbGFzdENoYXIpOyAvLyBsaXRlcmFsLCBub3QgYSBtYXRjaFxuICAgICAgICAgICAgdW5nZXQoYzMpO1xuICAgICAgICAgICAgdW5nZXQoYzIpO1xuICAgICAgICAgICAgbGFzdENoYXIgPSBjMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpdGVyYWxNb2RlbC5lbmNvZGUoTUFUQ0gsIGxhc3RDaGFyKTsgLy8gYSBtYXRjaCFcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGxvbmdlc3Qgb2YgdGhlIHBvc3NpYmxlIG1hdGNoZXNcbiAgICAgICAgICAgIHdpbnB1dChjMSk7IHdpbnB1dChjMik7IHdpbnB1dChjMyk7IGxhc3RDaGFyID0gYzM7XG4gICAgICAgICAgICB2YXIgYzQgPSBnZXQoKSwgbGFzdCA9IG1hdGNocG9zc2liaWxpdHlbMF07XG4gICAgICAgICAgICB2YXIgYmFzZSA9IHdpbmRvdy5sZW5ndGggKyB3aW5kb3dwb3M7XG4gICAgICAgICAgICBmb3IgKG1sZW4gPSBNQVRDSF9NSU47IG1sZW4gPCBNQVRDSF9NQVg7IG1sZW4rKywgYmFzZSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGM0ID09PSBTdHJlYW0uRU9GKSBicmVhaztcbiAgICAgICAgICAgICAgICBmb3IgKGo9MDsgaiA8IG1hdGNocG9zc2liaWxpdHkubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHc0ID0gd2luZG93WyhiYXNlIC0gbWF0Y2hwb3NzaWJpbGl0eVtqXSkgJiBPRkZTRVRfTUFTS107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjNCAhPT0gdzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBtYXRjaHBvc3NpYmlsaXR5W2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hwb3NzaWJpbGl0eS5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNocG9zc2liaWxpdHkubGVuZ3RoPT09MCkgYnJlYWs7IC8vIG5vIG1vcmUgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIHdpbnB1dChjNCk7IGxhc3RDaGFyID0gYzQ7XG4gICAgICAgICAgICAgICAgYzQgPSBnZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaHBvc3NpYmlsaXR5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG1heGltdW0gbGVuZ3RoIG1hdGNoLCByb2NrIG9uIVxuICAgICAgICAgICAgICAgIGxhc3QgPSBtYXRjaHBvc3NpYmlsaXR5WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5nZXQoYzQpO1xuXG4gICAgICAgICAgICAvLyBlbmNvZGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgICAgICAvLyBYWFggd2UgY291bGQgZ2V0IGEgYml0IG1vcmUgY29tcHJlc3Npb24gaWYgd2UgYWxsb3dlZFxuICAgICAgICAgICAgLy8gdGhlIGxlbmd0aCB0byBwcmVkaWN0IHRoZSBvZmZzZXQgKG9yIHZpY2UtdmVyc2EpXG4gICAgICAgICAgICBsZW5Nb2RlbC5lbmNvZGUobWxlbiAtIE1BVENIX01JTik7XG4gICAgICAgICAgICBvZmZzZXQgPSAoaW5pdGlhbFBvcyAtIGxhc3QpICYgT0ZGU0VUX01BU0s7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsYXN0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgcG9zTW9kZWwuZW5jb2RlKC0xKTsgLy8gY29tbW9uIGNhc2UhXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc01vZGVsLmVuY29kZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbGVTaXplIDwgMCkge1xuICAgICAgICBsaXRlcmFsTW9kZWwuZW5jb2RlKEVPRl9TWU0sIGxhc3RDaGFyKTsgLy8gZW5kIG9mIGZpbGUgKHN0cmVhbWluZylcbiAgICB9XG4gICAgZW5jb2Rlci5lbmNvZGVGaW5pc2goKTtcbn0sIHRydWUpO1xuXG4vKipcbiAqIERlY29tcHJlc3MgdXNpbmcgbW9kaWZpZWQgTFpKQiBhbGdvcml0aG0uXG4gKi9cbkx6amJSLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihMempiUi5NQUdJQywgZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgb3V0U2l6ZSkge1xuICAgIHZhciBzc3RhcnQsIGRzdGFydCA9IFtdLCBzbGVuLFxuICAgICAgICBzcmMgPSAwLCBkc3QgPSAwLFxuICAgICAgICBjcHksIGNvcHltYXAsXG4gICAgICAgIG1sZW4sIG9mZnNldCxcbiAgICAgICAgaSwgYztcblxuICAgIHZhciB3aW5kb3cgPSBVdGlsLm1ha2VVOEJ1ZmZlcihPRkZTRVRfTUFTSysxKTtcbiAgICB2YXIgd2luZG93cG9zID0gMDtcblxuICAgIHZhciBkZWNvZGVyID0gbmV3IFJhbmdlQ29kZXIoaW5TdHJlYW0pO1xuICAgIGRlY29kZXIuZGVjb2RlU3RhcnQodHJ1ZS8qIHdlIGFscmVhZHkgcmVhZCB0aGUgJ2ZyZWUnIGJ5dGUqLyk7XG5cbiAgICB2YXIgTUFUQ0ggPSAyNTY7XG4gICAgdmFyIEVPRl9TWU0gPSAyNTc7XG4gICAgdmFyIG5vTW9kZWxGYWN0b3J5ID0gTm9Nb2RlbC5mYWN0b3J5KGRlY29kZXIpO1xuICAgIHZhciBtb2RlbEZhY3RvcnkgPSBGZW53aWNrTW9kZWwuZmFjdG9yeShkZWNvZGVyLCAweEZGMDAsIDB4MTAwKTtcbiAgICB2YXIgbGl0ZXJhbE1vZGVsID0gbmV3IENvbnRleHQxTW9kZWwobW9kZWxGYWN0b3J5LCAyNTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgob3V0U2l6ZTwwKSA/IEVPRl9TWU0gOiBNQVRDSCkgKyAxKTtcbiAgICB2YXIgc3BhcnNlTW9kZWxGYWN0b3J5ID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA8PSBMRU5HVEhfTU9ERUxfQ1VUT0ZGKSB7IHJldHVybiBtb2RlbEZhY3Rvcnkoc2l6ZSk7IH1cbiAgICAgICAgcmV0dXJuIG5vTW9kZWxGYWN0b3J5KHNpemUpO1xuICAgIH07XG4gICAgdmFyIGxlbk1vZGVsID0gbmV3IExvZ0Rpc3RhbmNlTW9kZWwoKE1BVENIX01BWC1NQVRDSF9NSU4pKzEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxGYWN0b3J5LCBzcGFyc2VNb2RlbEZhY3RvcnkpO1xuICAgIHZhciBwb3NNb2RlbCA9IG5ldyBMb2dEaXN0YW5jZU1vZGVsKE9GRlNFVF9NQVNLKzEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxGYWN0b3J5LCBzcGFyc2VNb2RlbEZhY3RvcnkpO1xuICAgIHZhciBsYXN0Q2hhciA9IDB4MjAsIGxhc3RPZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvdXRTaXplICE9PSAwKSB7XG4gICAgICAgIGMgPSBsaXRlcmFsTW9kZWwuZGVjb2RlKGxhc3RDaGFyKTtcbiAgICAgICAgaWYgKGMgPT09IEVPRl9TWU0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IE1BVENIKSB7XG4gICAgICAgICAgICBtbGVuID0gbGVuTW9kZWwuZGVjb2RlKCkgKyBNQVRDSF9NSU47XG4gICAgICAgICAgICBjcHkgPSBwb3NNb2RlbC5kZWNvZGUoKTtcbiAgICAgICAgICAgIGlmIChjcHk8MCkgeyBjcHkgPSBsYXN0T2Zmc2V0OyB9XG4gICAgICAgICAgICBlbHNlICAgICAgIHsgbGFzdE9mZnNldCA9IGNweTsgfVxuICAgICAgICAgICAgaWYgKG91dFNpemUgPj0gMCkgb3V0U2l6ZSAtPSBtbGVuO1xuICAgICAgICAgICAgd2hpbGUgKC0tbWxlbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IGxhc3RDaGFyID0gd2luZG93W3dpbmRvd3BvcysrXSA9IHdpbmRvd1tjcHkrK107XG4gICAgICAgICAgICAgICAgb3V0U3RyZWFtLndyaXRlQnl0ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93cG9zID49IHdpbmRvdy5sZW5ndGgpIHsgd2luZG93cG9zPTA7IH1cbiAgICAgICAgICAgICAgICBpZiAoY3B5ID49IHdpbmRvdy5sZW5ndGgpIHsgY3B5ID0gMDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0U3RyZWFtLndyaXRlQnl0ZShjKTtcbiAgICAgICAgICAgIHdpbmRvd1t3aW5kb3dwb3MrK10gPSBsYXN0Q2hhciA9IGM7XG4gICAgICAgICAgICBpZiAod2luZG93cG9zID49IHdpbmRvdy5sZW5ndGgpIHsgd2luZG93cG9zPTA7IH1cbiAgICAgICAgICAgIGlmIChvdXRTaXplID49IDApIG91dFNpemUtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvZGVyLmRlY29kZUZpbmlzaCgpO1xufSk7XG5cblxucmV0dXJuIEx6amJSO1xufTtcbm1vZHVsZS5leHBvcnRzID0gYm9keV9mbi5hcHBseShudWxsLCBsaWJzKTtcbiIsIi8qIEltcGxlbWVudGF0aW9uIG9mIExaUDMoaXNoKSwgd2l0aCBhbiBhZGFwdGl2ZSBIdWZmbWFuIGNvZGUgb3IgYSByYW5nZVxuICogY29kZXIgKGluc3RlYWQgb2YgTFpQMydzIG9yaWdpbmFsIHN0YXRpYyBIdWZmbWFuIGNvZGUpLlxuICogU2VlOiBodHRwOi8vd3d3LmNibG9vbS5jb20vcGFwZXJzL2x6cC5wZGZcbiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vQml0U3RyZWFtJyksXG5cdHJlcXVpcmUoJy4vQ29udGV4dDFNb2RlbCcpLFxuXHRyZXF1aXJlKCcuL0RlZlN1bU1vZGVsJyksXG5cdHJlcXVpcmUoJy4vRmVud2lja01vZGVsJyksXG5cdHJlcXVpcmUoJy4vSHVmZm1hbicpLFxuXHRyZXF1aXJlKCcuL0xvZ0Rpc3RhbmNlTW9kZWwnKSxcblx0cmVxdWlyZSgnLi9Ob01vZGVsJyksXG5cdHJlcXVpcmUoJy4vUmFuZ2VDb2RlcicpLFxuXHRyZXF1aXJlKCcuL1N0cmVhbScpLFxuXHRyZXF1aXJlKCcuL1V0aWwnKVxuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKEJpdFN0cmVhbSwgQ29udGV4dDFNb2RlbCwgRGVmU3VtTW9kZWwsIEZlbndpY2tNb2RlbCwgSHVmZm1hbiwgTG9nRGlzdGFuY2VNb2RlbCwgTm9Nb2RlbCwgUmFuZ2VDb2RlciwgU3RyZWFtLCBVdGlsKXtcblxudmFyIEx6cDMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuTHpwMy5NQUdJQyA9ICdsenAzJztcblxuLy8gdXNlIEh1ZmZtYW4gY29kZXIgKGZhc3QpIG9yIGVsc2UgdXNlIHJhbmdlIGNvZGVyIChzbG93KVxudmFyIFVTRV9IVUZGTUFOX0NPREUgPSBmYWxzZTtcbi8vIHVzZSBkZWZlcnJlZC1zdW0gbW9kZWwsIHdoaWNoIGlzIHN1cHBvc2VkIHRvIGJlIGZhc3RlciAoYnV0IGNvbXByZXNzZXMgd29yc2UpXG52YXIgVVNFX0RFRlNVTSA9IGZhbHNlO1xuLy8gd2hlbiB0byBnaXZlIHVwIGF0dGVtcHRpbmcgdG8gbW9kZWwgdGhlIGxlbmd0aFxudmFyIExFTkdUSF9NT0RFTF9DVVRPRkYgPSAyNTY7XG52YXIgTU9ERUxfTUFYX1BST0IgPSAweEZGMDA7XG52YXIgTU9ERUxfSU5DUkVNRU5UID0gMHgxMDA7XG5cbi8vIENvbnN0YW50cyB3YXMgdXNlZCBmb3IgY29tcHJlc3MvZGVjb21wcmVzcyBmdW5jdGlvbi5cbnZhciBDVFhUNF9UQUJMRV9TSVpFID0gMSA8PCAxNjtcbnZhciBDVFhUM19UQUJMRV9TSVpFID0gMSA8PCAxMjtcbnZhciBDVFhUMl9UQUJMRV9TSVpFID0gMSA8PCAxNjtcbnZhciBDT05URVhUX0xFTiA9IDQ7XG52YXIgTE9HX1dJTkRPV19TSVpFID0gMjA7XG52YXIgV0lORE9XX1NJWkUgPSAxIDw8IExPR19XSU5ET1dfU0laRTtcbnZhciBNQVhfTUFUQ0hfTEVOID0gV0lORE9XX1NJWkUtMTtcbnZhciBNQVRDSF9MRU5fQ09OVEVYVFMgPSAxNjtcblxudmFyIE1BWDMyID0gMHhGRkZGRkZGRjtcbnZhciBNQVgyNCA9IDB4MDBGRkZGRkY7XG52YXIgTUFYMTYgPSAweDAwMDBGRkZGO1xudmFyIE1BWDggID0gMHgwMDAwMDBGRjtcblxuXG52YXIgV2luZG93ID0gZnVuY3Rpb24obWF4U2l6ZSkge1xuICB0aGlzLmJ1ZmZlciA9IFV0aWwubWFrZVU4QnVmZmVyKE1hdGgubWluKG1heFNpemUrNCwgV0lORE9XX1NJWkUpKTtcbiAgdGhpcy5wb3MgPSAwO1xuICAvLyBjb250ZXh0LTQgaGFzaCB0YWJsZS5cbiAgdGhpcy5jdHh0NCA9IFV0aWwubWFrZVUzMkJ1ZmZlcihDVFhUNF9UQUJMRV9TSVpFKTtcbiAgLy8gY29udGV4dC0zIGhhc2ggdGFibGVcbiAgdGhpcy5jdHh0MyA9IFV0aWwubWFrZVUzMkJ1ZmZlcihDVFhUM19UQUJMRV9TSVpFKTtcbiAgLy8gY29udGV4dC0yIHRhYmxlIChub3QgcmVhbGx5IGEgaGFzaCBhbnkgbW9yZSlcbiAgdGhpcy5jdHh0MiA9IFV0aWwubWFrZVUzMkJ1ZmZlcihDVFhUMl9UQUJMRV9TSVpFKTtcbiAgLy8gaW5pdGlhbCBjb250ZXh0XG4gIHRoaXMucHV0KDB4NjMpOyB0aGlzLnB1dCgweDUzKTsgdGhpcy5wdXQoMHg2MSk7IHRoaXMucHV0KDB4MjApO1xufTtcbldpbmRvdy5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oX2J5dGUpIHtcbiAgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPSBfYnl0ZTtcbiAgaWYgKHRoaXMucG9zID49IFdJTkRPV19TSVpFKSB7IHRoaXMucG9zID0gMDsgfVxuICByZXR1cm4gX2J5dGU7XG59O1xuV2luZG93LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwb3MpIHtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyW3BvcyAmIChXSU5ET1dfU0laRS0xKV07XG59O1xuV2luZG93LnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24ocG9zLCBuKSB7XG4gIHZhciBjID0gMCwgaTtcbiAgcG9zID0gKHBvcyAtIG4pICYgKFdJTkRPV19TSVpFLTEpO1xuICBmb3IgKGk9MDsgaTxuOyBpKyspIHtcbiAgICBjID0gKGMgPDwgOCkgfCB0aGlzLmJ1ZmZlcltwb3MrK107XG4gICAgaWYgKHBvcyA+PSBXSU5ET1dfU0laRSkgeyBwb3MgPSAwOyB9XG4gIH1cbiAgcmV0dXJuIGM7XG59O1xuLy8gaWYgbWF0Y2hMZW4gIT09IDAsIHVwZGF0ZSB0aGUgaW5kZXg7IG90aGVyd2lzZSBnZXQgaW5kZXggdmFsdWUuXG5XaW5kb3cucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24ocywgbWF0Y2hMZW4pIHtcbiAgdmFyIGMgPSB0aGlzLmNvbnRleHQocywgNCk7XG4gIC8vIGNvbXB1dGUgY29udGV4dCBoYXNoZXNcbiAgdmFyIGg0ID0gKChjPj4+MTUpIF4gYykgJiAoQ1RYVDRfVEFCTEVfU0laRS0xKTtcbiAgdmFyIGgzID0gKChjPj4+MTEpIF4gYykgJiAoQ1RYVDNfVEFCTEVfU0laRS0xKTtcbiAgdmFyIGgyID0gYyAmIE1BWDE2O1xuICAvLyBjaGVjayBvcmRlci00IGNvbnRleHRcbiAgdmFyIHAgPSAwLCBjaGVja2M7XG4gIC8vIG9ubHkgZG8gY29udGV4dCBjb25maXJtYXRpb24gaWYgbWF0Y2hMZW49PTAgKHRoYXQgaXMsIGlmIHdlJ3JlIG5vdCBqdXN0XG4gIC8vIGRvaW5nIGFuIHVwZGF0ZSlcbiAgaWYgKG1hdGNoTGVuPT09MCkge1xuICAgIHAgPSB0aGlzLmN0eHQ0W2g0XTtcbiAgICBpZiAocCAhPT0gMCAmJiBjICE9PSB0aGlzLmNvbnRleHQocC0xLCA0KSkge1xuICAgICAgcCA9IDA7IC8vIGNvbnRleHQgY29uZmlybWF0aW9uIGZhaWxlZFxuICAgIH1cbiAgICBpZiAocCA9PT0gMCkge1xuICAgICAgLy8gY2hlY2sgb3JkZXItMyBjb250ZXh0XG4gICAgICBwID0gdGhpcy5jdHh0M1toM107XG4gICAgICBpZiAocCAhPT0gMCAmJiAoYyAmIE1BWDI0KSAhPT0gdGhpcy5jb250ZXh0KHAtMSwgMykpIHtcbiAgICAgICAgcCA9IDA7IC8vIGNvbnRleHQgY29uZmlybWF0aW9uIGZhaWxlZFxuICAgICAgfVxuICAgICAgaWYgKHAgPT09IDApIHtcbiAgICAgICAgLy8gY2hlY2sgb3JkZXItMiBjb250ZXh0XG4gICAgICAgIHAgPSB0aGlzLmN0eHQyW2gyXTtcbiAgICAgICAgaWYgKHAgIT09IDAgJiYgKGMgJiYgTUFYMTYpICE9PSB0aGlzLmNvbnRleHQocC0xLCAyKSkge1xuICAgICAgICAgIHAgPSAwOyAvLyBjb250ZXh0IGNvbmZpcm1hdGlvbiBmYWlsZWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyB1cGRhdGUgY29udGV4dCBpbmRleFxuICBpZiAobWF0Y2hMZW4pIHsgbWF0Y2hMZW4tLTsgfVxuICB0aGlzLmN0eHQ0W2g0XSA9IHRoaXMuY3R4dDNbaDNdID0gdGhpcy5jdHh0MltoMl0gPVxuICAgIChzIHwgKG1hdGNoTGVuIDw8IExPR19XSU5ET1dfU0laRSkpICsgMTtcbiAgLy8gcmV0dXJuIGxvb2t1cCByZXN1bHQuXG4gIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBDb21wcmVzcyB1c2luZyBtb2RpZmllZCBMWlAzIGFsZ29yaXRobS4gIEluc3RlYWQgb2YgdXNpbmcgc3RhdGljXG4gKiBIdWZmbWFuIGNvZGluZywgd2UgdXNlIGFuIGFkYXB0aXZlIEh1ZmZtYW4gY29kZSBvciByYW5nZSBlbmNvZGluZy5cbiAqL1xuTHpwMy5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihMenAzLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSwgcHJvcHMpIHtcbiAgLy8gc2xpZGluZyB3aW5kb3cgJiBoYXNoIHRhYmxlXG4gIHZhciB3aW5kb3cgPSBuZXcgV2luZG93KCAoZmlsZVNpemU+PTApID8gZmlsZVNpemUgOiBXSU5ET1dfU0laRSApO1xuXG4gIHZhciBjb2RlckZhY3RvcnksIHNwYXJzZUNvZGVyRmFjdG9yeSwgZmx1c2g7XG5cbiAgaWYgKFVTRV9IVUZGTUFOX0NPREUpIHtcbiAgICAvLyBIdWZmbWFuIGNvbnRleHRzXG4gICAgb3V0U3RyZWFtLndyaXRlQnl0ZSgweDgwKTsgLy8gbWFyayB0aGF0IHRoaXMgaXMgSHVmZm1hbiBjb2RlZC5cbiAgICB2YXIgYml0c3RyZWFtID0gbmV3IEJpdFN0cmVhbShvdXRTdHJlYW0pO1xuICAgIGZsdXNoID0gYml0c3RyZWFtLmZsdXNoLmJpbmQoYml0c3RyZWFtKTtcbiAgICBjb2RlckZhY3RvcnkgPSBIdWZmbWFuLmZhY3RvcnkoYml0c3RyZWFtLCBNQVgxNik7XG4gICAgc3BhcnNlQ29kZXJGYWN0b3J5ID0gTm9Nb2RlbC5mYWN0b3J5KGJpdHN0cmVhbSk7XG5cbiAgfSBlbHNlIHsgLy8gcmFuZ2UgZW5jb2RlclxuICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZUNvZGVyKG91dFN0cmVhbSk7XG4gICAgcmFuZ2UuZW5jb2RlU3RhcnQoMHgwMCwgMCk7IC8vIDB4MDAgPT0gcmFuZ2UgZW5jb2RlZFxuXG4gICAgY29kZXJGYWN0b3J5ID0gRmVud2lja01vZGVsLmZhY3RvcnkocmFuZ2UsIE1PREVMX01BWF9QUk9CLCBNT0RFTF9JTkNSRU1FTlQpO1xuICAgIGlmIChVU0VfREVGU1VNKSB7XG4gICAgICBjb2RlckZhY3RvcnkgPSBEZWZTdW1Nb2RlbC5mYWN0b3J5KHJhbmdlLCBmYWxzZSAvKiBlbmNvZGVyICovKTtcbiAgICB9XG4gICAgLy8gc3dpdGNoIHNwYXJzZUNvZGVyRmFjdG9yeSB0byBhIE5vTW9kZWwgd2hlbiBzaXplID4gY3V0b2ZmXG4gICAgdmFyIG5vQ29kZXJGYWN0b3J5ID0gTm9Nb2RlbC5mYWN0b3J5KHJhbmdlKTtcbiAgICBzcGFyc2VDb2RlckZhY3RvcnkgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICBpZiAoc2l6ZSA+IExFTkdUSF9NT0RFTF9DVVRPRkYpIHtcbiAgICAgICAgcmV0dXJuIG5vQ29kZXJGYWN0b3J5KHNpemUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGVyRmFjdG9yeShzaXplKTtcbiAgICB9O1xuICAgIGZsdXNoID0gZnVuY3Rpb24oKSB7IHJhbmdlLmVuY29kZUZpbmlzaCgpOyB9O1xuICB9XG5cbiAgdmFyIGh1ZmZMaXRlcmFsPSBuZXcgQ29udGV4dDFNb2RlbChjb2RlckZhY3RvcnksIDI1NixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICB2YXIgaHVmZkxlbiA9IFtdLCBpO1xuICBmb3IgKGk9MDsgaTxNQVRDSF9MRU5fQ09OVEVYVFM7IGkrKykge1xuICAgIGh1ZmZMZW5baV0gPSBuZXcgTG9nRGlzdGFuY2VNb2RlbChNQVhfTUFUQ0hfTEVOKzEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVyRmFjdG9yeSwgc3BhcnNlQ29kZXJGYWN0b3J5KTtcbiAgfVxuXG4gIHZhciBpblNpemUgPSAwLCBzLCBtYXRjaENvbnRleHQgPSAwO1xuICB3aGlsZSAoaW5TaXplICE9PSBmaWxlU2l6ZSkge1xuICAgIHZhciBjaCA9IGluU3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgcyA9IHdpbmRvdy5wb3M7XG4gICAgdmFyIHAgPSB3aW5kb3cuZ2V0SW5kZXgocywgMCk7XG4gICAgaWYgKHAgIT09IDApIHtcbiAgICAgIC8vIGdyZWF0LCBhIG1hdGNoISBob3cgbG9uZyBpcyBpdD9cbiAgICAgIHAtLTsgLy8gcD0wIGlzIHVzZWQgZm9yICdub3QgaGVyZScuIHA9MSByZWFsbHkgbWVhbnMgV0lORE9XX1NJWkVcbiAgICAgIHZhciBwcmV2TWF0Y2hMZW4gPSAocCA+Pj4gTE9HX1dJTkRPV19TSVpFKSArIDE7XG4gICAgICB2YXIgbWF0Y2hMZW4gPSAwO1xuICAgICAgd2hpbGUgKHdpbmRvdy5nZXQocCArIG1hdGNoTGVuKSA9PT0gY2ggJiYgbWF0Y2hMZW4gPCBNQVhfTUFUQ0hfTEVOKSB7XG4gICAgICAgIG1hdGNoTGVuKys7XG4gICAgICAgIHdpbmRvdy5wdXQoY2gpO1xuICAgICAgICBjaCA9IGluU3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICB9XG4gICAgICAvLyBjb2RlIG1hdGNoIGxlbmd0aDsgbWF0Y2ggbGVuID0gMCBtZWFucyBcImxpdGVyYWxcIlxuICAgICAgLy8gdXNlIFwiZXh0cmEgc3RhdGVcIiAtMSB0byBtZWFuIFwic2FtZSBhcyBwcmV2aW91cyBtYXRjaCBsZW5ndGhcIlxuICAgICAgaWYgKHByZXZNYXRjaExlbj09PW1hdGNoTGVuKSB7XG4gICAgICAgIGh1ZmZMZW5bbWF0Y2hDb250ZXh0JihNQVRDSF9MRU5fQ09OVEVYVFMtMSldLmVuY29kZSgtMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodWZmTGVuW21hdGNoQ29udGV4dCYoTUFUQ0hfTEVOX0NPTlRFWFRTLTEpXS5lbmNvZGUobWF0Y2hMZW4pO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIGhhc2ggd2l0aCB0aGlzIG1hdGNoXG4gICAgICB3aW5kb3cuZ2V0SW5kZXgocywgbWF0Y2hMZW4pO1xuICAgICAgaW5TaXplICs9IG1hdGNoTGVuO1xuICAgICAgbWF0Y2hDb250ZXh0IDw8PSAxO1xuICAgICAgaWYgKG1hdGNoTGVuID4gMCkgeyBtYXRjaENvbnRleHQgfD0gMTsgfVxuICAgICAgLy8gWFhYOiBMWk1BIHVzZXMgYSBzcGVjaWFsIFwiZGVsdGEgbWF0Y2hcIiBjb250ZXh0IGhlcmUgaWYgbWF0Y2hMZW49PTBcbiAgICAgIC8vIFhYWDogaXQgYWxzbyB1c2VzIHRoZSBvZmZzZXQgYXMgY29udGV4dCBmb3IgdGhlIGxlbmd0aCAob3IgdmljZS12ZXJzYSlcbiAgICB9XG4gICAgLy8gYWx3YXlzIGVuY29kZSBhIGxpdGVyYWwgYWZ0ZXIgYSBtYXRjaFxuICAgIHZhciBjb250ZXh0MSA9IHdpbmRvdy5nZXQod2luZG93LnBvcy0xKTtcbiAgICBpZiAoY2g9PT1TdHJlYW0uRU9GKSB7XG4gICAgICBpZiAoZmlsZVNpemUgPCAwKSB7XG4gICAgICAgIGh1ZmZMaXRlcmFsLmVuY29kZSgyNTYsIGNvbnRleHQxKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBodWZmTGl0ZXJhbC5lbmNvZGUoY2gsIGNvbnRleHQxKTtcbiAgICB3aW5kb3cucHV0KGNoKTtcbiAgICBpblNpemUrKztcbiAgfVxuICBpZiAoZmx1c2gpIGZsdXNoKCk7XG59KTtcblxuLyoqXG4gKiBEZWNvbXByZXNzIHVzaW5nIG1vZGlmaWVkIExaUDMgYWxnb3JpdGhtLlxuICovXG5MenAzLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihMenAzLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSkge1xuICB2YXIgZmxhZ3MgPSBpblN0cmVhbS5yZWFkQnl0ZSgpO1xuICB2YXIgdXNlX2h1ZmZtYW5fY29kZSA9ICEhKGZsYWdzICYgMHg4MCk7XG5cbiAgLy8gc2xpZGluZyB3aW5kb3cgJiBoYXNoIHRhYmxlXG4gIHZhciB3aW5kb3cgPSBuZXcgV2luZG93KCAoZmlsZVNpemU+PTApID8gZmlsZVNpemUgOiBXSU5ET1dfU0laRSApO1xuXG4gIHZhciBjb2RlckZhY3RvcnksIHNwYXJzZUNvZGVyRmFjdG9yeSwgZmluaXNoO1xuXG4gIGlmICh1c2VfaHVmZm1hbl9jb2RlKSB7XG4gICAgLy8gSHVmZm1hbiBjb250ZXh0c1xuICAgIHZhciBiaXRzdHJlYW0gPSBuZXcgQml0U3RyZWFtKGluU3RyZWFtKTtcbiAgICBjb2RlckZhY3RvcnkgPSBIdWZmbWFuLmZhY3RvcnkoYml0c3RyZWFtLCBNQVgxNik7XG4gICAgc3BhcnNlQ29kZXJGYWN0b3J5ID0gTm9Nb2RlbC5mYWN0b3J5KGJpdHN0cmVhbSk7XG4gIH0gZWxzZSB7IC8vIHJhbmdlIGVuY29kZXJcbiAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2VDb2RlcihpblN0cmVhbSk7XG4gICAgcmFuZ2UuZGVjb2RlU3RhcnQodHJ1ZS8qIHNraXAgaW5pdGlhbCByZWFkICovKTtcbiAgICBjb2RlckZhY3RvcnkgPSBGZW53aWNrTW9kZWwuZmFjdG9yeShyYW5nZSwgTU9ERUxfTUFYX1BST0IsIE1PREVMX0lOQ1JFTUVOVCk7XG4gICAgaWYgKFVTRV9ERUZTVU0pIHtcbiAgICAgIGNvZGVyRmFjdG9yeSA9IERlZlN1bU1vZGVsLmZhY3RvcnkocmFuZ2UsIHRydWUgLyogZGVjb2RlciAqLyk7XG4gICAgfVxuICAgIC8vIHN3aXRjaCBzcGFyc2VDb2RlckZhY3RvcnkgdG8gYSBOb01vZGVsIHdoZW4gc2l6ZSA+IGN1dG9mZlxuICAgIHZhciBub0NvZGVyRmFjdG9yeSA9IE5vTW9kZWwuZmFjdG9yeShyYW5nZSk7XG4gICAgc3BhcnNlQ29kZXJGYWN0b3J5ID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgaWYgKHNpemUgPiBMRU5HVEhfTU9ERUxfQ1VUT0ZGKSB7XG4gICAgICAgIHJldHVybiBub0NvZGVyRmFjdG9yeShzaXplKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlckZhY3Rvcnkoc2l6ZSk7XG4gICAgfTtcbiAgICBmaW5pc2ggPSBmdW5jdGlvbigpIHsgcmFuZ2UuZGVjb2RlRmluaXNoKCk7IH07XG4gIH1cblxuICB2YXIgaHVmZkxpdGVyYWw9IG5ldyBDb250ZXh0MU1vZGVsKGNvZGVyRmFjdG9yeSwgMjU2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWxlU2l6ZTwwKSA/IDI1NyA6IDI1Nik7XG4gIHZhciBodWZmTGVuID0gW10sIGk7XG4gIGZvciAoaT0wOyBpPE1BVENIX0xFTl9DT05URVhUUzsgaSsrKSB7XG4gICAgaHVmZkxlbltpXSA9IG5ldyBMb2dEaXN0YW5jZU1vZGVsKE1BWF9NQVRDSF9MRU4rMSwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXJGYWN0b3J5LCBzcGFyc2VDb2RlckZhY3RvcnkpO1xuICB9XG5cbiAgdmFyIHMsIGNoLCBvdXRTaXplID0gMCwgbWF0Y2hDb250ZXh0ID0gMDtcbiAgd2hpbGUgKG91dFNpemUgIT09IGZpbGVTaXplKSB7XG4gICAgcyA9IHdpbmRvdy5wb3M7XG4gICAgdmFyIHAgPSB3aW5kb3cuZ2V0SW5kZXgocywgMCk7XG4gICAgaWYgKHAgIT09IDApIHtcbiAgICAgIHAtLTsgLy8gcD0wIGlzIHVzZWQgZm9yICdub3QgaGVyZScuIHA9MSByZWFsbHkgbWVhbnMgV0lORE9XX1NJWkVcbiAgICAgIHZhciBwcmV2TWF0Y2hMZW4gPSAocCA+Pj4gTE9HX1dJTkRPV19TSVpFKSArIDE7XG4gICAgICB2YXIgbWF0Y2hMZW4gPSBodWZmTGVuW21hdGNoQ29udGV4dCYoTUFUQ0hfTEVOX0NPTlRFWFRTLTEpXS5kZWNvZGUoKTtcbiAgICAgIGlmIChtYXRjaExlbiA8IDApIHsgbWF0Y2hMZW4gPSBwcmV2TWF0Y2hMZW47IH1cbiAgICAgIC8vIGNvcHkgY2hhcmFjdGVycyFcbiAgICAgIGZvciAoaT0wOyBpPG1hdGNoTGVuOyBpKyspIHtcbiAgICAgICAgY2ggPSB3aW5kb3cuZ2V0KHAgKyBpKTtcbiAgICAgICAgb3V0U3RyZWFtLndyaXRlQnl0ZSh3aW5kb3cucHV0KGNoKSk7XG4gICAgICB9XG4gICAgICB3aW5kb3cuZ2V0SW5kZXgocywgbWF0Y2hMZW4pO1xuICAgICAgb3V0U2l6ZSArPSBtYXRjaExlbjtcbiAgICAgIG1hdGNoQ29udGV4dCA8PD0gMTtcbiAgICAgIGlmIChtYXRjaExlbiA+IDApIG1hdGNoQ29udGV4dCB8PSAxO1xuICAgIH1cbiAgICAvLyBsaXRlcmFsIGFsd2F5cyBmb2xsb3dzIG1hdGNoIChvciBmYWlsZWQgbWF0Y2gpXG4gICAgaWYgKG91dFNpemUgPT09IGZpbGVTaXplKSB7XG4gICAgICBicmVhazsgLy8gRU9GXG4gICAgfVxuICAgIHZhciBjb250ZXh0MSA9IHdpbmRvdy5nZXQod2luZG93LnBvcy0xKTtcbiAgICBjaCA9IGh1ZmZMaXRlcmFsLmRlY29kZShjb250ZXh0MSk7XG4gICAgaWYgKGNoID09PSAyNTYpIHtcbiAgICAgIGJyZWFrOyAvLyBFT0ZcbiAgICB9XG4gICAgb3V0U3RyZWFtLndyaXRlQnl0ZSh3aW5kb3cucHV0KGNoKSk7XG4gICAgb3V0U2l6ZSsrO1xuICB9XG4gIGlmIChmaW5pc2gpIGZpbmlzaCgpO1xufSk7XG5cblxucmV0dXJuIEx6cDM7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyoqIFNpbXBsZSByYW5nZSBjb2RpbmcgbW9kZWwgdy8gZXNjYXBlLCBzdWl0YWJsZSBmb3Igc3BhcnNlIHN5bWJvbCBzZXRzLlxuICogIFVzZXMgYSBtb3ZlLXRvLWZyb250IGxpc3QsIHdoaWNoIGlzIHNpbXBsZSBhbmQgcmVsYXRpdmVseSBwZXJmb3JtYW50LFxuICogIGJ1dCBzbG93cyBkb3duIGEgbG90IGlmIHlvdSB3YW50IHRvIHRyeSB0byBtb2RlbCBlc2NhcGVzIG1vcmUgcHJlY2lzZWx5XG4gKiAgKHdoaWNoIGlzIHdoeSB0aGlzIGZlYXR1cmUgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCkuXG4gKi9cbnZhciBsaWJzID0gW1xuXHRyZXF1aXJlKCcuL1JhbmdlQ29kZXInKSxcblx0cmVxdWlyZSgnLi9TdHJlYW0nKSxcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChSYW5nZUNvZGVyLFN0cmVhbSxVdGlsKXtcblxudmFyIERFRkFVTFRfTUFYX1BST0IgPSAweEZGMDA7XG52YXIgREVGQVVMVF9JTkNSRU1FTlQ9IDB4MDEwMDtcblxudmFyIE5VTUVSSUNfU09SVCA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuXG52YXIgTVRGTW9kZWwgPSBmdW5jdGlvbihjb2Rlciwgc2l6ZSwgbWF4X3Byb2IsIGluY3JlbWVudCwgYmV0dGVyRXNjYXBlKSB7XG4gICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgIHRoaXMuaW5jcmVtZW50ID0gKCtpbmNyZW1lbnQpIHx8IERFRkFVTFRfSU5DUkVNRU5UO1xuICAgIHRoaXMubWF4X3Byb2IgPSAoK21heF9wcm9iKSB8fCBERUZBVUxUX01BWF9QUk9CO1xuICAgIGNvbnNvbGUuYXNzZXJ0KCh0aGlzLm1heF9wcm9iICsgKHRoaXMuaW5jcmVtZW50LTEpKSA8PSAweEZGRkYpO1xuICAgIHRoaXMuc3ltID0gVXRpbC5tYWtlVTE2QnVmZmVyKHNpemUrMSk7XG4gICAgdGhpcy5wcm9iPSBVdGlsLm1ha2VVMTZCdWZmZXIoc2l6ZSsyKTtcbiAgICB0aGlzLnN5bVswXSA9IHNpemU7IC8vIGVzY2FwZSBjb2RlXG4gICAgdGhpcy5wcm9iWzBdPSAwO1xuICAgIHRoaXMuc2VlblN5bXMgPSAxO1xuICAgIC8vIHRvdGFsIHByb2JhYmlsaXR5IGFsd2F5cyBmb3VuZCBpbiB0aGlzLnByb2JbdGhpcy5zZWVuU3ltc11cbiAgICB0aGlzLnByb2JbdGhpcy5zZWVuU3ltc10gPSB0aGlzLmluY3JlbWVudDtcbiAgICB0aGlzLm51bVN5bXMgPSBzaXplO1xuICAgIGlmIChiZXR0ZXJFc2NhcGUpIHtcbiAgICAgICAgdGhpcy5zb3J0ZWRTZWVuID0gW3NpemVdO1xuICAgIH1cbn07XG5NVEZNb2RlbC5mYWN0b3J5ID0gZnVuY3Rpb24oY29kZXIsIG1heF9wcm9iLCBpbmNyZW1lbnQsIGJldHRlckVzY2FwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgTVRGTW9kZWwoY29kZXIsIHNpemUsIG1heF9wcm9iLCBpbmNyZW1lbnQsIGJldHRlckVzY2FwZSk7XG4gICAgfTtcbn07XG5NVEZNb2RlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3TW9kZWwgPSBuZXcgTVRGTW9kZWwodGhpcy5jb2RlciwgdGhpcy5udW1TeW1zLCB0aGlzLm1heF9wcm9iLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudCwgISF0aGlzLnNvcnRlZFNlZW4pO1xuICAgIHZhciBpO1xuICAgIGZvciAoaT0wOyBpPHRoaXMuc2VlblN5bXM7IGkrKykge1xuICAgICAgICBuZXdNb2RlbC5zeW1baV0gPSB0aGlzLnN5bVtpXTtcbiAgICAgICAgbmV3TW9kZWwucHJvYltpXSA9IHRoaXMucHJvYltpXTtcbiAgICB9XG4gICAgbmV3TW9kZWwucHJvYltpXSA9IHRoaXMucHJvYltpXTsgLy8gdG90YWwgcHJvYmFiaWxpdHlcbiAgICBuZXdNb2RlbC5zZWVuU3ltcyA9IHRoaXMuc2VlblN5bXM7XG4gICAgaWYgKHRoaXMuc29ydGVkU2Vlbikge1xuICAgICAgICBuZXdNb2RlbC5zb3J0ZWRTZWVuID0gdGhpcy5zb3J0ZWRTZWVuLnNsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TW9kZWw7XG59O1xuTVRGTW9kZWwucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihzeW1ib2wsIGluZGV4LCBzeV9mKSB7XG4gICAgdmFyIGosIHRvdF9mO1xuICAgIC8vIG1vdmUgdGhpcyBzeW1ib2wgdG8gdGhlIGVuZFxuICAgIGZvciAoaj1pbmRleDsgajx0aGlzLnNlZW5TeW1zLTE7IGorKykge1xuICAgICAgICB0aGlzLnN5bVtqXSA9IHRoaXMuc3ltW2orMV07XG4gICAgICAgIHRoaXMucHJvYltqXSA9IHRoaXMucHJvYltqKzFdIC0gc3lfZjtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgdGhpcy5zZWVuU3ltcykge1xuICAgICAgICB0aGlzLnN5bVtqXSA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5wcm9iW2pdID0gdGhpcy5wcm9iW2orMV0gLSBzeV9mO1xuICAgICAgICAvLyBpbmNyZWFzZSBmcmVxdWVuY3kgZm9yIHRoaXMgc3ltYm9sLCBhbmQgdG90YWwgZnJlcSBhdCBzYW1lIHRpbWVcbiAgICAgICAgdGhpcy5wcm9iW3RoaXMuc2VlblN5bXNdID0gdG90X2YgPVxuICAgICAgICAgICAgdGhpcy5wcm9iW3RoaXMuc2VlblN5bXNdICsgdGhpcy5pbmNyZW1lbnQ7XG4gICAgICAgIGlmIChzeW1ib2wgPT09IHRoaXMubnVtU3ltcyAmJiB0aGlzLnNlZW5TeW1zID49IHRoaXMubnVtU3ltcykge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbGFzdCB0aW1lIHdlJ2xsIHNlZSBhbiBlc2NhcGUhIHJlbW92ZSBpdC5cbiAgICAgICAgICAgIHRvdF9mID0gdGhpcy5wcm9iWy0tdGhpcy5zZWVuU3ltc107XG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0ZWRTZWVuKSB7IHRoaXMuc29ydGVkU2Vlbi5sZW5ndGgtLTsgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHsgLy8gYWRkIHRvIHRoZSBlbmRcbiAgICAgICAgdG90X2YgPSB0aGlzLnByb2JbdGhpcy5zZWVuU3ltc107XG4gICAgICAgIHRoaXMuc3ltW2luZGV4XSA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5wcm9iW2luZGV4XSA9IHRvdF9mO1xuICAgICAgICB0b3RfZiArPSB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgdGhpcy5wcm9iWysrdGhpcy5zZWVuU3ltc10gPSB0b3RfZjtcbiAgICAgICAgaWYgKHRoaXMuc29ydGVkU2Vlbikge1xuICAgICAgICAgICAgdGhpcy5zb3J0ZWRTZWVuLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIC8vIGhvcGVmdWxseSBzb3J0IGlzIHZlcnkgZmFzdCBvbiBhIG1vc3RseS1zb3J0ZWQgYXJyYXlcbiAgICAgICAgICAgIHRoaXMuc29ydGVkU2Vlbi5zb3J0KE5VTUVSSUNfU09SVCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRvdF9mID49IHRoaXMubWF4X3Byb2IpIHsgdGhpcy5fcmVzY2FsZSgpOyB9XG4gICAgcmV0dXJuO1xufTtcbk1URk1vZGVsLnByb3RvdHlwZS5fcmVzY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBqLCB0b3RhbD0wO1xuICAgIHZhciBub0VzY2FwZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuc29ydGVkU2VlbikgeyB0aGlzLnNvcnRlZFNlZW4ubGVuZ3RoID0gMDsgfVxuICAgIGZvcihpPTAsIGo9MDsgaTx0aGlzLnNlZW5TeW1zOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bSA9IHRoaXMuc3ltW2ldO1xuICAgICAgICB2YXIgc3lfZiA9IHRoaXMucHJvYltpKzFdIC0gdGhpcy5wcm9iW2ldO1xuICAgICAgICBzeV9mID4+Pj0gMTtcbiAgICAgICAgaWYgKHN5X2YgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc3ltID09PSB0aGlzLm51bVN5bXMpIHtcbiAgICAgICAgICAgICAgICBub0VzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zeW1bal0gPSBzeW07XG4gICAgICAgICAgICB0aGlzLnByb2JbaisrXSA9IHRvdGFsO1xuICAgICAgICAgICAgdG90YWwgKz0gc3lfZjtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnRlZFNlZW4pIHsgdGhpcy5zb3J0ZWRTZWVuLnB1c2goc3ltKTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJvYltqXSA9IHRvdGFsO1xuICAgIHRoaXMuc2VlblN5bXMgPSBqO1xuICAgIGlmICh0aGlzLnNvcnRlZFNlZW4pIHtcbiAgICAgICAgdGhpcy5zb3J0ZWRTZWVuLnNvcnQoTlVNRVJJQ19TT1JUKTtcbiAgICB9XG4gICAgLy8gZG9uJ3QgYWxsb3cgZXNjYXBlIHRvIGdvIHRvIHplcm8gcHJvYiBpZiB3ZSBzdGlsbCBuZWVkIGl0XG4gICAgaWYgKG5vRXNjYXBlICYmIHRoaXMuc2VlblN5bXMgPCB0aGlzLm51bVN5bXMpIHtcbiAgICAgICAgLy8gTk9URSB0aGlzIGFkZHMgdGhpcy5pbmNyZW1lbnQgdG8gZXNjYXBlIGZyZXE7IHRoZSBGZW53aWNrTW9kZWxcbiAgICAgICAgLy8gICAgICBqdXN0IGFkZHMgb25lLlxuICAgICAgICB0aGlzLl91cGRhdGUodGhpcy5udW1TeW1zLyplc2NhcGUqLywgdGhpcy5zZWVuU3ltcy8qYXQgZW5kKi8pO1xuICAgIH1cbn07XG5NVEZNb2RlbC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdF9mID0gdGhpcy5wcm9iW3RoaXMuc2VlblN5bXNdO1xuICAgIHZhciBwcm9iID0gdGhpcy5jb2Rlci5kZWNvZGVDdWxGcmVxKHRvdF9mKTtcbiAgICAvLyB3ZSdyZSBleHBlY3RpbmcgdG8gZmluZCB0aGUgcHJvYmFiaWxpdHkgbmVhciB0aGUgXCJtb3N0IHJlY2VudFwiIHNpZGVcbiAgICAvLyBvZiBvdXIgYXJyYXlcbiAgICB2YXIgaTtcbiAgICBmb3IgKGk9dGhpcy5zZWVuU3ltcy0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMucHJvYltpXSA8PSBwcm9iIC8qJiYgcHJvYiA8IHRoaXMucHJvYltpKzFdKi8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc29sZS5hc3NlcnQoaT49MCk7XG4gICAgdmFyIHN5bWJvbCA9IHRoaXMuc3ltW2ldO1xuICAgIHZhciBsdF9mID0gdGhpcy5wcm9iW2ldO1xuICAgIHZhciBzeV9mID0gdGhpcy5wcm9iW2kgKyAxXSAtIGx0X2Y7XG4gICAgdGhpcy5jb2Rlci5kZWNvZGVVcGRhdGUoc3lfZiwgbHRfZiwgdG90X2YpO1xuICAgIHRoaXMuX3VwZGF0ZShzeW1ib2wsIGksIHN5X2YpO1xuICAgIGlmIChzeW1ib2wgPT09IHRoaXMubnVtU3ltcykge1xuICAgICAgICAvKiB0aGlzIGlzIGFuIGVzY2FwZSAqL1xuICAgICAgICAvKiBkZWNvZGUgdGhlIGxpdGVyYWwgKi9cbiAgICAgICAgc3lfZiA9IDE7XG4gICAgICAgIHRvdF9mID0gdGhpcy5udW1TeW1zO1xuICAgICAgICBpZiAodGhpcy5zb3J0ZWRTZWVuKSB7XG4gICAgICAgICAgICAvLyBkbyBhIHNsb3dlciwgYnV0IG1vcmUgcHJlY2lzZSBkZWNvZGluZyBvZiB0aGUgbGl0ZXJhbFxuICAgICAgICAgICAgLy8gYnkgZXhjbHVkaW5nIHRoZSBhbHJlYWR5LXNlZW4gc3ltYm9scy5cbiAgICAgICAgICAgIHZhciBzZWVuID0gdGhpcy5zb3J0ZWRTZWVuO1xuICAgICAgICAgICAgdG90X2YgPSB0aGlzLm51bVN5bXMgLSB0aGlzLnNlZW5TeW1zO1xuICAgICAgICAgICAgaWYgKHNlZW5bc2Vlbi5sZW5ndGgtMV0gPT09IHRoaXMubnVtU3ltcykgeyB0b3RfZisrOyB9XG4gICAgICAgICAgICBzeW1ib2wgPSBsdF9mID0gdGhpcy5jb2Rlci5kZWNvZGVDdWxGcmVxKHRvdF9mKTtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgc2Vlbi5sZW5ndGggJiYgc2VlbltpXSA8PSBzeW1ib2wgOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IGx0X2YgPSB0aGlzLmNvZGVyLmRlY29kZUN1bEZyZXEodG90X2YpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29kZXIuZGVjb2RlVXBkYXRlKHN5X2YsIGx0X2YsIHRvdF9mKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHN5bWJvbCwgdGhpcy5zZWVuU3ltcyk7XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2w7XG59O1xuTVRGTW9kZWwucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIC8vIGxvb2sgZm9yIHN5bWJvbCwgZnJvbSBtb3N0LXJlY2VudCB0byBvbGRlc3RcbiAgICB2YXIgaSwgc3lfZiwgbHRfZiwgdG90X2Y7XG4gICAgZm9yIChpPXRoaXMuc2VlblN5bXMtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGlmIChzeW1ib2wgPT09IHRoaXMuc3ltW2ldKSB7XG4gICAgICAgICAgICAvLyBvaywgZm91bmQgaXQuXG4gICAgICAgICAgICBsdF9mID0gdGhpcy5wcm9iW2ldO1xuICAgICAgICAgICAgc3lfZiA9IHRoaXMucHJvYltpICsgMV0gLSBsdF9mO1xuICAgICAgICAgICAgdG90X2YgPSB0aGlzLnByb2JbdGhpcy5zZWVuU3ltc107XG4gICAgICAgICAgICB0aGlzLmNvZGVyLmVuY29kZUZyZXEoc3lfZiwgbHRfZiwgdG90X2YpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShzeW1ib2wsIGksIHN5X2YpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvdWxkbid0IGZpbmQgdGhpcyBzeW1ib2wuICBlbmNvZGUgYXMgZXNjYXBlLlxuICAgIGNvbnNvbGUuYXNzZXJ0KHN5bWJvbCAhPT0gdGhpcy5udW1TeW1zKTsgLy8gY2F0Y2ggaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgdGhpcy5lbmNvZGUodGhpcy5udW1TeW1zKTsgLy8gZ3VhcmFudGVlZCB0byBiZSBmb3VuZCBpbiB0aGUgdGFibGUuXG4gICAgLy8gY29kZSBzeW1ib2wgYXMgbGl0ZXJhbFxuICAgIHN5X2YgPSAxO1xuICAgIGx0X2YgPSBzeW1ib2w7XG4gICAgdG90X2YgPSB0aGlzLm51bVN5bXM7XG4gICAgaWYgKHRoaXMuc29ydGVkU2Vlbikge1xuICAgICAgICAvLyBkbyBhIHNsb3dlciwgYnV0IG1vcmUgcHJlY2lzZSBlbmNvZGluZyBvZiB0aGUgbGl0ZXJhbFxuICAgICAgICAvLyBieSBleGNsdWRpbmcgdGhlIGFscmVhZHktc2VlbiBzeW1ib2xzLlxuICAgICAgICB2YXIgc2VlbiA9IHRoaXMuc29ydGVkU2VlbjtcbiAgICAgICAgdG90X2YgLT0gdGhpcy5zZWVuU3ltcztcbiAgICAgICAgaWYgKHNlZW5bc2Vlbi5sZW5ndGgtMV0gPT09IHRoaXMubnVtU3ltcykgeyB0b3RfZisrOyB9XG4gICAgICAgIGZvciAoaT0wOyBpIDwgc2Vlbi5sZW5ndGggJiYgc2VlbltpXSA8IHN5bWJvbDsgaSsrKSB7XG4gICAgICAgICAgICBsdF9mLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb2Rlci5lbmNvZGVGcmVxKHN5X2YsIGx0X2YsIHRvdF9mKTtcbiAgICAvLyBub3cgYWRkIHN5bWJvbCB0byB0aGUgZW5kLlxuICAgIHJldHVybiB0aGlzLl91cGRhdGUoc3ltYm9sLCB0aGlzLnNlZW5TeW1zKTtcbn07XG5cbk1URk1vZGVsLk1BR0lDID0gJ210Zm0nO1xuLyoqIFNpbXBsZSBvcmRlci0wIGNvbXByZXNzb3IsIGFzIHNlbGYtdGVzdC4gKi9cbk1URk1vZGVsLmNvbXByZXNzRmlsZSA9IFV0aWwuY29tcHJlc3NGaWxlSGVscGVyKE1URk1vZGVsLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSwgcHJvcHMsIGZpbmFsQnl0ZSkge1xuICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2VDb2RlcihvdXRTdHJlYW0pO1xuICByYW5nZS5lbmNvZGVTdGFydChmaW5hbEJ5dGUsIDEpO1xuICB2YXIgbW9kZWwgPSBuZXcgTVRGTW9kZWwocmFuZ2UsIChmaWxlU2l6ZTwwKSA/IDI1NyA6IDI1Nik7XG4gIFV0aWwuY29tcHJlc3NXaXRoTW9kZWwoaW5TdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gIHJhbmdlLmVuY29kZUZpbmlzaCgpO1xufSwgdHJ1ZSk7XG5cbi8qKiBTaW1wbGUgb3JkZXItMCBkZWNvbXByZXNzZXIsIGFzIHNlbGYtdGVzdC4gKi9cbk1URk1vZGVsLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihNVEZNb2RlbC5NQUdJQywgZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgZmlsZVNpemUpIHtcbiAgdmFyIHJhbmdlID0gbmV3IFJhbmdlQ29kZXIoaW5TdHJlYW0pO1xuICByYW5nZS5kZWNvZGVTdGFydCh0cnVlLyp3ZSBhbHJlYWR5IHJlYWQgdGhlICdmcmVlJyBieXRlKi8pO1xuICB2YXIgbW9kZWwgPSBuZXcgTVRGTW9kZWwocmFuZ2UsIChmaWxlU2l6ZTwwKSA/IDI1NyA6IDI1Nik7XG4gIFV0aWwuZGVjb21wcmVzc1dpdGhNb2RlbChvdXRTdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gIHJhbmdlLmRlY29kZUZpbmlzaCgpO1xufSk7XG5cbnJldHVybiBNVEZNb2RlbDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiogU2ltcGxlIFwibGFjayBvZiBtb2RlbFwiIC0tIGp1c3QgZW5jb2RlIHRoZSBiaXRzIGRpcmVjdGx5LlxuICogIFVzZWZ1bCBlc3BlY2lhbGx5IHdpdGggc3BhcnNlIHNwYWNlcyBvciBIdWZmbWFuIGNvZGVycyB3aGVyZSB0aGVyZSdzXG4gKiAgbm8gb2J2aW91cyBwcmVkaWN0aW9uIHRvIGJlIG1hZGUgdGhhdCB3aWxsIHBheSBmb3IgaXRzZWxmLlxuICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9CaXRTdHJlYW0nKSxcblx0cmVxdWlyZSgnLi9VdGlsJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChCaXRTdHJlYW0sVXRpbCkge1xuXG52YXIgTm9Nb2RlbCA9IGZ1bmN0aW9uKGJpdHN0cmVhbSwgc2l6ZSkge1xuICB0aGlzLmJpdHN0cmVhbSA9IGJpdHN0cmVhbTtcbiAgdGhpcy5iaXRzID0gVXRpbC5mbHMoc2l6ZS0xKTtcbn07XG5Ob01vZGVsLmZhY3RvcnkgPSBmdW5jdGlvbihiaXRzdHJlYW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNpemUpIHsgcmV0dXJuIG5ldyBOb01vZGVsKGJpdHN0cmVhbSwgc2l6ZSk7IH07XG59O1xuTm9Nb2RlbC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3ltYm9sKSB7XG4gIHZhciBpO1xuICBmb3IgKGk9dGhpcy5iaXRzLTE7IGk+PTA7IGktLSkge1xuICAgIHZhciBiID0gKHN5bWJvbCA+Pj4gaSkgJiAxO1xuICAgIHRoaXMuYml0c3RyZWFtLndyaXRlQml0KGIpO1xuICB9XG59O1xuTm9Nb2RlbC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpLCByID0gMDtcbiAgZm9yIChpPXRoaXMuYml0cy0xOyBpPj0wOyBpLS0pIHtcbiAgICByIDw8PSAxO1xuICAgIGlmICh0aGlzLmJpdHN0cmVhbS5yZWFkQml0KCkpIHIrKztcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8qKiBCcmFpbi1kZWFkIHNlbGYtdGVzdC4gKi9cbk5vTW9kZWwuTUFHSUMgPSAnbm9tbyc7XG5Ob01vZGVsLmNvbXByZXNzRmlsZSA9IFV0aWwuY29tcHJlc3NGaWxlSGVscGVyKE5vTW9kZWwuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplLCBwcm9wcykge1xuICAgIHZhciBiaXRzdHJlYW0gPSBuZXcgQml0U3RyZWFtKG91dFN0cmVhbSk7XG4gICAgdmFyIG1vZGVsID0gbmV3IE5vTW9kZWwoYml0c3RyZWFtLCAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICAgIFV0aWwuY29tcHJlc3NXaXRoTW9kZWwoaW5TdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gICAgYml0c3RyZWFtLmZsdXNoKCk7XG59KTtcbk5vTW9kZWwuZGVjb21wcmVzc0ZpbGUgPSBVdGlsLmRlY29tcHJlc3NGaWxlSGVscGVyKE5vTW9kZWwuTUFHSUMsIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplKSB7XG4gICAgdmFyIGJpdHN0cmVhbSA9IG5ldyBCaXRTdHJlYW0oaW5TdHJlYW0pO1xuICAgIHZhciBtb2RlbCA9IG5ldyBOb01vZGVsKGJpdHN0cmVhbSwgKGZpbGVTaXplPDApID8gMjU3IDogMjU2KTtcbiAgICBVdGlsLmRlY29tcHJlc3NXaXRoTW9kZWwob3V0U3RyZWFtLCBmaWxlU2l6ZSwgbW9kZWwpO1xufSk7XG5cbnJldHVybiBOb01vZGVsO1xufTtcbm1vZHVsZS5leHBvcnRzID0gYm9keV9mbi5hcHBseShudWxsLCBsaWJzKTtcbiIsIi8qKiBQYXJ0aWN1bGFybHkgc2ltcGxlLW1pbmRlZCBpbXBsZW1lbnRhdGlvbiBvZiBQUE0gY29tcHJlc3Npb24uICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9SYW5nZUNvZGVyJyksXG5cdHJlcXVpcmUoJy4vVXRpbCcpXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoUmFuZ2VDb2RlcixVdGlsKSB7XG5cbiAgdmFyIE1BWF9DT05URVhUID0gNTtcbiAgdmFyIExPR19XSU5ET1dfU0laRSA9IDE4O1xuICB2YXIgV0lORE9XX1NJWkUgPSAxIDw8IExPR19XSU5ET1dfU0laRTtcblxuICB2YXIgV2luZG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5idWZmZXIgPSBVdGlsLm1ha2VVOEJ1ZmZlcihXSU5ET1dfU0laRSk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZmlyc3RQYXNzID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpPTA7IGk8TUFYX0NPTlRFWFQ7IGkrKykge1xuICAgICAgdGhpcy5wdXQoJ2NTYUNzQScuY2hhckNvZGVBdChpJTYpKTtcbiAgICB9XG4gIH07XG4gIFdpbmRvdy5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oX2J5dGUpIHtcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSA9IF9ieXRlO1xuICAgIGlmICh0aGlzLnBvcyA+PSBXSU5ET1dfU0laRSkgeyB0aGlzLnBvcyA9IDA7IHRoaXMuZmlyc3RQYXNzID0gZmFsc2U7IH1cbiAgICByZXR1cm4gX2J5dGU7XG4gIH07XG4gIFdpbmRvdy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3BvcyAmIChXSU5ET1dfU0laRS0xKV07XG4gIH07XG4gIC8vIHRoZSBjb250ZXh0IGVuZGluZyBqdXN0IGJlZm9yZSAncG9zJ1xuICBXaW5kb3cucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbihwb3MsIG4pIHtcbiAgICB2YXIgYyA9IFtdLCBpO1xuICAgIHBvcyA9IChwb3MgLSBuKSAmIChXSU5ET1dfU0laRS0xKTtcbiAgICBmb3IgKGk9MDsgaTxuOyBpKyspIHtcbiAgICAgIGMucHVzaCh0aGlzLmJ1ZmZlcltwb3MrK10pO1xuICAgICAgaWYgKHBvcyA+PSBXSU5ET1dfU0laRSkgeyBwb3MgPSAwOyB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYyk7XG4gIH07XG5cbiAgdmFyIERNTV9JTkNSRU1FTlQgPSAweDEwMCwgRE1NX01BWF9QUk9CID0gMHhGRjAwO1xuXG4gIHZhciBQUE0gPSBmdW5jdGlvbihjb2Rlciwgc2l6ZSkge1xuICAgIHRoaXMud2luZG93ID0gbmV3IFdpbmRvdygpO1xuICAgIHRoaXMuY29udGV4dHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIGJyYWluLWRlYWQgJy0xJyBjb250ZXh0LCB1c2luZyBmdWxsIGV4Y2x1c2lvblxuICAgIHZhciBDbTFDb250ZXh0ID0gZnVuY3Rpb24oKSB7IH07XG4gICAgQ20xQ29udGV4dC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3ltYm9sLCBleGNsdWRlKSB7XG4gICAgICB2YXIgaSwgbHRfZiA9IDA7XG4gICAgICBmb3IgKGk9MDsgaTxzeW1ib2w7IGkrKykge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVbaV0pIHtcbiAgICAgICAgICBsdF9mKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0b3RfZiA9IHNpemUgLSBleGNsdWRlLnRvdGFsO1xuICAgICAgY29kZXIuZW5jb2RlRnJlcSgxLCBsdF9mLCB0b3RfZik7XG4gICAgfTtcbiAgICBDbTFDb250ZXh0LnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihleGNsdWRlKSB7XG4gICAgICB2YXIgaSwgc3ltYm9sLCBsdF9mO1xuICAgICAgdmFyIHRvdF9mID0gc2l6ZSAtIGV4Y2x1ZGUudG90YWw7XG4gICAgICBzeW1ib2wgPSBsdF9mID0gY29kZXIuZGVjb2RlQ3VsRnJlcSh0b3RfZik7XG4gICAgICBmb3IgKGk9MDsgaTw9c3ltYm9sOyBpKyspIHtcbiAgICAgICAgaWYgKGV4Y2x1ZGVbaV0pIHtcbiAgICAgICAgICBzeW1ib2wrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29kZXIuZGVjb2RlVXBkYXRlKDEsIGx0X2YsIHRvdF9mKTtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICB0aGlzLmNtMWNvZGVyID0gbmV3IENtMUNvbnRleHQoKTtcblxuICAgIHZhciBEZW5zZU1URk1vZGVsID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN5bSA9IFtzaXplXTtcbiAgICAgIHRoaXMucHJvYj0gWzAsIERNTV9JTkNSRU1FTlRdO1xuICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgfTtcbiAgICBEZW5zZU1URk1vZGVsLnByb3RvdHlwZS5fcmVzY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlZW5TeW1zID0gdGhpcy5zeW0ubGVuZ3RoO1xuICAgICAgdmFyIGksIGosIHRvdGFsPTA7XG4gICAgICB2YXIgbm9Fc2NhcGUgPSB0cnVlO1xuICAgICAgZm9yKGk9MCwgaj0wOyBpPHNlZW5TeW1zOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bSA9IHRoaXMuc3ltW2ldO1xuICAgICAgICB2YXIgc3lfZiA9IHRoaXMucHJvYltpKzFdIC0gdGhpcy5wcm9iW2ldO1xuICAgICAgICBzeV9mID4+Pj0gMTtcbiAgICAgICAgaWYgKHN5X2YgPiAwKSB7XG4gICAgICAgICAgaWYgKHN5bSA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgbm9Fc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zeW1bal0gPSBzeW07XG4gICAgICAgICAgdGhpcy5wcm9iW2orK10gPSB0b3RhbDtcbiAgICAgICAgICB0b3RhbCArPSBzeV9mO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByb2Jbal0gPSB0b3RhbDtcbiAgICAgIHNlZW5TeW1zID0gdGhpcy5zeW0ubGVuZ3RoID0gajtcbiAgICAgIHRoaXMucHJvYi5sZW5ndGggPSBzZWVuU3ltcyArIDE7XG4gICAgICAvLyBkb24ndCBhbGxvdyBlc2NhcGUgdG8gZ28gdG8gemVybyBwcm9iIGlmIHdlIHN0aWxsIG5lZWQgaXRcbiAgICAgIGlmIChub0VzY2FwZSAmJiBzZWVuU3ltcyA8IHNpemUpIHtcbiAgICAgICAgdG90YWwgPSB0aGlzLl91cGRhdGUoc2l6ZS8qZXNjYXBlKi8sIHNlZW5TeW1zLyphdCBlbmQqLywgMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfTtcbiAgICBEZW5zZU1URk1vZGVsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihzeW1ib2wsIGluY3IpIHtcbiAgICAgIC8vIGZpbmQgc3ltYm9sXG4gICAgICB2YXIgaT0wO1xuICAgICAgZm9yIChpPTA7IGk8dGhpcy5zeW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuc3ltW2ldID09PSBzeW1ib2wpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKHN5bWJvbCwgaSwgdGhpcy5wcm9iW2krMV0gLSB0aGlzLnByb2JbaV0sIGluY3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBzeW1ib2wgZXNjYXBlZFxuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShzeW1ib2wsIGksIDAsIGluY3IpO1xuICAgIH07XG4gICAgRGVuc2VNVEZNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKHN5bWJvbCwgaW5kZXgsIHN5X2YsIGluY3IpIHtcbiAgICAgIHZhciBzZWVuU3ltcyA9IHRoaXMuc3ltLmxlbmd0aDtcbiAgICAgIHZhciBpLCBqLCB0b3RfZjtcbiAgICAgIC8vIG1vdmUgdGhpcyBzeW1ib2wgdG8gdGhlIGVuZFxuICAgICAgZm9yIChqPWluZGV4OyBqPHNlZW5TeW1zLTE7IGorKykge1xuICAgICAgICB0aGlzLnN5bVtqXSA9IHRoaXMuc3ltW2orMV07XG4gICAgICAgIHRoaXMucHJvYltqXSA9IHRoaXMucHJvYltqKzFdIC0gc3lfZjtcbiAgICAgIH1cbiAgICAgIC8vIFwibWV0aG9kIERcIiAtLSBpZiB3ZSBhZGQgYSBuZXcgZXNjYXBlZCBzeW1ib2wsIGVzY2FwZSAmIHRoZSBzeW1ib2xcbiAgICAgIC8vIGJvdGggaW5jcmVhc2UgYnkgMS8yLlxuICAgICAgaWYgKGluZGV4IDwgc2VlblN5bXMpIHtcbiAgICAgICAgdGhpcy5zeW1bal0gPSBzeW1ib2w7XG4gICAgICAgIHRoaXMucHJvYltqXSA9IHRoaXMucHJvYltqKzFdIC0gc3lfZjtcbiAgICAgICAgLy8gaW5jcmVhc2UgZnJlcXVlbmN5IGZvciB0aGlzIHN5bWJvbCwgYW5kIHRvdGFsIGZyZXEgYXQgc2FtZSB0aW1lXG4gICAgICAgIHRoaXMucHJvYltzZWVuU3ltc10gPSB0b3RfZiA9XG4gICAgICAgICAgdGhpcy5wcm9iW3NlZW5TeW1zXSArIGluY3I7XG4gICAgICB9IGVsc2UgeyAvLyBhZGQgdG8gdGhlIGVuZFxuICAgICAgICB0b3RfZiA9IHRoaXMucHJvYltzZWVuU3ltc107XG4gICAgICAgIHRoaXMuc3ltW2luZGV4XSA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5wcm9iW2luZGV4XSA9IHRvdF9mO1xuICAgICAgICB0b3RfZiArPSBpbmNyO1xuICAgICAgICB0aGlzLnByb2JbKytzZWVuU3ltc10gPSB0b3RfZjtcbiAgICAgICAgLy8gcmVtb3ZlIHByb2JhYmlsaXR5IG9mIGVzY2FwZSBpZiB0YWJsZSBqdXN0IGZpbGxlZCB1cFxuICAgICAgICBpZiAodGhpcy5zeW0ubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaT0wOyBpPHNlZW5TeW1zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzaXplID09PSB0aGlzLnN5bVtpXSkge1xuICAgICAgICAgICAgICAvLyBmb3VuZCBpdC5cbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHNpemUsIGksIHRoaXMucHJvYltpKzFdIC0gdGhpcy5wcm9iW2ldLCAtMSk7XG4gICAgICAgICAgICAgIHRoaXMuc3ltLmxlbmd0aC0tO1xuICAgICAgICAgICAgICB0aGlzLnByb2IubGVuZ3RoLS07XG4gICAgICAgICAgICAgIHRvdF9mID0gdGhpcy5wcm9iW3RoaXMucHJvYi5sZW5ndGgtMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG90X2YgPj0gRE1NX01BWF9QUk9CKSB7IHRvdF9mID0gdGhpcy5fcmVzY2FsZSgpOyB9XG4gICAgICByZXR1cm4gdG90X2Y7XG4gICAgfTtcbiAgICBEZW5zZU1URk1vZGVsLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzeW1ib2wsIGV4Y2x1ZGUpIHtcbiAgICAgIC8vIGxvb2sgZm9yIHN5bWJvbCwgZnJvbSBtb3N0LXJlY2VudCB0byBvbGRlc3RcbiAgICAgIHZhciBpLCBqLCBzeV9mLCBsdF9mLCB0b3RfZiwgc2VlblN5bXMgPSB0aGlzLnN5bS5sZW5ndGg7XG4gICAgICB2YXIgZXhfc2VlbiA9IDAsIGV4X2x0X2YgPSAwLCBleF90b3RfZiA9IDAsIGV4X3N5X2Y7XG4gICAgICBmb3IgKGk9c2VlblN5bXMtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGx0X2YgPSB0aGlzLnByb2JbaV07XG4gICAgICAgIHN5X2YgPSB0aGlzLnByb2JbaSArIDFdIC0gbHRfZjtcbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gdGhpcy5zeW1baV0pIHtcbiAgICAgICAgICAvLyBvaywgZm91bmQgaXQuXG4gICAgICAgICAgLy8gY291bnQgdXAgdGhlIHJlc3Qgb2YgdGhlIHByb2JhYmlsaXRpZXNcbiAgICAgICAgICBmb3IgKGo9aS0xOyBqPj0wICYmIGV4X3NlZW4gPCBleGNsdWRlLnRvdGFsOyBqLS0pIHtcbiAgICAgICAgICAgIGlmIChleGNsdWRlW3RoaXMuc3ltW2pdXSkge1xuICAgICAgICAgICAgICBleF9zZWVuICs9IDE7XG4gICAgICAgICAgICAgIGV4X3N5X2YgPSB0aGlzLnByb2JbaisxXSAtIHRoaXMucHJvYltqXTtcbiAgICAgICAgICAgICAgZXhfbHRfZiArPSBleF9zeV9mO1xuICAgICAgICAgICAgICBleF90b3RfZiArPSBleF9zeV9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RfZiA9IHRoaXMucHJvYltzZWVuU3ltc107XG4gICAgICAgICAgLy8gYWRqdXN0IGJ5IGV4Y2x1ZGVkIHN5bWJvbHNcbiAgICAgICAgICBsdF9mIC09IGV4X2x0X2Y7XG4gICAgICAgICAgdG90X2YgLT0gZXhfdG90X2Y7XG4gICAgICAgICAgY29kZXIuZW5jb2RlRnJlcShzeV9mLCBsdF9mLCB0b3RfZik7XG4gICAgICAgICAgaWYgKHN5bWJvbCA9PT0gc2l6ZSkgeyAvLyBvbmx5IHVwZGF0ZSB0YWJsZSBmb3IgZXNjYXBlc1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHN5bWJvbCwgaSwgc3lfZiwgRE1NX0lOQ1JFTUVOVC8yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZXNjYXBlLlxuICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIHdlJ2xsIGRvIHVwZGF0ZSBsYXRlclxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBlbmNvZGVkIGNoYXJhY3RlciFcbiAgICAgICAgfSBlbHNlIGlmIChleGNsdWRlW3RoaXMuc3ltW2ldXSkge1xuICAgICAgICAgIGV4X3NlZW4gKz0gMTtcbiAgICAgICAgICBleF90b3RfZiArPSBzeV9mO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb3VsZG4ndCBmaW5kIHRoaXMgc3ltYm9sLiAgZW5jb2RlIGFzIGVzY2FwZS5cbiAgICAgIHRoaXMuZW5jb2RlKHNpemUsIGV4Y2x1ZGUpO1xuICAgICAgLy8gYWRkIHN5bWJvbHMgdG8gZXhjbHVzaW9uIHRhYmxlXG4gICAgICBjb25zb2xlLmFzc2VydCh0aGlzLnN5bVt0aGlzLnN5bS5sZW5ndGgtMV0gPT09IHNpemUpOy8vZXNjYXBlXG4gICAgICBmb3IgKGk9MDsgaTx0aGlzLnN5bS5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgIGlmICghZXhjbHVkZVt0aGlzLnN5bVtpXV0pIHtcbiAgICAgICAgICBleGNsdWRlW3RoaXMuc3ltW2ldXSA9IHRydWU7XG4gICAgICAgICAgZXhjbHVkZS50b3RhbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBEZW5zZU1URk1vZGVsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihleGNsdWRlKSB7XG4gICAgICB2YXIgc2VlblN5bXMgPSB0aGlzLnN5bS5sZW5ndGg7XG4gICAgICB2YXIgdG90X2YgPSB0aGlzLnByb2Jbc2VlblN5bXNdO1xuICAgICAgdmFyIGV4X3NlZW4gPSAwLCBleF9sdF9mID0gMCwgZXhfdG90X2YgPSAwLCBleF9zeV9mO1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGk9c2VlblN5bXMtMTsgaT49MCAmJiBleF9zZWVuIDwgZXhjbHVkZS50b3RhbDsgaS0tKSB7XG4gICAgICAgIGlmIChleGNsdWRlW3RoaXMuc3ltW2ldXSkge1xuICAgICAgICAgIGV4X3NlZW4gKz0gMTtcbiAgICAgICAgICBleF90b3RfZiArPSB0aGlzLnByb2JbaSsxXSAtIHRoaXMucHJvYltpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHByb2IgPSBjb2Rlci5kZWNvZGVDdWxGcmVxKHRvdF9mIC0gZXhfdG90X2YpICsgZXhfdG90X2Y7XG4gICAgICAvLyB3ZSdyZSBleHBlY3RpbmcgdG8gZmluZCB0aGUgcHJvYmFiaWxpdHkgbmVhciB0aGUgXCJtb3N0IHJlY2VudFwiIHNpZGVcbiAgICAgIC8vIG9mIG91ciBhcnJheVxuICAgICAgZXhfbHRfZiA9IGV4X3RvdF9mO1xuICAgICAgZm9yIChpPXNlZW5TeW1zLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBpZiAoZXhjbHVkZVt0aGlzLnN5bVtpXV0pIHtcbiAgICAgICAgICBleF9zeV9mID0gdGhpcy5wcm9iW2krMV0gLSB0aGlzLnByb2JbaV07XG4gICAgICAgICAgZXhfbHRfZiAtPSBleF9zeV9mO1xuICAgICAgICAgIHByb2IgLT0gZXhfc3lfZjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb2JbaV0gPD0gcHJvYiAvKiYmIHByb2IgPCB0aGlzLnByb2JbaSsxXSovKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc29sZS5hc3NlcnQoaT49MCk7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpcy5zeW1baV07XG4gICAgICB2YXIgbHRfZiA9IHRoaXMucHJvYltpXTtcbiAgICAgIHZhciBzeV9mID0gdGhpcy5wcm9iW2kgKyAxXSAtIGx0X2Y7XG4gICAgICBjb2Rlci5kZWNvZGVVcGRhdGUoc3lfZiwgbHRfZiAtIGV4X2x0X2YsIHRvdF9mIC0gZXhfdG90X2YpO1xuICAgICAgLy8gZGVmZXIgdXBkYXRlXG4gICAgICBpZiAoc3ltYm9sIDwgc2l6ZSkgeyByZXR1cm4gc3ltYm9sOyB9XG4gICAgICAvLyBhbiBlc2NhcGVcbiAgICAgIHRoaXMuX3VwZGF0ZShzeW1ib2wsIGksIHN5X2YsIERNTV9JTkNSRU1FTlQvMik7XG4gICAgICAvLyBhZGQgc3ltYm9scyB0byBleGNsdXNpb24gdGFibGVcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuc3ltW3RoaXMuc3ltLmxlbmd0aC0xXSA9PT0gc2l6ZSk7Ly9lc2NhcGVcbiAgICAgIGZvciAoaT0wOyBpPHRoaXMuc3ltLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgaWYgKCFleGNsdWRlW3RoaXMuc3ltW2ldXSkge1xuICAgICAgICAgIGV4Y2x1ZGVbdGhpcy5zeW1baV1dID0gdHJ1ZTtcbiAgICAgICAgICBleGNsdWRlLnRvdGFsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIHRoaXMubmV3Q29udGV4dCA9IGZ1bmN0aW9uKGluaXRpYWxTeW1ib2wpIHtcbiAgICAgIHJldHVybiBuZXcgRGVuc2VNVEZNb2RlbCgpO1xuICAgIH07XG4gICAgdGhpcy5uZXdFeGNsdWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlc3VsdC50b3RhbCA9IDA7IC8vIG5vIGV4Y2x1ZGVkIHN5bWJvbHMgKHlldClcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBzZXQgdXAgc29tZSBpbml0aWFsIGNvbnRleHRzXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGo7XG4gICAgICBmb3IgKGk9MDsgaTxNQVhfQ09OVEVYVDsgaSsrKSB7XG4gICAgICAgIGZvciAoaj0wOyBqPD1pOyBqKyspIHtcbiAgICAgICAgICB2YXIgY2MgPSB0aGlzLndpbmRvdy5jb250ZXh0KGorKChNQVhfQ09OVEVYVC0xKS1pKSwgaik7XG4gICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHRzW2NjXSkgeyB0aGlzLmNvbnRleHRzW2NjXSA9IHRoaXMubmV3Q29udGV4dCgpOyB9XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjY10ucmVmY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcyk7XG4gIH07XG4gIFBQTS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oc3ltYm9sLCBjb250ZXh0U3RyaW5nLCBtYXRjaExldmVsKSB7XG4gICAgLy8gc2xpZGUgdXAgdGhlIGNvbnRleHRzLCB1cGRhdGluZyB0aGVtXG4gICAgdmFyIG1vZGVsLCBjLCBjYztcbiAgICBmb3IgKGM9MDsgYyA8PSBNQVhfQ09OVEVYVDsgYysrKSB7XG4gICAgICBjYyA9IGNvbnRleHRTdHJpbmcuc2xpY2UoTUFYX0NPTlRFWFQgLSBjKTtcbiAgICAgIG1vZGVsID0gdGhpcy5jb250ZXh0c1tjY107XG4gICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIG1vZGVsID0gdGhpcy5jb250ZXh0c1tjY10gPSB0aGlzLm5ld0NvbnRleHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IG1hdGNoTGV2ZWwpIHtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgdXNlZnVsIGNvbnRleHRzXG4gICAgICAgIG1vZGVsLnVwZGF0ZShzeW1ib2wsIERNTV9JTkNSRU1FTlQgLyAyKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlZmNvdW50IGFsbCBjb250ZXh0cywgd2hldGhlciB1c2VkL3VwZGF0ZWQgb3Igbm90XG4gICAgICBtb2RlbC5yZWZjb3VudCsrO1xuICAgIH1cbiAgICAvLyBub3cgZ2FyYmFnZS1jb2xsZWN0IG9sZCBjb250ZXh0c1xuICAgIGNvbnRleHRTdHJpbmcgPSB0aGlzLndpbmRvdy5jb250ZXh0KHRoaXMud2luZG93LnBvcyArIE1BWF9DT05URVhULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9DT05URVhUKTtcbiAgICB2YXIgZmlyc3RQYXNzID0gdGhpcy53aW5kb3cuZmlyc3RQYXNzO1xuICAgIGZvciAoYz1NQVhfQ09OVEVYVDsgYz49MCAmJiAhZmlyc3RQYXNzOyBjLS0pIHtcbiAgICAgIGNjID0gY29udGV4dFN0cmluZy5zbGljZSgwLCBjKTtcbiAgICAgIG1vZGVsID0gdGhpcy5jb250ZXh0c1tjY107XG4gICAgICBjb25zb2xlLmFzc2VydChtb2RlbCk7XG4gICAgICBpZiAoKC0tbW9kZWwucmVmY291bnQpIDw9IDApIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoY2MgIT09ICcnKTsgLy8gZG9uJ3QgYWxsb3cgY29udGV4dC0wIHRvIGJlIGdjJ2VkIVxuICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1tjY107XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9rLCBhZHZhbmNlIHdpbmRvdy5cbiAgICB0aGlzLndpbmRvdy5wdXQoc3ltYm9sKTtcbiAgfTtcbiAgUFBNLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGV4dFN0cmluZyA9IHRoaXMud2luZG93LmNvbnRleHQodGhpcy53aW5kb3cucG9zLCBNQVhfQ09OVEVYVCk7XG4gICAgdmFyIGV4Y2x1ZGUgPSB0aGlzLm5ld0V4Y2x1ZGUoKTtcbiAgICB2YXIgbW9kZWwsIGMsIGNjLCBzeW1ib2w7XG4gICAgZm9yIChjPU1BWF9DT05URVhUOyBjPj0wOyBjLS0pIHtcbiAgICAgIGNjID0gY29udGV4dFN0cmluZy5zbGljZShNQVhfQ09OVEVYVCAtIGMpO1xuICAgICAgbW9kZWwgPSB0aGlzLmNvbnRleHRzW2NjXTtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBzeW1ib2wgPSBtb2RlbC5kZWNvZGUoZXhjbHVkZSk7XG4gICAgICAgIGlmIChzeW1ib2wgPj0gMCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlKHN5bWJvbCwgY29udGV4dFN0cmluZywgYyk7XG4gICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBzdGlsbCBubyBtYXRjaCwgZmFsbCBiYWNrIHRvIGNvbnRleHQgLTFcbiAgICBzeW1ib2wgPSB0aGlzLmNtMWNvZGVyLmRlY29kZShleGNsdWRlKTtcbiAgICB0aGlzLnVwZGF0ZShzeW1ib2wsIGNvbnRleHRTdHJpbmcsIGMpO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH07XG4gIFBQTS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgdmFyIGNvbnRleHRTdHJpbmcgPSB0aGlzLndpbmRvdy5jb250ZXh0KHRoaXMud2luZG93LnBvcywgTUFYX0NPTlRFWFQpO1xuICAgIHZhciBleGNsdWRlID0gdGhpcy5uZXdFeGNsdWRlKCk7XG4gICAgdmFyIGM7XG4gICAgZm9yIChjPU1BWF9DT05URVhUOyBjPj0wOyBjLS0pIHtcbiAgICAgIHZhciBjYyA9IGNvbnRleHRTdHJpbmcuc2xpY2UoTUFYX0NPTlRFWFQgLSBjKTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuY29udGV4dHNbY2NdO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIHZhciBzdWNjZXNzID0gbW9kZWwuZW5jb2RlKHN5bWJvbCwgZXhjbHVkZSk7XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUoc3ltYm9sLCBjb250ZXh0U3RyaW5nLCBjKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmFsbCBiYWNrIHRvIGNvbnRleHQgLTEgKGJ1dCBzdGlsbCB1c2UgZXhjbHVzaW9uIHRhYmxlKVxuICAgIHRoaXMuY20xY29kZXIuZW5jb2RlKHN5bWJvbCwgZXhjbHVkZSk7XG4gICAgdGhpcy51cGRhdGUoc3ltYm9sLCBjb250ZXh0U3RyaW5nLCBjKTtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgUFBNLk1BR0lDID0gJ3BwbTInO1xuICBQUE0uY29tcHJlc3NGaWxlID0gVXRpbC5jb21wcmVzc0ZpbGVIZWxwZXIoUFBNLk1BR0lDLCBmdW5jdGlvbihpblN0cmVhbSwgb3V0U3RyZWFtLCBmaWxlU2l6ZSwgcHJvcHMsIGZpbmFsQnl0ZSkge1xuICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZUNvZGVyKG91dFN0cmVhbSk7XG4gICAgcmFuZ2UuZW5jb2RlU3RhcnQoZmluYWxCeXRlLCAxKTtcbiAgICB2YXIgbW9kZWwgPSBuZXcgUFBNKHJhbmdlLCAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICAgIFV0aWwuY29tcHJlc3NXaXRoTW9kZWwoaW5TdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gICAgcmFuZ2UuZW5jb2RlRmluaXNoKCk7XG4gIH0sIHRydWUpO1xuICBQUE0uZGVjb21wcmVzc0ZpbGUgPSBVdGlsLmRlY29tcHJlc3NGaWxlSGVscGVyKFBQTS5NQUdJQywgZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgZmlsZVNpemUpIHtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2VDb2RlcihpblN0cmVhbSk7XG4gICAgcmFuZ2UuZGVjb2RlU3RhcnQodHJ1ZS8qd2UgYWxyZWFkeSByZWFkIHRoZSAnZnJlZScgYnl0ZSovKTtcbiAgICB2YXIgbW9kZWwgPSBuZXcgUFBNKHJhbmdlLCAoZmlsZVNpemU8MCkgPyAyNTcgOiAyNTYpO1xuICAgIFV0aWwuZGVjb21wcmVzc1dpdGhNb2RlbChvdXRTdHJlYW0sIGZpbGVTaXplLCBtb2RlbCk7XG4gICAgcmFuZ2UuZGVjb2RlRmluaXNoKCk7XG4gIH0pO1xuXG4gIHJldHVybiBQUE07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyogUmFuZ2UgQ29kZXIuICBJbnNwaXJlZCBieSByYW5nZWNvZC5jIGZyb20gcm5nY29kMTMuemlwIGZyb21cbiAqICAgIGh0dHA6Ly93d3cuY29tcHJlc3Njb25zdWx0LmNvbS9yYW5nZWNvZGVyL1xuICogVGhpcyBKYXZhU2NyaXB0IHZlcnNpb24gaXM6XG4gKiAgICBDb3B5cmlnaHQgKGMpIDIwMTMgQy4gU2NvdHQgQW5hbmlhbi5cbiAqL1xudmFyIGxpYnMgPSBbXG5dO1xudmFyIGJvZHlfZm4gPSBmdW5jdGlvbiAoKXtcblxuICAgIC8vIFVzZXMgMzItYml0IGludGVnZXIgbWF0aC4gIEhvcGVmdWxseSB0aGUgSmF2YVNjcmlwdCBydW50aW1lIGZpZ3VyZXNcbiAgICAvLyB0aGF0IG91dC4gOylcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbi93aWtpL0xMVk0tVHlwZXMtaW4tSmF2YVNjcmlwdFxuICAgIC8vIGZvciBzb21lIGhpbnRzIG9uIGRvaW5nIDMyLWJpdCB1bnNpZ25lZCBtYXRjaCBpbiBKYXZhU2NyaXB0LlxuICAgIC8vIE9uZSBrZXkgaXMgdGhlIHVzZSBvZiBcIj4+PjBcIiB0byBjaGFuZ2UgYSBzaWduZWQgcmVzdWx0IHRvIHVuc2lnbmVkLlxuICAgIHZhciBDT0RFX0JJVFMgPSAzMjtcbiAgICB2YXIgVG9wX3ZhbHVlID0gTWF0aC5wb3coMiwgQ09ERV9CSVRTLTEpO1xuICAgIHZhciBTSElGVF9CSVRTID0gKENPREVfQklUUyAtIDkpO1xuICAgIHZhciBFWFRSQV9CSVRTID0gKChDT0RFX0JJVFMtMikgJSA4ICsgMSk7XG4gICAgdmFyIEJvdHRvbV92YWx1ZSA9IChUb3BfdmFsdWUgPj4+IDgpO1xuXG4gICAgdmFyIE1BWF9JTlQgPSBNYXRoLnBvdygyLCBDT0RFX0JJVFMpIC0gMTtcblxuICAgIC8qIGl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0aGF0IHRoZSB0b3RhbCBmcmVxdWVuY3kgY291bnQgaXMgbGVzcyAgKi9cbiAgICAvKiB0aGFuIDEgPDwgMTkgdG8gbWluaW1pemUgcm91bmRpbmcgZWZmZWN0cy4gICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgLyogdGhlIHRvdGFsIGZyZXF1ZW5jeSBjb3VudCBNVVNUIGJlIGxlc3MgdGhhbiAxPDwyMyAgICAgICAgICAgICAgICAqL1xuXG5cbiAgICB2YXIgUmFuZ2VDb2RlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICB0aGlzLmxvdyA9IDA7IC8qIGxvdyBlbmQgb2YgaW50ZXJ2YWwgKi9cbiAgICAgICAgdGhpcy5yYW5nZSA9IFRvcF92YWx1ZTsgLyogbGVuZ3RoIG9mIGludGVydmFsICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gMDsgLyogYnVmZmVyIGZvciBpbnB1dC9vdXRwdXQgKi9cbiAgICAgICAgdGhpcy5oZWxwID0gMDsgLyogYnl0ZXNfdG9fZm9sbG93IC8gaW50ZXJtZWRpYXRlIHZhbHVlICovXG4gICAgICAgIHRoaXMuYnl0ZWNvdW50ID0gMDsgLyogY291bnRlciBmb3Igb3V0cHV0IGJ5dGVzICovXG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgIH07XG5cbiAgICAvKiBEbyB0aGUgbm9ybWFsaXphdGlvbiBiZWZvcmUgd2UgbmVlZCBhIGRlZmluZWQgc3RhdGUsIGluc3RlYWQgb2ZcbiAgICAgKiBhZnRlciBtZXNzaW5nIGl0IHVwLiAgVGhpcyBzaW1wbGlmaWVzIHN0YXJ0aW5nIGFuZCBlbmRpbmcuICovXG4gICAgdmFyIGVuY19ub3JtYWxpemUgPSBmdW5jdGlvbihyYywgb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgIHdoaWxlIChyYy5yYW5nZSA8PSBCb3R0b21fdmFsdWUpIHsgLyogZG8gd2UgbmVlZCByZW5vcm1hbGl6YXRpb24/ICovXG4gICAgICAgICAgICBpZiAocmMubG93IDwgKDB4RkYgPDwgU0hJRlRfQklUUykpIHsvL25vIGNhcnJ5IHBvc3NpYmxlLCBzbyBvdXRwdXRcbiAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGVCeXRlKHJjLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgZm9yICg7IHJjLmhlbHA7IHJjLmhlbHAtLSlcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlQnl0ZSgweEZGKTtcbiAgICAgICAgICAgICAgICByYy5idWZmZXIgPSAocmMubG93ID4+PiBTSElGVF9CSVRTKSAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJjLmxvdyAmIFRvcF92YWx1ZSkgeyAvKiBjYXJyeSBub3csIG5vIGZ1dHVyZSBjYXJyeSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZUJ5dGUocmMuYnVmZmVyKzEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyByYy5oZWxwOyByYy5oZWxwLS0pXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICAgICAgICAgICAgcmMuYnVmZmVyID0gKHJjLmxvdyA+Pj4gU0hJRlRfQklUUykgJiAweEZGO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYy5oZWxwKys7XG4gICAgICAgICAgICAgICAgaWYgKHJjLmhlbHAgPiBNQVhfSU5UKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBieXRlcyBvdXRzdGFuZGluZywgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGUgdG9vIGxhcmdlIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJjLnJhbmdlID0gKHJjLnJhbmdlIDw8IDgpID4+PiAwOy8qZW5zdXJlIHJlc3VsdCByZW1haW5zIHBvc2l0aXZlKi9cbiAgICAgICAgICAgIHJjLmxvdyA9ICgocmMubG93IDw8IDgpICYgKFRvcF92YWx1ZSAtIDEpKSA+Pj4gMDsgLyogdW5zaWduZWQgKi9cbiAgICAgICAgICAgIHJjLmJ5dGVjb3VudCsrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIFN0YXJ0IHRoZSBlbmNvZGVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIGMgaXMgd3JpdHRlbiBhcyB0aGUgZmlyc3QgYnl0ZSBpbiB0aGUgZGF0YXN0cmVhbS5cbiAgICAgKiBvbmUgY291bGQgZG8gdy9vLCBidXQgdGhlbiB5b3UgaGF2ZSBhbiBhZGRpdGlvbmFsIGlmIHBlciBvdXRwdXQgYnl0ZSAqL1xuICAgIFJhbmdlQ29kZXIucHJvdG90eXBlLmVuY29kZVN0YXJ0ID0gZnVuY3Rpb24oYywgaW5pdGxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvdyA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2UgPSBUb3BfdmFsdWU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYztcbiAgICAgICAgdGhpcy5oZWxwID0gMDtcbiAgICAgICAgdGhpcy5ieXRlY291bnQgPSBpbml0bGVuZ3RoO1xuICAgIH07XG5cbiAgIC8qIEVuY29kZSBhIHN5bWJvbCB1c2luZyBmcmVxdWVuY2llcyAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIHJjIGlzIHRoZSByYW5nZSBjb2RlciB0byBiZSB1c2VkICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIHN5X2YgaXMgdGhlIGludGVydmFsIGxlbmd0aCAoZnJlcXVlbmN5IG9mIHRoZSBzeW1ib2wpICAgICAqL1xuICAgIC8qIGx0X2YgaXMgdGhlIGxvd2VyIGVuZCAoZnJlcXVlbmN5IHN1bSBvZiA8IHN5bWJvbHMpICAgICAgICAqL1xuICAgIC8qIHRvdF9mIGlzIHRoZSB0b3RhbCBpbnRlcnZhbCBsZW5ndGggKHRvdGFsIGZyZXF1ZW5jeSBzdW0pICAqL1xuICAgIC8qIG9yIChmYXN0ZXIpOiB0b3RfZiA9IChjb2RlX3ZhbHVlKTE8PHNoaWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIFJhbmdlQ29kZXIucHJvdG90eXBlLmVuY29kZUZyZXEgPSBmdW5jdGlvbihzeV9mLCBsdF9mLCB0b3RfZikge1xuICAgICAgICBlbmNfbm9ybWFsaXplKHRoaXMsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdmFyIHIgPSAodGhpcy5yYW5nZSAvIHRvdF9mKSA+Pj4gMDsgLy8gbm90ZSBjb2VyY2lvbiB0byBpbnRlZ2VyXG4gICAgICAgIHZhciB0bXAgPSByICogbHRfZjtcbiAgICAgICAgdGhpcy5sb3cgKz0gdG1wO1xuICAgICAgICBpZiAoKGx0X2YgKyBzeV9mKSA8IHRvdF9mKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gciAqIHN5X2Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlIC09IHRtcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZW5jb2RlU2hpZnQgPSBmdW5jdGlvbihzeV9mLCBsdF9mLCBzaGlmdCkge1xuICAgICAgICBlbmNfbm9ybWFsaXplKHRoaXMsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhbmdlID4+PiBzaGlmdDtcbiAgICAgICAgdmFyIHRtcCA9IHIgKiBsdF9mO1xuICAgICAgICB0aGlzLmxvdyArPSB0bXA7XG4gICAgICAgIGlmICgobHRfZiArIHN5X2YpID4+PiBzaGlmdCkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSAtPSB0bXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gciAqIHN5X2Y7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEVuY29kZSBhIGJpdCB3L28gbW9kZWxsaW5nLiAqL1xuICAgIFJhbmdlQ29kZXIucHJvdG90eXBlLmVuY29kZUJpdCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVTaGlmdCgxLCBiPzE6MCwgMSk7XG4gICAgfTtcbiAgICAvKiBFbmNvZGUgYSBieXRlIHcvbyBtb2RlbGxpbmcuICovXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZW5jb2RlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVTaGlmdCgxLCBiLCA4KTtcbiAgICB9O1xuICAgIC8qIEVuY29kZSBhIHNob3J0IHcvbyBtb2RlbGxpbmcuICovXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZW5jb2RlU2hvcnQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlU2hpZnQoMSwgcywgMTYpO1xuICAgIH07XG5cbiAgICAvKiBGaW5pc2ggZW5jb2RpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAvKiByZXR1cm5zIG51bWJlciBvZiBieXRlcyB3cml0dGVuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICBSYW5nZUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG91dHB1dFN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICBlbmNfbm9ybWFsaXplKHRoaXMsIG91dHB1dFN0cmVhbSk7XG4gICAgICAgIHRoaXMuYnl0ZWNvdW50ICs9IDU7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmxvdyA+Pj4gU0hJRlRfQklUUztcbiAgICAgICAgaWYgKCh0aGlzLmxvdyAmIChCb3R0b21fdmFsdWUtMSkpID49ICgodGhpcy5ieXRlY291bnQmMHhGRkZGRkYpPj4+MSkpIHtcbiAgICAgICAgICAgIHRtcCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0bXAgPiAweEZGKSB7IC8qIHdlIGhhdmUgYSBjYXJyeSAqL1xuICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlQnl0ZSh0aGlzLmJ1ZmZlciArIDEpO1xuICAgICAgICAgICAgZm9yICg7IHRoaXMuaGVscDsgdGhpcy5oZWxwLS0pXG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlQnl0ZSgweDAwKTtcbiAgICAgICAgfSBlbHNlIHsgLyogbm8gY2FycnkgKi9cbiAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZUJ5dGUodGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgZm9yICg7IHRoaXMuaGVscDsgdGhpcy5oZWxwLS0pXG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlQnl0ZSgweEZGKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGVCeXRlKHRtcCAmIDB4RkYpO1xuICAgICAgICAvLyBYWFg6IGknbSBwcmV0dHkgc3VyZSB0aGVzZSBjb3VsZCBiZSB0aHJlZSBhcmJpdHJhcnkgYnl0ZXNcbiAgICAgICAgLy8gICAgICB0aGV5IGFyZSBjb25zdW1lZCBieSB0aGUgZGVjb2RlciBhdCB0aGUgZW5kXG4gICAgICAgIG91dHB1dFN0cmVhbS53cml0ZUJ5dGUoKHRoaXMuYnl0ZWNvdW50ID4+PiAxNikgJiAweEZGKTtcbiAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlQnl0ZSgodGhpcy5ieXRlY291bnQgPj4+ICA4KSAmIDB4RkYpO1xuICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGVCeXRlKCh0aGlzLmJ5dGVjb3VudCAgICAgICApICYgMHhGRik7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVjb3VudDtcbiAgICB9O1xuXG4gICAgLyogU3RhcnQgdGhlIGRlY29kZXI7IHlvdSBuZWVkIHRvIHByb3ZpZGUgdGhlICpzZWNvbmQqIGJ5dGUgZnJvbSB0aGVcbiAgICAgKiBkYXRhc3RyZWFtLiAoVGhlIGZpcnN0IGJ5dGUgd2FzIHByb3ZpZGVkIHRvIHN0YXJ0RW5jb2RpbmcgYW5kIGlzXG4gICAgICogaWdub3JlZCBieSB0aGUgZGVjb2Rlci4pXG4gICAgICovXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZGVjb2RlU3RhcnQgPSBmdW5jdGlvbihza2lwSW5pdGlhbFJlYWQpIHtcbiAgICAgICAgdmFyIGMgPSBza2lwSW5pdGlhbFJlYWQgPyAwIDogdGhpcy5zdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZihjKSAhPT0gJ251bWJlcicgfHwgYyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjOyAvLyBFT0ZcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuc3RyZWFtLnJlYWRCeXRlKCk7XG4gICAgICAgIHRoaXMubG93ID0gdGhpcy5idWZmZXIgPj4+ICg4IC0gRVhUUkFfQklUUyk7XG4gICAgICAgIHRoaXMucmFuZ2UgPSAxIDw8IEVYVFJBX0JJVFM7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH07XG5cbiAgICB2YXIgZGVjX25vcm1hbGl6ZSA9IGZ1bmN0aW9uKHJjLCBpbnB1dFN0cmVhbSkge1xuICAgICAgICB3aGlsZSAocmMucmFuZ2UgPD0gQm90dG9tX3ZhbHVlKSB7XG4gICAgICAgICAgICByYy5sb3cgPSAocmMubG93IDw8IDgpIHwgKChyYy5idWZmZXIgPDwgRVhUUkFfQklUUykgJiAweEZGKTtcbiAgICAgICAgICAgIC8qIHJjLmxvdyBjb3VsZCBiZSBuZWdhdGl2ZSBoZXJlOyBkb24ndCBmaXggaXQgcXVpdGUgeWV0ICovXG4gICAgICAgICAgICByYy5idWZmZXIgPSBpbnB1dFN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgcmMubG93IHw9IHJjLmJ1ZmZlciA+Pj4gKDgtRVhUUkFfQklUUyk7XG4gICAgICAgICAgICByYy5sb3cgPSByYy5sb3cgPj4+IDA7IC8qIGZpeCBpdCBub3cgKi9cbiAgICAgICAgICAgIHJjLnJhbmdlID0gKHJjLnJhbmdlIDw8IDgpID4+PiAwOyAvKiBlbnN1cmUgc3RheXMgcG9zaXRpdmUgKi9cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKiBDYWxjdWxhdGUgY3VtdWxhdGl2ZSBmcmVxdWVuY3kgZm9yIG5leHQgc3ltYm9sLiBEb2VzIE5PIHVwZGF0ZSEqL1xuICAgIC8qIHJjIGlzIHRoZSByYW5nZSBjb2RlciB0byBiZSB1c2VkICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIHRvdF9mIGlzIHRoZSB0b3RhbCBmcmVxdWVuY3kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIG9yOiB0b3RmIGlzIChjb2RlX3ZhbHVlKTE8PHNoaWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIHJldHVybnMgdGhlIDw9IGN1bXVsYXRpdmUgZnJlcXVlbmN5ICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZGVjb2RlQ3VsRnJlcSA9IGZ1bmN0aW9uKHRvdF9mKSB7XG4gICAgICAgIGRlY19ub3JtYWxpemUodGhpcywgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLmhlbHAgPSAodGhpcy5yYW5nZSAvIHRvdF9mKSA+Pj4gMDsgLy8gbm90ZSBjb2VyY2lvbiB0byBpbnRlZ2VyXG4gICAgICAgIHZhciB0bXAgPSAodGhpcy5sb3cgLyB0aGlzLmhlbHApID4+PiAwOyAvLyBhZ2FpblxuICAgICAgICByZXR1cm4gKHRtcCA+PSB0b3RfZiA/IHRvdF9mLTEgOiB0bXApO1xuICAgIH07XG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZGVjb2RlQ3VsU2hpZnQgPSBmdW5jdGlvbihzaGlmdCkge1xuICAgICAgICBkZWNfbm9ybWFsaXplKHRoaXMsIHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy5oZWxwID0gdGhpcy5yYW5nZSA+Pj4gc2hpZnQ7XG4gICAgICAgIHZhciB0bXAgPSAodGhpcy5sb3cgLyB0aGlzLmhlbHApID4+PiAwOyAvLyBjb2VyY2lvbiB0byB1bnNpZ25lZFxuICAgICAgICAvLyBzaGlmdCBpcyBsZXNzIHRoYW4gMzEsIHNvIHNoaWZ0IGJlbG93IHdpbGwgcmVtYWluIHBvc2l0aXZlXG4gICAgICAgIHJldHVybiAoKHRtcD4+PnNoaWZ0KSA/ICgxPDxzaGlmdCktMSA6IHRtcCk7XG4gICAgfTtcblxuICAgIC8qIFVwZGF0ZSBkZWNvZGluZyBzdGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIHJjIGlzIHRoZSByYW5nZSBjb2RlciB0byBiZSB1c2VkICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgIC8qIHN5X2YgaXMgdGhlIGludGVydmFsIGxlbmd0aCAoZnJlcXVlbmN5IG9mIHRoZSBzeW1ib2wpICAgICAqL1xuICAgIC8qIGx0X2YgaXMgdGhlIGxvd2VyIGVuZCAoZnJlcXVlbmN5IHN1bSBvZiA8IHN5bWJvbHMpICAgICAgICAqL1xuICAgIC8qIHRvdF9mIGlzIHRoZSB0b3RhbCBpbnRlcnZhbCBsZW5ndGggKHRvdGFsIGZyZXF1ZW5jeSBzdW0pICAqL1xuICAgIFJhbmdlQ29kZXIucHJvdG90eXBlLmRlY29kZVVwZGF0ZSA9IGZ1bmN0aW9uKHN5X2YsIGx0X2YsIHRvdF9mKSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmhlbHAgKiBsdF9mOyAvLyBzaG91bGQgbm90IG92ZXJmbG93IVxuICAgICAgICB0aGlzLmxvdyAtPSB0bXA7XG4gICAgICAgIGlmIChsdF9mICsgc3lfZiA8IHRvdF9mKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gKHRoaXMuaGVscCAqIHN5X2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSAtPSB0bXA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyogRGVjb2RlIGEgYml0IHcvbyBtb2RlbGxpbmcuICovXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZGVjb2RlQml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmRlY29kZUN1bFNoaWZ0KDEpO1xuICAgICAgICB0aGlzLmRlY29kZVVwZGF0ZSgxLCB0bXAsIDE8PDEpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH07XG4gICAgLyogZGVjb2RlIGEgYnl0ZSB3L28gbW9kZWxsaW5nICovXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUuZGVjb2RlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5kZWNvZGVDdWxTaGlmdCg4KTtcbiAgICAgICAgdGhpcy5kZWNvZGVVcGRhdGUoMSwgdG1wLCAxPDw4KTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9O1xuICAgIC8qIGRlY29kZSBhIHNob3J0IHcvbyBtb2RlbGxpbmcgKi9cbiAgICBSYW5nZUNvZGVyLnByb3RvdHlwZS5kZWNvZGVTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5kZWNvZGVDdWxTaGlmdCgxNik7XG4gICAgICAgIHRoaXMuZGVjb2RlVXBkYXRlKDEsIHRtcCwgMTw8MTYpO1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgIH07XG5cbiAgICAvKiBGaW5pc2ggZGVjb2RpbmcgKi9cbiAgICBSYW5nZUNvZGVyLnByb3RvdHlwZS5kZWNvZGVGaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogbm9ybWFsaXplIHRvIHVzZSB1cCBhbGwgYnl0ZXMgKi9cbiAgICAgICAgZGVjX25vcm1hbGl6ZSh0aGlzLCB0aGlzLnN0cmVhbSk7XG4gICAgfTtcblxuICAgIC8qKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuXG4gICAgLy8gYml0c3RyZWFtIGludGVyZmFjZVxuICAgIFJhbmdlQ29kZXIucHJvdG90eXBlLndyaXRlQml0ID0gUmFuZ2VDb2Rlci5wcm90b3R5cGUuZW5jb2RlQml0O1xuICAgIFJhbmdlQ29kZXIucHJvdG90eXBlLnJlYWRCaXQgPSBSYW5nZUNvZGVyLnByb3RvdHlwZS5kZWNvZGVCaXQ7XG5cbiAgICAvLyBzdHJlYW0gaW50ZXJmYWNlXG4gICAgUmFuZ2VDb2Rlci5wcm90b3R5cGUud3JpdGVCeXRlID0gUmFuZ2VDb2Rlci5wcm90b3R5cGUuZW5jb2RlQnl0ZTtcbiAgICBSYW5nZUNvZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IFJhbmdlQ29kZXIucHJvdG90eXBlLmRlY29kZUJ5dGU7XG5cbiAgICByZXR1cm4gUmFuZ2VDb2Rlcjtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCIvKiAqVmVyeSogc2ltcGxlIGRlL2NvbXByZXNzaW9uIHV0aWxpdHksIGJhc2VkIG9uIHNpbXBsZV9jIGFuZCBzaW1wbGVfZCBmcm9tXG4gKiBybmdjb2QxMy56aXAgYXQgaHR0cDovL3d3dy5jb21wcmVzc2NvbnN1bHQuY29tL3JhbmdlY29kZXIvXG4gKiBSZWFsbHkganVzdCBhIGRlbW9uc3RyYXRpb24vdGVzdCBvZiB0aGUgcmFuZ2Vjb2Rlci5cbiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vUmFuZ2VDb2RlcicpLFxuXHRyZXF1aXJlKCcuL1N0cmVhbScpLFxuXHRyZXF1aXJlKCcuL1V0aWwnKVxuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKFJhbmdlQ29kZXIsU3RyZWFtLFV0aWwpe1xuICAgIHZhciBNQVhfQkxPQ0tfU0laRSA9IDE8PDE3O1xuXG4gICAgdmFyIFNpbXBsZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgU2ltcGxlLk1BR0lDID0gJ3NtcGwnO1xuICAgIFNpbXBsZS5jb21wcmVzc0ZpbGUgPSBVdGlsLmNvbXByZXNzRmlsZUhlbHBlcihTaW1wbGUuTUFHSUMsIGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIHNpemUsIHByb3BzLCBmaW5hbEJ5dGUpIHtcbiAgICAgICAgdmFyIGVuY29kZXIgPSBuZXcgUmFuZ2VDb2RlcihvdXRwdXQpO1xuICAgICAgICBlbmNvZGVyLmVuY29kZVN0YXJ0KGZpbmFsQnl0ZSwgMSk7XG5cbiAgICAgICAgLy8gcmVhZCBhIGJsb2NrXG4gICAgICAgIHZhciBibG9jayA9IFV0aWwubWFrZVU4QnVmZmVyKE1BWF9CTE9DS19TSVpFKTtcbiAgICAgICAgdmFyIGNvdW50cyA9IFtdO1xuICAgICAgICB2YXIgYmxvY2tMZW5ndGggPSAwLCBzYXdFT0YgPSBmYWxzZTtcblxuICAgICAgICB2YXIgcmVhZEJsb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgY291bnRzXG4gICAgICAgICAgICBmb3IgKHBvcz0wOyBwb3MgPCAyNTY7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgY291bnRzW3Bvc10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNhd0VPRikge1xuICAgICAgICAgICAgICAgIGJsb2NrTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHBvcz0wOyBwb3MgPCBNQVhfQkxPQ0tfU0laRTsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBpbnB1dC5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjPT09U3RyZWFtLkVPRikge1xuICAgICAgICAgICAgICAgICAgICBzYXdFT0YgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2tbcG9zKytdID0gYztcbiAgICAgICAgICAgICAgICBjb3VudHNbY10rKztcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGlmIHNvbWUgY291bnQgcmVhY2hlcyBtYXhpbXVtXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50c1tjXT09PTB4RkZGRikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja0xlbmd0aCA9IHBvcztcbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICByZWFkQmxvY2soKTtcbiAgICAgICAgICAgIGlmIChzYXdFT0YgJiYgYmxvY2tMZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmRpY2F0ZSB0aGF0IHRoZXJlJ3MgYW5vdGhlciBibG9jayBjb21pbidcbiAgICAgICAgICAgIGVuY29kZXIuZW5jb2RlQml0KHRydWUpO1xuICAgICAgICAgICAgLy8gd3JpdGUgYWxsIHRoZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTwyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGVuY29kZXIuZW5jb2RlU2hvcnQoY291bnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgY291bnRzIHRvIGN1bXVsYXRpdmUgY291bnRzXG4gICAgICAgICAgICBjb3VudHNbMjU2XSA9IGJsb2NrTGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpPTI1NjsgaTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY291bnRzW2ktMV0gPSBjb3VudHNbaV0gLSBjb3VudHNbaS0xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgc3ltYm9scyB1c2luZyB0aGUgcHJvYmFiaWxpdHkgdGFibGUuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxibG9ja0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gYmxvY2tbaV07XG4gICAgICAgICAgICAgICAgZW5jb2Rlci5lbmNvZGVGcmVxKGNvdW50c1tjaCsxXS1jb3VudHNbY2hdLCBjb3VudHNbY2hdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudHNbMjU2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd3JpdGUgYSBzdG9wIGJpdFxuICAgICAgICBlbmNvZGVyLmVuY29kZUJpdChmYWxzZSk7XG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIGVuY29kZXIuZW5jb2RlRmluaXNoKCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgU2ltcGxlLmRlY29tcHJlc3NGaWxlID0gVXRpbC5kZWNvbXByZXNzRmlsZUhlbHBlcihTaW1wbGUuTUFHSUMsIGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIHNpemUpIHtcbiAgICAgICAgdmFyIGRlY29kZXIgPSBuZXcgUmFuZ2VDb2RlcihpbnB1dCk7XG4gICAgICAgIGRlY29kZXIuZGVjb2RlU3RhcnQodHJ1ZS8qd2UgYWxyZWFkeSByZWFkIHRoZSAnZnJlZScgYnl0ZSovKTtcbiAgICAgICAgd2hpbGUgKGRlY29kZXIuZGVjb2RlQml0KCkpIHtcbiAgICAgICAgICAgIHZhciBpLCBjb3VudHMgPSBbXTtcbiAgICAgICAgICAgIC8vIHJlYWQgYWxsIHRoZSBzdGF0aXN0aWNzXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTwyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50c1tpXSA9IGRlY29kZXIuZGVjb2RlU2hvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgY3VtdWxhdGl2ZSBzdGF0cyAmIHRvdGFsIGJsb2NrIHNpemVcbiAgICAgICAgICAgIHZhciBibG9ja3NpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpPTA7IGk8MjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gY291bnRzW2ldO1xuICAgICAgICAgICAgICAgIGNvdW50c1tpXSA9IGJsb2Nrc2l6ZTtcbiAgICAgICAgICAgICAgICBibG9ja3NpemUgKz0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRzWzI1Nl0gPSBibG9ja3NpemU7XG5cbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNmID0gZGVjb2Rlci5kZWNvZGVDdWxGcmVxKGJsb2Nrc2l6ZSk7XG4gICAgICAgICAgICAgICAgLy8gaW5lZmZpY2llbnQgd2F5IHRvIGxvb2sgdXAgdGhlIHN5bWJvbC5cbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sO1xuICAgICAgICAgICAgICAgIGZvciAoc3ltYm9sPTA7IHN5bWJvbDwyNTY7IHN5bWJvbCsrKVxuICAgICAgICAgICAgICAgICAgICAvLyBjYXJlZnVsLCB0aGVyZSBhcmUgbGVuZ3RoLTAgcmFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIC8vICh3aGVyZSBjb3VudHNbc3ltYm9sXT09PWNvdW50c1tzeW1ib2wrMV0pXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudHNbc3ltYm9sXTw9Y2YgJiYgY2YgPCBjb3VudHNbc3ltYm9sKzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlVXBkYXRlKGNvdW50c1tzeW1ib2wrMV0gLSBjb3VudHNbc3ltYm9sXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudHNbc3ltYm9sXSwgYmxvY2tzaXplKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQud3JpdGVCeXRlKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2Rlci5kZWNvZGVGaW5pc2goKTtcbiAgICB9KTtcbiAgICByZXR1cm4gU2ltcGxlO1xufTtcbm1vZHVsZS5leHBvcnRzID0gYm9keV9mbi5hcHBseShudWxsLCBsaWJzKTtcbiIsIi8qKiBBYnN0cmFjdCBTdHJlYW0gaW50ZXJmYWNlLCBmb3IgYnl0ZS1vcmllbnRlZCBpL28uICovXG52YXIgbGlicyA9IFtcblx0cmVxdWlyZSgnLi9mcmVlemUnKVxuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKGZyZWV6ZSkge1xuICAgIHZhciBFT0YgPSAtMTtcblxuICAgIHZhciBTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyogQUJTVFJBQ1QgKi9cbiAgICB9O1xuICAgIC8vIHlvdSBtdXN0IGRlZmluZSBvbmUgb2YgcmVhZCAvIHJlYWRCeXRlIGZvciBhIHJlYWRhYmxlIHN0cmVhbVxuICAgIFN0cmVhbS5wcm90b3R5cGUucmVhZEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFsgMCBdO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5yZWFkKGJ1ZiwgMCwgMSk7XG4gICAgICAgIGlmIChsZW49PT0wKSB7IHRoaXMuX2VvZiA9IHRydWU7IHJldHVybiBFT0Y7IH1cbiAgICAgICAgcmV0dXJuIGJ1ZlswXTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGJ1ZiwgYnVmT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoLCBieXRlc1JlYWQgPSAwO1xuICAgICAgICB3aGlsZSAoYnl0ZXNSZWFkIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gRU9GKSB7IHRoaXMuX2VvZiA9IHRydWU7IGJyZWFrOyB9XG4gICAgICAgICAgICBidWZbYnVmT2Zmc2V0KyhieXRlc1JlYWQrKyldID0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICB9O1xuICAgIC8vIHJlYXNvbmFibGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiAnZW9mJ1xuICAgIFN0cmVhbS5wcm90b3R5cGUuZW9mID0gZnVuY3Rpb24oKSB7IHJldHVybiAhIXRoaXMuX2VvZjsgfTtcbiAgICAvLyBub3QgYWxsIHJlYWRhYmxlIHN0cmVhbXMgYXJlIHNlZWthYmxlXG4gICAgU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyZWFtIGlzIG5vdCBzZWVrYWJsZS4nKTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUudGVsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBpcyBub3Qgc2Vla2FibGUuJyk7XG4gICAgfTtcbiAgICAvLyB5b3UgbXVzdCBkZWZpbmUgb25lIG9mIHdyaXRlIC8gd3JpdGVCeXRlIGZvciBhIHdyaXRhYmxlIHN0cmVhbVxuICAgIFN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24oX2J5dGUpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFsgX2J5dGUgXTtcbiAgICAgICAgdGhpcy53cml0ZShidWYsIDAsIDEpO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZiwgYnVmT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnl0ZShidWZbYnVmT2Zmc2V0ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfTtcbiAgICAvLyBmbHVzaCB3aWxsIGhhcHBpbHkgZG8gbm90aGluZyBpZiB5b3UgZG9uJ3Qgb3ZlcnJpZGUgaXQuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4gICAgLy8gZXhwb3J0IEVPRiBhcyBhIGNvbnN0YW50LlxuICAgIFN0cmVhbS5FT0YgPSBFT0Y7XG5cbiAgICByZXR1cm4gZnJlZXplKFN0cmVhbSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBib2R5X2ZuLmFwcGx5KG51bGwsIGxpYnMpO1xuIiwiLyogU29tZSBiYXNpYyB1dGlsaXRpZXMsIHVzZWQgaW4gYSBudW1iZXIgb2YgcGxhY2VzLiAqL1xudmFyIGxpYnMgPSBbXG5cdHJlcXVpcmUoJy4vZnJlZXplJyksXG5cdHJlcXVpcmUoJy4vU3RyZWFtJylcbl07XG52YXIgYm9keV9mbiA9IGZ1bmN0aW9uIChmcmVlemUsIFN0cmVhbSkge1xuICAgIHZhciBVdGlsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciBFT0YgPSBTdHJlYW0uRU9GO1xuXG4gICAgLyogVGFrZSBhIGJ1ZmZlciwgYXJyYXksIG9yIHN0cmVhbSwgYW5kIHJldHVybiBhbiBpbnB1dCBzdHJlYW0uICovXG4gICAgVXRpbC5jb2VyY2VJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKGlucHV0LCBmb3JjZVJlYWQpIHtcbiAgICAgICAgaWYgKCEoJ3JlYWRCeXRlJyBpbiBpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBpbnB1dDtcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmVhbSgpO1xuICAgICAgICAgICAgaW5wdXQuc2l6ZSA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpbnB1dC5wb3MgPSAwO1xuICAgICAgICAgICAgaW5wdXQucmVhZEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5zaXplKSB7IHJldHVybiBFT0Y7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyW3RoaXMucG9zKytdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlucHV0LnJlYWQgPSBmdW5jdGlvbihidWYsIGJ1Zk9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJ5dGVzUmVhZCA8IGxlbmd0aCAmJiB0aGlzLnBvcyA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J1Zk9mZnNldCsrXSA9IGJ1ZmZlclt0aGlzLnBvcysrXTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5wdXQuc2VlayA9IGZ1bmN0aW9uKHBvcykgeyB0aGlzLnBvcyA9IHBvczsgfTtcbiAgICAgICAgICAgIGlucHV0LnRlbGwgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucG9zOyB9O1xuICAgICAgICAgICAgaW5wdXQuZW9mID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvcyA+PSBidWZmZXIubGVuZ3RoOyB9O1xuICAgICAgICB9IGVsc2UgaWYgKGZvcmNlUmVhZCAmJiAhKCdyZWFkJyBpbiBpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgaW5wdXQgaWYgaXQgZG9lc24ndCBpbXBsZW1lbnQgcmVhZFxuICAgICAgICAgICAgdmFyIHMgPSBpbnB1dDtcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmVhbSgpO1xuICAgICAgICAgICAgaW5wdXQucmVhZEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBzLnJlYWRCeXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSBFT0YpIHsgdGhpcy5fZW9mID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoJ3NpemUnIGluIHMpIHsgaW5wdXQuc2l6ZSA9IHMuc2l6ZTsgfVxuICAgICAgICAgICAgaWYgKCdzZWVrJyBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2VlayA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgICAgICAgICBzLnNlZWsocG9zKTsgLy8gbWF5IHRocm93IGlmIHMgZG9lc24ndCBpbXBsZW1lbnQgc2Vla1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lb2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd0ZWxsJyBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQudGVsbCA9IHMudGVsbC5iaW5kKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuXG4gICAgdmFyIEJ1ZmZlclN0cmVhbSA9IGZ1bmN0aW9uKGJ1ZmZlciwgcmVzaXplT2spIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMucmVzaXplT2sgPSByZXNpemVPaztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH07XG4gICAgQnVmZmVyU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyZWFtLnByb3RvdHlwZSk7XG4gICAgQnVmZmVyU3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGUgPSBmdW5jdGlvbihfYnl0ZSkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPayAmJiB0aGlzLnBvcyA+PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXdCdWZmZXIgPSBVdGlsLm1ha2VVOEJ1ZmZlcih0aGlzLmJ1ZmZlci5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPSBfYnl0ZTtcbiAgICB9O1xuICAgIEJ1ZmZlclN0cmVhbS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRyaW0gYnVmZmVyIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5wb3MgIT09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZU9rKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ291dHB1dHNpemUgZG9lcyBub3QgbWF0Y2ggZGVjb2RlZCBpbnB1dCcpO1xuICAgICAgICAgICAgdmFyIG5ld0J1ZmZlciA9IFV0aWwubWFrZVU4QnVmZmVyKHRoaXMucG9zKTtcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICB9O1xuXG4gICAgLyogVGFrZSBhIHN0cmVhbSAob3Igbm90KSBhbmQgYW4gKG9wdGlvbmFsKSBzaXplLCBhbmQgcmV0dXJuIGFuXG4gICAgICogb3V0cHV0IHN0cmVhbS4gIFJldHVybiBhbiBvYmplY3Qgd2l0aCBhICdyZXR2YWwnIGZpZWxkIGVxdWFsIHRvXG4gICAgICogdGhlIG91dHB1dCBzdHJlYW0gKGlmIHRoYXQgd2FzIGdpdmVuKSBvciBlbHNlIGEgcG9pbnRlciBhdCB0aGVcbiAgICAgKiBpbnRlcm5hbCBVaW50OEFycmF5L2J1ZmZlci9hcnJheTsgYW5kIGEgJ3N0cmVhbScgZmllbGQgZXF1YWwgdG9cbiAgICAgKiBhbiBvdXRwdXQgc3RyZWFtIHRvIHVzZS5cbiAgICAgKi9cbiAgICBVdGlsLmNvZXJjZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKG91dHB1dCwgc2l6ZSkge1xuICAgICAgICB2YXIgciA9IHsgc3RyZWFtOiBvdXRwdXQsIHJldHZhbDogb3V0cHV0IH07XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yob3V0cHV0KT09PSdvYmplY3QnICYmICd3cml0ZUJ5dGUnIGluIG91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByOyAvKiBsZWF2ZSBvdXRwdXQgYWxvbmUgKi9cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHNpemUpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNpemUgPj0gMCk7XG4gICAgICAgICAgICAgICAgci5zdHJlYW0gPSBuZXcgQnVmZmVyU3RyZWFtKFV0aWwubWFrZVU4QnVmZmVyKHNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBvdXRwdXQgaXMgYSBidWZmZXJcbiAgICAgICAgICAgICAgICByLnN0cmVhbSA9IG5ldyBCdWZmZXJTdHJlYW0ob3V0cHV0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLnN0cmVhbSA9IG5ldyBCdWZmZXJTdHJlYW0oVXRpbC5tYWtlVThCdWZmZXIoMTYzODQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgJ3JldHZhbCcsIHtcbiAgICAgICAgICAgIGdldDogci5zdHJlYW0uZ2V0QnVmZmVyLmJpbmQoci5zdHJlYW0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgVXRpbC5jb21wcmVzc0ZpbGVIZWxwZXIgPSBmdW5jdGlvbihtYWdpYywgZ3V0cywgc3VwcHJlc3NGaW5hbEJ5dGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGluU3RyZWFtLCBvdXRTdHJlYW0sIHByb3BzKSB7XG4gICAgICAgICAgICBpblN0cmVhbSA9IFV0aWwuY29lcmNlSW5wdXRTdHJlYW0oaW5TdHJlYW0pO1xuICAgICAgICAgICAgdmFyIG8gPSBVdGlsLmNvZXJjZU91dHB1dFN0cmVhbShvdXRTdHJlYW0sIG91dFN0cmVhbSk7XG4gICAgICAgICAgICBvdXRTdHJlYW0gPSBvLnN0cmVhbTtcblxuICAgICAgICAgICAgLy8gd3JpdGUgdGhlIG1hZ2ljIG51bWJlciB0byBpZGVudGlmeSB0aGlzIGZpbGUgdHlwZVxuICAgICAgICAgICAgLy8gKGl0IGJldHRlciBiZSBBU0NJSSwgd2UncmUgbm90IGRvaW5nIHV0Zi04IGNvbnZlcnNpb24pXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPG1hZ2ljLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0U3RyZWFtLndyaXRlQnl0ZShtYWdpYy5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2Uga25vdyB0aGUgc2l6ZSwgd3JpdGUgaXRcbiAgICAgICAgICAgIHZhciBmaWxlU2l6ZTtcbiAgICAgICAgICAgIGlmICgnc2l6ZScgaW4gaW5TdHJlYW0gJiYgaW5TdHJlYW0uc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZmlsZVNpemUgPSBpblN0cmVhbS5zaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlU2l6ZSA9IC0xOyAvLyBzaXplIHVua25vd25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXBwcmVzc0ZpbmFsQnl0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXBPdXRwdXQgPSBVdGlsLmNvZXJjZU91dHB1dFN0cmVhbShbXSk7XG4gICAgICAgICAgICAgICAgVXRpbC53cml0ZVVuc2lnbmVkTnVtYmVyKHRtcE91dHB1dC5zdHJlYW0sIGZpbGVTaXplICsgMSk7XG4gICAgICAgICAgICAgICAgdG1wT3V0cHV0ID0gdG1wT3V0cHV0LnJldHZhbDtcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx0bXBPdXRwdXQubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRTdHJlYW0ud3JpdGVCeXRlKHRtcE91dHB1dFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1cHByZXNzRmluYWxCeXRlID0gdG1wT3V0cHV0W3RtcE91dHB1dC5sZW5ndGgtMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFV0aWwud3JpdGVVbnNpZ25lZE51bWJlcihvdXRTdHJlYW0sIGZpbGVTaXplICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGd1dHMgdG8gZG8gdGhlIHJlYWwgY29tcHJlc3Npb25cbiAgICAgICAgICAgIGd1dHMoaW5TdHJlYW0sIG91dFN0cmVhbSwgZmlsZVNpemUsIHByb3BzLCBzdXBwcmVzc0ZpbmFsQnl0ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBvLnJldHZhbDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFV0aWwuZGVjb21wcmVzc0ZpbGVIZWxwZXIgPSBmdW5jdGlvbihtYWdpYywgZ3V0cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSkge1xuICAgICAgICAgICAgaW5TdHJlYW0gPSBVdGlsLmNvZXJjZUlucHV0U3RyZWFtKGluU3RyZWFtKTtcblxuICAgICAgICAgICAgLy8gcmVhZCB0aGUgbWFnaWMgbnVtYmVyIHRvIGNvbmZpcm0gdGhpcyBmaWxlIHR5cGVcbiAgICAgICAgICAgIC8vIChpdCBiZXR0ZXIgYmUgQVNDSUksIHdlJ3JlIG5vdCBkb2luZyB1dGYtOCBjb252ZXJzaW9uKVxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxtYWdpYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYWdpYy5jaGFyQ29kZUF0KGkpICE9PSBpblN0cmVhbS5yZWFkQnl0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBtYWdpY1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlYWQgdGhlIGZpbGUgc2l6ZSAmIGNyZWF0ZSBhbiBhcHByb3ByaWF0ZSBvdXRwdXQgc3RyZWFtL2J1ZmZlclxuICAgICAgICAgICAgdmFyIGZpbGVTaXplID0gVXRpbC5yZWFkVW5zaWduZWROdW1iZXIoaW5TdHJlYW0pIC0gMTtcbiAgICAgICAgICAgIHZhciBvID0gVXRpbC5jb2VyY2VPdXRwdXRTdHJlYW0ob3V0U3RyZWFtLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgICBvdXRTdHJlYW0gPSBvLnN0cmVhbTtcblxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgZ3V0cyB0byBkbyB0aGUgcmVhbCBkZWNvbXByZXNzaW9uXG4gICAgICAgICAgICBndXRzKGluU3RyZWFtLCBvdXRTdHJlYW0sIGZpbGVTaXplKTtcblxuICAgICAgICAgICAgcmV0dXJuIG8ucmV0dmFsO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gYSBoZWxwZXIgZm9yIHNpbXBsZSBzZWxmLXRlc3Qgb2YgbW9kZWwgZW5jb2RlXG4gICAgVXRpbC5jb21wcmVzc1dpdGhNb2RlbCA9IGZ1bmN0aW9uKGluU3RyZWFtLCBmaWxlU2l6ZSwgbW9kZWwpIHtcbiAgICAgICAgdmFyIGluU2l6ZSA9IDA7XG4gICAgICAgIHdoaWxlIChpblNpemUgIT09IGZpbGVTaXplKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBpblN0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSBFT0YpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5lbmNvZGUoMjU2KTsgLy8gZW5kIG9mIHN0cmVhbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsLmVuY29kZShjaCk7XG4gICAgICAgICAgICBpblNpemUrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gYSBoZWxwZXIgZm9yIHNpbXBsZSBzZWxmLXRlc3Qgb2YgbW9kZWwgZGVjb2RlXG4gICAgVXRpbC5kZWNvbXByZXNzV2l0aE1vZGVsID0gZnVuY3Rpb24ob3V0U3RyZWFtLCBmaWxlU2l6ZSwgbW9kZWwpIHtcbiAgICAgICAgdmFyIG91dFNpemUgPSAwO1xuICAgICAgICB3aGlsZSAob3V0U2l6ZSAhPT0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IG1vZGVsLmRlY29kZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZW5kIG9mIHN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dFN0cmVhbS53cml0ZUJ5dGUoY2gpO1xuICAgICAgICAgICAgb3V0U2l6ZSsrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBXcml0ZSBhIG51bWJlciB1c2luZyBhIHNlbGYtZGVsaW1pdGluZyBiaWctZW5kaWFuIGVuY29kaW5nLiAqL1xuICAgIFV0aWwud3JpdGVVbnNpZ25lZE51bWJlciA9IGZ1bmN0aW9uKG91dHB1dCwgbikge1xuICAgICAgICBjb25zb2xlLmFzc2VydChuID49IDApO1xuICAgICAgICB2YXIgYnl0ZXMgPSBbXSwgaTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChuICYgMHg3Rik7XG4gICAgICAgICAgICAvLyB1c2UgZGl2aXNpb24gaW5zdGVhZCBvZiBzaGlmdCB0byBhbGxvdyBlbmNvZGluZyBudW1iZXJzIHVwIHRvXG4gICAgICAgICAgICAvLyAyXjUzXG4gICAgICAgICAgICBuID0gTWF0aC5mbG9vciggbiAvIDEyOCApO1xuICAgICAgICB9IHdoaWxlIChuICE9PSAwKTtcbiAgICAgICAgYnl0ZXNbMF0gfD0gMHg4MDsgLy8gbWFyayBlbmQgb2YgZW5jb2RpbmcuXG4gICAgICAgIGZvciAoaT1ieXRlcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBvdXRwdXQud3JpdGVCeXRlKGJ5dGVzW2ldKTsgLy8gd3JpdGUgaW4gYmlnLWVuZGlhbiBvcmRlclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKiBSZWFkIGEgbnVtYmVyIHVzaW5nIGEgc2VsZi1kZWxpbWl0aW5nIGJpZy1lbmRpYW4gZW5jb2RpbmcuICovXG4gICAgVXRpbC5yZWFkVW5zaWduZWROdW1iZXIgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgbiA9IDAsIGM7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjID0gaW5wdXQucmVhZEJ5dGUoKTtcbiAgICAgICAgICAgIGlmIChjJjB4ODApIHsgbiArPSAoYyYweDdGKTsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vIHVzaW5nICsgYW5kICogaW5zdGVhZCBvZiA8PCBhbGxvd3MgZGVjb2RpbmcgbnVtYmVycyB1cCB0byAyXjUzXG4gICAgICAgICAgICBuID0gKG4gKyBjKSAqIDEyODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9O1xuXG4gICAgLy8gQ29tcGF0aWJpbGl0eSB0aHVua3MgZm9yIEJ1ZmZlci9UeXBlZEFycmF5IGNvbnN0cnVjdG9ycy5cblxuICAgIHZhciB6ZXJvZmlsbCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICB2YXIgZmFsbGJhY2thcnJheSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHplcm9maWxsKG5ldyBBcnJheShzaXplKSk7XG4gICAgfTtcblxuICAgIC8vIE5vZGUgMC4xMS42IC0gMC4xMS4xMGlzaCBkb24ndCBwcm9wZXJseSB6ZXJvIGZpbGwgdHlwZWQgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzY2NjRcbiAgICAvLyBUcnkgdG8gZGV0ZWN0IGFuZCB3b3JrYXJvdW5kIHRoZSBidWcuXG4gICAgdmFyIGVuc3VyZVplcm9lZCA9IGZ1bmN0aW9uIGlkKGEpIHsgcmV0dXJuIGE7IH07XG4gICAgaWYgKCh0eXBlb2YocHJvY2VzcykgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKG5ldyBVaW50MzJBcnJheSgxMjgpLCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4geCAhPT0gMDtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgLy9jb25zb2xlLndhcm4oJ1dvcmtpbmcgYXJvdW5kIGJyb2tlbiBUeXBlZEFycmF5Jyk7XG4gICAgICAgIGVuc3VyZVplcm9lZCA9IHplcm9maWxsO1xuICAgIH1cblxuICAgIC8qKiBQb3J0YWJsZSA4LWJpdCB1bnNpZ25lZCBidWZmZXIuICovXG4gICAgVXRpbC5tYWtlVThCdWZmZXIgPSAodHlwZW9mKFVpbnQ4QXJyYXkpICE9PSAndW5kZWZpbmVkJykgPyBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkgb3VnaHQgdG8gYmUgIGF1dG9tYXRpY2FsbHkgemVyby1maWxsZWRcbiAgICAgICAgcmV0dXJuIGVuc3VyZVplcm9lZChuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgfSA6ICh0eXBlb2YoQnVmZmVyKSAhPT0gJ3VuZGVmaW5lZCcpID8gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgYiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIGIuZmlsbCgwKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfSA6IGZhbGxiYWNrYXJyYXk7XG5cbiAgICAvKiogUG9ydGFibGUgMTYtYml0IHVuc2lnbmVkIGJ1ZmZlci4gKi9cbiAgICBVdGlsLm1ha2VVMTZCdWZmZXIgPSAodHlwZW9mKFVpbnQxNkFycmF5KSAhPT0gJ3VuZGVmaW5lZCcpID8gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAvLyBVaW50MTZBcnJheSBvdWdodCB0byBiZSAgYXV0b21hdGljYWxseSB6ZXJvLWZpbGxlZFxuICAgICAgICByZXR1cm4gZW5zdXJlWmVyb2VkKG5ldyBVaW50MTZBcnJheShzaXplKSk7XG4gICAgfSA6IGZhbGxiYWNrYXJyYXk7XG5cbiAgICAvKiogUG9ydGFibGUgMzItYml0IHVuc2lnbmVkIGJ1ZmZlci4gKi9cbiAgICBVdGlsLm1ha2VVMzJCdWZmZXIgPSAodHlwZW9mKFVpbnQzMkFycmF5KSAhPT0gJ3VuZGVmaW5lZCcpID8gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAvLyBVaW50MzJBcnJheSBvdWdodCB0byBiZSAgYXV0b21hdGljYWxseSB6ZXJvLWZpbGxlZFxuICAgICAgICByZXR1cm4gZW5zdXJlWmVyb2VkKG5ldyBVaW50MzJBcnJheShzaXplKSk7XG4gICAgfSA6IGZhbGxiYWNrYXJyYXk7XG5cbiAgICAvKiogUG9ydGFibGUgMzItYml0IHNpZ25lZCBidWZmZXIuICovXG4gICAgVXRpbC5tYWtlUzMyQnVmZmVyID0gKHR5cGVvZihJbnQzMkFycmF5KSAhPT0gJ3VuZGVmaW5lZCcpID8gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAvLyBJbnQzMkFycmF5IG91Z2h0IHRvIGJlICBhdXRvbWF0aWNhbGx5IHplcm8tZmlsbGVkXG4gICAgICAgIHJldHVybiBlbnN1cmVaZXJvZWQobmV3IEludDMyQXJyYXkoc2l6ZSkpO1xuICAgIH0gOiBmYWxsYmFja2FycmF5O1xuXG4gICAgVXRpbC5hcnJheWNvcHkgPSBmdW5jdGlvbihkc3QsIHNyYykge1xuICAgICAgICBjb25zb2xlLmFzc2VydChkc3QubGVuZ3RoID49IHNyYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfTtcblxuICAgIC8qKiBIaWdoZXN0IGJpdCBzZXQgaW4gYSBieXRlLiAqL1xuICAgIHZhciBieXRlbXNiID0gW1xuICAgICAgICAwLCAxLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgICAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LFxuICAgICAgICA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA2LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LFxuICAgICAgICA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LFxuICAgICAgICA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LFxuICAgICAgICA3LCA3LCA3LCA3LCA3LCA3LCA3LCA3LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LFxuICAgICAgICA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LFxuICAgICAgICA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LFxuICAgICAgICA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LFxuICAgICAgICA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LFxuICAgICAgICA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4LCA4IC8qIDI1NiAqL1xuICAgIF07XG4gICAgY29uc29sZS5hc3NlcnQoYnl0ZW1zYi5sZW5ndGg9PT0weDEwMCk7XG4gICAgLyoqIEZpbmQgbGFzdCBzZXQgKG1vc3Qgc2lnbmlmaWNhbnQgYml0KS5cbiAgICAgKiAgQHJldHVybiB0aGUgbGFzdCBiaXQgc2V0IGluIHRoZSBhcmd1bWVudC5cbiAgICAgKiAgICAgICAgICA8Y29kZT5mbHMoMCk9PTA8L2NvZGU+IGFuZCA8Y29kZT5mbHMoMSk9PTE8L2NvZGU+LiAqL1xuICAgIHZhciBmbHMgPSBVdGlsLmZscyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodj49MCk7XG4gICAgICAgIGlmICh2ID4gMHhGRkZGRkZGRikgeyAvLyB1c2UgZmxvYXRpbmctcG9pbnQgbW9qb1xuICAgICAgICAgICAgcmV0dXJuIDMyICsgZmxzKE1hdGguZmxvb3IodiAvIDB4MTAwMDAwMDAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAodiAmIDB4RkZGRjAwMDApICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoICh2ICYgMHhGRjAwMDAwMCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjQgKyBieXRlbXNiWyh2Pj4+MjQpICYgMHhGRl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxNiArIGJ5dGVtc2Jbdj4+PjE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggKHYgJiAweDAwMDBGRjAwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDggKyBieXRlbXNiW3Y+Pj44XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlbXNiW3ZdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBjZWlsKGxvZzIobikpICovXG4gICAgVXRpbC5sb2cyYyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuICh2PT09MCk/LTE6ZmxzKHYtMSk7XG4gICAgfTtcblxuICAgIHJldHVybiBmcmVlemUoVXRpbCk7IC8vIGVuc3VyZSBjb25zdGFudHMgYXJlIHJlY29nbml6ZWQgYXMgc3VjaC5cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJvZHlfZm4uYXBwbHkobnVsbCwgbGlicyk7XG4iLCJcbnZhciBsaWJzID0gW1xuXTtcbnZhciBib2R5X2ZuID0gZnVuY3Rpb24gKCl7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBPYmplY3QuZnJlZXplKCksIG9yIGEgdGh1bmsgaWYgdGhhdCBtZXRob2QgaXMgbm90IHByZXNlbnQgaW4gdGhpc1xuICAvLyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuXG4gIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG87IH07XG4gIH1cblxufTtcbm1vZHVsZS5leHBvcnRzID0gYm9keV9mbi5hcHBseShudWxsLCBsaWJzKTtcbiIsIu+7vy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogbGlucS5qcyAtIExJTlEgZm9yIEphdmFTY3JpcHRcclxuICogbGljZW5zZWQgdW5kZXIgTUlUIExpY2Vuc2VcclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuKGZ1bmN0aW9uIChyb290LCB1bmRlZmluZWQpIHtcclxuICAgIC8vIFJlYWRPbmx5IEZ1bmN0aW9uXHJcbiAgICB2YXIgRnVuY3Rpb25zID0ge1xyXG4gICAgICAgIElkZW50aXR5OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSxcclxuICAgICAgICBUcnVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxyXG4gICAgICAgIEJsYW5rOiBmdW5jdGlvbiAoKSB7IH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gY29uc3QgVHlwZVxyXG4gICAgdmFyIFR5cGVzID0ge1xyXG4gICAgICAgIEJvb2xlYW46IHR5cGVvZiB0cnVlLFxyXG4gICAgICAgIE51bWJlcjogdHlwZW9mIDAsXHJcbiAgICAgICAgU3RyaW5nOiB0eXBlb2YgXCJcIixcclxuICAgICAgICBPYmplY3Q6IHR5cGVvZiB7fSxcclxuICAgICAgICBVbmRlZmluZWQ6IHR5cGVvZiB1bmRlZmluZWQsXHJcbiAgICAgICAgRnVuY3Rpb246IHR5cGVvZiBmdW5jdGlvbiAoKSB7IH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gY3JlYXRlTGFtYmRhIGNhY2hlXHJcbiAgICB2YXIgZnVuY0NhY2hlID0geyBcIlwiOiBGdW5jdGlvbnMuSWRlbnRpdHkgfTtcclxuXHJcbiAgICAvLyBwcml2YXRlIHV0aWxpdHkgbWV0aG9kc1xyXG4gICAgdmFyIFV0aWxzID0ge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhbm9ueW1vdXMgZnVuY3Rpb24gZnJvbSBsYW1iZGEgZXhwcmVzc2lvbiBzdHJpbmdcclxuICAgICAgICBjcmVhdGVMYW1iZGE6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09IG51bGwpIHJldHVybiBGdW5jdGlvbnMuSWRlbnRpdHk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gVHlwZXMuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgZnJvbSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jQ2FjaGVbZXhwcmVzc2lvbl07XHJcbiAgICAgICAgICAgICAgICBpZiAoZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaW5kZXhPZihcIj0+XCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiWyRdK1wiLCBcImdcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXhwLmV4ZWMoZXhwcmVzc2lvbikpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtTnVtYmVyID0gbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1OdW1iZXIgPiBtYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heExlbmd0aCA9IHBhcmFtTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBtYXhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9sbGFyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbGxhciArPSBcIiRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdBcnJheS5wdXNoKGRvbGxhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJnQXJyYXksIFwiLFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IG5ldyBGdW5jdGlvbihhcmdzLCBcInJldHVybiBcIiArIGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNDYWNoZVtleHByZXNzaW9uXSA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwciA9IGV4cHJlc3Npb24ubWF0Y2goL15bKFxcc10qKFteKCldKj8pWylcXHNdKj0+KC4qKS8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBuZXcgRnVuY3Rpb24oZXhwclsxXSwgXCJyZXR1cm4gXCIgKyBleHByWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jQ2FjaGVbZXhwcmVzc2lvbl0gPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzSUVudW1lcmFibGU6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFbnVtZXJhdG9yICE9PSBUeXBlcy5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVudW1lcmF0b3Iob2JqKTsgLy8gY2hlY2sgSlNjcmlwdChJRSkncyBFbnVtZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBJRTgncyBkZWZpbmVQcm9wZXJ0eSBpcyBkZWZpbmVkIGJ1dCBjYW5ub3QgdXNlLCB0aGVyZWZvcmUgY2hlY2sgZGVmaW5lUHJvcGVydGllc1xyXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiAoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgIT0gbnVsbClcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAodGFyZ2V0LCBtZXRob2ROYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbWV0aG9kTmFtZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAodGFyZ2V0LCBtZXRob2ROYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSA9PT0gYikgPyAwXHJcbiAgICAgICAgICAgICAgICAgOiAoYSA+IGIpID8gMVxyXG4gICAgICAgICAgICAgICAgIDogLTE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqICE9IG51bGwpIG9iai5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJRW51bWVyYXRvciBTdGF0ZVxyXG4gICAgdmFyIFN0YXRlID0geyBCZWZvcmU6IDAsIFJ1bm5pbmc6IDEsIEFmdGVyOiAyIH07XHJcblxyXG4gICAgLy8gXCJFbnVtZXJhdG9yXCIgaXMgY29uZmxpY3QgSlNjcmlwdCdzIFwiRW51bWVyYXRvclwiXHJcbiAgICB2YXIgSUVudW1lcmF0b3IgPSBmdW5jdGlvbiAoaW5pdGlhbGl6ZSwgdHJ5R2V0TmV4dCwgZGlzcG9zZSkge1xyXG4gICAgICAgIHZhciB5aWVsZGVyID0gbmV3IFlpZWxkZXIoKTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBTdGF0ZS5CZWZvcmU7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHlpZWxkZXIuY3VycmVudDtcclxuXHJcbiAgICAgICAgdGhpcy5tb3ZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkJlZm9yZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTdGF0ZS5SdW5uaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuUnVubmluZzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUdldE5leHQuYXBwbHkoeWllbGRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLkFmdGVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9IFN0YXRlLlJ1bm5pbmcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFN0YXRlLkFmdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZm9yIHRyeUdldE5leHRcclxuICAgIHZhciBZaWVsZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50OyB9O1xyXG4gICAgICAgIHRoaXMueWllbGRSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMueWllbGRCcmVhayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVudW1lcmFibGUgY29uc3R1Y3RvclxyXG4gICAgdmFyIEVudW1lcmFibGUgPSBmdW5jdGlvbiAoZ2V0RW51bWVyYXRvcikge1xyXG4gICAgICAgIHRoaXMuZ2V0RW51bWVyYXRvciA9IGdldEVudW1lcmF0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFV0aWxpdHlcclxuXHJcbiAgICBFbnVtZXJhYmxlLlV0aWxzID0ge307IC8vIGNvbnRhaW5lclxyXG5cclxuICAgIEVudW1lcmFibGUuVXRpbHMuY3JlYXRlTGFtYmRhID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcclxuICAgICAgICByZXR1cm4gVXRpbHMuY3JlYXRlTGFtYmRhKGV4cHJlc3Npb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLlV0aWxzLmNyZWF0ZUVudW1lcmFibGUgPSBmdW5jdGlvbiAoZ2V0RW51bWVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShnZXRFbnVtZXJhdG9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5VdGlscy5jcmVhdGVFbnVtZXJhdG9yID0gZnVuY3Rpb24gKGluaXRpYWxpemUsIHRyeUdldE5leHQsIGRpc3Bvc2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKGluaXRpYWxpemUsIHRyeUdldE5leHQsIGRpc3Bvc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLlV0aWxzLmV4dGVuZFRvID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgdHlwZVByb3RvID0gdHlwZS5wcm90b3R5cGU7XHJcbiAgICAgICAgdmFyIGVudW1lcmFibGVQcm90bztcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEFycmF5KSB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGVQcm90byA9IEFycmF5RW51bWVyYWJsZS5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIFV0aWxzLmRlZmluZVByb3BlcnR5KHR5cGVQcm90bywgXCJnZXRTb3VyY2VcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZVByb3RvID0gRW51bWVyYWJsZS5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIFV0aWxzLmRlZmluZVByb3BlcnR5KHR5cGVQcm90bywgXCJnZXRFbnVtZXJhdG9yXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFbnVtZXJhYmxlLmZyb20odGhpcykuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gZW51bWVyYWJsZVByb3RvKSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gZW51bWVyYWJsZVByb3RvW21ldGhvZE5hbWVdO1xyXG5cclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBleHRlbmRlZFxyXG4gICAgICAgICAgICBpZiAodHlwZVByb3RvW21ldGhvZE5hbWVdID09IGZ1bmMpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gYWxyZWFkeSBkZWZpbmVkKGV4YW1wbGUgQXJyYXkjcmV2ZXJzZS9qb2luL2ZvckVhY2guLi4pXHJcbiAgICAgICAgICAgIGlmICh0eXBlUHJvdG9bbWV0aG9kTmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWUgKyBcIkJ5TGlucVwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVQcm90b1ttZXRob2ROYW1lXSA9PSBmdW5jKSBjb250aW51ZTsgLy8gcmVjaGVja1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5kZWZpbmVQcm9wZXJ0eSh0eXBlUHJvdG8sIG1ldGhvZE5hbWUsIGZ1bmMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0b3JcclxuXHJcbiAgICBFbnVtZXJhYmxlLmNob2ljZSA9IGZ1bmN0aW9uICgpIC8vIHZhcmlhYmxlIGFyZ3VtZW50XHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IChhcmdzWzBdIGluc3RhbmNlb2YgQXJyYXkpID8gYXJnc1swXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChhcmdzWzBdLmdldEVudW1lcmF0b3IgIT0gbnVsbCkgPyBhcmdzWzBdLnRvQXJyYXkoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGFyZ3NbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJncy5sZW5ndGgpXSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5jeWNsZSA9IGZ1bmN0aW9uICgpIC8vIHZhcmlhYmxlIGFyZ3VtZW50XHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IChhcmdzWzBdIGluc3RhbmNlb2YgQXJyYXkpID8gYXJnc1swXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChhcmdzWzBdLmdldEVudW1lcmF0b3IgIT0gbnVsbCkgPyBhcmdzWzBdLnRvQXJyYXkoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBhcmdzLmxlbmd0aCkgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGFyZ3NbaW5kZXgrK10pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5mcm9tID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRW51bWVyYWJsZS5lbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRW51bWVyYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSBUeXBlcy5OdW1iZXIgfHwgdHlwZW9mIG9iaiA9PSBUeXBlcy5Cb29sZWFuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbnVtZXJhYmxlLnJlcGVhdChvYmosIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSBUeXBlcy5TdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCBvYmoubGVuZ3RoKSA/IHRoaXMueWllbGRSZXR1cm4ob2JqLmNoYXJBdChpbmRleCsrKSkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPSBUeXBlcy5GdW5jdGlvbikge1xyXG4gICAgICAgICAgICAvLyBhcnJheSBvciBhcnJheSBsaWtlIG9iamVjdFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggPT0gVHlwZXMuTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5RW51bWVyYWJsZShvYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBKU2NyaXB0J3MgSUVudW1lcmFibGVcclxuICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgT2JqZWN0KSAmJiBVdGlscy5pc0lFbnVtZXJhYmxlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IG5ldyBFbnVtZXJhdG9yKG9iaik7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSBpc0ZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGVudW1lcmF0b3IubW92ZU5leHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IuYXRFbmQoKSkgPyBmYWxzZSA6IHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5pdGVtKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmspO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdpbk1EIElJdGVyYWJsZTxUPlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFdpbmRvd3MgPT09IFR5cGVzLk9iamVjdCAmJiB0eXBlb2Ygb2JqLmZpcnN0ID09PSBUeXBlcy5GdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNGaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBlbnVtZXJhdG9yID0gb2JqLmZpcnN0KCk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSBpc0ZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGVudW1lcmF0b3IubW92ZU5leHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IuaGFzQ3VycmVudCkgPyB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCkgOiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjYXNlIGZ1bmN0aW9uL29iamVjdCA6IENyZWF0ZSBrZXlWYWx1ZVBhaXJbXVxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IGFycmF5Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKGFycmF5W2luZGV4KytdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIEVudW1lcmFibGUubWFrZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIEVudW1lcmFibGUucmVwZWF0KGVsZW1lbnQsIDEpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihpbnB1dCwgcGF0dGVybilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGlucHV0LCBwYXR0ZXJuLCBmbGFncylcclxuICAgIEVudW1lcmFibGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChpbnB1dCwgcGF0dGVybiwgZmxhZ3MpIHtcclxuICAgICAgICBpZiAoZmxhZ3MgPT0gbnVsbCkgZmxhZ3MgPSBcIlwiO1xyXG4gICAgICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgIGZsYWdzICs9IChwYXR0ZXJuLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICBmbGFncyArPSAocGF0dGVybi5tdWx0aWxpbmUpID8gXCJtXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmbGFncy5pbmRleE9mKFwiZ1wiKSA9PT0gLTEpIGZsYWdzICs9IFwiZ1wiO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVnZXg7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyhpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtYXRjaCkgPyB0aGlzLnlpZWxkUmV0dXJuKG1hdGNoKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHN0YXJ0LCBjb3VudClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHN0YXJ0LCBjb3VudCwgc3RlcClcclxuICAgIEVudW1lcmFibGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGNvdW50LCBzdGVwKSB7XHJcbiAgICAgICAgaWYgKHN0ZXAgPT0gbnVsbCkgc3RlcCA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHZhbHVlID0gc3RhcnQgLSBzdGVwOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXgrKyA8IGNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4odmFsdWUgKz0gc3RlcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihzdGFydCwgY291bnQpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihzdGFydCwgY291bnQsIHN0ZXApXHJcbiAgICBFbnVtZXJhYmxlLnJhbmdlRG93biA9IGZ1bmN0aW9uIChzdGFydCwgY291bnQsIHN0ZXApIHtcclxuICAgICAgICBpZiAoc3RlcCA9PSBudWxsKSBzdGVwID0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgdmFsdWUgPSBzdGFydCArIHN0ZXA7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCsrIDwgY291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy55aWVsZFJldHVybih2YWx1ZSAtPSBzdGVwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMueWllbGRCcmVhaygpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHN0YXJ0LCB0bylcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHN0YXJ0LCB0bywgc3RlcClcclxuICAgIEVudW1lcmFibGUucmFuZ2VUbyA9IGZ1bmN0aW9uIChzdGFydCwgdG8sIHN0ZXApIHtcclxuICAgICAgICBpZiAoc3RlcCA9PSBudWxsKSBzdGVwID0gMTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyB2YWx1ZSA9IHN0YXJ0IC0gc3RlcDsgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZhbHVlICs9IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXh0IDw9IHRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4obmV4dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmspO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgdmFsdWUgPSBzdGFydCArIHN0ZXA7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2YWx1ZSAtPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV4dCA+PSB0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKG5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZEJyZWFrKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihlbGVtZW50KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZWxlbWVudCwgY291bnQpXHJcbiAgICBFbnVtZXJhYmxlLnJlcGVhdCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb3VudCkge1xyXG4gICAgICAgIGlmIChjb3VudCAhPSBudWxsKSByZXR1cm4gRW51bWVyYWJsZS5yZXBlYXQoZWxlbWVudCkudGFrZShjb3VudCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmssXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGVsZW1lbnQpOyB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5yZXBlYXRXaXRoRmluYWxpemUgPSBmdW5jdGlvbiAoaW5pdGlhbGl6ZXIsIGZpbmFsaXplcikge1xyXG4gICAgICAgIGluaXRpYWxpemVyID0gVXRpbHMuY3JlYXRlTGFtYmRhKGluaXRpYWxpemVyKTtcclxuICAgICAgICBmaW5hbGl6ZXIgPSBVdGlscy5jcmVhdGVMYW1iZGEoZmluYWxpemVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVsZW1lbnQgPSBpbml0aWFsaXplcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy55aWVsZFJldHVybihlbGVtZW50KTsgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplcihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGZ1bmMpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihmdW5jLCBjb3VudClcclxuICAgIEVudW1lcmFibGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoZnVuYywgY291bnQpIHtcclxuICAgICAgICBpZiAoY291bnQgIT0gbnVsbCkgcmV0dXJuIEVudW1lcmFibGUuZ2VuZXJhdGUoZnVuYykudGFrZShjb3VudCk7XHJcbiAgICAgICAgZnVuYyA9IFV0aWxzLmNyZWF0ZUxhbWJkYShmdW5jKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZnVuYygpKTsgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHN0YXJ0KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc3RhcnQsIHN0ZXApXHJcbiAgICBFbnVtZXJhYmxlLnRvSW5maW5pdHkgPSBmdW5jdGlvbiAoc3RhcnQsIHN0ZXApIHtcclxuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgc3RhcnQgPSAwO1xyXG4gICAgICAgIGlmIChzdGVwID09IG51bGwpIHN0ZXAgPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHZhbHVlID0gc3RhcnQgLSBzdGVwOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy55aWVsZFJldHVybih2YWx1ZSArPSBzdGVwKTsgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHN0YXJ0KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc3RhcnQsIHN0ZXApXHJcbiAgICBFbnVtZXJhYmxlLnRvTmVnYXRpdmVJbmZpbml0eSA9IGZ1bmN0aW9uIChzdGFydCwgc3RlcCkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSBzdGFydCA9IDA7XHJcbiAgICAgICAgaWYgKHN0ZXAgPT0gbnVsbCkgc3RlcCA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgdmFsdWUgPSBzdGFydCArIHN0ZXA7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHZhbHVlIC09IHN0ZXApOyB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS51bmZvbGQgPSBmdW5jdGlvbiAoc2VlZCwgZnVuYykge1xyXG4gICAgICAgIGZ1bmMgPSBVdGlscy5jcmVhdGVMYW1iZGEoZnVuYyk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZnVuYyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUuZGVmZXIgPSBmdW5jdGlvbiAoZW51bWVyYWJsZUZhY3RvcnkpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBlbnVtZXJhdG9yID0gRW51bWVyYWJsZS5mcm9tKGVudW1lcmFibGVGYWN0b3J5KCkpLmdldEVudW1lcmF0b3IoKTsgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IubW92ZU5leHQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMueWllbGRCcmVhaygpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4dGVuc2lvbiBNZXRob2RzXHJcblxyXG4gICAgLyogUHJvamVjdGlvbiBhbmQgRmlsdGVyaW5nIE1ldGhvZHMgKi9cclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihmdW5jKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZnVuYywgcmVzdWx0U2VsZWN0b3I8ZWxlbWVudD4pXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihmdW5jLCByZXN1bHRTZWxlY3RvcjxlbGVtZW50LCBuZXN0TGV2ZWw+KVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUudHJhdmVyc2VCcmVhZHRoRmlyc3QgPSBmdW5jdGlvbiAoZnVuYywgcmVzdWx0U2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICBmdW5jID0gVXRpbHMuY3JlYXRlTGFtYmRhKGZ1bmMpO1xyXG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKHJlc3VsdFNlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBuZXN0TGV2ZWwgPSAwO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTsgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChlbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihyZXN1bHRTZWxlY3RvcihlbnVtZXJhdG9yLmN1cnJlbnQoKSwgbmVzdExldmVsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gRW51bWVyYWJsZS5mcm9tKGJ1ZmZlcikuc2VsZWN0TWFueShmdW5jdGlvbiAoeCkgeyByZXR1cm4gZnVuYyh4KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5hbnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdExldmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gbmV4dC5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZnVuYylcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGZ1bmMsIHJlc3VsdFNlbGVjdG9yPGVsZW1lbnQ+KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZnVuYywgcmVzdWx0U2VsZWN0b3I8ZWxlbWVudCwgbmVzdExldmVsPilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnRyYXZlcnNlRGVwdGhGaXJzdCA9IGZ1bmN0aW9uIChmdW5jLCByZXN1bHRTZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgICAgIGZ1bmMgPSBVdGlscy5jcmVhdGVMYW1iZGEoZnVuYyk7XHJcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEocmVzdWx0U2VsZWN0b3IpO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvclN0YWNrID0gW107XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0U2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCksIGVudW1lcmF0b3JTdGFjay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvclN0YWNrLnB1c2goZW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gRW51bWVyYWJsZS5mcm9tKGZ1bmMoZW51bWVyYXRvci5jdXJyZW50KCkpKS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yU3RhY2subGVuZ3RoIDw9IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvciA9IGVudW1lcmF0b3JTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBFbnVtZXJhYmxlLmZyb20oZW51bWVyYXRvclN0YWNrKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHMuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVFbnVtZXJhdG9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaWRkbGVFbnVtZXJhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaWRkbGVFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihtaWRkbGVFbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRkbGVFbnVtZXJhdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IuY3VycmVudCgpIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5kaXNwb3NlKG1pZGRsZUVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZGRsZUVudW1lcmF0b3IgPSBFbnVtZXJhYmxlLmZyb20oZW51bWVyYXRvci5jdXJyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RNYW55KEZ1bmN0aW9ucy5JZGVudGl0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZsYXR0ZW4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShtaWRkbGVFbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUucGFpcndpc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICBzZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gZW51bWVyYXRvci5jdXJyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy55aWVsZFJldHVybihzZWxlY3RvcihwcmV2LCBlbnVtZXJhdG9yLmN1cnJlbnQoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZnVuYylcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlZWQsZnVuYzx2YWx1ZSxlbGVtZW50PilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiAoc2VlZCwgZnVuYykge1xyXG4gICAgICAgIHZhciBpc1VzZVNlZWQ7XHJcbiAgICAgICAgaWYgKGZ1bmMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmdW5jID0gVXRpbHMuY3JlYXRlTGFtYmRhKHNlZWQpOyAvLyBhcmd1bWVudHNbMF1cclxuICAgICAgICAgICAgaXNVc2VTZWVkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnVuYyA9IFV0aWxzLmNyZWF0ZUxhbWJkYShmdW5jKTtcclxuICAgICAgICAgICAgaXNVc2VTZWVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VzZVNlZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybih2YWx1ZSA9IGVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHZhbHVlID0gc2VlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4odmFsdWUgPSBmdW5jKHZhbHVlLCBlbnVtZXJhdG9yLmN1cnJlbnQoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VsZWN0b3I8ZWxlbWVudD4pXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihzZWxlY3RvcjxlbGVtZW50LGluZGV4PilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKHNlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdG9yLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVTZWxlY3RFbnVtZXJhYmxlKHRoaXMsIG51bGwsIHNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IubW92ZU5leHQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy55aWVsZFJldHVybihzZWxlY3RvcihlbnVtZXJhdG9yLmN1cnJlbnQoKSwgaW5kZXgrKykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihjb2xsZWN0aW9uU2VsZWN0b3I8ZWxlbWVudD4pXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihjb2xsZWN0aW9uU2VsZWN0b3I8ZWxlbWVudCxpbmRleD4pXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihjb2xsZWN0aW9uU2VsZWN0b3I8ZWxlbWVudD4scmVzdWx0U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihjb2xsZWN0aW9uU2VsZWN0b3I8ZWxlbWVudCxpbmRleD4scmVzdWx0U2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5zZWxlY3RNYW55ID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25TZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICBjb2xsZWN0aW9uU2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoY29sbGVjdGlvblNlbGVjdG9yKTtcclxuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3IgPT0gbnVsbCkgcmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYjsgfTtcclxuICAgICAgICByZXN1bHRTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShyZXN1bHRTZWxlY3Rvcik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgbWlkZGxlRW51bWVyYXRvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaWRkbGVFbnVtZXJhdG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWlkZGxlRW51bWVyYXRvciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkZGxlU2VxID0gY29sbGVjdGlvblNlbGVjdG9yKGVudW1lcmF0b3IuY3VycmVudCgpLCBpbmRleCsrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZGRsZUVudW1lcmF0b3IgPSBFbnVtZXJhYmxlLmZyb20obWlkZGxlU2VxKS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZUVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4ocmVzdWx0U2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCksIG1pZGRsZUVudW1lcmF0b3IuY3VycmVudCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShtaWRkbGVFbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkZGxlRW51bWVyYXRvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5kaXNwb3NlKG1pZGRsZUVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihwcmVkaWNhdGU8ZWxlbWVudD4pXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihwcmVkaWNhdGU8ZWxlbWVudCxpbmRleD4pXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICBwcmVkaWNhdGUgPSBVdGlscy5jcmVhdGVMYW1iZGEocHJlZGljYXRlKTtcclxuXHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlRW51bWVyYWJsZSh0aGlzLCBwcmVkaWNhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZW51bWVyYXRvci5jdXJyZW50KCksIGluZGV4KyspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlbGVjdG9yPGVsZW1lbnQ+KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VsZWN0b3I8ZWxlbWVudCxpbmRleD4pXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5jaG9vc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBzZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShzZWxlY3Rvcik7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCksIGluZGV4KyspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCcmVhaygpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLm9mVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIHR5cGVOYW1lO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcclxuICAgICAgICAgICAgICAgIHR5cGVOYW1lID0gVHlwZXMuTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxyXG4gICAgICAgICAgICAgICAgdHlwZU5hbWUgPSBUeXBlcy5TdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxyXG4gICAgICAgICAgICAgICAgdHlwZU5hbWUgPSBUeXBlcy5Cb29sZWFuO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb246XHJcbiAgICAgICAgICAgICAgICB0eXBlTmFtZSA9IFR5cGVzLkZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0eXBlTmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0eXBlTmFtZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgPyB0aGlzLndoZXJlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgdHlwZTsgfSlcclxuICAgICAgICAgICAgOiB0aGlzLndoZXJlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgeCA9PT0gdHlwZU5hbWU7IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBtdXRpcGxlIGFyZ3VtZW50cywgbGFzdCBvbmUgaXMgc2VsZWN0b3IsIG90aGVycyBhcmUgZW51bWVyYWJsZVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuemlwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKTtcclxuXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICAgICAgLy8gb3B0aW1pemVkIGNhc2U6YXJndW1lbnQgaXMgMlxyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgdmFyIHNlY29uZCA9IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RFbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZEVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbnVtZXJhdG9yID0gRW51bWVyYWJsZS5mcm9tKHNlY29uZCkuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFbnVtZXJhdG9yLm1vdmVOZXh0KCkgJiYgc2Vjb25kRW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHNlbGVjdG9yKGZpcnN0RW51bWVyYXRvci5jdXJyZW50KCksIHNlY29uZEVudW1lcmF0b3IuY3VycmVudCgpLCBpbmRleCsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShmaXJzdEVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2Uoc2Vjb25kRW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnVtZXJhdG9ycztcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBFbnVtZXJhYmxlLm1ha2Uoc291cmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KEVudW1lcmFibGUuZnJvbShhcmdzKS50YWtlRXhjZXB0TGFzdCgpLnNlbGVjdChFbnVtZXJhYmxlLmZyb20pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmdldEVudW1lcmF0b3IoKSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3JzID0gRW51bWVyYWJsZS5mcm9tKGFycmF5KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3JzLmFsbChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5tb3ZlTmV4dCgpIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IGVudW1lcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmN1cnJlbnQoKSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaChpbmRleCsrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oc2VsZWN0b3IuYXBwbHkobnVsbCwgYXJyYXkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEVudW1lcmFibGUuZnJvbShlbnVtZXJhdG9ycykuZm9yRWFjaChVdGlscy5kaXNwb3NlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG11dGlwbGUgYXJndW1lbnRzXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3JzO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvcnMgPSBFbnVtZXJhYmxlLm1ha2Uoc291cmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KEVudW1lcmFibGUuZnJvbShhcmdzKS5zZWxlY3QoRW51bWVyYWJsZS5mcm9tKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5nZXRFbnVtZXJhdG9yKCkgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVudW1lcmF0b3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggPj0gZW51bWVyYXRvcnMubGVuZ3RoIC0gMSkgPyAwIDogaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW51bWVyYXRvciA9IGVudW1lcmF0b3JzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvcnMuc3BsaWNlKGluZGV4LS0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRW51bWVyYWJsZS5mcm9tKGVudW1lcmF0b3JzKS5mb3JFYWNoKFV0aWxzLmRpc3Bvc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qIEpvaW4gTWV0aG9kcyAqL1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uIChpbm5lciwgb3V0ZXJLZXlTZWxlY3RvciwgaW5uZXJLZXlTZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbiAoaW5uZXIsIG91dGVyS2V5U2VsZWN0b3IsIGlubmVyS2V5U2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCBjb21wYXJlU2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKGlubmVyLCBvdXRlcktleVNlbGVjdG9yLCBpbm5lcktleVNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgb3V0ZXJLZXlTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShvdXRlcktleVNlbGVjdG9yKTtcclxuICAgICAgICBpbm5lcktleVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGlubmVyS2V5U2VsZWN0b3IpO1xyXG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKHJlc3VsdFNlbGVjdG9yKTtcclxuICAgICAgICBjb21wYXJlU2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoY29tcGFyZVNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG91dGVyRW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIGxvb2t1cDtcclxuICAgICAgICAgICAgdmFyIGlubmVyRWxlbWVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyRW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwID0gRW51bWVyYWJsZS5mcm9tKGlubmVyKS50b0xvb2t1cChpbm5lcktleVNlbGVjdG9yLCBGdW5jdGlvbnMuSWRlbnRpdHksIGNvbXBhcmVTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lckVsZW1lbnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckVsZW1lbnQgPSBpbm5lckVsZW1lbnRzW2lubmVyQ291bnQrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihyZXN1bHRTZWxlY3RvcihvdXRlckVudW1lcmF0b3IuY3VycmVudCgpLCBpbm5lckVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlckVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IG91dGVyS2V5U2VsZWN0b3Iob3V0ZXJFbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckVsZW1lbnRzID0gbG9va3VwLmdldChrZXkpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IFV0aWxzLmRpc3Bvc2Uob3V0ZXJFbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uIChpbm5lciwgb3V0ZXJLZXlTZWxlY3RvciwgaW5uZXJLZXlTZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbiAoaW5uZXIsIG91dGVyS2V5U2VsZWN0b3IsIGlubmVyS2V5U2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCBjb21wYXJlU2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5ncm91cEpvaW4gPSBmdW5jdGlvbiAoaW5uZXIsIG91dGVyS2V5U2VsZWN0b3IsIGlubmVyS2V5U2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yLCBjb21wYXJlU2VsZWN0b3IpIHtcclxuICAgICAgICBvdXRlcktleVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKG91dGVyS2V5U2VsZWN0b3IpO1xyXG4gICAgICAgIGlubmVyS2V5U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoaW5uZXJLZXlTZWxlY3Rvcik7XHJcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEocmVzdWx0U2VsZWN0b3IpO1xyXG4gICAgICAgIGNvbXBhcmVTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShjb21wYXJlU2VsZWN0b3IpO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBsb29rdXAgPSBFbnVtZXJhYmxlLmZyb20oaW5uZXIpLnRvTG9va3VwKGlubmVyS2V5U2VsZWN0b3IsIEZ1bmN0aW9ucy5JZGVudGl0eSwgY29tcGFyZVNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJFbGVtZW50ID0gbG9va3VwLmdldChvdXRlcktleVNlbGVjdG9yKGVudW1lcmF0b3IuY3VycmVudCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHJlc3VsdFNlbGVjdG9yKGVudW1lcmF0b3IuY3VycmVudCgpLCBpbm5lckVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qIFNldCBNZXRob2RzICovXHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IFV0aWxzLmNyZWF0ZUxhbWJkYShwcmVkaWNhdGUpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUoeCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24ocHJlZGljYXRlKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IFV0aWxzLmNyZWF0ZUxhbWJkYShwcmVkaWNhdGUpO1xyXG5cclxuICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXMuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHJldHVybiBlbnVtZXJhdG9yLm1vdmVOZXh0KCk7IC8vIGNhc2U6ZnVuY3Rpb24oKVxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSkgLy8gY2FzZTpmdW5jdGlvbihwcmVkaWNhdGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZW51bWVyYXRvci5jdXJyZW50KCkpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYW55KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG11bHRpcGxlIGFyZ3VtZW50c1xyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0RW51bWVyYXRvcjtcclxuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRFbnVtZXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGZpcnN0RW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZEVudW1lcmF0b3IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGZpcnN0RW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbnVtZXJhdG9yID0gRW51bWVyYWJsZS5mcm9tKHNlY29uZCkuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kRW51bWVyYXRvci5tb3ZlTmV4dCgpKSByZXR1cm4gdGhpcy55aWVsZFJldHVybihzZWNvbmRFbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5kaXNwb3NlKGZpcnN0RW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5kaXNwb3NlKHNlY29uZEVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnVtZXJhdG9ycztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvcnMgPSBFbnVtZXJhYmxlLm1ha2Uoc291cmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChFbnVtZXJhYmxlLmZyb20oYXJncykuc2VsZWN0KEVudW1lcmFibGUuZnJvbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmdldEVudW1lcmF0b3IoKSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVudW1lcmF0b3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yID0gZW51bWVyYXRvcnNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3JzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJyZWFrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEVudW1lcmFibGUuZnJvbShlbnVtZXJhdG9ycykuZm9yRWFjaChVdGlscy5kaXNwb3NlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIHNlY29uZCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RFbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kRW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAgICAgdmFyIGlzRW51bWVyYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdEVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEVudW1lcmF0b3IgPSBFbnVtZXJhYmxlLmZyb20oc2Vjb25kKS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSBpbmRleCAmJiBzZWNvbmRFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbnVtZXJhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oc2Vjb25kRW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZmlyc3RFbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbnVtZXJhdGVkICYmIHNlY29uZEVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihzZWNvbmRFbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShmaXJzdEVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShzZWNvbmRFbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuYWx0ZXJuYXRlID0gZnVuY3Rpb24gKGFsdGVybmF0ZVZhbHVlT3JTZXF1ZW5jZSkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyO1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIGFsdGVybmF0ZVNlcXVlbmNlO1xyXG4gICAgICAgICAgICB2YXIgYWx0ZXJuYXRlRW51bWVyYXRvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZVZhbHVlT3JTZXF1ZW5jZSBpbnN0YW5jZW9mIEFycmF5IHx8IGFsdGVybmF0ZVZhbHVlT3JTZXF1ZW5jZS5nZXRFbnVtZXJhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlU2VxdWVuY2UgPSBFbnVtZXJhYmxlLmZyb20oRW51bWVyYWJsZS5mcm9tKGFsdGVybmF0ZVZhbHVlT3JTZXF1ZW5jZSkudG9BcnJheSgpKTsgLy8gZnJlZXplXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGVTZXF1ZW5jZSA9IEVudW1lcmFibGUubWFrZShhbHRlcm5hdGVWYWx1ZU9yU2VxdWVuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKSBidWZmZXIgPSBlbnVtZXJhdG9yLmN1cnJlbnQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZUVudW1lcmF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZUVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGFsdGVybmF0ZUVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZUVudW1lcmF0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyID09IG51bGwgJiYgZW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBlbnVtZXJhdG9yLmN1cnJlbnQoKTsgLy8gaGFzTmV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlRW51bWVyYXRvciA9IGFsdGVybmF0ZVNlcXVlbmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBHT1RPXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRWYWwgPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4ocmV0VmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCcmVhaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoYWx0ZXJuYXRlRW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHZhbHVlKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24odmFsdWUsIGNvbXBhcmVTZWxlY3RvcilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbHVlLCBjb21wYXJlU2VsZWN0b3IpIHtcclxuICAgICAgICBjb21wYXJlU2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoY29tcGFyZVNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXMuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlU2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCkpID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmRlZmF1bHRJZkVtcHR5ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkgZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihlbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oY29tcGFyZVNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjZXB0KEVudW1lcmFibGUuZW1wdHkoKSwgY29tcGFyZVNlbGVjdG9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBmdW5jdGlvbiAoY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgY29tcGFyZVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGNvbXBhcmVTZWxlY3Rvcik7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgY29tcGFyZUtleTtcclxuICAgICAgICAgICAgdmFyIGluaXRpYWw7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjb21wYXJlU2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihlbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlS2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihlbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihzZWNvbmQpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihzZWNvbmQsIGNvbXBhcmVTZWxlY3RvcilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmV4Y2VwdCA9IGZ1bmN0aW9uIChzZWNvbmQsIGNvbXBhcmVTZWxlY3Rvcikge1xyXG4gICAgICAgIGNvbXBhcmVTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShjb21wYXJlU2VsZWN0b3IpO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIGtleXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBuZXcgRGljdGlvbmFyeShjb21wYXJlU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIEVudW1lcmFibGUuZnJvbShzZWNvbmQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBrZXlzLmFkZChrZXkpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGVudW1lcmF0b3IuY3VycmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleXMuY29udGFpbnMoY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuYWRkKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlY29uZClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlY29uZCwgY29tcGFyZVNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKHNlY29uZCwgY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgY29tcGFyZVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGNvbXBhcmVTZWxlY3Rvcik7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIga2V5cztcclxuICAgICAgICAgICAgdmFyIG91dHM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXlzID0gbmV3IERpY3Rpb25hcnkoY29tcGFyZVNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBFbnVtZXJhYmxlLmZyb20oc2Vjb25kKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsga2V5cy5hZGQoa2V5KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cyA9IG5ldyBEaWN0aW9uYXJ5KGNvbXBhcmVTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbnVtZXJhdG9yLmN1cnJlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRzLmNvbnRhaW5zKGN1cnJlbnQpICYmIGtleXMuY29udGFpbnMoY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHMuYWRkKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlY29uZClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlY29uZCwgY29tcGFyZVNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuc2VxdWVuY2VFcXVhbCA9IGZ1bmN0aW9uIChzZWNvbmQsIGNvbXBhcmVTZWxlY3Rvcikge1xyXG4gICAgICAgIGNvbXBhcmVTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShjb21wYXJlU2VsZWN0b3IpO1xyXG5cclxuICAgICAgICB2YXIgZmlyc3RFbnVtZXJhdG9yID0gdGhpcy5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHNlY29uZEVudW1lcmF0b3IgPSBFbnVtZXJhYmxlLmZyb20oc2Vjb25kKS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmlyc3RFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlY29uZEVudW1lcmF0b3IubW92ZU5leHQoKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGNvbXBhcmVTZWxlY3RvcihmaXJzdEVudW1lcmF0b3IuY3VycmVudCgpKSAhPT0gY29tcGFyZVNlbGVjdG9yKHNlY29uZEVudW1lcmF0b3IuY3VycmVudCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWNvbmRFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShzZWNvbmRFbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShmaXJzdEVudW1lcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAoc2Vjb25kLCBjb21wYXJlU2VsZWN0b3IpIHtcclxuICAgICAgICBjb21wYXJlU2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoY29tcGFyZVNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGZpcnN0RW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIHNlY29uZEVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBrZXlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdEVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBuZXcgRGljdGlvbmFyeShjb21wYXJlU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kRW51bWVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdEVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGZpcnN0RW51bWVyYXRvci5jdXJyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleXMuY29udGFpbnMoY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLmFkZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbnVtZXJhdG9yID0gRW51bWVyYWJsZS5mcm9tKHNlY29uZCkuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2Vjb25kRW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBzZWNvbmRFbnVtZXJhdG9yLmN1cnJlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlzLmNvbnRhaW5zKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLmFkZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShmaXJzdEVudW1lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShzZWNvbmRFbnVtZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyogT3JkZXJpbmcgTWV0aG9kcyAqL1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLm9yZGVyQnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9yZGVyZWRFbnVtZXJhYmxlKHRoaXMsIGtleVNlbGVjdG9yLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLm9yZGVyQnlEZXNjZW5kaW5nID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPcmRlcmVkRW51bWVyYWJsZSh0aGlzLCBrZXlTZWxlY3RvciwgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXI7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gc291cmNlLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oYnVmZmVyWy0taW5kZXhdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBidWZmZXIgPSBzb3VyY2UudG9BcnJheSgpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihidWZmZXIuc3BsaWNlKGksIDEpWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFuayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLndlaWdodGVkU2FtcGxlID0gZnVuY3Rpb24gKHdlaWdodFNlbGVjdG9yKSB7XHJcbiAgICAgICAgd2VpZ2h0U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEod2VpZ2h0U2VsZWN0b3IpO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc29ydGVkQnlCb3VuZDtcclxuICAgICAgICAgICAgdmFyIHRvdGFsV2VpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQnlCb3VuZCA9IHNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2hvb3NlKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0U2VsZWN0b3IoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0IDw9IDApIHJldHVybiBudWxsOyAvLyBpZ25vcmUgMFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB4LCBib3VuZDogdG90YWxXZWlnaHQgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEJ5Qm91bmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRvdGFsV2VpZ2h0KSArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXIgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwcGVyID0gc29ydGVkQnlCb3VuZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh1cHBlciAtIGxvd2VyID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcigobG93ZXIgKyB1cHBlcikgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRCeUJvdW5kW2luZGV4XS5ib3VuZCA+PSBkcmF3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXIgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHNvcnRlZEJ5Qm91bmRbdXBwZXJdLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnJlYWsoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiBHcm91cGluZyBNZXRob2RzICovXHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oa2V5U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcixlbGVtZW50U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcixlbGVtZW50U2VsZWN0b3IscmVzdWx0U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcixlbGVtZW50U2VsZWN0b3IscmVzdWx0U2VsZWN0b3IsY29tcGFyZVNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuZ3JvdXBCeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCByZXN1bHRTZWxlY3RvciwgY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcbiAgICAgICAga2V5U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoa2V5U2VsZWN0b3IpO1xyXG4gICAgICAgIGVsZW1lbnRTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShlbGVtZW50U2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChyZXN1bHRTZWxlY3RvciAhPSBudWxsKSByZXN1bHRTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShyZXN1bHRTZWxlY3Rvcik7XHJcbiAgICAgICAgY29tcGFyZVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGNvbXBhcmVTZWxlY3Rvcik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gc291cmNlLnRvTG9va3VwKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGNvbXBhcmVTZWxlY3RvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRW51bWVyYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHRTZWxlY3RvciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkUmV0dXJuKHJlc3VsdFNlbGVjdG9yKGVudW1lcmF0b3IuY3VycmVudCgpLmtleSgpLCBlbnVtZXJhdG9yLmN1cnJlbnQoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oa2V5U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcixlbGVtZW50U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcixlbGVtZW50U2VsZWN0b3IscmVzdWx0U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcixlbGVtZW50U2VsZWN0b3IscmVzdWx0U2VsZWN0b3IsY29tcGFyZVNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUucGFydGl0aW9uQnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgcmVzdWx0U2VsZWN0b3IsIGNvbXBhcmVTZWxlY3Rvcikge1xyXG5cclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICBrZXlTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShrZXlTZWxlY3Rvcik7XHJcbiAgICAgICAgZWxlbWVudFNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGVsZW1lbnRTZWxlY3Rvcik7XHJcbiAgICAgICAgY29tcGFyZVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGNvbXBhcmVTZWxlY3Rvcik7XHJcbiAgICAgICAgdmFyIGhhc1Jlc3VsdFNlbGVjdG9yO1xyXG4gICAgICAgIGlmIChyZXN1bHRTZWxlY3RvciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhhc1Jlc3VsdFNlbGVjdG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKGtleSwgZ3JvdXApIHsgcmV0dXJuIG5ldyBHcm91cGluZyhrZXksIGdyb3VwKTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc1Jlc3VsdFNlbGVjdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEocmVzdWx0U2VsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJlS2V5O1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlTZWxlY3RvcihlbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVLZXkgPSBjb21wYXJlU2VsZWN0b3Ioa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAucHVzaChlbGVtZW50U2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNOZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaGFzTmV4dCA9IGVudW1lcmF0b3IubW92ZU5leHQoKSkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZUtleSA9PT0gY29tcGFyZVNlbGVjdG9yKGtleVNlbGVjdG9yKGVudW1lcmF0b3IuY3VycmVudCgpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnB1c2goZWxlbWVudFNlbGVjdG9yKGVudW1lcmF0b3IuY3VycmVudCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoaGFzUmVzdWx0U2VsZWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdFNlbGVjdG9yKGtleSwgRW51bWVyYWJsZS5mcm9tKGdyb3VwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzdWx0U2VsZWN0b3Ioa2V5LCBncm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNOZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlTZWxlY3RvcihlbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlS2V5ID0gY29tcGFyZVNlbGVjdG9yKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9IFtlbGVtZW50U2VsZWN0b3IoZW51bWVyYXRvci5jdXJyZW50KCkpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGdyb3VwID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmJ1ZmZlciA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVudW1lcmF0b3IubW92ZU5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gY291bnQpIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+IDApIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyogQWdncmVnYXRlIE1ldGhvZHMgKi9cclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihmdW5jKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VlZCxmdW5jKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VlZCxmdW5jLHJlc3VsdFNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuYWdncmVnYXRlID0gZnVuY3Rpb24gKHNlZWQsIGZ1bmMsIHJlc3VsdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEocmVzdWx0U2VsZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRTZWxlY3Rvcih0aGlzLnNjYW4oc2VlZCwgZnVuYywgcmVzdWx0U2VsZWN0b3IpLmxhc3QoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuYXZlcmFnZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIHNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKHNlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgc3VtICs9IHNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgICArK2NvdW50O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gc3VtIC8gY291bnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZSlcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IChwcmVkaWNhdGUgPT0gbnVsbCkgPyBGdW5jdGlvbnMuVHJ1ZSA6IFV0aWxzLmNyZWF0ZUxhbWJkYShwcmVkaWNhdGUpO1xyXG5cclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHgsIGkpKSsrY291bnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbigpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihzZWxlY3RvcilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChzZWxlY3RvciA9PSBudWxsKSBzZWxlY3RvciA9IEZ1bmN0aW9ucy5JZGVudGl0eTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2VsZWN0b3IpLmFnZ3JlZ2F0ZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPiBiKSA/IGEgOiBiOyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgPT0gbnVsbCkgc2VsZWN0b3IgPSBGdW5jdGlvbnMuSWRlbnRpdHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHNlbGVjdG9yKS5hZ2dyZWdhdGUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhIDwgYikgPyBhIDogYjsgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLm1heEJ5ID0gZnVuY3Rpb24gKGtleVNlbGVjdG9yKSB7XHJcbiAgICAgICAga2V5U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoa2V5U2VsZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFnZ3JlZ2F0ZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGtleVNlbGVjdG9yKGEpID4ga2V5U2VsZWN0b3IoYikpID8gYSA6IGI7IH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5taW5CeSA9IGZ1bmN0aW9uIChrZXlTZWxlY3Rvcikge1xyXG4gICAgICAgIGtleVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGtleVNlbGVjdG9yKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZ2dyZWdhdGUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChrZXlTZWxlY3RvcihhKSA8IGtleVNlbGVjdG9yKGIpKSA/IGEgOiBiOyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgPT0gbnVsbCkgc2VsZWN0b3IgPSBGdW5jdGlvbnMuSWRlbnRpdHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHNlbGVjdG9yKS5hZ2dyZWdhdGUoMCwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyogUGFnaW5nIE1ldGhvZHMgKi9cclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5lbGVtZW50QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHg7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFmb3VuZCkgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaXMgbGVzcyB0aGFuIDAgb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gc291cmNlLlwiKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmVsZW1lbnRBdE9yRGVmYXVsdCA9IGZ1bmN0aW9uIChpbmRleCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSBkZWZhdWx0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0geDtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gKCFmb3VuZCkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24ocHJlZGljYXRlKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSAhPSBudWxsKSByZXR1cm4gdGhpcy53aGVyZShwcmVkaWNhdGUpLmZpcnN0KCk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB4O1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFmb3VuZCkgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3Q6Tm8gZWxlbWVudCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbi5cIik7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5maXJzdE9yRGVmYXVsdCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gVHlwZXMuRnVuY3Rpb24gfHwgdHlwZW9mIFV0aWxzLmNyZWF0ZUxhbWJkYShwcmVkaWNhdGUpID09PSBUeXBlcy5GdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUocHJlZGljYXRlKS5maXJzdE9yRGVmYXVsdCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJlZGljYXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHg7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoIWZvdW5kKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbigpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihwcmVkaWNhdGUpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUgIT0gbnVsbCkgcmV0dXJuIHRoaXMud2hlcmUocHJlZGljYXRlKS5sYXN0KCk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghZm91bmQpIHRocm93IG5ldyBFcnJvcihcImxhc3Q6Tm8gZWxlbWVudCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbi5cIik7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5sYXN0T3JEZWZhdWx0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlID09PSBUeXBlcy5GdW5jdGlvbiB8fCB0eXBlb2YgVXRpbHMuY3JlYXRlTGFtYmRhKHByZWRpY2F0ZSkgPT09IFR5cGVzLkZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShwcmVkaWNhdGUpLmxhc3RPckRlZmF1bHQodW5kZWZpbmVkLCBkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByZWRpY2F0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICghZm91bmQpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZSlcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnNpbmdsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlICE9IG51bGwpIHJldHVybiB0aGlzLndoZXJlKHByZWRpY2F0ZSkuc2luZ2xlKCk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB4O1xyXG4gICAgICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwic2luZ2xlOnNlcXVlbmNlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgZWxlbWVudC5cIik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghZm91bmQpIHRocm93IG5ldyBFcnJvcihcInNpbmdsZTpObyBlbGVtZW50IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uLlwiKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGRlZmF1bHRWYWx1ZSxwcmVkaWNhdGUpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5zaW5nbGVPckRlZmF1bHQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIGRlZmF1bHRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSAhPSBudWxsKSByZXR1cm4gdGhpcy53aGVyZShwcmVkaWNhdGUpLnNpbmdsZU9yRGVmYXVsdChudWxsLCBkZWZhdWx0VmFsdWUpO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0geDtcclxuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcInNpbmdsZTpzZXF1ZW5jZSBjb250YWlucyBtb3JlIHRoYW4gb25lIGVsZW1lbnQuXCIpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gKCFmb3VuZCkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4KysgPCBjb3VudCAmJiBlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IubW92ZU5leHQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZTxlbGVtZW50PilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZTxlbGVtZW50LGluZGV4PilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnNraXBXaGlsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICBwcmVkaWNhdGUgPSBVdGlscy5jcmVhdGVMYW1iZGEocHJlZGljYXRlKTtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBpc1NraXBFbmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghaXNTa2lwRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlZGljYXRlKGVudW1lcmF0b3IuY3VycmVudCgpLCBpbmRleCsrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2tpcEVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IubW92ZU5leHQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKGVudW1lcmF0b3IuY3VycmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS50YWtlID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCsrIDwgY291bnQgJiYgZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZTxlbGVtZW50PilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZTxlbGVtZW50LGluZGV4PilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICBwcmVkaWNhdGUgPSBVdGlscy5jcmVhdGVMYW1iZGEocHJlZGljYXRlKTtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTsgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVudW1lcmF0b3IubW92ZU5leHQoKSAmJiBwcmVkaWNhdGUoZW51bWVyYXRvci5jdXJyZW50KCksIGluZGV4KyspKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oY291bnQpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS50YWtlRXhjZXB0TGFzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDE7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAwKSByZXR1cm4gc291cmNlLmdldEVudW1lcmF0b3IoKTsgLy8gZG8gbm90aGluZ1xyXG5cclxuICAgICAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgICAgIHZhciBxID0gW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTsgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmxlbmd0aCA9PSBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5wdXNoKGVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKHEuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wdXNoKGVudW1lcmF0b3IuY3VycmVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgVXRpbHMuZGlzcG9zZShlbnVtZXJhdG9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnRha2VGcm9tTGFzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIGlmIChjb3VudCA8PSAwIHx8IGNvdW50ID09IG51bGwpIHJldHVybiBFbnVtZXJhYmxlLmVtcHR5KCk7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VFbnVtZXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIHEgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHNvdXJjZUVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzb3VyY2VFbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID09IGNvdW50KSBxLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHVzaChzb3VyY2VFbnVtZXJhdG9yLmN1cnJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvciA9IEVudW1lcmFibGUuZnJvbShxKS5nZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oaXRlbSlcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZSlcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBmb3VuZCA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIGl0ZW0gYXMgcHJlZGljYXRlXHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaXRlbSkgPT09IFR5cGVzLkZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0oeCwgaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoZm91bmQgIT09IG51bGwpID8gZm91bmQgOiAtMTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oaXRlbSlcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHByZWRpY2F0ZSlcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcblxyXG4gICAgICAgIC8vIGl0ZW0gYXMgcHJlZGljYXRlXHJcbiAgICAgICAgaWYgKHR5cGVvZiAoaXRlbSkgPT09IFR5cGVzLkZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0oeCwgaSkpIHJlc3VsdCA9IGk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaXRlbSkgcmVzdWx0ID0gaTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiBDb252ZXJ0IE1ldGhvZHMgKi9cclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5hc0VudW1lcmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEVudW1lcmFibGUuZnJvbSh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgYXJyYXkucHVzaCh4KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvcilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBjb21wYXJlU2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS50b0xvb2t1cCA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBjb21wYXJlU2VsZWN0b3IpIHtcclxuICAgICAgICBrZXlTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShrZXlTZWxlY3Rvcik7XHJcbiAgICAgICAgZWxlbWVudFNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGVsZW1lbnRTZWxlY3Rvcik7XHJcbiAgICAgICAgY29tcGFyZVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGNvbXBhcmVTZWxlY3Rvcik7XHJcblxyXG4gICAgICAgIHZhciBkaWN0ID0gbmV3IERpY3Rpb25hcnkoY29tcGFyZVNlbGVjdG9yKTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleVNlbGVjdG9yKHgpO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRTZWxlY3Rvcih4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGRpY3QuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChhcnJheSAhPT0gdW5kZWZpbmVkKSBhcnJheS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBlbHNlIGRpY3QuYWRkKGtleSwgW2VsZW1lbnRdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IExvb2t1cChkaWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGtleVNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKGtleVNlbGVjdG9yKTtcclxuICAgICAgICBlbGVtZW50U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoZWxlbWVudFNlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBvYmpba2V5U2VsZWN0b3IoeCldID0gZWxlbWVudFNlbGVjdG9yKHgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBjb21wYXJlU2VsZWN0b3IpXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS50b0RpY3Rpb25hcnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAga2V5U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoa2V5U2VsZWN0b3IpO1xyXG4gICAgICAgIGVsZW1lbnRTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShlbGVtZW50U2VsZWN0b3IpO1xyXG4gICAgICAgIGNvbXBhcmVTZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShjb21wYXJlU2VsZWN0b3IpO1xyXG5cclxuICAgICAgICB2YXIgZGljdCA9IG5ldyBEaWN0aW9uYXJ5KGNvbXBhcmVTZWxlY3Rvcik7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGRpY3QuYWRkKGtleVNlbGVjdG9yKHgpLCBlbGVtZW50U2VsZWN0b3IoeCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkaWN0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbigpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihyZXBsYWNlcilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHJlcGxhY2VyLCBzcGFjZSlcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnRvSlNPTlN0cmluZyA9IGZ1bmN0aW9uIChyZXBsYWNlciwgc3BhY2UpIHtcclxuICAgICAgICBpZiAodHlwZW9mIEpTT04gPT09IFR5cGVzLlVuZGVmaW5lZCB8fCBKU09OLnN0cmluZ2lmeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvSlNPTlN0cmluZyBjYW4ndCBmaW5kIEpTT04uc3RyaW5naWZ5LiBUaGlzIHdvcmtzIG5hdGl2ZSBKU09OIHN1cHBvcnQgQnJvd3NlciBvciBpbmNsdWRlIGpzb24yLmpzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0FycmF5KCksIHJlcGxhY2VyLCBzcGFjZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlcGFyYXRvcilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlcGFyYXRvcixzZWxlY3RvcilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLnRvSm9pbmVkU3RyaW5nID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHNlcGFyYXRvciA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHNlbGVjdG9yID09IG51bGwpIHNlbGVjdG9yID0gRnVuY3Rpb25zLklkZW50aXR5O1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2VsZWN0b3IpLnRvQXJyYXkoKS5qb2luKHNlcGFyYXRvcik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKiBBY3Rpb24gTWV0aG9kcyAqL1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGFjdGlvbjxlbGVtZW50PilcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKGFjdGlvbjxlbGVtZW50LGluZGV4PilcclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmRvQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG4gICAgICAgIGFjdGlvbiA9IFV0aWxzLmNyZWF0ZUxhbWJkYShhY3Rpb24pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uKGVudW1lcmF0b3IuY3VycmVudCgpLCBpbmRleCsrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oYWN0aW9uPGVsZW1lbnQ+KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oYWN0aW9uPGVsZW1lbnQsaW5kZXg+KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZnVuYzxlbGVtZW50LGJvb2w+KVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oZnVuYzxlbGVtZW50LGluZGV4LGJvb2w+KVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICBhY3Rpb24gPSBVdGlscy5jcmVhdGVMYW1iZGEoYWN0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXMuZ2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24oZW51bWVyYXRvci5jdXJyZW50KCksIGluZGV4KyspID09PSBmYWxzZSkgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VwYXJhdG9yKVxyXG4gICAgLy8gT3ZlcmxvYWQ6ZnVuY3Rpb24oc2VwYXJhdG9yLHNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBzZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkgc2VwYXJhdG9yID0gXCJcIjtcclxuICAgICAgICBzZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGlzRmlyc3QpIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgZWxzZSBkb2N1bWVudC53cml0ZShzZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC53cml0ZShzZWxlY3RvcihpdGVtKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUud3JpdGVMaW5lID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgc2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGVsbihzZWxlY3RvcihpdGVtKSArIFwiPGJyIC8+XCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5mb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXMuZ2V0RW51bWVyYXRvcigpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKiBGdW5jdGlvbmFsIE1ldGhvZHMgKi9cclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5sZXRCaW5kID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICBmdW5jID0gVXRpbHMuY3JlYXRlTGFtYmRhKGZ1bmMpO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvciA9IEVudW1lcmFibGUuZnJvbShmdW5jKHNvdXJjZSkpLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy55aWVsZFJldHVybihlbnVtZXJhdG9yLmN1cnJlbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5zaGFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICB2YXIgc2hhcmVkRW51bWVyYXRvcjtcclxuICAgICAgICB2YXIgZGlzcG9zZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NhYmxlRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXJlZEVudW1lcmF0b3IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRFbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlZCkgdGhyb3cgbmV3IEVycm9yKFwiZW51bWVyYXRvciBpcyBkaXNwb3NlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzaGFyZWRFbnVtZXJhdG9yLm1vdmVOZXh0KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy55aWVsZFJldHVybihzaGFyZWRFbnVtZXJhdG9yLmN1cnJlbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmtcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgVXRpbHMuZGlzcG9zZShzaGFyZWRFbnVtZXJhdG9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUubWVtb2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcztcclxuICAgICAgICB2YXIgY2FjaGU7XHJcbiAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcbiAgICAgICAgdmFyIGRpc3Bvc2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZUVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yID0gc291cmNlLmdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlZCkgdGhyb3cgbmV3IEVycm9yKFwiZW51bWVyYXRvciBpcyBkaXNwb3NlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGUubGVuZ3RoIDw9IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKGNhY2hlW2luZGV4XSA9IGVudW1lcmF0b3IuY3VycmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkUmV0dXJuKGNhY2hlW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBkaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgIGNhY2hlID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyogRXJyb3IgSGFuZGxpbmcgTWV0aG9kcyAqL1xyXG5cclxuICAgIEVudW1lcmFibGUucHJvdG90eXBlLmNhdGNoRXJyb3IgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIGhhbmRsZXIgPSBVdGlscy5jcmVhdGVMYW1iZGEoaGFuZGxlcik7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFbnVtZXJhYmxlLnByb3RvdHlwZS5maW5hbGx5QWN0aW9uID0gZnVuY3Rpb24gKGZpbmFsbHlBY3Rpb24pIHtcclxuICAgICAgICBmaW5hbGx5QWN0aW9uID0gVXRpbHMuY3JlYXRlTGFtYmRhKGZpbmFsbHlBY3Rpb24pO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVudW1lcmFibGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZW51bWVyYXRvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmRpc3Bvc2UoZW51bWVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUFjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiBGb3IgRGVidWcgTWV0aG9kcyAqL1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKHNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgc2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kb0FjdGlvbihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFR5cGVzLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc2VsZWN0b3IoaXRlbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKG1lc3NhZ2UpXHJcbiAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihtZXNzYWdlLHNlbGVjdG9yKVxyXG4gICAgRW51bWVyYWJsZS5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSBtZXNzYWdlID0gXCJUcmFjZVwiO1xyXG4gICAgICAgIHNlbGVjdG9yID0gVXRpbHMuY3JlYXRlTGFtYmRhKHNlbGVjdG9yKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9BY3Rpb24oZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBUeXBlcy5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UsIHNlbGVjdG9yKGl0ZW0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBwcml2YXRlXHJcblxyXG4gICAgdmFyIE9yZGVyZWRFbnVtZXJhYmxlID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5U2VsZWN0b3IsIGRlc2NlbmRpbmcsIHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoa2V5U2VsZWN0b3IpO1xyXG4gICAgICAgIHRoaXMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB9O1xyXG4gICAgT3JkZXJlZEVudW1lcmFibGUucHJvdG90eXBlID0gbmV3IEVudW1lcmFibGUoKTtcclxuXHJcbiAgICBPcmRlcmVkRW51bWVyYWJsZS5wcm90b3R5cGUuY3JlYXRlT3JkZXJlZEVudW1lcmFibGUgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IsIGRlc2NlbmRpbmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9yZGVyZWRFbnVtZXJhYmxlKHRoaXMuc291cmNlLCBrZXlTZWxlY3RvciwgZGVzY2VuZGluZywgdGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9yZGVyZWRFbnVtZXJhYmxlLnByb3RvdHlwZS50aGVuQnkgPSBmdW5jdGlvbiAoa2V5U2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPcmRlcmVkRW51bWVyYWJsZShrZXlTZWxlY3RvciwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcmRlcmVkRW51bWVyYWJsZS5wcm90b3R5cGUudGhlbkJ5RGVzY2VuZGluZyA9IGZ1bmN0aW9uIChrZXlTZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWRFbnVtZXJhYmxlKGtleVNlbGVjdG9yLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgT3JkZXJlZEVudW1lcmFibGUucHJvdG90eXBlLmdldEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBidWZmZXI7XHJcbiAgICAgICAgdmFyIGluZGV4ZXM7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBJRW51bWVyYXRvcihcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICAgICAgICAgICAgICBpbmRleGVzID0gW107XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBzb3J0Q29udGV4dCA9IFNvcnRDb250ZXh0LmNyZWF0ZShzZWxmLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHNvcnRDb250ZXh0LkdlbmVyYXRlS2V5cyhidWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGluZGV4ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gc29ydENvbnRleHQuY29tcGFyZShhLCBiKTsgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCBpbmRleGVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMueWllbGRSZXR1cm4oYnVmZmVyW2luZGV4ZXNbaW5kZXgrK11dKVxyXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEZ1bmN0aW9ucy5CbGFua1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTb3J0Q29udGV4dCA9IGZ1bmN0aW9uIChrZXlTZWxlY3RvciwgZGVzY2VuZGluZywgY2hpbGQpIHtcclxuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XHJcbiAgICAgICAgdGhpcy5kZXNjZW5kaW5nID0gZGVzY2VuZGluZztcclxuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XHJcbiAgICAgICAgdGhpcy5rZXlzID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgU29ydENvbnRleHQuY3JlYXRlID0gZnVuY3Rpb24gKG9yZGVyZWRFbnVtZXJhYmxlLCBjdXJyZW50Q29udGV4dCkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IFNvcnRDb250ZXh0KG9yZGVyZWRFbnVtZXJhYmxlLmtleVNlbGVjdG9yLCBvcmRlcmVkRW51bWVyYWJsZS5kZXNjZW5kaW5nLCBjdXJyZW50Q29udGV4dCk7XHJcbiAgICAgICAgaWYgKG9yZGVyZWRFbnVtZXJhYmxlLnBhcmVudCAhPSBudWxsKSByZXR1cm4gU29ydENvbnRleHQuY3JlYXRlKG9yZGVyZWRFbnVtZXJhYmxlLnBhcmVudCwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFNvcnRDb250ZXh0LnByb3RvdHlwZS5HZW5lcmF0ZUtleXMgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGtleVNlbGVjdG9yID0gdGhpcy5rZXlTZWxlY3RvcjtcclxuICAgICAgICB2YXIga2V5cyA9IG5ldyBBcnJheShsZW4pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGtleXNbaV0gPSBrZXlTZWxlY3Rvcihzb3VyY2VbaV0pO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkICE9IG51bGwpIHRoaXMuY2hpbGQuR2VuZXJhdGVLZXlzKHNvdXJjZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNvcnRDb250ZXh0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGluZGV4MSwgaW5kZXgyKSB7XHJcbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSBVdGlscy5jb21wYXJlKHRoaXMua2V5c1tpbmRleDFdLCB0aGlzLmtleXNbaW5kZXgyXSk7XHJcblxyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgIT0gbnVsbCkgcmV0dXJuIHRoaXMuY2hpbGQuY29tcGFyZShpbmRleDEsIGluZGV4Mik7XHJcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5jb21wYXJlKGluZGV4MSwgaW5kZXgyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAodGhpcy5kZXNjZW5kaW5nKSA/IC1jb21wYXJpc29uIDogY29tcGFyaXNvbjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIERpc3Bvc2FibGVFbnVtZXJhYmxlID0gZnVuY3Rpb24gKGdldEVudW1lcmF0b3IsIGRpc3Bvc2UpIHtcclxuICAgICAgICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlO1xyXG4gICAgICAgIEVudW1lcmFibGUuY2FsbCh0aGlzLCBnZXRFbnVtZXJhdG9yKTtcclxuICAgIH07XHJcbiAgICBEaXNwb3NhYmxlRW51bWVyYWJsZS5wcm90b3R5cGUgPSBuZXcgRW51bWVyYWJsZSgpO1xyXG5cclxuICAgIC8vIG9wdGltaXplIGFycmF5IG9yIGFycmF5bGlrZSBvYmplY3RcclxuXHJcbiAgICB2YXIgQXJyYXlFbnVtZXJhYmxlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlOyB9O1xyXG4gICAgfTtcclxuICAgIEFycmF5RW51bWVyYWJsZS5wcm90b3R5cGUgPSBuZXcgRW51bWVyYWJsZSgpO1xyXG5cclxuICAgIEFycmF5RW51bWVyYWJsZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHJldHVybiAocHJlZGljYXRlID09IG51bGwpXHJcbiAgICAgICAgICAgID8gKHRoaXMuZ2V0U291cmNlKCkubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgOiBFbnVtZXJhYmxlLnByb3RvdHlwZS5hbnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWRpY2F0ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U291cmNlKCkubGVuZ3RoXHJcbiAgICAgICAgICAgIDogRW51bWVyYWJsZS5wcm90b3R5cGUuY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS5lbGVtZW50QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcclxuICAgICAgICByZXR1cm4gKDAgPD0gaW5kZXggJiYgaW5kZXggPCBzb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICA/IHNvdXJjZVtpbmRleF1cclxuICAgICAgICAgICAgOiBFbnVtZXJhYmxlLnByb3RvdHlwZS5lbGVtZW50QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS5lbGVtZW50QXRPckRlZmF1bHQgPSBmdW5jdGlvbiAoaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkgZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcclxuICAgICAgICByZXR1cm4gKDAgPD0gaW5kZXggJiYgaW5kZXggPCBzb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICA/IHNvdXJjZVtpbmRleF1cclxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIEFycmF5RW51bWVyYWJsZS5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIChwcmVkaWNhdGUgPT0gbnVsbCAmJiBzb3VyY2UubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgPyBzb3VyY2VbMF1cclxuICAgICAgICAgICAgOiBFbnVtZXJhYmxlLnByb3RvdHlwZS5maXJzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBcnJheUVudW1lcmFibGUucHJvdG90eXBlLmZpcnN0T3JEZWZhdWx0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbnVtZXJhYmxlLnByb3RvdHlwZS5maXJzdE9yRGVmYXVsdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcmVkaWNhdGU7XHJcblxyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UubGVuZ3RoID4gMCA/IHNvdXJjZVswXSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xyXG4gICAgICAgIHJldHVybiAocHJlZGljYXRlID09IG51bGwgJiYgc291cmNlLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgID8gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICA6IEVudW1lcmFibGUucHJvdG90eXBlLmxhc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS5sYXN0T3JEZWZhdWx0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbnVtZXJhYmxlLnByb3RvdHlwZS5sYXN0T3JEZWZhdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByZWRpY2F0ZTtcclxuXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5sZW5ndGggPiAwID8gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGluZGV4ID0gKGNvdW50IDwgMCkgPyAwIDogY291bnQ7IH0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy55aWVsZFJldHVybihzb3VyY2VbaW5kZXgrK10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgRnVuY3Rpb25zLkJsYW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS50YWtlRXhjZXB0TGFzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFrZSh0aGlzLmdldFNvdXJjZSgpLmxlbmd0aCAtIGNvdW50KTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS50YWtlRnJvbUxhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5za2lwKHRoaXMuZ2V0U291cmNlKCkubGVuZ3RoIC0gY291bnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBcnJheUVudW1lcmFibGUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRW51bWVyYWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzb3VyY2UubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4ID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnlpZWxkUmV0dXJuKHNvdXJjZVstLWluZGV4XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBBcnJheUVudW1lcmFibGUucHJvdG90eXBlLnNlcXVlbmNlRXF1YWwgPSBmdW5jdGlvbiAoc2Vjb25kLCBjb21wYXJlU2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoKHNlY29uZCBpbnN0YW5jZW9mIEFycmF5RW51bWVyYWJsZSB8fCBzZWNvbmQgaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgICAgICAgJiYgY29tcGFyZVNlbGVjdG9yID09IG51bGxcclxuICAgICAgICAgICAgJiYgRW51bWVyYWJsZS5mcm9tKHNlY29uZCkuY291bnQoKSAhPSB0aGlzLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIEVudW1lcmFibGUucHJvdG90eXBlLnNlcXVlbmNlRXF1YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgQXJyYXlFbnVtZXJhYmxlLnByb3RvdHlwZS50b0pvaW5lZFN0cmluZyA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XHJcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgfHwgIShzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVudW1lcmFibGUucHJvdG90eXBlLnRvSm9pbmVkU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHNlcGFyYXRvciA9IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5qb2luKHNlcGFyYXRvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEFycmF5RW51bWVyYWJsZS5wcm90b3R5cGUuZ2V0RW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcclxuICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgLy8gZmFzdCBhbmQgc2ltcGxlIGVudW1lcmF0b3JcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjdXJyZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VbaW5kZXhdOyB9LFxyXG4gICAgICAgICAgICBtb3ZlTmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICsraW5kZXggPCBzb3VyY2UubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXNwb3NlOiBGdW5jdGlvbnMuQmxhbmtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBvcHRpbWl6YXRpb24gZm9yIG11bHRpcGxlIHdoZXJlIGFuZCBtdWx0aXBsZSBzZWxlY3QgYW5kIHdoZXJlc2VsZWN0XHJcblxyXG4gICAgdmFyIFdoZXJlRW51bWVyYWJsZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHRoaXMucHJldlNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnByZXZQcmVkaWNhdGUgPSBwcmVkaWNhdGU7IC8vIHByZWRpY2F0ZS5sZW5ndGggYWx3YXlzIDw9IDFcclxuICAgIH07XHJcbiAgICBXaGVyZUVudW1lcmFibGUucHJvdG90eXBlID0gbmV3IEVudW1lcmFibGUoKTtcclxuXHJcbiAgICBXaGVyZUVudW1lcmFibGUucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IFV0aWxzLmNyZWF0ZUxhbWJkYShwcmVkaWNhdGUpO1xyXG5cclxuICAgICAgICBpZiAocHJlZGljYXRlLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2UHJlZGljYXRlID0gdGhpcy5wcmV2UHJlZGljYXRlO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9zZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJldlByZWRpY2F0ZSh4KSAmJiBwcmVkaWNhdGUoeCk7IH07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVFbnVtZXJhYmxlKHRoaXMucHJldlNvdXJjZSwgY29tcG9zZWRQcmVkaWNhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgcHJlZGljYXRlIHVzZSBpbmRleCwgY2FuJ3QgY29tcG9zZVxyXG4gICAgICAgICAgICByZXR1cm4gRW51bWVyYWJsZS5wcm90b3R5cGUud2hlcmUuY2FsbCh0aGlzLCBwcmVkaWNhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgV2hlcmVFbnVtZXJhYmxlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBzZWxlY3RvciA9IFV0aWxzLmNyZWF0ZUxhbWJkYShzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgIHJldHVybiAoc2VsZWN0b3IubGVuZ3RoIDw9IDEpXHJcbiAgICAgICAgICAgID8gbmV3IFdoZXJlU2VsZWN0RW51bWVyYWJsZSh0aGlzLnByZXZTb3VyY2UsIHRoaXMucHJldlByZWRpY2F0ZSwgc2VsZWN0b3IpXHJcbiAgICAgICAgICAgIDogRW51bWVyYWJsZS5wcm90b3R5cGUuc2VsZWN0LmNhbGwodGhpcywgc2VsZWN0b3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBXaGVyZUVudW1lcmFibGUucHJvdG90eXBlLmdldEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHRoaXMucHJldlByZWRpY2F0ZTtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5wcmV2U291cmNlO1xyXG4gICAgICAgIHZhciBlbnVtZXJhdG9yO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGVudW1lcmF0b3IgPSBzb3VyY2UuZ2V0RW51bWVyYXRvcigpOyB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbnVtZXJhdG9yLmN1cnJlbnQoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRSZXR1cm4oZW51bWVyYXRvci5jdXJyZW50KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFdoZXJlU2VsZWN0RW51bWVyYWJsZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByZWRpY2F0ZSwgc2VsZWN0b3IpIHtcclxuICAgICAgICB0aGlzLnByZXZTb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wcmV2UHJlZGljYXRlID0gcHJlZGljYXRlOyAvLyBwcmVkaWNhdGUubGVuZ3RoIGFsd2F5cyA8PSAxIG9yIG51bGxcclxuICAgICAgICB0aGlzLnByZXZTZWxlY3RvciA9IHNlbGVjdG9yOyAvLyBzZWxlY3Rvci5sZW5ndGggYWx3YXlzIDw9IDFcclxuICAgIH07XHJcbiAgICBXaGVyZVNlbGVjdEVudW1lcmFibGUucHJvdG90eXBlID0gbmV3IEVudW1lcmFibGUoKTtcclxuXHJcbiAgICBXaGVyZVNlbGVjdEVudW1lcmFibGUucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IFV0aWxzLmNyZWF0ZUxhbWJkYShwcmVkaWNhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gKHByZWRpY2F0ZS5sZW5ndGggPD0gMSlcclxuICAgICAgICAgICAgPyBuZXcgV2hlcmVFbnVtZXJhYmxlKHRoaXMsIHByZWRpY2F0ZSlcclxuICAgICAgICAgICAgOiBFbnVtZXJhYmxlLnByb3RvdHlwZS53aGVyZS5jYWxsKHRoaXMsIHByZWRpY2F0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFdoZXJlU2VsZWN0RW51bWVyYWJsZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgc2VsZWN0b3IgPSBVdGlscy5jcmVhdGVMYW1iZGEoc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZWN0b3IubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgdmFyIHByZXZTZWxlY3RvciA9IHRoaXMucHJldlNlbGVjdG9yO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9zZWRTZWxlY3RvciA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiBzZWxlY3RvcihwcmV2U2VsZWN0b3IoeCkpOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlU2VsZWN0RW51bWVyYWJsZSh0aGlzLnByZXZTb3VyY2UsIHRoaXMucHJldlByZWRpY2F0ZSwgY29tcG9zZWRTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3RvciB1c2UgaW5kZXgsIGNhbid0IGNvbXBvc2VcclxuICAgICAgICAgICAgcmV0dXJuIEVudW1lcmFibGUucHJvdG90eXBlLnNlbGVjdC5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFdoZXJlU2VsZWN0RW51bWVyYWJsZS5wcm90b3R5cGUuZ2V0RW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5wcmV2UHJlZGljYXRlO1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMucHJldlNlbGVjdG9yO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnByZXZTb3VyY2U7XHJcbiAgICAgICAgdmFyIGVudW1lcmF0b3I7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgSUVudW1lcmF0b3IoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZW51bWVyYXRvciA9IHNvdXJjZS5nZXRFbnVtZXJhdG9yKCk7IH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlID09IG51bGwgfHwgcHJlZGljYXRlKGVudW1lcmF0b3IuY3VycmVudCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihzZWxlY3RvcihlbnVtZXJhdG9yLmN1cnJlbnQoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBVdGlscy5kaXNwb3NlKGVudW1lcmF0b3IpOyB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ29sbGVjdGlvbnNcclxuXHJcbiAgICB2YXIgRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3RhdGljIHV0aWxpdHkgbWV0aG9kc1xyXG4gICAgICAgIHZhciBjYWxsSGFzT3duUHJvcGVydHkgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGNvbXB1dGVIYXNoQ29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqLnRvU3RyaW5nID09PSBUeXBlcy5GdW5jdGlvbilcclxuICAgICAgICAgICAgICAgID8gb2JqLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gTGlua2VkTGlzdCBmb3IgRGljdGlvbmFyeVxyXG4gICAgICAgIHZhciBIYXNoRW50cnkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBFbnRyeUxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRW50cnlMaXN0LnByb3RvdHlwZSA9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhZGRMYXN0OiBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdC5uZXh0ID0gZW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucHJldiA9IHRoaXMubGFzdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBlbnRyeTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmZpcnN0ID0gdGhpcy5sYXN0ID0gZW50cnk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoZW50cnksIG5ld0VudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkucHJldiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucHJldi5uZXh0ID0gbmV3RW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RW50cnkucHJldiA9IGVudHJ5LnByZXY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5maXJzdCA9IG5ld0VudHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5uZXh0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5uZXh0LnByZXYgPSBuZXdFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFbnRyeS5uZXh0ID0gZW50cnkubmV4dDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmxhc3QgPSBuZXdFbnRyeTtcclxuXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnByZXYgIT0gbnVsbCkgZW50cnkucHJldi5uZXh0ID0gZW50cnkubmV4dDtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5maXJzdCA9IGVudHJ5Lm5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5Lm5leHQgIT0gbnVsbCkgZW50cnkubmV4dC5wcmV2ID0gZW50cnkucHJldjtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5sYXN0ID0gZW50cnkucHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE92ZXJsb2FkOmZ1bmN0aW9uKClcclxuICAgICAgICAvLyBPdmVybG9hZDpmdW5jdGlvbihjb21wYXJlU2VsZWN0b3IpXHJcbiAgICAgICAgdmFyIERpY3Rpb25hcnkgPSBmdW5jdGlvbiAoY29tcGFyZVNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnRGaWVsZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZW50cnlMaXN0ID0gbmV3IEVudHJ5TGlzdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHMgPSB7fTsgLy8gYXMgRGljdGlvbmFyeTxzdHJpbmcsTGlzdDxvYmplY3Q+PlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVTZWxlY3RvciA9IChjb21wYXJlU2VsZWN0b3IgPT0gbnVsbCkgPyBGdW5jdGlvbnMuSWRlbnRpdHkgOiBjb21wYXJlU2VsZWN0b3I7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZSA9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZUtleSA9IHRoaXMuY29tcGFyZVNlbGVjdG9yKGtleSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGNvbXB1dGVIYXNoQ29kZShjb21wYXJlS2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG5ldyBIYXNoRW50cnkoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbEhhc093blByb3BlcnR5KHRoaXMuYnVja2V0cywgaGFzaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmJ1Y2tldHNbaGFzaF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlU2VsZWN0b3IoYXJyYXlbaV0ua2V5KSA9PT0gY29tcGFyZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRyeUxpc3QucmVwbGFjZShhcnJheVtpXSwgZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBlbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWNrZXRzW2hhc2hdID0gW2VudHJ5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnRGaWVsZCsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRyeUxpc3QuYWRkTGFzdChlbnRyeSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlS2V5ID0gdGhpcy5jb21wYXJlU2VsZWN0b3Ioa2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gY29tcHV0ZUhhc2hDb2RlKGNvbXBhcmVLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsSGFzT3duUHJvcGVydHkodGhpcy5idWNrZXRzLCBoYXNoKSkgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmJ1Y2tldHNbaGFzaF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gYXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZVNlbGVjdG9yKGVudHJ5LmtleSkgPT09IGNvbXBhcmVLZXkpIHJldHVybiBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZUtleSA9IHRoaXMuY29tcGFyZVNlbGVjdG9yKGtleSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGNvbXB1dGVIYXNoQ29kZShjb21wYXJlS2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsSGFzT3duUHJvcGVydHkodGhpcy5idWNrZXRzLCBoYXNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuYnVja2V0c1toYXNoXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVTZWxlY3RvcihhcnJheVtpXS5rZXkpID09PSBjb21wYXJlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RW50cnkgPSBuZXcgSGFzaEVudHJ5KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRyeUxpc3QucmVwbGFjZShhcnJheVtpXSwgbmV3RW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBuZXdFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlS2V5ID0gdGhpcy5jb21wYXJlU2VsZWN0b3Ioa2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gY29tcHV0ZUhhc2hDb2RlKGNvbXBhcmVLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsSGFzT3duUHJvcGVydHkodGhpcy5idWNrZXRzLCBoYXNoKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuYnVja2V0c1toYXNoXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlU2VsZWN0b3IoYXJyYXlbaV0ua2V5KSA9PT0gY29tcGFyZUtleSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudEZpZWxkID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVja2V0cyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRyeUxpc3QgPSBuZXcgRW50cnlMaXN0KCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlS2V5ID0gdGhpcy5jb21wYXJlU2VsZWN0b3Ioa2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gY29tcHV0ZUhhc2hDb2RlKGNvbXBhcmVLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsSGFzT3duUHJvcGVydHkodGhpcy5idWNrZXRzLCBoYXNoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuYnVja2V0c1toYXNoXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlU2VsZWN0b3IoYXJyYXlbaV0ua2V5KSA9PT0gY29tcGFyZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVudHJ5TGlzdC5yZW1vdmUoYXJyYXlbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCkgZGVsZXRlIHRoaXMuYnVja2V0c1toYXNoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudEZpZWxkLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBjb3VudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnRGaWVsZDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHRvRW51bWVyYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEVudHJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElFbnVtZXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGN1cnJlbnRFbnRyeSA9IHNlbGYuZW50cnlMaXN0LmZpcnN0OyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVudHJ5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0geyBrZXk6IGN1cnJlbnRFbnRyeS5rZXksIHZhbHVlOiBjdXJyZW50RW50cnkudmFsdWUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkgPSBjdXJyZW50RW50cnkubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZFJldHVybihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBGdW5jdGlvbnMuQmxhbmspO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gRGljdGlvbmFyeTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZGljdGlvbmFyeSA9IERpY3Rpb25hcnk8VEtleSwgVFZhbHVlW10+XHJcbiAgICB2YXIgTG9va3VwID0gZnVuY3Rpb24gKGRpY3Rpb25hcnkpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGljdGlvbmFyeS5jb3VudCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbnVtZXJhYmxlLmZyb20oZGljdGlvbmFyeS5nZXQoa2V5KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGljdGlvbmFyeS5jb250YWlucyhrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50b0VudW1lcmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWN0aW9uYXJ5LnRvRW51bWVyYWJsZSgpLnNlbGVjdChmdW5jdGlvbiAoa3ZwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyb3VwaW5nKGt2cC5rZXksIGt2cC52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBHcm91cGluZyA9IGZ1bmN0aW9uIChncm91cEtleSwgZWxlbWVudHMpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwS2V5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQXJyYXlFbnVtZXJhYmxlLmNhbGwodGhpcywgZWxlbWVudHMpO1xyXG4gICAgfTtcclxuICAgIEdyb3VwaW5nLnByb3RvdHlwZSA9IG5ldyBBcnJheUVudW1lcmFibGUoKTtcclxuXHJcbiAgICAvLyBtb2R1bGUgZXhwb3J0XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gVHlwZXMuRnVuY3Rpb24gJiYgZGVmaW5lLmFtZCkgeyAvLyBBTURcclxuICAgICAgICBkZWZpbmUoXCJsaW5xanNcIiwgW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVudW1lcmFibGU7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gVHlwZXMuVW5kZWZpbmVkICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vIE5vZGVcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEVudW1lcmFibGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByb290LkVudW1lcmFibGUgPSBFbnVtZXJhYmxlO1xyXG4gICAgfVxyXG59KSh0aGlzKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBMb25nO1xyXG5cclxuLyoqXHJcbiAqIHdhc20gb3B0aW1pemF0aW9ucywgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXHJcbiAqL1xyXG52YXIgd2FzbSA9IG51bGw7XHJcblxyXG50cnkge1xyXG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXHJcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxyXG4gIF0pKSwge30pLmV4cG9ydHM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gKiBAZXhwb3J0cyBMb25nXHJcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbn1cclxuXHJcbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4vL1xyXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuLy9cclxuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4vKipcclxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgfVxyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgIHZhciBwO1xyXG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcclxuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk9ORSA9IE9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4vKipcclxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcclxuICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgcmVzID0gWkVSTztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgcmVtID0gdGhpcztcclxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgbnVtQml0cyAmPSA2MztcclxuICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAyNFxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBoaSA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmZcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1swXSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1szXSA8PCAyNCxcclxuICAgICAgICBieXRlc1s0XSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s3XSA8PCAyNCxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzRdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1s1XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzddLFxyXG4gICAgICAgIGJ5dGVzWzBdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1sxXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzNdLFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG52YXIgUmVmbGVjdDtcclxuKGZ1bmN0aW9uIChSZWZsZWN0KSB7XHJcbiAgICAvLyBNZXRhZGF0YSBQcm9wb3NhbFxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS9cclxuICAgIChmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XHJcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOlxyXG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCk7XHJcbiAgICAgICAgdmFyIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKFJlZmxlY3QpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygcm9vdC5SZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJvb3QuUmVmbGVjdCA9IFJlZmxlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihyb290LlJlZmxlY3QsIGV4cG9ydGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmFjdG9yeShleHBvcnRlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUV4cG9ydGVyKHRhcmdldCwgcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gICAgICAgIC8vIGZlYXR1cmUgdGVzdCBmb3IgU3ltYm9sIHN1cHBvcnRcclxuICAgICAgICB2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xyXG4gICAgICAgIHZhciBpdGVyYXRvclN5bWJvbCA9IHN1cHBvcnRzU3ltYm9sICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgOiBcIkBAaXRlcmF0b3JcIjtcclxuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxyXG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxyXG4gICAgICAgIHZhciBkb3duTGV2ZWwgPSAhc3VwcG9ydHNDcmVhdGUgJiYgIXN1cHBvcnRzUHJvdG87XHJcbiAgICAgICAgdmFyIEhhc2hNYXAgPSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvYmplY3QgaW4gZGljdGlvbmFyeSBtb2RlIChhLmsuYS4gXCJzbG93XCIgbW9kZSBpbiB2OClcclxuICAgICAgICAgICAgY3JlYXRlOiBzdXBwb3J0c0NyZWF0ZVxyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxyXG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0c1Byb3RvXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7IF9fcHJvdG9fXzogbnVsbCB9KTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9LFxyXG4gICAgICAgICAgICBoYXM6IGRvd25MZXZlbFxyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KTsgfVxyXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH0sXHJcbiAgICAgICAgICAgIGdldDogZG93bkxldmVsXHJcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7IH1cclxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExvYWQgZ2xvYmFsIG9yIHNoaW0gdmVyc2lvbnMgb2YgTWFwLCBTZXQsIGFuZCBXZWFrTWFwXHJcbiAgICAgICAgdmFyIGZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uKTtcclxuICAgICAgICB2YXIgdXNlUG9seWZpbGwgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudltcIlJFRkxFQ1RfTUVUQURBVEFfVVNFX01BUF9QT0xZRklMTFwiXSA9PT0gXCJ0cnVlXCI7XHJcbiAgICAgICAgdmFyIF9NYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IE1hcCA6IENyZWF0ZU1hcFBvbHlmaWxsKCk7XHJcbiAgICAgICAgdmFyIF9TZXQgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IFNldCA6IENyZWF0ZVNldFBvbHlmaWxsKCk7XHJcbiAgICAgICAgdmFyIF9XZWFrTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCk7XHJcbiAgICAgICAgLy8gW1tNZXRhZGF0YV1dIGludGVybmFsIHNsb3RcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcclxuICAgICAgICB2YXIgTWV0YWRhdGEgPSBuZXcgX1dlYWtNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIGEgc2V0IG9mIGRlY29yYXRvcnMgdG8gYSBwcm9wZXJ0eSBvZiBhIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIGRlY29yYXRvcnMgQW4gYXJyYXkgb2YgZGVjb3JhdG9ycy5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgdG8gZGVjb3JhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIHRhcmdldCBrZXkuXHJcbiAgICAgICAgICogQHJlbWFya3MgRGVjb3JhdG9ycyBhcmUgYXBwbGllZCBpbiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgRXhhbXBsZSA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIixcclxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIikpKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpKSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoYXR0cmlidXRlcykgJiYgIUlzVW5kZWZpbmVkKGF0dHJpYnV0ZXMpICYmICFJc051bGwoYXR0cmlidXRlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzTnVsbChhdHRyaWJ1dGVzKSlcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJkZWNvcmF0ZVwiLCBkZWNvcmF0ZSk7XHJcbiAgICAgICAgLy8gNC4xLjIgUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBkZWZhdWx0IG1ldGFkYXRhIGRlY29yYXRvciBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgb24gYSBjbGFzcywgY2xhc3MgbWVtYmVyLCBvciBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IFRoZSBrZXkgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cclxuICAgICAgICAgKiBAcmV0dXJucyBBIGRlY29yYXRvciBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgICAqIElmIGBtZXRhZGF0YUtleWAgaXMgYWxyZWFkeSBkZWZpbmVkIGZvciB0aGUgdGFyZ2V0IGFuZCB0YXJnZXQga2V5LCB0aGVcclxuICAgICAgICAgKiBtZXRhZGF0YVZhbHVlIGZvciB0aGF0IGtleSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IsIFR5cGVTY3JpcHQgb25seSlcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSwgVHlwZVNjcmlwdCBvbmx5KVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBwcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QoKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QoKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSAmJiAhSXNQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJtZXRhZGF0YVwiLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cclxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xyXG4gICAgICAgICAqICAgICAgICAgcmV0dXJuICh0YXJnZXQsIGtleT8pID0+IFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCB0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZGVmaW5lTWV0YWRhdGFcIiwgZGVmaW5lTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiaGFzTWV0YWRhdGFcIiwgaGFzTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3QgaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0OyBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNPd25NZXRhZGF0YVwiLCBoYXNPd25NZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImdldE1ldGFkYXRhXCIsIGdldE1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhXCIsIGdldE93bk1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFLZXlzXCIsIGdldE1ldGFkYXRhS2V5cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdW5pcXVlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0T3duTWV0YWRhdGFLZXlzXCIsIGdldE93bk1ldGFkYXRhS2V5cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyB0aGUgbWV0YWRhdGEgZW50cnkgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGVudHJ5IHdhcyBmb3VuZCBhbmQgZGVsZXRlZDsgb3RoZXJ3aXNlLCBmYWxzZS5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHByb3BlcnR5S2V5LCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YU1hcC5kZWxldGUobWV0YWRhdGFLZXkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFNYXAuc2l6ZSA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLmRlbGV0ZShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRNZXRhZGF0YS5zaXplID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBNZXRhZGF0YS5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZGVsZXRlTWV0YWRhdGFcIiwgZGVsZXRlTWV0YWRhdGEpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGRlY29yYXRlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIENyZWF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQoTyk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZCh0YXJnZXRNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBNZXRhZGF0YS5zZXQoTywgdGFyZ2V0TWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNtZXRhZGF0YVxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS4zLjEgT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG93bm1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS42LjEgT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcclxuICAgICAgICAgICAgdmFyIHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50S2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xyXG4gICAgICAgICAgICBpZiAob3duS2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRLZXlzO1xyXG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvd25LZXlzXzEgPSBvd25LZXlzOyBfaSA8IG93bktleXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyZW50S2V5c18xID0gcGFyZW50S2V5czsgX2EgPCBwYXJlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFyZW50S2V5c18xW19hXTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjcuMSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIHZhciBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihrZXlzT2JqKTtcclxuICAgICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXNba10gPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNiBFQ01BU2NyaXB0IERhdGEgVHlwMGVzIGFuZCBWYWx1ZXNcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xyXG4gICAgICAgIGZ1bmN0aW9uIFR5cGUoeCkge1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjogcmV0dXJuIDAgLyogVW5kZWZpbmVkICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIDMgLyogU3RyaW5nICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOiByZXR1cm4gNCAvKiBTeW1ib2wgKi87XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjogcmV0dXJuIHggPT09IG51bGwgPyAxIC8qIE51bGwgKi8gOiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuMSBUaGUgVW5kZWZpbmVkIFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNVbmRlZmluZWQoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuMiBUaGUgTnVsbCBUeXBlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1udWxsLXR5cGVcclxuICAgICAgICBmdW5jdGlvbiBJc051bGwoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1zeW1ib2wtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzU3ltYm9sKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuNyBUaGUgT2JqZWN0IFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzT2JqZWN0KHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiID8geCAhPT0gbnVsbCA6IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMSBUeXBlIENvbnZlcnNpb25cclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlLWNvbnZlcnNpb25cclxuICAgICAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxyXG4gICAgICAgIGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBVbmRlZmluZWQgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBOdWxsICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoaW50ID0gUHJlZmVycmVkVHlwZSA9PT0gMyAvKiBTdHJpbmcgKi8gPyBcInN0cmluZ1wiIDogUHJlZmVycmVkVHlwZSA9PT0gNSAvKiBOdW1iZXIgKi8gPyBcIm51bWJlclwiIDogXCJkZWZhdWx0XCI7XHJcbiAgICAgICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcclxuICAgICAgICAgICAgaWYgKGV4b3RpY1RvUHJpbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gXCJkZWZhdWx0XCIgPyBcIm51bWJlclwiIDogaGludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcclxuICAgICAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZ18xID0gTy50b1N0cmluZztcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18yLmNhbGwoTyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtdG9ib29sZWFuXHJcbiAgICAgICAgZnVuY3Rpb24gVG9Cb29sZWFuKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMTIgVG9TdHJpbmcoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcclxuICAgICAgICBmdW5jdGlvbiBUb1N0cmluZyhhcmd1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGFyZ3VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMTQgVG9Qcm9wZXJ0eUtleShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XHJcbiAgICAgICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gVG9QcmltaXRpdmUoYXJndW1lbnQsIDMgLyogU3RyaW5nICovKTtcclxuICAgICAgICAgICAgaWYgKElzU3ltYm9sKGtleSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gVG9TdHJpbmcoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlc3RpbmctYW5kLWNvbXBhcmlzb24tb3BlcmF0aW9uc1xyXG4gICAgICAgIC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxyXG4gICAgICAgIGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXlcclxuICAgICAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcclxuICAgICAgICAgICAgICAgIDogYXJndW1lbnQgaW5zdGFuY2VvZiBPYmplY3RcclxuICAgICAgICAgICAgICAgICAgICA/IGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXlcclxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yLjMgSXNDYWxsYWJsZShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNDYWxsYWJsZShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2QuXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yLjQgSXNDb25zdHJ1Y3Rvcihhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXHJcbiAgICAgICAgZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcclxuICAgICAgICBmdW5jdGlvbiBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShhcmd1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4zIE9wZXJhdGlvbnMgb24gT2JqZWN0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xyXG4gICAgICAgIC8vIDcuMy45IEdldE1ldGhvZChWLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxyXG4gICAgICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gVltQXTtcclxuICAgICAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xyXG4gICAgICAgIGZ1bmN0aW9uIEdldEl0ZXJhdG9yKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgaXRlcmF0b3JTeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gZnJvbSBDYWxsXHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC40IEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLWl0ZXJhdG9ydmFsdWVcclxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcnN0ZXBcclxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gZmFsc2UgOiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JjbG9zZVxyXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcclxuICAgICAgICAgICAgaWYgKGYpXHJcbiAgICAgICAgICAgICAgICBmLmNhbGwoaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA5LjEgT3JkaW5hcnkgT2JqZWN0IEludGVybmFsIE1ldGhvZHMgYW5kIEludGVybmFsIFNsb3RzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXHJcbiAgICAgICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnlnZXRwcm90b3R5cGVvZlxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTykge1xyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTyAhPT0gXCJmdW5jdGlvblwiIHx8IE8gPT09IGZ1bmN0aW9uUHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLiBDb21wYXRpYmxlIGltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgICAgICAvLyBtdXN0IGVpdGhlciBzZXQgX19wcm90b19fIG9uIGEgc3ViY2xhc3MgY29uc3RydWN0b3IgdG8gdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XHJcbiAgICAgICAgICAgIC8vIHBvaW50cyBiYWNrIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgRnVuY3Rpb24uW1tQcm90b3R5cGVdXSwgdGhlbiB0aGlzIGlzIGRlZmluYXRlbHkgaW5oZXJpdGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxyXG4gICAgICAgICAgICBpZiAocHJvdG8gIT09IGZ1bmN0aW9uUHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IE8ucHJvdG90eXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlUHJvdG8gPSBwcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5haXZlIE1hcCBzaGltXHJcbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlTWFwUG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XHJcbiAgICAgICAgICAgIHZhciBhcnJheVNlbnRpbmVsID0gW107XHJcbiAgICAgICAgICAgIHZhciBNYXBJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihrZXlzLCB2YWx1ZXMsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3NlbGVjdG9yKHRoaXMuX2tleXNbaW5kZXhdLCB0aGlzLl92YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA+PSB0aGlzLl9rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleXMubGVuZ3RoOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpID49IDA7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl92YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXNbaSAtIDFdID0gdGhpcy5fa2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpIC0gMV0gPSB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLl9jYWNoZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRLZXkpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRWYWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRFbnRyeSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuX2ZpbmQgPSBmdW5jdGlvbiAoa2V5LCBpbnNlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXkgIT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKHRoaXMuX2NhY2hlS2V5ID0ga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlSW5kZXggPCAwICYmIGluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRLZXkoa2V5LCBfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKF8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYWl2ZSBTZXQgc2hpbVxyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVNldFBvbHlmaWxsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLnNldCh2YWx1ZSwgdmFsdWUpLCB0aGlzOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWFwLmNsZWFyKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAua2V5cygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0O1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cclxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHZhciBVVUlEX1NJWkUgPSAxNjtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEtleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuaGFzKHRhYmxlLCB0aGlzLl9rZXkpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0YWJsZVt0aGlzLl9rZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVW5pcXVlS2V5KCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJAQFdlYWtNYXBAQFwiICsgQ3JlYXRlVVVJRCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xyXG4gICAgICAgICAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCBjcmVhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwodGFyZ2V0LCByb290S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHJvb3RLZXksIHsgdmFsdWU6IEhhc2hNYXAuY3JlYXRlKCkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Jvb3RLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAweGZmIHwgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gR2VuUmFuZG9tQnl0ZXMoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgQXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEdlblJhbmRvbUJ5dGVzKFVVSURfU0laRSk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIHJhbmRvbSAtIFJGQyA0MTIyIMKnIDQuNFxyXG4gICAgICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcclxuICAgICAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdICYgMHhiZiB8IDB4ODA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdGFbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSA0IHx8IG9mZnNldCA9PT0gNiB8fCBvZmZzZXQgPT09IDgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZSA8IDE2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVzZXMgYSBoZXVyaXN0aWMgdXNlZCBieSB2OCBhbmQgY2hha3JhIHRvIGZvcmNlIGFuIG9iamVjdCBpbnRvIGRpY3Rpb25hcnkgbW9kZS5cclxuICAgICAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcclxuICAgICAgICAgICAgb2JqLl9fID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBkZWxldGUgb2JqLl9fO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmbGVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4vU3ViamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogQGNsYXNzIEFzeW5jU3ViamVjdDxUPlxuICovXG52YXIgQXN5bmNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU3ViamVjdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc05leHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzQ29tcGxldGVkICYmIHRoaXMuaGFzTmV4dCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBBc3luY1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmhhc05leHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY1N1YmplY3Q7XG59KFN1YmplY3RfMS5TdWJqZWN0KSk7XG5leHBvcnRzLkFzeW5jU3ViamVjdCA9IEFzeW5jU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jU3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4vU3ViamVjdCcpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbi8qKlxuICogQGNsYXNzIEJlaGF2aW9yU3ViamVjdDxUPlxuICovXG52YXIgQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmVoYXZpb3JTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJlaGF2aW9yU3ViamVjdChfdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uICYmICFzdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy50aHJvd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlID0gdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEJlaGF2aW9yU3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuQmVoYXZpb3JTdWJqZWN0ID0gQmVoYXZpb3JTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmVoYXZpb3JTdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElubmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElubmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbm5lclN1YnNjcmliZXIocGFyZW50LCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5vdXRlclZhbHVlID0gb3V0ZXJWYWx1ZTtcbiAgICAgICAgdGhpcy5vdXRlckluZGV4ID0gb3V0ZXJJbmRleDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5TmV4dCh0aGlzLm91dGVyVmFsdWUsIHZhbHVlLCB0aGlzLm91dGVySW5kZXgsIHRoaXMuaW5kZXgrKywgdGhpcyk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlFcnJvcihlcnJvciwgdGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlDb21wbGV0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIElubmVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuSW5uZXJTdWJzY3JpYmVyID0gSW5uZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZXJTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHVzaC1iYXNlZCBldmVudCBvciB2YWx1ZSB0aGF0IGFuIHtAbGluayBPYnNlcnZhYmxlfSBjYW4gZW1pdC5cbiAqIFRoaXMgY2xhc3MgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igb3BlcmF0b3JzIHRoYXQgbWFuYWdlIG5vdGlmaWNhdGlvbnMsXG4gKiBsaWtlIHtAbGluayBtYXRlcmlhbGl6ZX0sIHtAbGluayBkZW1hdGVyaWFsaXplfSwge0BsaW5rIG9ic2VydmVPbn0sIGFuZFxuICogb3RoZXJzLiBCZXNpZGVzIHdyYXBwaW5nIHRoZSBhY3R1YWwgZGVsaXZlcmVkIHZhbHVlLCBpdCBhbHNvIGFubm90YXRlcyBpdFxuICogd2l0aCBtZXRhZGF0YSBvZiwgZm9yIGluc3RhbmNlLCB3aGF0IHR5cGUgb2YgcHVzaCBtZXNzYWdlIGl0IGlzIChgbmV4dGAsXG4gKiBgZXJyb3JgLCBvciBgY29tcGxldGVgKS5cbiAqXG4gKiBAc2VlIHtAbGluayBtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIGRlbWF0ZXJpYWxpemV9XG4gKiBAc2VlIHtAbGluayBvYnNlcnZlT259XG4gKlxuICogQGNsYXNzIE5vdGlmaWNhdGlvbjxUPlxuICovXG52YXIgTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb24oa2luZCwgdmFsdWUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0ga2luZCA9PT0gJ04nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxpdmVycyB0byB0aGUgZ2l2ZW4gYG9ic2VydmVyYCB0aGUgdmFsdWUgd3JhcHBlZCBieSB0aGlzIE5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlclxuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuY29tcGxldGUgJiYgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gc29tZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrcywgZGVsaXZlciB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICogY3VycmVudCBOb3RpZmljYXRpb24gdG8gdGhlIGNvcnJlY3RseSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0IEFuIE9ic2VydmVyIGBuZXh0YCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogYW55KTogdm9pZH0gW2Vycm9yXSBBbiBPYnNlcnZlciBgZXJyb3JgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBBbiBPYnNlcnZlciBgY29tcGxldGVgIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmRvID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCAmJiBuZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlICYmIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIE9ic2VydmVyIG9yIGl0cyBpbmRpdmlkdWFsIGNhbGxiYWNrIGZ1bmN0aW9ucywgYW5kIGNhbGxzIGBvYnNlcnZlYFxuICAgICAqIG9yIGBkb2AgbWV0aG9kcyBhY2NvcmRpbmdseS5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gbmV4dE9yT2JzZXJ2ZXIgQW4gT2JzZXJ2ZXIgb3JcbiAgICAgKiB0aGUgYG5leHRgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyICYmIHR5cGVvZiBuZXh0T3JPYnNlcnZlci5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBqdXN0IGRlbGl2ZXJzIHRoZSBub3RpZmljYXRpb24gcmVwcmVzZW50ZWRcbiAgICAgKiBieSB0aGlzIE5vdGlmaWNhdGlvbiBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vZih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aHJvdyh0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBub3RpZmljYXRpb24ga2luZCB2YWx1ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYG5leHRgIGZyb20gYVxuICAgICAqIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcIm5leHRcIiBOb3RpZmljYXRpb24gcmVwcmVzZW50aW5nIHRoZVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignTicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm90aWZpY2F0aW9uLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGVycm9yYCBmcm9tIGFcbiAgICAgKiBnaXZlbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXJyb3IuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJlcnJvclwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBjb21wbGV0ZWAuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPGFueT59IFRoZSB2YWx1ZWxlc3MgXCJjb21wbGV0ZVwiIE5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOb3RpZmljYXRpb24uY29tcGxldGVOb3RpZmljYXRpb247XG4gICAgfTtcbiAgICBOb3RpZmljYXRpb24uY29tcGxldGVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdDJyk7XG4gICAgTm90aWZpY2F0aW9uLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignTicsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vdGlmaWNhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL29ic2VydmFibGUnKTtcbnZhciBwaXBlXzEgPSByZXF1aXJlKCcuL3V0aWwvcGlwZScpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFueSBzZXQgb2YgdmFsdWVzIG92ZXIgYW55IGFtb3VudCBvZiB0aW1lLiBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIGJ1aWxkaW5nIGJsb2NrXG4gKiBvZiBSeEpTLlxuICpcbiAqIEBjbGFzcyBPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmUgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGFuIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlIGFuZCByZWdpc3RlcnMgT2JzZXJ2ZXIgaGFuZGxlcnMgZm9yIG5vdGlmaWNhdGlvbnMgaXQgd2lsbCBlbWl0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlVzZSBpdCB3aGVuIHlvdSBoYXZlIGFsbCB0aGVzZSBPYnNlcnZhYmxlcywgYnV0IHN0aWxsIG5vdGhpbmcgaXMgaGFwcGVuaW5nLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIGBzdWJzY3JpYmVgIGlzIG5vdCBhIHJlZ3VsYXIgb3BlcmF0b3IsIGJ1dCBhIG1ldGhvZCB0aGF0IGNhbGxzIE9ic2VydmFibGUncyBpbnRlcm5hbCBgc3Vic2NyaWJlYCBmdW5jdGlvbi4gSXRcbiAgICAgKiBtaWdodCBiZSBmb3IgZXhhbXBsZSBhIGZ1bmN0aW9uIHRoYXQgeW91IHBhc3NlZCB0byBhIHtAbGluayBjcmVhdGV9IHN0YXRpYyBmYWN0b3J5LCBidXQgbW9zdCBvZiB0aGUgdGltZSBpdCBpc1xuICAgICAqIGEgbGlicmFyeSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggZGVmaW5lcyB3aGF0IGFuZCB3aGVuIHdpbGwgYmUgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgICAqIGBzdWJzY3JpYmVgIGlzIGFjdHVhbGx5IHRoZSBtb21lbnQgd2hlbiBPYnNlcnZhYmxlIHN0YXJ0cyBpdHMgd29yaywgbm90IHdoZW4gaXQgaXMgY3JlYXRlZCwgYXMgaXQgaXMgb2Z0ZW5cbiAgICAgKiB0aG91Z2h0LlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzdGFydGluZyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUsIHRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gbGlzdGVuIGZvciB2YWx1ZXNcbiAgICAgKiB0aGF0IGFuIE9ic2VydmFibGUgZW1pdHMsIGFzIHdlbGwgYXMgZm9yIHdoZW4gaXQgY29tcGxldGVzIG9yIGVycm9ycy4gWW91IGNhbiBhY2hpZXZlIHRoaXMgaW4gdHdvXG4gICAgICogZm9sbG93aW5nIHdheXMuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgd2F5IGlzIGNyZWF0aW5nIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMge0BsaW5rIE9ic2VydmVyfSBpbnRlcmZhY2UuIEl0IHNob3VsZCBoYXZlIG1ldGhvZHNcbiAgICAgKiBkZWZpbmVkIGJ5IHRoYXQgaW50ZXJmYWNlLCBidXQgbm90ZSB0aGF0IGl0IHNob3VsZCBiZSBqdXN0IGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCwgd2hpY2ggeW91IGNhbiBjcmVhdGVcbiAgICAgKiB5b3Vyc2VsZiBpbiBhbnkgd2F5IHlvdSB3YW50IChFUzYgY2xhc3MsIGNsYXNzaWMgZnVuY3Rpb24gY29uc3RydWN0b3IsIG9iamVjdCBsaXRlcmFsIGV0Yy4pLiBJbiBwYXJ0aWN1bGFyIGRvXG4gICAgICogbm90IGF0dGVtcHQgdG8gdXNlIGFueSBSeEpTIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdG8gY3JlYXRlIE9ic2VydmVycyAtIHlvdSBkb24ndCBuZWVkIHRoZW0uIFJlbWVtYmVyIGFsc29cbiAgICAgKiB0aGF0IHlvdXIgb2JqZWN0IGRvZXMgbm90IGhhdmUgdG8gaW1wbGVtZW50IGFsbCBtZXRob2RzLiBJZiB5b3UgZmluZCB5b3Vyc2VsZiBjcmVhdGluZyBhIG1ldGhvZCB0aGF0IGRvZXNuJ3RcbiAgICAgKiBkbyBhbnl0aGluZywgeW91IGNhbiBzaW1wbHkgb21pdCBpdC4gTm90ZSBob3dldmVyLCB0aGF0IGlmIGBlcnJvcmAgbWV0aG9kIGlzIG5vdCBwcm92aWRlZCwgYWxsIGVycm9ycyB3aWxsXG4gICAgICogYmUgbGVmdCB1bmNhdWdodC5cbiAgICAgKlxuICAgICAqIFRoZSBzZWNvbmQgd2F5IGlzIHRvIGdpdmUgdXAgb24gT2JzZXJ2ZXIgb2JqZWN0IGFsdG9nZXRoZXIgYW5kIHNpbXBseSBwcm92aWRlIGNhbGxiYWNrIGZ1bmN0aW9ucyBpbiBwbGFjZSBvZiBpdHMgbWV0aG9kcy5cbiAgICAgKiBUaGlzIG1lYW5zIHlvdSBjYW4gcHJvdmlkZSB0aHJlZSBmdW5jdGlvbnMgYXMgYXJndW1lbnRzIHRvIGBzdWJzY3JpYmVgLCB3aGVyZSBmaXJzdCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50XG4gICAgICogb2YgYSBgbmV4dGAgbWV0aG9kLCBzZWNvbmQgb2YgYW4gYGVycm9yYCBtZXRob2QgYW5kIHRoaXJkIG9mIGEgYGNvbXBsZXRlYCBtZXRob2QuIEp1c3QgYXMgaW4gY2FzZSBvZiBPYnNlcnZlcixcbiAgICAgKiBpZiB5b3UgZG8gbm90IG5lZWQgdG8gbGlzdGVuIGZvciBzb21ldGhpbmcsIHlvdSBjYW4gb21pdCBhIGZ1bmN0aW9uLCBwcmVmZXJhYmx5IGJ5IHBhc3NpbmcgYHVuZGVmaW5lZGAgb3IgYG51bGxgLFxuICAgICAqIHNpbmNlIGBzdWJzY3JpYmVgIHJlY29nbml6ZXMgdGhlc2UgZnVuY3Rpb25zIGJ5IHdoZXJlIHRoZXkgd2VyZSBwbGFjZWQgaW4gZnVuY3Rpb24gY2FsbC4gV2hlbiBpdCBjb21lc1xuICAgICAqIHRvIGBlcnJvcmAgZnVuY3Rpb24sIGp1c3QgYXMgYmVmb3JlLCBpZiBub3QgcHJvdmlkZWQsIGVycm9ycyBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUgd2lsbCBiZSB0aHJvd24uXG4gICAgICpcbiAgICAgKiBXaGF0ZXZlciBzdHlsZSBvZiBjYWxsaW5nIGBzdWJzY3JpYmVgIHlvdSB1c2UsIGluIGJvdGggY2FzZXMgaXQgcmV0dXJucyBhIFN1YnNjcmlwdGlvbiBvYmplY3QuXG4gICAgICogVGhpcyBvYmplY3QgYWxsb3dzIHlvdSB0byBjYWxsIGB1bnN1YnNjcmliZWAgb24gaXQsIHdoaWNoIGluIHR1cm4gd2lsbCBzdG9wIHdvcmsgdGhhdCBhbiBPYnNlcnZhYmxlIGRvZXMgYW5kIHdpbGwgY2xlYW5cbiAgICAgKiB1cCBhbGwgcmVzb3VyY2VzIHRoYXQgYW4gT2JzZXJ2YWJsZSB1c2VkLiBOb3RlIHRoYXQgY2FuY2VsbGluZyBhIHN1YnNjcmlwdGlvbiB3aWxsIG5vdCBjYWxsIGBjb21wbGV0ZWAgY2FsbGJhY2tcbiAgICAgKiBwcm92aWRlZCB0byBgc3Vic2NyaWJlYCBmdW5jdGlvbiwgd2hpY2ggaXMgcmVzZXJ2ZWQgZm9yIGEgcmVndWxhciBjb21wbGV0aW9uIHNpZ25hbCB0aGF0IGNvbWVzIGZyb20gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIFJlbWVtYmVyIHRoYXQgY2FsbGJhY2tzIHByb3ZpZGVkIHRvIGBzdWJzY3JpYmVgIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuXG4gICAgICogSXQgaXMgYW4gT2JzZXJ2YWJsZSBpdHNlbGYgdGhhdCBkZWNpZGVzIHdoZW4gdGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkLiBGb3IgZXhhbXBsZSB7QGxpbmsgb2Z9XG4gICAgICogYnkgZGVmYXVsdCBlbWl0cyBhbGwgaXRzIHZhbHVlcyBzeW5jaHJvbm91c2x5LiBBbHdheXMgY2hlY2sgZG9jdW1lbnRhdGlvbiBmb3IgaG93IGdpdmVuIE9ic2VydmFibGVcbiAgICAgKiB3aWxsIGJlaGF2ZSB3aGVuIHN1YnNjcmliZWQgYW5kIGlmIGl0cyBkZWZhdWx0IGJlaGF2aW9yIGNhbiBiZSBtb2RpZmllZCB3aXRoIGEge0BsaW5rIFNjaGVkdWxlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdWJzY3JpYmUgd2l0aCBhbiBPYnNlcnZlcjwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCBzdW1PYnNlcnZlciA9IHtcbiAgICAgKiAgIHN1bTogMCxcbiAgICAgKiAgIG5leHQodmFsdWUpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0FkZGluZzogJyArIHZhbHVlKTtcbiAgICAgKiAgICAgdGhpcy5zdW0gPSB0aGlzLnN1bSArIHZhbHVlO1xuICAgICAqICAgfSxcbiAgICAgKiAgIGVycm9yKCkgeyAvLyBXZSBhY3R1YWxseSBjb3VsZCBqdXN0IHJlbW92ZSB0aGlzIG1ldGhvZCxcbiAgICAgKiAgIH0sICAgICAgICAvLyBzaW5jZSB3ZSBkbyBub3QgcmVhbGx5IGNhcmUgYWJvdXQgZXJyb3JzIHJpZ2h0IG5vdy5cbiAgICAgKiAgIGNvbXBsZXRlKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnU3VtIGVxdWFsczogJyArIHRoaXMuc3VtKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogUnguT2JzZXJ2YWJsZS5vZigxLCAyLCAzKSAvLyBTeW5jaHJvbm91c2x5IGVtaXRzIDEsIDIsIDMgYW5kIHRoZW4gY29tcGxldGVzLlxuICAgICAqIC5zdWJzY3JpYmUoc3VtT2JzZXJ2ZXIpO1xuICAgICAqXG4gICAgICogLy8gTG9nczpcbiAgICAgKiAvLyBcIkFkZGluZzogMVwiXG4gICAgICogLy8gXCJBZGRpbmc6IDJcIlxuICAgICAqIC8vIFwiQWRkaW5nOiAzXCJcbiAgICAgKiAvLyBcIlN1bSBlcXVhbHM6IDZcIlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdWJzY3JpYmUgd2l0aCBmdW5jdGlvbnM8L2NhcHRpb24+XG4gICAgICogbGV0IHN1bSA9IDA7XG4gICAgICpcbiAgICAgKiBSeC5PYnNlcnZhYmxlLm9mKDEsIDIsIDMpXG4gICAgICogLnN1YnNjcmliZShcbiAgICAgKiAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdBZGRpbmc6ICcgKyB2YWx1ZSk7XG4gICAgICogICAgIHN1bSA9IHN1bSArIHZhbHVlO1xuICAgICAqICAgfSxcbiAgICAgKiAgIHVuZGVmaW5lZCxcbiAgICAgKiAgIGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnU3VtIGVxdWFsczogJyArIHN1bSk7XG4gICAgICogICB9XG4gICAgICogKTtcbiAgICAgKlxuICAgICAqIC8vIExvZ3M6XG4gICAgICogLy8gXCJBZGRpbmc6IDFcIlxuICAgICAqIC8vIFwiQWRkaW5nOiAyXCJcbiAgICAgKiAvLyBcIkFkZGluZzogM1wiXG4gICAgICogLy8gXCJTdW0gZXF1YWxzOiA2XCJcbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q2FuY2VsIGEgc3Vic2NyaXB0aW9uPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkuc3Vic2NyaWJlKFxuICAgICAqICAgbnVtID0+IGNvbnNvbGUubG9nKG51bSksXG4gICAgICogICB1bmRlZmluZWQsXG4gICAgICogICAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGVkIScpIC8vIFdpbGwgbm90IGJlIGNhbGxlZCwgZXZlblxuICAgICAqICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbmNlbGxpbmcgc3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKlxuICAgICAqIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAqICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICogICBjb25zb2xlLmxvZygndW5zdWJzY3JpYmVkIScpO1xuICAgICAqIH0sIDI1MDApO1xuICAgICAqXG4gICAgICogLy8gTG9nczpcbiAgICAgKiAvLyAwIGFmdGVyIDFzXG4gICAgICogLy8gMSBhZnRlciAyc1xuICAgICAqIC8vIFwidW5zdWJzY3JpYmVkIVwiIGFmdGVyIDIuNXNcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxGdW5jdGlvbn0gb2JzZXJ2ZXJPck5leHQgKG9wdGlvbmFsKSBFaXRoZXIgYW4gb2JzZXJ2ZXIgd2l0aCBtZXRob2RzIHRvIGJlIGNhbGxlZCxcbiAgICAgKiAgb3IgdGhlIGZpcnN0IG9mIHRocmVlIHBvc3NpYmxlIGhhbmRsZXJzLCB3aGljaCBpcyB0aGUgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGZyb20gdGhlIHN1YnNjcmliZWRcbiAgICAgKiAgT2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAob3B0aW9uYWwpIEEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBhbiBlcnJvci4gSWYgbm8gZXJyb3IgaGFuZGxlciBpcyBwcm92aWRlZCxcbiAgICAgKiAgdGhlIGVycm9yIHdpbGwgYmUgdGhyb3duIGFzIHVuaGFuZGxlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wbGV0ZSAob3B0aW9uYWwpIEEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybiB7SVN1YnNjcmlwdGlvbn0gYSBzdWJzY3JpcHRpb24gcmVmZXJlbmNlIHRvIHRoZSByZWdpc3RlcmVkIGhhbmRsZXJzXG4gICAgICogQG1ldGhvZCBzdWJzY3JpYmVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuc291cmNlIHx8ICFzaW5rLnN5bmNFcnJvclRocm93YWJsZSA/IHRoaXMuX3N1YnNjcmliZShzaW5rKSA6IHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBkZWNsYXJlZCBpbiBhIHNlcGFyYXRlIHN0YXRlbWVudCB0byBhdm9pZCBhIFJlZmVybmNlRXJyb3Igd2hlblxuICAgICAgICAgICAgLy8gYWNjZXNzaW5nIHN1YnNjcmlwdGlvbiBiZWxvdyBpbiB0aGUgY2xvc3VyZSBkdWUgdG8gVGVtcG9yYWwgRGVhZCBab25lLlxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN0aXRjaCB0b2dldGhlciBmdW5jdGlvbmFsIG9wZXJhdG9ycyBpbnRvIGEgY2hhaW4uXG4gICAgICogQG1ldGhvZCBwaXBlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhlIE9ic2VydmFibGUgcmVzdWx0IG9mIGFsbCBvZiB0aGUgb3BlcmF0b3JzIGhhdmluZ1xuICAgICAqIGJlZW4gY2FsbGVkIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcGFzc2VkIGluLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGltcG9ydCB7IG1hcCwgZmlsdGVyLCBzY2FuIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuICAgICAqXG4gICAgICogUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKVxuICAgICAqICAgLnBpcGUoXG4gICAgICogICAgIGZpbHRlcih4ID0+IHggJSAyID09PSAwKSxcbiAgICAgKiAgICAgbWFwKHggPT4geCArIHgpLFxuICAgICAqICAgICBzY2FuKChhY2MsIHgpID0+IGFjYyArIHgpXG4gICAgICogICApXG4gICAgICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZV8xLnBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykodGhpcyk7XG4gICAgfTtcbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChQcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gdmFsdWUgPSB4OyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEhBQ0s6IFNpbmNlIFR5cGVTY3JpcHQgaW5oZXJpdHMgc3RhdGljIHByb3BlcnRpZXMgdG9vLCB3ZSBoYXZlIHRvXG4gICAgLy8gZmlnaHQgYWdhaW5zdCBUeXBlU2NyaXB0IGhlcmUgc28gU3ViamVjdCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBzdGF0aWMgY3JlYXRlIHNpZ25hdHVyZVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sZCBPYnNlcnZhYmxlIGJ5IGNhbGxpbmcgdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlPyB0aGUgc3Vic2NyaWJlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBjb2xkIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT3V0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT3V0ZXJTdWJzY3JpYmVyID0gT3V0ZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi9TdWJqZWN0Jyk7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL3F1ZXVlJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvb2JzZXJ2ZU9uJyk7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3ViamVjdFN1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgUmVwbGF5U3ViamVjdDxUPlxuICovXG52YXIgUmVwbGF5U3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGxheVN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHZvaWQgMCkgeyBidWZmZXJTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIGlmICh3aW5kb3dUaW1lID09PSB2b2lkIDApIHsgd2luZG93VGltZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9idWZmZXJTaXplID0gYnVmZmVyU2l6ZSA8IDEgPyAxIDogYnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5fd2luZG93VGltZSA9IHdpbmRvd1RpbWUgPCAxID8gMSA6IHdpbmRvd1RpbWU7XG4gICAgfVxuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuX2dldE5vdygpO1xuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChuZXcgUmVwbGF5RXZlbnQobm93LCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF9ldmVudHMgPSB0aGlzLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb247XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc3Vic2NyaWJlciA9IG5ldyBvYnNlcnZlT25fMS5PYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHNjaGVkdWxlcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBfZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChfZXZlbnRzW2ldLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fZ2V0Tm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2NoZWR1bGVyIHx8IHF1ZXVlXzEucXVldWUpLm5vdygpO1xuICAgIH07XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5fZ2V0Tm93KCk7XG4gICAgICAgIHZhciBfYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlclNpemU7XG4gICAgICAgIHZhciBfd2luZG93VGltZSA9IHRoaXMuX3dpbmRvd1RpbWU7XG4gICAgICAgIHZhciBfZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICB2YXIgZXZlbnRzQ291bnQgPSBfZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHNwbGljZUNvdW50ID0gMDtcbiAgICAgICAgLy8gVHJpbSBldmVudHMgdGhhdCBmYWxsIG91dCBvZiB0aGUgdGltZSB3aW5kb3cuXG4gICAgICAgIC8vIFN0YXJ0IGF0IHRoZSBmcm9udCBvZiB0aGUgbGlzdC4gQnJlYWsgZWFybHkgb25jZVxuICAgICAgICAvLyB3ZSBlbmNvdW50ZXIgYW4gZXZlbnQgdGhhdCBmYWxscyB3aXRoaW4gdGhlIHdpbmRvdy5cbiAgICAgICAgd2hpbGUgKHNwbGljZUNvdW50IDwgZXZlbnRzQ291bnQpIHtcbiAgICAgICAgICAgIGlmICgobm93IC0gX2V2ZW50c1tzcGxpY2VDb3VudF0udGltZSkgPCBfd2luZG93VGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BsaWNlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRzQ291bnQgPiBfYnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgc3BsaWNlQ291bnQgPSBNYXRoLm1heChzcGxpY2VDb3VudCwgZXZlbnRzQ291bnQgLSBfYnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGljZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgX2V2ZW50cy5zcGxpY2UoMCwgc3BsaWNlQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZXZlbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGxheVN1YmplY3Q7XG59KFN1YmplY3RfMS5TdWJqZWN0KSk7XG5leHBvcnRzLlJlcGxheVN1YmplY3QgPSBSZXBsYXlTdWJqZWN0O1xudmFyIFJlcGxheUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBsYXlFdmVudCh0aW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSZXBsYXlFdmVudDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXlTdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBleGVjdXRpb24gY29udGV4dCBhbmQgYSBkYXRhIHN0cnVjdHVyZSB0byBvcmRlciB0YXNrcyBhbmQgc2NoZWR1bGUgdGhlaXJcbiAqIGV4ZWN1dGlvbi4gUHJvdmlkZXMgYSBub3Rpb24gb2YgKHBvdGVudGlhbGx5IHZpcnR1YWwpIHRpbWUsIHRocm91Z2ggdGhlXG4gKiBgbm93KClgIGdldHRlciBtZXRob2QuXG4gKlxuICogRWFjaCB1bml0IG9mIHdvcmsgaW4gYSBTY2hlZHVsZXIgaXMgY2FsbGVkIGFuIHtAbGluayBBY3Rpb259LlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBTY2hlZHVsZXIge1xuICogICBub3coKTogbnVtYmVyO1xuICogICBzY2hlZHVsZSh3b3JrLCBkZWxheT8sIHN0YXRlPyk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBTY2hlZHVsZXJcbiAqL1xudmFyIFNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgICAgIGlmIChub3cgPT09IHZvaWQgMCkgeyBub3cgPSBTY2hlZHVsZXIubm93OyB9XG4gICAgICAgIHRoaXMuU2NoZWR1bGVyQWN0aW9uID0gU2NoZWR1bGVyQWN0aW9uO1xuICAgICAgICB0aGlzLm5vdyA9IG5vdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24sIGB3b3JrYCwgZm9yIGV4ZWN1dGlvbi4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluXG4gICAgICogdGhlIGZ1dHVyZSwgYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGB3b3JrYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBnaXZlbiBhcmd1bWVudHMgd2lsbCBiZSBwcm9jZXNzZWQgYW4gc3RvcmVkIGFzIGFuIEFjdGlvbiBvYmplY3QgaW4gYVxuICAgICAqIHF1ZXVlIG9mIGFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0YXRlOiA/VCk6ID9TdWJzY3JpcHRpb259IHdvcmsgQSBmdW5jdGlvbiByZXByZXNlbnRpbmcgYVxuICAgICAqIHRhc2ssIG9yIHNvbWUgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gQSBzdWJzY3JpcHRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1bnN1YnNjcmliZVxuICAgICAqIHRoZSBzY2hlZHVsZWQgd29yay5cbiAgICAgKi9cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgU2NoZWR1bGVyLm5vdyA9IERhdGUubm93ID8gRGF0ZS5ub3cgOiBmdW5jdGlvbiAoKSB7IHJldHVybiArbmV3IERhdGUoKTsgfTtcbiAgICByZXR1cm4gU2NoZWR1bGVyO1xufSgpKTtcbmV4cG9ydHMuU2NoZWR1bGVyID0gU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3Q7XG4vKipcbiAqIEBjbGFzcyBBbm9ueW1vdXNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5vbnltb3VzU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBBbm9ueW1vdXNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmlwdGlvbihzdWJqZWN0LCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmlwdGlvbiA9IFN1YmplY3RTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhBQ0soYmVubGVzaCk6IFRvIHJlc29sdmUgYW4gaXNzdWUgd2hlcmUgTm9kZSB1c2VycyBtYXkgaGF2ZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb3BpZXMgb2YgcnhqcyBpbiB0aGVpciBub2RlX21vZHVsZXMgZGlyZWN0b3J5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUcnVzdGVkU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cnVzdGVkU3Vic2NyaWJlciA9IGRlc3RpbmF0aW9uT3JOZXh0W3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1c3RlZFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHRydXN0ZWRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RlZFN1YnNjcmliZXIuYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS5yeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRpYyBmYWN0b3J5IGZvciBhIFN1YnNjcmliZXIsIGdpdmVuIGEgKHBvdGVudGlhbGx5IHBhcnRpYWwpIGRlZmluaXRpb25cbiAgICAgKiBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6ID9UKTogdm9pZH0gW25leHRdIFRoZSBgbmV4dGAgY2FsbGJhY2sgb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlOiA/YW55KTogdm9pZH0gW2Vycm9yXSBUaGUgYGVycm9yYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBUaGUgYGNvbXBsZXRlYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmliZXI8VD59IEEgU3Vic2NyaWJlciB3cmFwcGluZyB0aGUgKHBhcnRpYWxseSBkZWZpbmVkKVxuICAgICAqIE9ic2VydmVyIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICAgICovXG4gICAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgbmV4dGAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGEgdmFsdWUuIFRoZSBPYnNlcnZhYmxlIG1heSBjYWxsIHRoaXMgbWV0aG9kIDAgb3IgbW9yZVxuICAgICAqIHRpbWVzLlxuICAgICAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBUaGUgYG5leHRgIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYGVycm9yYCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIEVycm9yfS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXRcbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSBoYXMgZXhwZXJpZW5jZWQgYW4gZXJyb3IgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBleGNlcHRpb24uXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhIHZhbHVlbGVzcyBub3RpZmljYXRpb24gb2YgdHlwZVxuICAgICAqIGBjb21wbGV0ZWAgZnJvbSB0aGUgT2JzZXJ2YWJsZS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXQgdGhlIE9ic2VydmFibGVcbiAgICAgKiBoYXMgZmluaXNoZWQgc2VuZGluZyBwdXNoLWJhc2VkIG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBfcGFyZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnRTdWJzY3JpYmVyLCBvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlck9yTmV4dCAhPT0gT2JzZXJ2ZXJfMS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG9ic2VydmVyT3JOZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5fbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fbmV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY29tcGxldGUuY2FsbChfdGhpcy5fY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIod3JhcHBlZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHdyYXBwZWRDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBpc1RydXN0ZWRTdWJzY3JpYmVyKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBTdWJzY3JpYmVyIHx8ICgnc3luY0Vycm9yVGhyb3dhYmxlJyBpbiBvYmogJiYgb2JqW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNBcnJheScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNPYmplY3QnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGRpc3Bvc2FibGUgcmVzb3VyY2UsIHN1Y2ggYXMgdGhlIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlLiBBXG4gKiBTdWJzY3JpcHRpb24gaGFzIG9uZSBpbXBvcnRhbnQgbWV0aG9kLCBgdW5zdWJzY3JpYmVgLCB0aGF0IHRha2VzIG5vIGFyZ3VtZW50XG4gKiBhbmQganVzdCBkaXNwb3NlcyB0aGUgcmVzb3VyY2UgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc3Vic2NyaXB0aW9ucyBtYXkgYmUgZ3JvdXBlZCB0b2dldGhlciB0aHJvdWdoIHRoZSBgYWRkKClgXG4gKiBtZXRob2QsIHdoaWNoIHdpbGwgYXR0YWNoIGEgY2hpbGQgU3Vic2NyaXB0aW9uIHRvIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbi5cbiAqIFdoZW4gYSBTdWJzY3JpcHRpb24gaXMgdW5zdWJzY3JpYmVkLCBhbGwgaXRzIGNoaWxkcmVuIChhbmQgaXRzIGdyYW5kY2hpbGRyZW4pXG4gKiB3aWxsIGJlIHVuc3Vic2NyaWJlZCBhcyB3ZWxsLlxuICpcbiAqIEBjbGFzcyBTdWJzY3JpcHRpb25cbiAqL1xudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbdW5zdWJzY3JpYmVdIEEgZnVuY3Rpb24gZGVzY3JpYmluZyBob3cgdG9cbiAgICAgKiBwZXJmb3JtIHRoZSBkaXNwb3NhbCBvZiByZXNvdXJjZXMgd2hlbiB0aGUgYHVuc3Vic2NyaWJlYCBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBTdWJzY3JpcHRpb24gaGFzIGFscmVhZHkgYmVlbiB1bnN1YnNjcmliZWQuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uIE1heSwgZm9yIGluc3RhbmNlLCBjYW5jZWxcbiAgICAgKiBhbiBvbmdvaW5nIE9ic2VydmFibGUgZXhlY3V0aW9uIG9yIGNhbmNlbCBhbnkgb3RoZXIgdHlwZSBvZiB3b3JrIHRoYXRcbiAgICAgKiBzdGFydGVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiB3YXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9ycztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHMsIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSwgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgLy8gbnVsbCBvdXQgX3N1YnNjcmlwdGlvbnMgZmlyc3Qgc28gYW55IGNoaWxkIHN1YnNjcmlwdGlvbnMgdGhhdCBhdHRlbXB0XG4gICAgICAgIC8vIHRvIHJlbW92ZSB0aGVtc2VsdmVzIGZyb20gdGhpcyBzdWJzY3JpcHRpb24gd2lsbCBub29wXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGxlbiA9IF9wYXJlbnRzID8gX3BhcmVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgLy8gaWYgdGhpcy5fcGFyZW50IGlzIG51bGwsIHRoZW4gc28gaXMgdGhpcy5fcGFyZW50cywgYW5kIHdlXG4gICAgICAgIC8vIGRvbid0IGhhdmUgdG8gcmVtb3ZlIG91cnNlbHZlcyBmcm9tIGFueSBwYXJlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgd2hpbGUgKF9wYXJlbnQpIHtcbiAgICAgICAgICAgIF9wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgLy8gaWYgdGhpcy5fcGFyZW50cyBpcyBudWxsIG9yIGluZGV4ID49IGxlbixcbiAgICAgICAgICAgIC8vIHRoZW4gX3BhcmVudCBpcyBzZXQgdG8gbnVsbCwgYW5kIHRoZSBsb29wIGV4aXRzXG4gICAgICAgICAgICBfcGFyZW50ID0gKytpbmRleCA8IGxlbiAmJiBfcGFyZW50c1tpbmRleF0gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChfdW5zdWJzY3JpYmUpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCAoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IgP1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lLmVycm9ycykgOiBbZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KF9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc3ViLnVuc3Vic2NyaWJlKS5jYWxsKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGVhciBkb3duIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlKCkgb2YgdGhpc1xuICAgICAqIFN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0ZWFyIGRvd24gYmVpbmcgYWRkZWQgaXMgYSBzdWJzY3JpcHRpb24gdGhhdCBpcyBhbHJlYWR5XG4gICAgICogdW5zdWJzY3JpYmVkLCBpcyB0aGUgc2FtZSByZWZlcmVuY2UgYGFkZGAgaXMgYmVpbmcgY2FsbGVkIG9uLCBvciBpc1xuICAgICAqIGBTdWJzY3JpcHRpb24uRU1QVFlgLCBpdCB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgc3Vic2NyaXB0aW9uIGlzIGFscmVhZHkgaW4gYW4gYGNsb3NlZGAgc3RhdGUsIHRoZSBwYXNzZWRcbiAgICAgKiB0ZWFyIGRvd24gbG9naWMgd2lsbCBiZSBleGVjdXRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGVhcmRvd25Mb2dpY30gdGVhcmRvd24gVGhlIGFkZGl0aW9uYWwgbG9naWMgdG8gZXhlY3V0ZSBvblxuICAgICAqIHRlYXJkb3duLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gUmV0dXJucyB0aGUgU3Vic2NyaXB0aW9uIHVzZWQgb3IgY3JlYXRlZCB0byBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zIGxpc3QuIFRoaXMgU3Vic2NyaXB0aW9uIGNhbiBiZSB1c2VkIHdpdGhcbiAgICAgKiBgcmVtb3ZlKClgIHRvIHJlbW92ZSB0aGUgcGFzc2VkIHRlYXJkb3duIGxvZ2ljIGZyb20gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBsaXN0LlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIGlmICghdGVhcmRvd24gfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZWFyZG93biA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRlYXJkb3duO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNsb3NlZCB8fCB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQgIT09ICdmdW5jdGlvbicgLyogcXVhY2sgcXVhY2sgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uX3N1YnNjcmlwdGlvbnMgPSBbdG1wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKTtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5fYWRkUGFyZW50KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIFN1YnNjcmlwdGlvbiBmcm9tIHRoZSBpbnRlcm5hbCBsaXN0IG9mIHN1YnNjcmlwdGlvbnMgdGhhdCB3aWxsXG4gICAgICogdW5zdWJzY3JpYmUgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSBwcm9jZXNzIG9mIHRoaXMgU3Vic2NyaXB0aW9uLlxuICAgICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIHN1YnNjcmlwdGlvbiB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkluZGV4ID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzO1xuICAgICAgICBpZiAoIV9wYXJlbnQgfHwgX3BhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcGFyZW50LCBvciB0aGUgbmV3IHBhcmVudCBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcGFyZW50LCB0aGVuIHNldCB0aGlzLl9wYXJlbnQgdG8gdGhlIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnRzKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgb25lIHBhcmVudCwgYnV0IG5vdCBtdWx0aXBsZSwgYWxsb2NhdGUgYW4gQXJyYXkgdG9cbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSByZXN0IG9mIHRoZSBwYXJlbnQgU3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudHMgPSBbcGFyZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfcGFyZW50cy5pbmRleE9mKHBhcmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGFkZCB0aGUgbmV3IHBhcmVudCB0byB0aGUgX3BhcmVudHMgbGlzdCBpZiBpdCdzIG5vdCBhbHJlYWR5IHRoZXJlLlxuICAgICAgICAgICAgX3BhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9KG5ldyBTdWJzY3JpcHRpb24oKSkpO1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb247XG5mdW5jdGlvbiBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JzKSB7XG4gICAgcmV0dXJuIGVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKGVycnMsIGVycikgeyByZXR1cm4gZXJycy5jb25jYXQoKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSA/IGVyci5lcnJvcnMgOiBlcnIpOyB9LCBbXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU2NhbGFyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9TY2FsYXJPYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBcnJheUxpa2VPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlMaWtlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheUxpa2VPYnNlcnZhYmxlKGFycmF5TGlrZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5TGlrZSA9IGFycmF5TGlrZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIGlmICghc2NoZWR1bGVyICYmIGFycmF5TGlrZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheUxpa2VbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYXJyYXlMaWtlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGVfMS5TY2FsYXJPYnNlcnZhYmxlKGFycmF5TGlrZVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZShhcnJheUxpa2UsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5TGlrZU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGFycmF5TGlrZSA9IHN0YXRlLmFycmF5TGlrZSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgbGVuZ3RoID0gc3RhdGUubGVuZ3RoLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheUxpa2VbaW5kZXhdKTtcbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGFycmF5TGlrZSA9IF9hLmFycmF5TGlrZSwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheUxpa2VPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgYXJyYXlMaWtlOiBhcnJheUxpa2UsIGluZGV4OiBpbmRleCwgbGVuZ3RoOiBsZW5ndGgsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlMaWtlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFycmF5TGlrZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFycmF5TGlrZU9ic2VydmFibGUgPSBBcnJheUxpa2VPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlMaWtlT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgICAqIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgc3luY2hyb25vdXNseSwgYWx0aG91Z2ggd2l0aCBhIGRpZmZlcmVudCBJU2NoZWR1bGVyXG4gICAgICogaXQgaXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZW4gdGhvc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlIGRlbGl2ZXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgMTAsIDIwLCAzMCwgdGhlbiAnYScsICdiJywgJ2MnLCB0aGVuIHN0YXJ0IHRpY2tpbmcgZXZlcnkgc2Vjb25kLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUub2YoMTAsIDIwLCAzMCk7XG4gICAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IG51bWJlcnMuY29uY2F0KGxldHRlcnMpLmNvbmNhdChpbnRlcnZhbCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIEFyZ3VtZW50cyB0aGF0IHJlcHJlc2VudCBgbmV4dGAgdmFsdWVzIHRvIGJlIGVtaXR0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BcnJheU9ic2VydmFibGUgPSBBcnJheU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHJlZkNvdW50XzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvcmVmQ291bnQnKTtcbi8qKlxuICogQGNsYXNzIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHN1YmplY3RGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2lzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ViamVjdCgpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0O1xuICAgICAgICBpZiAoIXN1YmplY3QgfHwgc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYWRkKHRoaXMuc291cmNlXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShuZXcgQ29ubmVjdGFibGVTdWJzY3JpYmVyKHRoaXMuZ2V0U3ViamVjdCgpLCB0aGlzKSkpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlZkNvdW50XzEucmVmQ291bnQoKSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbnZhciBjb25uZWN0YWJsZVByb3RvID0gQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZTtcbmV4cG9ydHMuY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciA9IHtcbiAgICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICAgIF9yZWZDb3VudDogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3ViamVjdDogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfY29ubmVjdGlvbjogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3Vic2NyaWJlOiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLl9zdWJzY3JpYmUgfSxcbiAgICBfaXNDb21wbGV0ZTogeyB2YWx1ZTogY29ubmVjdGFibGVQcm90by5faXNDb21wbGV0ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBnZXRTdWJqZWN0OiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLmdldFN1YmplY3QgfSxcbiAgICBjb25uZWN0OiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLmNvbm5lY3QgfSxcbiAgICByZWZDb3VudDogeyB2YWx1ZTogY29ubmVjdGFibGVQcm90by5yZWZDb3VudCB9XG59O1xudmFyIENvbm5lY3RhYmxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUuX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmIChjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVTdWJzY3JpYmVyO1xufShTdWJqZWN0XzEuU3ViamVjdFN1YnNjcmliZXIpKTtcbnZhciBSZWZDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9wZXJhdG9yKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50Kys7XG4gICAgICAgIHZhciByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHJlZkNvdW50ZXIpO1xuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZWZDb3VudGVyLmNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudE9wZXJhdG9yO1xufSgpKTtcbnZhciBSZWZDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHZhciByZWZDb3VudCA9IGNvbm5lY3RhYmxlLl9yZWZDb3VudDtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBsb2NhbCBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiB0byB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAgICAgLy8gdGhlIFJlZkNvdW50U3Vic2NyaWJlcidzIGRvd25zdHJlYW0gT2JzZXJ2ZXJzIHN5bmNocm9ub3VzbHkgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgICAgICAvLyAgIC5wdWJsaXNoKClcbiAgICAgICAgLy8gICAucmVmQ291bnQoKVxuICAgICAgICAvLyAgIC50YWtlKDUpXG4gICAgICAgIC8vICAgLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgICAvLyB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlJ3Mgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBleGlzdHMsICphbmQqIGVpdGhlcjpcbiAgICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgICAvLyAgICAgIFN1YnNjcmlwdGlvbiB5ZXQsIG9yLFxuICAgICAgICAvLyAgIGIuIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHJlZmVyZW5jZSBpcyBpZGVudGljYWxcbiAgICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAgIC8vL1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0YWJsZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkp1c3QgZW1pdHMgJ2NvbXBsZXRlJywgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2VtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlclxuICAgICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIGNvbXBsZXRlLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5lbXB0eSgpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG9ubHkgb2RkIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYyc8L2NhcHRpb24+XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgICAqICAgeCAlIDIgPT09IDEgPyBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHRvIHRoZSBjb25zb2xlOlxuICAgICAqIC8vIHggaXMgZXF1YWwgdG8gdGhlIGNvdW50IG9uIHRoZSBpbnRlcnZhbCBlZygwLDEsMiwzLC4uLilcbiAgICAgKiAvLyB4IHdpbGwgb2NjdXIgZXZlcnkgMTAwMG1zXG4gICAgICogLy8gaWYgeCAlIDIgaXMgZXF1YWwgdG8gMSBwcmludCBhYmNcbiAgICAgKiAvLyBpZiB4ICUgMiBpcyBub3QgZXF1YWwgdG8gMSBub3RoaW5nIHdpbGwgYmUgb3V0cHV0XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gXCJlbXB0eVwiIE9ic2VydmFibGU6IGVtaXRzIG9ubHkgdGhlIGNvbXBsZXRlXG4gICAgICogbm90aWZpY2F0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGVtcHR5XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFbXB0eU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVtcHR5T2JzZXJ2YWJsZSA9IEVtcHR5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIGlzQXJyYXlMaWtlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXlMaWtlJyk7XG52YXIgaXNQcm9taXNlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzUHJvbWlzZScpO1xudmFyIFByb21pc2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1Byb21pc2VPYnNlcnZhYmxlJyk7XG52YXIgSXRlcmF0b3JPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0l0ZXJhdG9yT2JzZXJ2YWJsZScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbnZhciBBcnJheUxpa2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5TGlrZU9ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL29ic2VydmVPbicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gYW4gQXJyYXksIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBhIFByb21pc2UsIGFuXG4gICAgICogaXRlcmFibGUgb2JqZWN0LCBvciBhbiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnRzIGFsbW9zdCBhbnl0aGluZyB0byBhbiBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIENvbnZlcnQgdmFyaW91cyBvdGhlciBvYmplY3RzIGFuZCBkYXRhIHR5cGVzIGludG8gT2JzZXJ2YWJsZXMuIGBmcm9tYFxuICAgICAqIGNvbnZlcnRzIGEgUHJvbWlzZSBvciBhbiBhcnJheS1saWtlIG9yIGFuXG4gICAgICogW2l0ZXJhYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhYmxlKVxuICAgICAqIG9iamVjdCBpbnRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgaW4gdGhhdCBwcm9taXNlIG9yIGFycmF5IG9yXG4gICAgICogaXRlcmFibGUuIEEgU3RyaW5nLCBpbiB0aGlzIGNvbnRleHQsIGlzIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2Ugb2JqZWN0cyAoY29udGFpbnMgYSBmdW5jdGlvbiBuYW1lZCB3aXRoIHRoZSBFUzIwMTUgU3ltYm9sXG4gICAgICogZm9yIE9ic2VydmFibGUpIGNhbiBhbHNvIGJlIGNvbnZlcnRlZCB0aHJvdWdoIHRoaXMgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0cyBhbiBhcnJheSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIHZhciBhcnJheSA9IFsxMCwgMjAsIDMwXTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tKGFycmF5KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICAgICAqIC8vIDEwIDIwIDMwXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIGluZmluaXRlIGl0ZXJhYmxlIChmcm9tIGEgZ2VuZXJhdG9yKSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uKiBnZW5lcmF0ZURvdWJsZXMoc2VlZCkge1xuICAgICAqICAgdmFyIGkgPSBzZWVkO1xuICAgICAqICAgd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgICAgeWllbGQgaTtcbiAgICAgKiAgICAgaSA9IDIgKiBpOyAvLyBkb3VibGUgaXRcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaXRlcmF0b3IgPSBnZW5lcmF0ZURvdWJsZXMoMyk7XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbShpdGVyYXRvcikudGFrZSgxMCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAgICAgKiAvLyAzIDYgMTIgMjQgNDggOTYgMTkyIDM4NCA3NjggMTUzNlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudH1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXQ8VD59IGlzaCBBIHN1YnNjcmliYWJsZSBvYmplY3QsIGEgUHJvbWlzZSwgYW5cbiAgICAgKiBPYnNlcnZhYmxlLWxpa2UsIGFuIEFycmF5LCBhbiBpdGVyYWJsZSBvciBhbiBhcnJheS1saWtlIG9iamVjdCB0byBiZVxuICAgICAqIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBlbWlzc2lvbnMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgb3JpZ2luYWxseSBmcm9tIHRoZVxuICAgICAqIGlucHV0IG9iamVjdCB0aGF0IHdhcyBjb252ZXJ0ZWQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGlzaCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChpc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc2hbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzaCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlICYmICFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5XzEuaXNBcnJheShpc2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VPYnNlcnZhYmxlXzEuUHJvbWlzZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlzaFtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlXzEuSXRlcmF0b3JPYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlXzEuaXNBcnJheUxpa2UoaXNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZV8xLkFycmF5TGlrZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKGlzaCAhPT0gbnVsbCAmJiB0eXBlb2YgaXNoIHx8IGlzaCkgKyAnIGlzIG5vdCBvYnNlcnZhYmxlJyk7XG4gICAgfTtcbiAgICBGcm9tT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpc2ggPSB0aGlzLmlzaDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpc2hbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdKCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzaFtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0oKS5zdWJzY3JpYmUobmV3IG9ic2VydmVPbl8xLk9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGcm9tT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRnJvbU9ic2VydmFibGUgPSBGcm9tT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21PYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgSXRlcmF0b3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXRlcmF0b3JPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yT2JzZXJ2YWJsZShpdGVyYXRvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKGl0ZXJhdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgSXRlcmF0b3JPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlKGl0ZXJhdG9yLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgSXRlcmF0b3JPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YXRlLmluZGV4LCBoYXNFcnJvciA9IHN0YXRlLmhhc0Vycm9yLCBpdGVyYXRvciA9IHN0YXRlLml0ZXJhdG9yLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHN0YXRlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGl0ZXJhdG9yID0gX2EuaXRlcmF0b3IsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsIGl0ZXJhdG9yOiBpdGVyYXRvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSXRlcmF0b3JPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5JdGVyYXRvck9ic2VydmFibGUgPSBJdGVyYXRvck9ic2VydmFibGU7XG52YXIgU3RyaW5nSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKHN0ciwgaWR4LCBsZW4pIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gdm9pZCAwKSB7IGlkeCA9IDA7IH1cbiAgICAgICAgaWYgKGxlbiA9PT0gdm9pZCAwKSB7IGxlbiA9IHN0ci5sZW5ndGg7IH1cbiAgICAgICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMpOyB9O1xuICAgIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RyLmNoYXJBdCh0aGlzLmlkeCsrKVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdJdGVyYXRvcjtcbn0oKSk7XG52YXIgQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcihhcnIsIGlkeCwgbGVuKSB7XG4gICAgICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSB0b0xlbmd0aChhcnIpOyB9XG4gICAgICAgIHRoaXMuYXJyID0gYXJyO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIEFycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXJyW3RoaXMuaWR4KytdXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG59KCkpO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIGkgPSBvYmpbaXRlcmF0b3JfMS5pdGVyYXRvcl07XG4gICAgaWYgKCFpICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKCFpICYmIG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKCFpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialtpdGVyYXRvcl8xLml0ZXJhdG9yXSgpO1xufVxudmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbmZ1bmN0aW9uIHRvTGVuZ3RoKG8pIHtcbiAgICB2YXIgbGVuID0gK28ubGVuZ3RoO1xuICAgIGlmIChpc05hTihsZW4pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID09PSAwIHx8ICFudW1iZXJJc0Zpbml0ZShsZW4pKSB7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIGxlbiA9IHNpZ24obGVuKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobGVuKSk7XG4gICAgaWYgKGxlbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobGVuID4gbWF4U2FmZUludGVnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1heFNhZmVJbnRlZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gbnVtYmVySXNGaW5pdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByb290XzEucm9vdC5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaWduKHZhbHVlKSB7XG4gICAgdmFyIHZhbHVlQXNOdW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKHZhbHVlQXNOdW1iZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gICAgfVxuICAgIGlmIChpc05hTih2YWx1ZUFzTnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVBc051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlQXNOdW1iZXIgPCAwID8gLTEgOiAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SXRlcmF0b3JPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBQcm9taXNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb21pc2VPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUHJvbWlzZSB0byBhbiBPYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGp1c3QgZW1pdHMgdGhlIFByb21pc2Unc1xuICAgICAqIHJlc29sdmVkIHZhbHVlLCB0aGVuIGNvbXBsZXRlcy48L3NwYW4+XG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyBhbiBFUzIwMTUgUHJvbWlzZSBvciBhIFByb21pc2VzL0ErIHNwZWMgY29tcGxpYW50IFByb21pc2UgdG8gYW5cbiAgICAgKiBPYnNlcnZhYmxlLiBJZiB0aGUgUHJvbWlzZSByZXNvbHZlcyB3aXRoIGEgdmFsdWUsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICAgICAqIGVtaXRzIHRoYXQgcmVzb2x2ZWQgdmFsdWUgYXMgYSBgbmV4dGAsIGFuZCB0aGVuIGNvbXBsZXRlcy4gSWYgdGhlIFByb21pc2VcbiAgICAgKiBpcyByZWplY3RlZCwgdGhlbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgdGhlIGNvcnJlc3BvbmRpbmcgRXJyb3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IEZldGNoIHRvIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbVByb21pc2UoZmV0Y2goJ2h0dHA6Ly9teXNlcnZlci5jb20vJykpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcm9taXNlTGlrZTxUPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSB0byBiZSBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGRlbGl2ZXJ5IG9mIHRoZSByZXNvbHZlZCB2YWx1ZSAob3IgdGhlIHJlamVjdGlvbikuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB3aGljaCB3cmFwcyB0aGUgUHJvbWlzZS5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBmcm9tUHJvbWlzZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgUHJvbWlzZU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHByb21pc2UsIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBQcm9taXNlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHRoZSBwcm9taXNlIHRyYXAsIHRocm93IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hFcnJvciwgMCwgeyBlcnI6IGVyciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSB0aGUgcHJvbWlzZSB0cmFwLCB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHJvb3RfMS5yb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUHJvbWlzZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlByb21pc2VPYnNlcnZhYmxlID0gUHJvbWlzZU9ic2VydmFibGU7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHZhbHVlID0gYXJnLnZhbHVlLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hFcnJvcihhcmcpIHtcbiAgICB2YXIgZXJyID0gYXJnLmVyciwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb21pc2VPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBTY2FsYXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2FsYXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBzdGF0ZS5kb25lLCB2YWx1ZSA9IHN0YXRlLnZhbHVlLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBTY2FsYXJPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2NhbGFyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU2NhbGFyT2JzZXJ2YWJsZSA9IFNjYWxhck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2FsYXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFRpbWVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lck9ic2VydmFibGUoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGR1ZVRpbWUgPT09IHZvaWQgMCkgeyBkdWVUaW1lID0gMDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSAtMTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gMDtcbiAgICAgICAgaWYgKGlzTnVtZXJpY18xLmlzTnVtZXJpYyhwZXJpb2QpKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IE51bWJlcihwZXJpb2QpIDwgMSAmJiAxIHx8IE51bWJlcihwZXJpb2QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIocGVyaW9kKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gcGVyaW9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBpc0RhdGVfMS5pc0RhdGUoZHVlVGltZSkgP1xuICAgICAgICAgICAgKCtkdWVUaW1lIC0gdGhpcy5zY2hlZHVsZXIubm93KCkpIDpcbiAgICAgICAgICAgIGR1ZVRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IHN0YXJ0cyBlbWl0dGluZyBhZnRlciBhbiBgaW5pdGlhbERlbGF5YCBhbmRcbiAgICAgKiBlbWl0cyBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWUgdGhlcmVhZnRlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdHMgbGlrZSB7QGxpbmsgaW50ZXJ2YWx9LCBidXQgeW91IGNhbiBzcGVjaWZ5IHdoZW5cbiAgICAgKiBzaG91bGQgdGhlIGVtaXNzaW9ucyBzdGFydC48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL3RpbWVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYHRpbWVyYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZiBhc2NlbmRpbmdcbiAgICAgKiBpbnRlZ2Vycywgd2l0aCBhIGNvbnN0YW50IGludGVydmFsIG9mIHRpbWUsIGBwZXJpb2RgIG9mIHlvdXIgY2hvb3NpbmdcbiAgICAgKiBiZXR3ZWVuIHRob3NlIGVtaXNzaW9ucy4gVGhlIGZpcnN0IGVtaXNzaW9uIGhhcHBlbnMgYWZ0ZXIgdGhlIHNwZWNpZmllZFxuICAgICAqIGBpbml0aWFsRGVsYXlgLiBUaGUgaW5pdGlhbCBkZWxheSBtYXkgYmUgYSB7QGxpbmsgRGF0ZX0uIEJ5IGRlZmF1bHQsIHRoaXNcbiAgICAgKiBvcGVyYXRvciB1c2VzIHRoZSBgYXN5bmNgIElTY2hlZHVsZXIgdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91XG4gICAgICogbWF5IHBhc3MgYW55IElTY2hlZHVsZXIgdG8gaXQuIElmIGBwZXJpb2RgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpLCBzdGFydGluZyBhZnRlciAzIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDMwMDAsIDEwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgb25lIG51bWJlciBhZnRlciBmaXZlIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDUwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaW50ZXJ2YWx9XG4gICAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRlfSBpbml0aWFsRGVsYXkgVGhlIGluaXRpYWwgZGVsYXkgdGltZSB0byB3YWl0IGJlZm9yZVxuICAgICAqIGVtaXR0aW5nIHRoZSBmaXJzdCB2YWx1ZSBvZiBgMGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2RdIFRoZSBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVtaXNzaW9ucyBvZiB0aGVcbiAgICAgKiBzdWJzZXF1ZW50IG51bWJlcnMuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB2YWx1ZXMsIGFuZCBwcm92aWRpbmcgYSBub3Rpb24gb2YgXCJ0aW1lXCIuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgYDBgIGFmdGVyIHRoZVxuICAgICAqIGBpbml0aWFsRGVsYXlgIGFuZCBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWVcbiAgICAgKiB0aGVyZWFmdGVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIHRpbWVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBUaW1lck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGluaXRpYWxEZWxheSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGluaXRpYWxEZWxheSA9PT0gdm9pZCAwKSB7IGluaXRpYWxEZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lck9ic2VydmFibGUoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBUaW1lck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIHBlcmlvZCA9IHN0YXRlLnBlcmlvZCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5kZXgpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwZXJpb2QgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBhY3Rpb24uc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG4gICAgfTtcbiAgICBUaW1lck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwZXJpb2QgPSBfYS5wZXJpb2QsIGR1ZVRpbWUgPSBfYS5kdWVUaW1lLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoVGltZXJPYnNlcnZhYmxlLmRpc3BhdGNoLCBkdWVUaW1lLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsIHBlcmlvZDogcGVyaW9kLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuVGltZXJPYnNlcnZhYmxlID0gVGltZXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgb2ZfMSA9IHJlcXVpcmUoJy4vb2YnKTtcbnZhciBmcm9tXzEgPSByZXF1aXJlKCcuL2Zyb20nKTtcbnZhciBjb25jYXRBbGxfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycy9jb25jYXRBbGwnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggc2VxdWVudGlhbGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBnaXZlblxuICogT2JzZXJ2YWJsZSBhbmQgdGhlbiBtb3ZlcyBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb25jYXRgIGpvaW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyLCBieSBzdWJzY3JpYmluZyB0byB0aGVtIG9uZSBhdCBhIHRpbWUgYW5kXG4gKiBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFlvdSBjYW4gcGFzcyBlaXRoZXIgYW4gYXJyYXkgb2ZcbiAqIE9ic2VydmFibGVzLCBvciBwdXQgdGhlbSBkaXJlY3RseSBhcyBhcmd1bWVudHMuIFBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgd2lsbCByZXN1bHRcbiAqIGluIE9ic2VydmFibGUgdGhhdCBjb21wbGV0ZXMgaW1tZWRpYXRlbHkuXG4gKlxuICogYGNvbmNhdGAgd2lsbCBzdWJzY3JpYmUgdG8gZmlyc3QgaW5wdXQgT2JzZXJ2YWJsZSBhbmQgZW1pdCBhbGwgaXRzIHZhbHVlcywgd2l0aG91dFxuICogY2hhbmdpbmcgb3IgYWZmZWN0aW5nIHRoZW0gaW4gYW55IHdheS4gV2hlbiB0aGF0IE9ic2VydmFibGUgY29tcGxldGVzLCBpdCB3aWxsXG4gKiBzdWJzY3JpYmUgdG8gdGhlbiBuZXh0IE9ic2VydmFibGUgcGFzc2VkIGFuZCwgYWdhaW4sIGVtaXQgaXRzIHZhbHVlcy4gVGhpcyB3aWxsIGJlXG4gKiByZXBlYXRlZCwgdW50aWwgdGhlIG9wZXJhdG9yIHJ1bnMgb3V0IG9mIE9ic2VydmFibGVzLiBXaGVuIGxhc3QgaW5wdXQgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsXG4gKiBgY29uY2F0YCB3aWxsIGNvbXBsZXRlIGFzIHdlbGwuIEF0IGFueSBnaXZlbiBtb21lbnQgb25seSBvbmUgT2JzZXJ2YWJsZSBwYXNzZWQgdG8gb3BlcmF0b3JcbiAqIGVtaXRzIHZhbHVlcy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gZW1pdCB2YWx1ZXMgZnJvbSBwYXNzZWQgT2JzZXJ2YWJsZXMgY29uY3VycmVudGx5LCBjaGVjayBvdXRcbiAqIHtAbGluayBtZXJnZX0gaW5zdGVhZCwgZXNwZWNpYWxseSB3aXRoIG9wdGlvbmFsIGBjb25jdXJyZW50YCBwYXJhbWV0ZXIuIEFzIGEgbWF0dGVyIG9mIGZhY3QsXG4gKiBgY29uY2F0YCBpcyBhbiBlcXVpdmFsZW50IG9mIGBtZXJnZWAgb3BlcmF0b3Igd2l0aCBgY29uY3VycmVudGAgcGFyYW1ldGVyIHNldCB0byBgMWAuXG4gKlxuICogTm90ZSB0aGF0IGlmIHNvbWUgaW5wdXQgT2JzZXJ2YWJsZSBuZXZlciBjb21wbGV0ZXMsIGBjb25jYXRgIHdpbGwgYWxzbyBuZXZlciBjb21wbGV0ZVxuICogYW5kIE9ic2VydmFibGVzIGZvbGxvd2luZyB0aGUgb25lIHRoYXQgZGlkIG5vdCBjb21wbGV0ZSB3aWxsIG5ldmVyIGJlIHN1YnNjcmliZWQuIE9uIHRoZSBvdGhlclxuICogaGFuZCwgaWYgc29tZSBPYnNlcnZhYmxlIHNpbXBseSBjb21wbGV0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgc3Vic2NyaWJlZCwgaXQgd2lsbCBiZVxuICogaW52aXNpYmxlIGZvciBgY29uY2F0YCwgd2hpY2ggd2lsbCBqdXN0IG1vdmUgb24gdG8gdGhlIG5leHQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBJZiBhbnkgT2JzZXJ2YWJsZSBpbiBjaGFpbiBlcnJvcnMsIGluc3RlYWQgb2YgcGFzc2luZyBjb250cm9sIHRvIHRoZSBuZXh0IE9ic2VydmFibGUsXG4gKiBgY29uY2F0YCB3aWxsIGVycm9yIGltbWVkaWF0ZWx5IGFzIHdlbGwuIE9ic2VydmFibGVzIHRoYXQgd291bGQgYmUgc3Vic2NyaWJlZCBhZnRlclxuICogdGhlIG9uZSB0aGF0IGVtaXR0ZWQgZXJyb3IsIG5ldmVyIHdpbGwuXG4gKlxuICogSWYgeW91IHBhc3MgdG8gYGNvbmNhdGAgdGhlIHNhbWUgT2JzZXJ2YWJsZSBtYW55IHRpbWVzLCBpdHMgc3RyZWFtIG9mIHZhbHVlc1xuICogd2lsbCBiZSBcInJlcGxheWVkXCIgb24gZXZlcnkgc3Vic2NyaXB0aW9uLCB3aGljaCBtZWFucyB5b3UgY2FuIHJlcGVhdCBnaXZlbiBPYnNlcnZhYmxlXG4gKiBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLiBJZiBwYXNzaW5nIHRoZSBzYW1lIE9ic2VydmFibGUgdG8gYGNvbmNhdGAgMTAwMCB0aW1lcyBiZWNvbWVzIHRlZGlvdXMsXG4gKiB5b3UgY2FuIGFsd2F5cyB1c2Uge0BsaW5rIHJlcGVhdH0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbjpcbiAqIC8vIDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDMgLWltbWVkaWF0ZS0+IDEgLi4uIDEwXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGFuIGFycmF5IG9mIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuY29uY2F0KFt0aW1lcjEsIHRpbWVyMiwgdGltZXIzXSk7IC8vIG5vdGUgdGhhdCBhcnJheSBpcyBwYXNzZWRcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgdGhlIHNhbWUgT2JzZXJ2YWJsZSB0byByZXBlYXQgaXQ8L2NhcHRpb24+XG4gKiBjb25zdCB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgyKTtcbiAqXG4gKiBSeC5PYnNlcnZhYmxlLmNvbmNhdCh0aW1lciwgdGltZXIpIC8vIGNvbmNhdGluZyB0aGUgc2FtZSBPYnNlcnZhYmxlIVxuICogLnN1YnNjcmliZShcbiAqICAgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnIgPT4ge30sXG4gKiAgICgpID0+IGNvbnNvbGUubG9nKCcuLi5hbmQgaXQgaXMgZG9uZSEnKVxuICogKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAxc1xuICogLy8gMSBhZnRlciAyc1xuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gXCIuLi5hbmQgaXQgaXMgZG9uZSFcIiBhbHNvIGFmdGVyIDRzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MSBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MiBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHNjaGVkdWxlIGVhY2hcbiAqIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQWxsIHZhbHVlcyBvZiBlYWNoIHBhc3NlZCBPYnNlcnZhYmxlIG1lcmdlZCBpbnRvIGFcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCBpbiBvcmRlciwgaW4gc2VyaWFsIGZhc2hpb24uXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGNvbmNhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxIHx8IChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDIgJiYgaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihvYnNlcnZhYmxlc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBmcm9tXzEuZnJvbShvYnNlcnZhYmxlc1swXSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRBbGxfMS5jb25jYXRBbGwoKShvZl8xLm9mLmFwcGx5KHZvaWQgMCwgb2JzZXJ2YWJsZXMpKTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEZyb21PYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Zyb21PYnNlcnZhYmxlJyk7XG5leHBvcnRzLmZyb20gPSBGcm9tT2JzZXJ2YWJsZV8xLkZyb21PYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvbWVyZ2VBbGwnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggY29uY3VycmVudGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBldmVyeVxuICogZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnkgYmxlbmRpbmdcbiAqIHRoZWlyIHZhbHVlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZWAgc3Vic2NyaWJlcyB0byBlYWNoIGdpdmVuIGlucHV0IE9ic2VydmFibGUgKGFzIGFyZ3VtZW50cyksIGFuZCBzaW1wbHlcbiAqIGZvcndhcmRzICh3aXRob3V0IGRvaW5nIGFueSB0cmFuc2Zvcm1hdGlvbikgYWxsIHRoZSB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0XG4gKiBPYnNlcnZhYmxlcyB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5IGNvbXBsZXRlc1xuICogb25jZSBhbGwgaW5wdXQgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnkgYW4gaW5wdXRcbiAqIE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciB0d28gT2JzZXJ2YWJsZXM6IDFzIGludGVydmFsIGFuZCBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3NPclRpbWVyID0gUnguT2JzZXJ2YWJsZS5tZXJnZShjbGlja3MsIHRpbWVyKTtcbiAqIGNsaWNrc09yVGltZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIHRpbWVyIHdpbGwgZW1pdCBhc2NlbmRpbmcgdmFsdWVzLCBvbmUgZXZlcnkgc2Vjb25kKDEwMDBtcykgdG8gY29uc29sZVxuICogLy8gY2xpY2tzIGxvZ3MgTW91c2VFdmVudHMgdG8gY29uc29sZSBldmVyeXRpbWUgdGhlIFwiZG9jdW1lbnRcIiBpcyBjbGlja2VkXG4gKiAvLyBTaW5jZSB0aGUgdHdvIHN0cmVhbXMgYXJlIG1lcmdlZCB5b3Ugc2VlIHRoZXNlIGhhcHBlbmluZ1xuICogLy8gYXMgdGhleSBvY2N1ci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciAzIE9ic2VydmFibGVzLCBidXQgb25seSAyIHJ1biBjb25jdXJyZW50bHk8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIGNvbmN1cnJlbnQgPSAyOyAvLyB0aGUgYXJndW1lbnRcbiAqIHZhciBtZXJnZWQgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKHRpbWVyMSwgdGltZXIyLCB0aW1lcjMsIGNvbmN1cnJlbnQpO1xuICogbWVyZ2VkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAtIEZpcnN0IHRpbWVyMSBhbmQgdGltZXIyIHdpbGwgcnVuIGNvbmN1cnJlbnRseVxuICogLy8gLSB0aW1lcjEgd2lsbCBlbWl0IGEgdmFsdWUgZXZlcnkgMTAwMG1zIGZvciAxMCBpdGVyYXRpb25zXG4gKiAvLyAtIHRpbWVyMiB3aWxsIGVtaXQgYSB2YWx1ZSBldmVyeSAyMDAwbXMgZm9yIDYgaXRlcmF0aW9uc1xuICogLy8gLSBhZnRlciB0aW1lcjEgaGl0cyBpdCdzIG1heCBpdGVyYXRpb24sIHRpbWVyMiB3aWxsXG4gKiAvLyAgIGNvbnRpbnVlLCBhbmQgdGltZXIzIHdpbGwgc3RhcnQgdG8gcnVuIGNvbmN1cnJlbnRseSB3aXRoIHRpbWVyMlxuICogLy8gLSB3aGVuIHRpbWVyMiBoaXRzIGl0J3MgbWF4IGl0ZXJhdGlvbiBpdCB0ZXJtaW5hdGVzLCBhbmRcbiAqIC8vICAgdGltZXIzIHdpbGwgY29udGludWUgdG8gZW1pdCBhIHZhbHVlIGV2ZXJ5IDUwMG1zIHVudGlsIGl0IGlzIGNvbXBsZXRlXG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlSW5wdXR9IG9ic2VydmFibGVzIElucHV0IE9ic2VydmFibGVzIHRvIG1lcmdlIHRvZ2V0aGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBtYW5hZ2luZ1xuICogY29uY3VycmVuY3kgb2YgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZlxuICogZXZlcnkgaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgbWVyZ2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICB2YXIgbGFzdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGxhc3QpKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgICAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25jdXJyZW50ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gbnVsbCAmJiBvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgb2JzZXJ2YWJsZXNbMF0gaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUFsbF8xLm1lcmdlQWxsKGNvbmN1cnJlbnQpKG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5vZiA9IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZS5vZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbmZ1bmN0aW9uIHJhY2UoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8vIGlmIHRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBpdCB3YXMgbW9zdCBsaWtlbHkgY2FsbGVkIHdpdGhcbiAgICAvLyBgcmFjZShbb2JzMSwgb2JzMiwgLi4uXSlgXG4gICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzKS5saWZ0KG5ldyBSYWNlT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLnJhY2UgPSByYWNlO1xudmFyIFJhY2VPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFjZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBSYWNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSYWNlU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFjZU9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuUmFjZU9wZXJhdG9yID0gUmFjZU9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSYWNlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhY2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhY2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBSYWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzLnB1c2gob2JzZXJ2YWJsZSk7XG4gICAgfTtcbiAgICBSYWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZXMgPSB0aGlzLm9ic2VydmFibGVzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2YWJsZXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAmJiAhdGhpcy5oYXNGaXJzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlLCBvYnNlcnZhYmxlLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IG91dGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFjZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5SYWNlU3Vic2NyaWJlciA9IFJhY2VTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBUaW1lck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vVGltZXJPYnNlcnZhYmxlJyk7XG5leHBvcnRzLnRpbWVyID0gVGltZXJPYnNlcnZhYmxlXzEuVGltZXJPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGF1ZGl0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9hdWRpdCcpO1xuZXhwb3J0cy5hdWRpdCA9IGF1ZGl0XzEuYXVkaXQ7XG52YXIgYXVkaXRUaW1lXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9hdWRpdFRpbWUnKTtcbmV4cG9ydHMuYXVkaXRUaW1lID0gYXVkaXRUaW1lXzEuYXVkaXRUaW1lO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYnVmZmVyJyk7XG5leHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlcl8xLmJ1ZmZlcjtcbnZhciBidWZmZXJDb3VudF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYnVmZmVyQ291bnQnKTtcbmV4cG9ydHMuYnVmZmVyQ291bnQgPSBidWZmZXJDb3VudF8xLmJ1ZmZlckNvdW50O1xudmFyIGJ1ZmZlclRpbWVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2J1ZmZlclRpbWUnKTtcbmV4cG9ydHMuYnVmZmVyVGltZSA9IGJ1ZmZlclRpbWVfMS5idWZmZXJUaW1lO1xudmFyIGJ1ZmZlclRvZ2dsZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYnVmZmVyVG9nZ2xlJyk7XG5leHBvcnRzLmJ1ZmZlclRvZ2dsZSA9IGJ1ZmZlclRvZ2dsZV8xLmJ1ZmZlclRvZ2dsZTtcbnZhciBidWZmZXJXaGVuXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9idWZmZXJXaGVuJyk7XG5leHBvcnRzLmJ1ZmZlcldoZW4gPSBidWZmZXJXaGVuXzEuYnVmZmVyV2hlbjtcbnZhciBjYXRjaEVycm9yXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9jYXRjaEVycm9yJyk7XG5leHBvcnRzLmNhdGNoRXJyb3IgPSBjYXRjaEVycm9yXzEuY2F0Y2hFcnJvcjtcbnZhciBjb21iaW5lQWxsXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9jb21iaW5lQWxsJyk7XG5leHBvcnRzLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsXzEuY29tYmluZUFsbDtcbnZhciBjb21iaW5lTGF0ZXN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0Jyk7XG5leHBvcnRzLmNvbWJpbmVMYXRlc3QgPSBjb21iaW5lTGF0ZXN0XzEuY29tYmluZUxhdGVzdDtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2NvbmNhdCcpO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXRfMS5jb25jYXQ7XG52YXIgY29uY2F0QWxsXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9jb25jYXRBbGwnKTtcbmV4cG9ydHMuY29uY2F0QWxsID0gY29uY2F0QWxsXzEuY29uY2F0QWxsO1xudmFyIGNvbmNhdE1hcF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY29uY2F0TWFwJyk7XG5leHBvcnRzLmNvbmNhdE1hcCA9IGNvbmNhdE1hcF8xLmNvbmNhdE1hcDtcbnZhciBjb25jYXRNYXBUb18xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvY29uY2F0TWFwVG8nKTtcbmV4cG9ydHMuY29uY2F0TWFwVG8gPSBjb25jYXRNYXBUb18xLmNvbmNhdE1hcFRvO1xudmFyIGNvdW50XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9jb3VudCcpO1xuZXhwb3J0cy5jb3VudCA9IGNvdW50XzEuY291bnQ7XG52YXIgZGVib3VuY2VfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2RlYm91bmNlJyk7XG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2VfMS5kZWJvdW5jZTtcbnZhciBkZWJvdW5jZVRpbWVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2RlYm91bmNlVGltZScpO1xuZXhwb3J0cy5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWVfMS5kZWJvdW5jZVRpbWU7XG52YXIgZGVmYXVsdElmRW1wdHlfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5Jyk7XG5leHBvcnRzLmRlZmF1bHRJZkVtcHR5ID0gZGVmYXVsdElmRW1wdHlfMS5kZWZhdWx0SWZFbXB0eTtcbnZhciBkZWxheV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZGVsYXknKTtcbmV4cG9ydHMuZGVsYXkgPSBkZWxheV8xLmRlbGF5O1xudmFyIGRlbGF5V2hlbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZGVsYXlXaGVuJyk7XG5leHBvcnRzLmRlbGF5V2hlbiA9IGRlbGF5V2hlbl8xLmRlbGF5V2hlbjtcbnZhciBkZW1hdGVyaWFsaXplXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplJyk7XG5leHBvcnRzLmRlbWF0ZXJpYWxpemUgPSBkZW1hdGVyaWFsaXplXzEuZGVtYXRlcmlhbGl6ZTtcbnZhciBkaXN0aW5jdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZGlzdGluY3QnKTtcbmV4cG9ydHMuZGlzdGluY3QgPSBkaXN0aW5jdF8xLmRpc3RpbmN0O1xudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsQ2hhbmdlZCcpO1xuZXhwb3J0cy5kaXN0aW5jdFVudGlsQ2hhbmdlZCA9IGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbENoYW5nZWQ7XG52YXIgZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJyk7XG5leHBvcnRzLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkID0gZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbnZhciBlbGVtZW50QXRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2VsZW1lbnRBdCcpO1xuZXhwb3J0cy5lbGVtZW50QXQgPSBlbGVtZW50QXRfMS5lbGVtZW50QXQ7XG52YXIgZXZlcnlfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2V2ZXJ5Jyk7XG5leHBvcnRzLmV2ZXJ5ID0gZXZlcnlfMS5ldmVyeTtcbnZhciBleGhhdXN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9leGhhdXN0Jyk7XG5leHBvcnRzLmV4aGF1c3QgPSBleGhhdXN0XzEuZXhoYXVzdDtcbnZhciBleGhhdXN0TWFwXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9leGhhdXN0TWFwJyk7XG5leHBvcnRzLmV4aGF1c3RNYXAgPSBleGhhdXN0TWFwXzEuZXhoYXVzdE1hcDtcbnZhciBleHBhbmRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2V4cGFuZCcpO1xuZXhwb3J0cy5leHBhbmQgPSBleHBhbmRfMS5leHBhbmQ7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9maWx0ZXInKTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyXzEuZmlsdGVyO1xudmFyIGZpbmFsaXplXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9maW5hbGl6ZScpO1xuZXhwb3J0cy5maW5hbGl6ZSA9IGZpbmFsaXplXzEuZmluYWxpemU7XG52YXIgZmluZF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZmluZCcpO1xuZXhwb3J0cy5maW5kID0gZmluZF8xLmZpbmQ7XG52YXIgZmluZEluZGV4XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9maW5kSW5kZXgnKTtcbmV4cG9ydHMuZmluZEluZGV4ID0gZmluZEluZGV4XzEuZmluZEluZGV4O1xudmFyIGZpcnN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9maXJzdCcpO1xuZXhwb3J0cy5maXJzdCA9IGZpcnN0XzEuZmlyc3Q7XG52YXIgZ3JvdXBCeV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZ3JvdXBCeScpO1xuZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeV8xLmdyb3VwQnk7XG52YXIgaWdub3JlRWxlbWVudHNfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2lnbm9yZUVsZW1lbnRzJyk7XG5leHBvcnRzLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHNfMS5pZ25vcmVFbGVtZW50cztcbnZhciBpc0VtcHR5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9pc0VtcHR5Jyk7XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5XzEuaXNFbXB0eTtcbnZhciBsYXN0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9sYXN0Jyk7XG5leHBvcnRzLmxhc3QgPSBsYXN0XzEubGFzdDtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21hcCcpO1xuZXhwb3J0cy5tYXAgPSBtYXBfMS5tYXA7XG52YXIgbWFwVG9fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21hcFRvJyk7XG5leHBvcnRzLm1hcFRvID0gbWFwVG9fMS5tYXBUbztcbnZhciBtYXRlcmlhbGl6ZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWF0ZXJpYWxpemUnKTtcbmV4cG9ydHMubWF0ZXJpYWxpemUgPSBtYXRlcmlhbGl6ZV8xLm1hdGVyaWFsaXplO1xudmFyIG1heF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWF4Jyk7XG5leHBvcnRzLm1heCA9IG1heF8xLm1heDtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWVyZ2UnKTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZV8xLm1lcmdlO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9tZXJnZUFsbCcpO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsXzEubWVyZ2VBbGw7XG52YXIgbWVyZ2VNYXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL21lcmdlTWFwJyk7XG5leHBvcnRzLm1lcmdlTWFwID0gbWVyZ2VNYXBfMS5tZXJnZU1hcDtcbnZhciBtZXJnZU1hcF8yID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWVyZ2VNYXAnKTtcbmV4cG9ydHMuZmxhdE1hcCA9IG1lcmdlTWFwXzIubWVyZ2VNYXA7XG52YXIgbWVyZ2VNYXBUb18xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWVyZ2VNYXBUbycpO1xuZXhwb3J0cy5tZXJnZU1hcFRvID0gbWVyZ2VNYXBUb18xLm1lcmdlTWFwVG87XG52YXIgbWVyZ2VTY2FuXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9tZXJnZVNjYW4nKTtcbmV4cG9ydHMubWVyZ2VTY2FuID0gbWVyZ2VTY2FuXzEubWVyZ2VTY2FuO1xudmFyIG1pbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvbWluJyk7XG5leHBvcnRzLm1pbiA9IG1pbl8xLm1pbjtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL211bHRpY2FzdCcpO1xuZXhwb3J0cy5tdWx0aWNhc3QgPSBtdWx0aWNhc3RfMS5tdWx0aWNhc3Q7XG52YXIgb2JzZXJ2ZU9uXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9vYnNlcnZlT24nKTtcbmV4cG9ydHMub2JzZXJ2ZU9uID0gb2JzZXJ2ZU9uXzEub2JzZXJ2ZU9uO1xudmFyIG9uRXJyb3JSZXN1bWVOZXh0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9vbkVycm9yUmVzdW1lTmV4dCcpO1xuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dCA9IG9uRXJyb3JSZXN1bWVOZXh0XzEub25FcnJvclJlc3VtZU5leHQ7XG52YXIgcGFpcndpc2VfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3BhaXJ3aXNlJyk7XG5leHBvcnRzLnBhaXJ3aXNlID0gcGFpcndpc2VfMS5wYWlyd2lzZTtcbnZhciBwYXJ0aXRpb25fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3BhcnRpdGlvbicpO1xuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb25fMS5wYXJ0aXRpb247XG52YXIgcGx1Y2tfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3BsdWNrJyk7XG5leHBvcnRzLnBsdWNrID0gcGx1Y2tfMS5wbHVjaztcbnZhciBwdWJsaXNoXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wdWJsaXNoJyk7XG5leHBvcnRzLnB1Ymxpc2ggPSBwdWJsaXNoXzEucHVibGlzaDtcbnZhciBwdWJsaXNoQmVoYXZpb3JfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3B1Ymxpc2hCZWhhdmlvcicpO1xuZXhwb3J0cy5wdWJsaXNoQmVoYXZpb3IgPSBwdWJsaXNoQmVoYXZpb3JfMS5wdWJsaXNoQmVoYXZpb3I7XG52YXIgcHVibGlzaExhc3RfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3B1Ymxpc2hMYXN0Jyk7XG5leHBvcnRzLnB1Ymxpc2hMYXN0ID0gcHVibGlzaExhc3RfMS5wdWJsaXNoTGFzdDtcbnZhciBwdWJsaXNoUmVwbGF5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9wdWJsaXNoUmVwbGF5Jyk7XG5leHBvcnRzLnB1Ymxpc2hSZXBsYXkgPSBwdWJsaXNoUmVwbGF5XzEucHVibGlzaFJlcGxheTtcbnZhciByYWNlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yYWNlJyk7XG5leHBvcnRzLnJhY2UgPSByYWNlXzEucmFjZTtcbnZhciByZWR1Y2VfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3JlZHVjZScpO1xuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2VfMS5yZWR1Y2U7XG52YXIgcmVwZWF0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yZXBlYXQnKTtcbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0XzEucmVwZWF0O1xudmFyIHJlcGVhdFdoZW5fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3JlcGVhdFdoZW4nKTtcbmV4cG9ydHMucmVwZWF0V2hlbiA9IHJlcGVhdFdoZW5fMS5yZXBlYXRXaGVuO1xudmFyIHJldHJ5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yZXRyeScpO1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5XzEucmV0cnk7XG52YXIgcmV0cnlXaGVuXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yZXRyeVdoZW4nKTtcbmV4cG9ydHMucmV0cnlXaGVuID0gcmV0cnlXaGVuXzEucmV0cnlXaGVuO1xudmFyIHJlZkNvdW50XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9yZWZDb3VudCcpO1xuZXhwb3J0cy5yZWZDb3VudCA9IHJlZkNvdW50XzEucmVmQ291bnQ7XG52YXIgc2FtcGxlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zYW1wbGUnKTtcbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlXzEuc2FtcGxlO1xudmFyIHNhbXBsZVRpbWVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NhbXBsZVRpbWUnKTtcbmV4cG9ydHMuc2FtcGxlVGltZSA9IHNhbXBsZVRpbWVfMS5zYW1wbGVUaW1lO1xudmFyIHNjYW5fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NjYW4nKTtcbmV4cG9ydHMuc2NhbiA9IHNjYW5fMS5zY2FuO1xudmFyIHNlcXVlbmNlRXF1YWxfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NlcXVlbmNlRXF1YWwnKTtcbmV4cG9ydHMuc2VxdWVuY2VFcXVhbCA9IHNlcXVlbmNlRXF1YWxfMS5zZXF1ZW5jZUVxdWFsO1xudmFyIHNoYXJlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9zaGFyZScpO1xuZXhwb3J0cy5zaGFyZSA9IHNoYXJlXzEuc2hhcmU7XG52YXIgc2hhcmVSZXBsYXlfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NoYXJlUmVwbGF5Jyk7XG5leHBvcnRzLnNoYXJlUmVwbGF5ID0gc2hhcmVSZXBsYXlfMS5zaGFyZVJlcGxheTtcbnZhciBzaW5nbGVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NpbmdsZScpO1xuZXhwb3J0cy5zaW5nbGUgPSBzaW5nbGVfMS5zaW5nbGU7XG52YXIgc2tpcF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvc2tpcCcpO1xuZXhwb3J0cy5za2lwID0gc2tpcF8xLnNraXA7XG52YXIgc2tpcExhc3RfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NraXBMYXN0Jyk7XG5leHBvcnRzLnNraXBMYXN0ID0gc2tpcExhc3RfMS5za2lwTGFzdDtcbnZhciBza2lwVW50aWxfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3NraXBVbnRpbCcpO1xuZXhwb3J0cy5za2lwVW50aWwgPSBza2lwVW50aWxfMS5za2lwVW50aWw7XG52YXIgc2tpcFdoaWxlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9za2lwV2hpbGUnKTtcbmV4cG9ydHMuc2tpcFdoaWxlID0gc2tpcFdoaWxlXzEuc2tpcFdoaWxlO1xudmFyIHN0YXJ0V2l0aF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvc3RhcnRXaXRoJyk7XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aF8xLnN0YXJ0V2l0aDtcbi8qKlxuICogVE9ETyhodHRwczovL2dpdGh1Yi5jb20vUmVhY3RpdmVYL3J4anMvaXNzdWVzLzI5MDApOiBBZGQgYmFjayBzdWJzY3JpYmVPbiBvbmNlIGl0IGNhbiBiZVxuICogdHJlZXNoYWtlbi4gQ3VycmVudGx5IGlmIHRoaXMgZXhwb3J0IGlzIGFkZGVkIGJhY2ssIGl0XG4gKiBmb3JjZXMgYXBwcyB0byBicmluZyBpbiBhc2FwIHNjaGVkdWxlciBhbG9uZyB3aXRoXG4gKiBJbW1lZGlhdGUsIHJvb3QsIGFuZCBvdGhlciBzdXBwb3J0aW5nIGNvZGUuXG4gKi9cbi8vIGV4cG9ydCB7IHN1YnNjcmliZU9uIH0gZnJvbSAnLi9vcGVyYXRvcnMvc3Vic2NyaWJlT24nO1xudmFyIHN3aXRjaEFsbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvc3dpdGNoQWxsJyk7XG5leHBvcnRzLnN3aXRjaEFsbCA9IHN3aXRjaEFsbF8xLnN3aXRjaEFsbDtcbnZhciBzd2l0Y2hNYXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3N3aXRjaE1hcCcpO1xuZXhwb3J0cy5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXA7XG52YXIgc3dpdGNoTWFwVG9fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3N3aXRjaE1hcFRvJyk7XG5leHBvcnRzLnN3aXRjaE1hcFRvID0gc3dpdGNoTWFwVG9fMS5zd2l0Y2hNYXBUbztcbnZhciB0YWtlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90YWtlJyk7XG5leHBvcnRzLnRha2UgPSB0YWtlXzEudGFrZTtcbnZhciB0YWtlTGFzdF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGFrZUxhc3QnKTtcbmV4cG9ydHMudGFrZUxhc3QgPSB0YWtlTGFzdF8xLnRha2VMYXN0O1xudmFyIHRha2VVbnRpbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGFrZVVudGlsJyk7XG5leHBvcnRzLnRha2VVbnRpbCA9IHRha2VVbnRpbF8xLnRha2VVbnRpbDtcbnZhciB0YWtlV2hpbGVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3Rha2VXaGlsZScpO1xuZXhwb3J0cy50YWtlV2hpbGUgPSB0YWtlV2hpbGVfMS50YWtlV2hpbGU7XG52YXIgdGFwXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90YXAnKTtcbmV4cG9ydHMudGFwID0gdGFwXzEudGFwO1xudmFyIHRocm90dGxlXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90aHJvdHRsZScpO1xuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlXzEudGhyb3R0bGU7XG52YXIgdGhyb3R0bGVUaW1lXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90aHJvdHRsZVRpbWUnKTtcbmV4cG9ydHMudGhyb3R0bGVUaW1lID0gdGhyb3R0bGVUaW1lXzEudGhyb3R0bGVUaW1lO1xudmFyIHRpbWVJbnRlcnZhbF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGltZUludGVydmFsJyk7XG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbF8xLnRpbWVJbnRlcnZhbDtcbnZhciB0aW1lb3V0XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90aW1lb3V0Jyk7XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0XzEudGltZW91dDtcbnZhciB0aW1lb3V0V2l0aF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGltZW91dFdpdGgnKTtcbmV4cG9ydHMudGltZW91dFdpdGggPSB0aW1lb3V0V2l0aF8xLnRpbWVvdXRXaXRoO1xudmFyIHRpbWVzdGFtcF8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdGltZXN0YW1wJyk7XG5leHBvcnRzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcF8xLnRpbWVzdGFtcDtcbnZhciB0b0FycmF5XzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy90b0FycmF5Jyk7XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5XzEudG9BcnJheTtcbnZhciB3aW5kb3dfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3dpbmRvdycpO1xuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3dfMS53aW5kb3c7XG52YXIgd2luZG93Q291bnRfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3dpbmRvd0NvdW50Jyk7XG5leHBvcnRzLndpbmRvd0NvdW50ID0gd2luZG93Q291bnRfMS53aW5kb3dDb3VudDtcbnZhciB3aW5kb3dUaW1lXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy93aW5kb3dUaW1lJyk7XG5leHBvcnRzLndpbmRvd1RpbWUgPSB3aW5kb3dUaW1lXzEud2luZG93VGltZTtcbnZhciB3aW5kb3dUb2dnbGVfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3dpbmRvd1RvZ2dsZScpO1xuZXhwb3J0cy53aW5kb3dUb2dnbGUgPSB3aW5kb3dUb2dnbGVfMS53aW5kb3dUb2dnbGU7XG52YXIgd2luZG93V2hlbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvd2luZG93V2hlbicpO1xuZXhwb3J0cy53aW5kb3dXaGVuID0gd2luZG93V2hlbl8xLndpbmRvd1doZW47XG52YXIgd2l0aExhdGVzdEZyb21fMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3dpdGhMYXRlc3RGcm9tJyk7XG5leHBvcnRzLndpdGhMYXRlc3RGcm9tID0gd2l0aExhdGVzdEZyb21fMS53aXRoTGF0ZXN0RnJvbTtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3ppcCcpO1xuZXhwb3J0cy56aXAgPSB6aXBfMS56aXA7XG52YXIgemlwQWxsXzEgPSByZXF1aXJlKCcuL29wZXJhdG9ycy96aXBBbGwnKTtcbmV4cG9ydHMuemlwQWxsID0gemlwQWxsXzEuemlwQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0b3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogSWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciBhIGR1cmF0aW9uIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLCB0aGVuXG4gKiBlbWl0cyB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzXG4gKiBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGF1ZGl0VGltZX0sIGJ1dCB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYXVkaXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0YCBpcyBzaW1pbGFyIHRvIGB0aHJvdHRsZWAsIGJ1dCBlbWl0cyB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBzaWxlbmNlZFxuICogdGltZSB3aW5kb3csIGluc3RlYWQgb2YgdGhlIGZpcnN0IHZhbHVlLiBgYXVkaXRgIGVtaXRzIHRoZSBtb3N0IHJlY2VudCB2YWx1ZVxuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXMgaXRzIGludGVybmFsXG4gKiB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZSB0aW1lciBpcyBlbmFibGVkLlxuICogSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZSB2YWx1ZSBhcnJpdmVzLFxuICogdGhlIHRpbWVyIGlzIGVuYWJsZWQgYnkgY2FsbGluZyB0aGUgYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHdpdGggdGhlXG4gKiBzb3VyY2UgdmFsdWUsIHdoaWNoIHJldHVybnMgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLiBXaGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0XG4gKiByZWNlbnQgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzXG4gKiByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5hdWRpdChldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBkdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgZm9yIGNvbXB1dGluZyB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgcmF0ZS1saW1pdGluZyBvZlxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBhdWRpdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYXVkaXQoZHVyYXRpb25TZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBhdWRpdE9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgQXVkaXRPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXVkaXQgPSBhdWRpdDtcbnZhciBBdWRpdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdWRpdE9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgQXVkaXRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEF1ZGl0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXVkaXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXVkaXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1ZGl0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuZHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB2YWx1ZSA9IF9hLnZhbHVlLCBoYXNWYWx1ZSA9IF9hLmhhc1ZhbHVlLCB0aHJvdHRsZWQgPSBfYS50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRocm90dGxlKCk7XG4gICAgfTtcbiAgICBBdWRpdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGF1ZGl0XzEgPSByZXF1aXJlKCcuL2F1ZGl0Jyk7XG52YXIgdGltZXJfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvdGltZXInKTtcbi8qKlxuICogSWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcywgdGhlbiBlbWl0cyB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIHJlcGVhdHMgdGhpcyBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuIGl0IHNlZXMgYSBzb3VyY2UgdmFsdWVzLCBpdCBpZ25vcmVzIHRoYXQgcGx1c1xuICogdGhlIG5leHQgb25lcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGl0IGVtaXRzIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWUgZnJvbSB0aGUgc291cmNlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2F1ZGl0VGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgYXVkaXRUaW1lYCBpcyBzaW1pbGFyIHRvIGB0aHJvdHRsZVRpbWVgLCBidXQgZW1pdHMgdGhlIGxhc3QgdmFsdWUgZnJvbSB0aGVcbiAqIHNpbGVuY2VkIHRpbWUgd2luZG93LCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCB2YWx1ZS4gYGF1ZGl0VGltZWAgZW1pdHMgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYXMgc29vbiBhc1xuICogaXRzIGludGVybmFsIHRpbWVyIGJlY29tZXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiB0aW1lciBpcyBlbmFibGVkLiBJbml0aWFsbHksIHRoZSB0aW1lciBpcyBkaXNhYmxlZC4gQXMgc29vbiBhcyB0aGUgZmlyc3RcbiAqIHNvdXJjZSB2YWx1ZSBhcnJpdmVzLCB0aGUgdGltZXIgaXMgZW5hYmxlZC4gQWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMgKG9yXG4gKiB0aGUgdGltZSB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGhhcyBwYXNzZWQsXG4gKiB0aGUgdGltZXIgaXMgZGlzYWJsZWQsIHRoZW4gdGhlIG1vc3QgcmVjZW50IHNvdXJjZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLlxuICogT3B0aW9uYWxseSB0YWtlcyBhIHtAbGluayBJU2NoZWR1bGVyfSBmb3IgbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuYXVkaXRUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyB0aGUgbW9zdCByZWNlbnQgc291cmNlXG4gKiB2YWx1ZSwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5XG4gKiBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSByYXRlLWxpbWl0aW5nIGJlaGF2aW9yLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHJhdGUtbGltaXRpbmcgb2ZcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgYXVkaXRUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBhdWRpdFRpbWUoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIGF1ZGl0XzEuYXVkaXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGltZXJfMS50aW1lcihkdXJhdGlvbiwgc2NoZWR1bGVyKTsgfSk7XG59XG5leHBvcnRzLmF1ZGl0VGltZSA9IGF1ZGl0VGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1ZGl0VGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIGBjbG9zaW5nTm90aWZpZXJgIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheSwgYW5kIGVtaXRzXG4gKiB0aGF0IGFycmF5IG9ubHkgd2hlbiBhbm90aGVyIE9ic2VydmFibGUgZW1pdHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdGhlIGluY29taW5nIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIHRoZSBnaXZlbiBgY2xvc2luZ05vdGlmaWVyYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBhdCB3aGljaCBwb2ludCBpdCBlbWl0cyB0aGUgYnVmZmVyIG9uIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgYW5kIHN0YXJ0cyBhIG5ldyBidWZmZXIgaW50ZXJuYWxseSwgYXdhaXRpbmcgdGhlIG5leHQgdGltZVxuICogYGNsb3NpbmdOb3RpZmllcmAgZW1pdHMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIGVtaXQgYXJyYXkgb2YgbW9zdCByZWNlbnQgaW50ZXJ2YWwgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgYnVmZmVyZWQgPSBpbnRlcnZhbC5idWZmZXIoY2xpY2tzKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxhbnk+fSBjbG9zaW5nTm90aWZpZXIgQW4gT2JzZXJ2YWJsZSB0aGF0IHNpZ25hbHMgdGhlXG4gKiBidWZmZXIgdG8gYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIE9ic2VydmFibGUgb2YgYnVmZmVycywgd2hpY2ggYXJlIGFycmF5cyBvZlxuICogdmFsdWVzLlxuICogQG1ldGhvZCBidWZmZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcihjbG9zaW5nTm90aWZpZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYnVmZmVyT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBCdWZmZXJPcGVyYXRvcihjbG9zaW5nTm90aWZpZXIpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5idWZmZXIgPSBidWZmZXI7XG52YXIgQnVmZmVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlck9wZXJhdG9yKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICB0aGlzLmNsb3NpbmdOb3RpZmllciA9IGNsb3NpbmdOb3RpZmllcjtcbiAgICB9XG4gICAgQnVmZmVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllcikpO1xuICAgIH1cbiAgICBCdWZmZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIEJ1ZmZlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIHRoZSBzaXplIGhpdHMgdGhlIG1heGltdW1cbiAqIGBidWZmZXJTaXplYCBnaXZlbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhhdCBhcnJheSBvbmx5IHdoZW4gaXRzIHNpemUgcmVhY2hlcyBgYnVmZmVyU2l6ZWAuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyQ291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyBhIG51bWJlciBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYGJ1ZmZlclNpemVgIHRoZW5cbiAqIGVtaXRzIHRoZSBidWZmZXIgYW5kIGNsZWFycyBpdCwgYW5kIHN0YXJ0cyBhIG5ldyBidWZmZXIgZWFjaFxuICogYHN0YXJ0QnVmZmVyRXZlcnlgIHZhbHVlcy4gSWYgYHN0YXJ0QnVmZmVyRXZlcnlgIGlzIG5vdCBwcm92aWRlZCBvciBpc1xuICogYG51bGxgLCB0aGVuIG5ldyBidWZmZXJzIGFyZSBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlXG4gKiBhbmQgd2hlbiBlYWNoIGJ1ZmZlciBjbG9zZXMgYW5kIGlzIGVtaXR0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgZW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyLCAxKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHBhaXJ3aXNlfVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclNpemUgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgYnVmZmVyIGVtaXR0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0QnVmZmVyRXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IGJ1ZmZlci5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydEJ1ZmZlckV2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgYnVmZmVyIHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyBidWZmZXIgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIE9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyQ291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlckNvdW50KGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpIHtcbiAgICBpZiAoc3RhcnRCdWZmZXJFdmVyeSA9PT0gdm9pZCAwKSB7IHN0YXJ0QnVmZmVyRXZlcnkgPSBudWxsOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlckNvdW50T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBCdWZmZXJDb3VudE9wZXJhdG9yKGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xudmFyIEJ1ZmZlckNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckNvdW50T3BlcmF0b3IoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgICAgICBpZiAoIXN0YXJ0QnVmZmVyRXZlcnkgfHwgYnVmZmVyU2l6ZSA9PT0gc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyQ2xhc3MgPSBCdWZmZXJDb3VudFN1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJDbGFzcyA9IEJ1ZmZlclNraXBDb3VudFN1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnVmZmVyQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IHRoaXMuc3Vic2NyaWJlckNsYXNzKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5zdGFydEJ1ZmZlckV2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyQ291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlckNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlckNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGJ1ZmZlclNpemUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cbiAgICBCdWZmZXJDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSB0aGlzLmJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlckNvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclNraXBDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJFdmVyeSA9IHN0YXJ0QnVmZmVyRXZlcnk7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYnVmZmVyU2l6ZSA9IF9hLmJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkgPSBfYS5zdGFydEJ1ZmZlckV2ZXJ5LCBidWZmZXJzID0gX2EuYnVmZmVycywgY291bnQgPSBfYS5jb3VudDtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICBpZiAoY291bnQgJSBzdGFydEJ1ZmZlckV2ZXJ5ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBidWZmZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XG4gICAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gYnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJTa2lwQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlcnMgPSBfYS5idWZmZXJzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVycy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyU2tpcENvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlckNvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGZvciBhIHNwZWNpZmljIHRpbWUgcGVyaW9kLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheSwgYW5kIGVtaXRzXG4gKiB0aG9zZSBhcnJheXMgcGVyaW9kaWNhbGx5IGluIHRpbWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBCdWZmZXJzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgZm9yIGEgc3BlY2lmaWMgdGltZSBkdXJhdGlvbiBgYnVmZmVyVGltZVNwYW5gLlxuICogVW5sZXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgaXMgZ2l2ZW4sIGl0IGVtaXRzIGFuZFxuICogcmVzZXRzIHRoZSBidWZmZXIgZXZlcnkgYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMuIElmXG4gKiBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgaXMgZ2l2ZW4sIHRoaXMgb3BlcmF0b3Igb3BlbnMgdGhlIGJ1ZmZlciBldmVyeVxuICogYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyBhbmQgY2xvc2VzIChlbWl0cyBhbmQgcmVzZXRzKSB0aGVcbiAqIGJ1ZmZlciBldmVyeSBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcy4gV2hlbiB0aGUgb3B0aW9uYWwgYXJndW1lbnRcbiAqIGBtYXhCdWZmZXJTaXplYCBpcyBzcGVjaWZpZWQsIHRoZSBidWZmZXIgd2lsbCBiZSBjbG9zZWQgZWl0aGVyIGFmdGVyXG4gKiBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcyBvciB3aGVuIGl0IGNvbnRhaW5zIGBtYXhCdWZmZXJTaXplYCBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBzZWNvbmQsIGVtaXQgYW4gYXJyYXkgb2YgdGhlIHJlY2VudCBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRpbWUoMTAwMCk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgNSBzZWNvbmRzLCBlbWl0IHRoZSBjbGljayBldmVudHMgZnJvbSB0aGUgbmV4dCAyIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRpbWUoMjAwMCwgNTAwMCk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVGltZVNwYW4gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGZpbGwgZWFjaCBidWZmZXIgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckNyZWF0aW9uSW50ZXJ2YWxdIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEJ1ZmZlclNpemVdIFRoZSBtYXhpbXVtIGJ1ZmZlciBzaXplLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gKiBpbnRlcnZhbHMgdGhhdCBkZXRlcm1pbmUgYnVmZmVyIGJvdW5kYXJpZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVGltZShidWZmZXJUaW1lU3Bhbikge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IG51bGw7XG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHZhciBtYXhCdWZmZXJTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgICBtYXhCdWZmZXJTaXplID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gYnVmZmVyVGltZU9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgQnVmZmVyVGltZU9wZXJhdG9yKGJ1ZmZlclRpbWVTcGFuLCBidWZmZXJDcmVhdGlvbkludGVydmFsLCBtYXhCdWZmZXJTaXplLCBzY2hlZHVsZXIpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5idWZmZXJUaW1lID0gYnVmZmVyVGltZTtcbnZhciBCdWZmZXJUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRpbWVPcGVyYXRvcihidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyVGltZVNwYW4gPSBidWZmZXJUaW1lU3BhbjtcbiAgICAgICAgdGhpcy5idWZmZXJDcmVhdGlvbkludGVydmFsID0gYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhCdWZmZXJTaXplID0gbWF4QnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIEJ1ZmZlclRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlclRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyVGltZVNwYW4sIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgdGhpcy5tYXhCdWZmZXJTaXplLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRpbWVPcGVyYXRvcjtcbn0oKSk7XG52YXIgQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5idWZmZXJUaW1lU3BhbiA9IGJ1ZmZlclRpbWVTcGFuO1xuICAgICAgICB0aGlzLmJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBidWZmZXJDcmVhdGlvbkludGVydmFsO1xuICAgICAgICB0aGlzLm1heEJ1ZmZlclNpemUgPSBtYXhCdWZmZXJTaXplO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMub3BlbkNvbnRleHQoKTtcbiAgICAgICAgdGhpcy50aW1lc3Bhbk9ubHkgPSBidWZmZXJDcmVhdGlvbkludGVydmFsID09IG51bGwgfHwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA8IDA7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzcGFuT25seSkge1xuICAgICAgICAgICAgdmFyIHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0LCBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJUaW1lU3Bhbk9ubHksIGJ1ZmZlclRpbWVTcGFuLCB0aW1lU3Bhbk9ubHlTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNsb3NlU3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIGNvbnRleHQ6IGNvbnRleHQgfTtcbiAgICAgICAgICAgIHZhciBjcmVhdGlvblN0YXRlID0geyBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIHN1YnNjcmliZXI6IHRoaXMsIHNjaGVkdWxlcjogc2NoZWR1bGVyIH07XG4gICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LmNsb3NlQWN0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyQ2xvc2UsIGJ1ZmZlclRpbWVTcGFuLCBjbG9zZVN0YXRlKSk7XG4gICAgICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJDcmVhdGlvbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgY3JlYXRpb25TdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICB2YXIgZmlsbGVkQnVmZmVyQ29udGV4dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGZpbGxlZEJ1ZmZlckNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsZWRCdWZmZXJDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm9uQnVmZmVyRnVsbChmaWxsZWRCdWZmZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0cy5sZW5ndGggPSAwO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250ZXh0cyA9IF9hLmNvbnRleHRzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAoY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLm9uQnVmZmVyRnVsbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB2YXIgY2xvc2VBY3Rpb24gPSBjb250ZXh0LmNsb3NlQWN0aW9uO1xuICAgICAgICBjbG9zZUFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlbW92ZShjbG9zZUFjdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy50aW1lc3Bhbk9ubHkpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLm9wZW5Db250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgYnVmZmVyVGltZVNwYW4gPSB0aGlzLmJ1ZmZlclRpbWVTcGFuO1xuICAgICAgICAgICAgdmFyIHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0LCBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seSwgYnVmZmVyVGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBzcGxpY2VJbmRleCA9IGNvbnRleHRzID8gY29udGV4dHMuaW5kZXhPZihjb250ZXh0KSA6IC0xO1xuICAgICAgICBpZiAoc3BsaWNlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29udGV4dHMuc3BsaWNlKGNvbnRleHRzLmluZGV4T2YoY29udGV4dCksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICB2YXIgcHJldkNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgIGlmIChwcmV2Q29udGV4dCkge1xuICAgICAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChwcmV2Q29udGV4dCk7XG4gICAgfVxuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IHN1YnNjcmliZXIub3BlbkNvbnRleHQoKTtcbiAgICAgICAgc3RhdGUuY29udGV4dC5jbG9zZUFjdGlvbiA9IHRoaXMuc2NoZWR1bGUoc3RhdGUsIHN0YXRlLmJ1ZmZlclRpbWVTcGFuKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNyZWF0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBzdGF0ZS5idWZmZXJDcmVhdGlvbkludGVydmFsLCBidWZmZXJUaW1lU3BhbiA9IHN0YXRlLmJ1ZmZlclRpbWVTcGFuLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyO1xuICAgIHZhciBjb250ZXh0ID0gc3Vic2NyaWJlci5vcGVuQ29udGV4dCgpO1xuICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoY29udGV4dC5jbG9zZUFjdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlckNsb3NlLCBidWZmZXJUaW1lU3BhbiwgeyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLCBjb250ZXh0OiBjb250ZXh0IH0pKTtcbiAgICAgICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBidWZmZXJDcmVhdGlvbkludGVydmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNsb3NlKGFyZykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIGNvbnRleHQgPSBhcmcuY29udGV4dDtcbiAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChjb250ZXh0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHN0YXJ0aW5nIGZyb20gYW4gZW1pc3Npb24gZnJvbVxuICogYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXkuIFN0YXJ0c1xuICogY29sbGVjdGluZyBvbmx5IHdoZW4gYG9wZW5pbmdgIGVtaXRzLCBhbmQgY2FsbHMgdGhlIGBjbG9zaW5nU2VsZWN0b3JgXG4gKiBmdW5jdGlvbiB0byBnZXQgYW4gT2JzZXJ2YWJsZSB0aGF0IHRlbGxzIHdoZW4gdG8gY2xvc2UgdGhlIGJ1ZmZlci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9idWZmZXJUb2dnbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIGJ5IG9wZW5pbmcgdGhlIGJ1ZmZlciB2aWEgc2lnbmFscyBmcm9tIGFuXG4gKiBPYnNlcnZhYmxlIHByb3ZpZGVkIHRvIGBvcGVuaW5nc2AsIGFuZCBjbG9zaW5nIGFuZCBzZW5kaW5nIHRoZSBidWZmZXJzIHdoZW5cbiAqIGEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGBjbG9zaW5nU2VsZWN0b3JgIGZ1bmN0aW9uIGVtaXRzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IG90aGVyIHNlY29uZCwgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgNTAwbXM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9wZW5pbmdzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJUb2dnbGUob3BlbmluZ3MsIGkgPT5cbiAqICAgaSAlIDIgPyBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkgOiBSeC5PYnNlcnZhYmxlLmVtcHR5KClcbiAqICk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqXG4gKiBAcGFyYW0ge1N1YnNjcmliYWJsZU9yUHJvbWlzZTxPPn0gb3BlbmluZ3MgQSBTdWJzY3JpYmFibGUgb3IgUHJvbWlzZSBvZiBub3RpZmljYXRpb25zIHRvIHN0YXJ0IG5ld1xuICogYnVmZmVycy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IE8pOiBTdWJzY3JpYmFibGVPclByb21pc2V9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqIHRoZSB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBgb3BlbmluZ3NgIG9ic2VydmFibGUgYW5kIHJldHVybnMgYSBTdWJzY3JpYmFibGUgb3IgUHJvbWlzZSxcbiAqIHdoaWNoLCB3aGVuIGl0IGVtaXRzLCBzaWduYWxzIHRoYXQgdGhlIGFzc29jaWF0ZWQgYnVmZmVyIHNob3VsZCBiZSBlbWl0dGVkXG4gKiBhbmQgY2xlYXJlZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VFtdPn0gQW4gb2JzZXJ2YWJsZSBvZiBhcnJheXMgb2YgYnVmZmVyZWQgdmFsdWVzLlxuICogQG1ldGhvZCBidWZmZXJUb2dnbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvZ2dsZShvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJ1ZmZlclRvZ2dsZU9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgQnVmZmVyVG9nZ2xlT3BlcmF0b3Iob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG59XG5leHBvcnRzLmJ1ZmZlclRvZ2dsZSA9IGJ1ZmZlclRvZ2dsZTtcbnZhciBCdWZmZXJUb2dnbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyVG9nZ2xlT3BlcmF0b3Iob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLm9wZW5pbmdzID0gb3BlbmluZ3M7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgIH1cbiAgICBCdWZmZXJUb2dnbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vcGVuaW5ncywgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJUb2dnbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9wZW5pbmdzID0gb3BlbmluZ3M7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb3BlbmluZ3MpKTtcbiAgICB9XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29udGV4dHNbaV0uYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHdoaWxlIChjb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHdoaWxlIChjb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoY29udGV4dC5idWZmZXIpO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgb3V0ZXJWYWx1ZSA/IHRoaXMuY2xvc2VCdWZmZXIob3V0ZXJWYWx1ZSkgOiB0aGlzLm9wZW5CdWZmZXIoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKGlubmVyU3ViLmNvbnRleHQpO1xuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUub3BlbkJ1ZmZlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdTZWxlY3RvciA9IHRoaXMuY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IGNsb3NpbmdTZWxlY3Rvci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN1YnNjcmliZShjbG9zaW5nTm90aWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlQnVmZmVyID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgaWYgKGNvbnRleHRzICYmIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBjb250ZXh0LmJ1ZmZlciwgc3Vic2NyaXB0aW9uID0gY29udGV4dC5zdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnRleHRzLnNwbGljZShjb250ZXh0cy5pbmRleE9mKGNvbnRleHQpLCAxKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgYnVmZmVyID0gW107XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0geyBidWZmZXI6IGJ1ZmZlciwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gfTtcbiAgICAgICAgY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUJ1ZmZlcihjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRvZ2dsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzLCB1c2luZyBhIGZhY3RvcnkgZnVuY3Rpb24gb2YgY2xvc2luZ1xuICogT2JzZXJ2YWJsZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gY2xvc2UsIGVtaXQsIGFuZCByZXNldCB0aGUgYnVmZmVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheS4gV2hlbiBpdFxuICogc3RhcnRzIGNvbGxlY3RpbmcgdmFsdWVzLCBpdCBjYWxscyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXRcbiAqIHRlbGxzIHdoZW4gdG8gY2xvc2UgdGhlIGJ1ZmZlciBhbmQgcmVzdGFydCBjb2xsZWN0aW5nLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlcldoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogT3BlbnMgYSBidWZmZXIgaW1tZWRpYXRlbHksIHRoZW4gY2xvc2VzIHRoZSBidWZmZXIgd2hlbiB0aGUgb2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgY2FsbGluZyBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cyBhIHZhbHVlLiBXaGVuIGl0IGNsb3Nlc1xuICogdGhlIGJ1ZmZlciwgaXQgaW1tZWRpYXRlbHkgb3BlbnMgYSBuZXcgYnVmZmVyIGFuZCByZXBlYXRzIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgYW4gYXJyYXkgb2YgdGhlIGxhc3QgY2xpY2tzIGV2ZXJ5IFsxLTVdIHJhbmRvbSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJXaGVuKCgpID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCArIE1hdGgucmFuZG9tKCkgKiA0MDAwKVxuICogKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogT2JzZXJ2YWJsZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIGJ1ZmZlciBjbG9zdXJlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBvYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlcldoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcldoZW4oY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBCdWZmZXJXaGVuT3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYnVmZmVyV2hlbiA9IGJ1ZmZlcldoZW47XG52YXIgQnVmZmVyV2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJXaGVuT3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgIH1cbiAgICBCdWZmZXJXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlcldoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlcldoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyV2hlblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyV2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLnN1YnNjcmliaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgIH1cbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbkJ1ZmZlcigpO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmluZykge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvc2luZ1N1YnNjcmlwdGlvbiA9IHRoaXMuY2xvc2luZ1N1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGNsb3NpbmdTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNsb3NpbmdTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgY2xvc2luZ05vdGlmaWVyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmNsb3NpbmdTZWxlY3RvcikoKTtcbiAgICAgICAgaWYgKGNsb3NpbmdOb3RpZmllciA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZ1N1YnNjcmlwdGlvbiA9IGNsb3NpbmdTdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0aGlzLmFkZChjbG9zaW5nU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlcldoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlcldoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENhdGNoZXMgZXJyb3JzIG9uIHRoZSBvYnNlcnZhYmxlIHRvIGJlIGhhbmRsZWQgYnkgcmV0dXJuaW5nIGEgbmV3IG9ic2VydmFibGUgb3IgdGhyb3dpbmcgYW4gZXJyb3IuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jYXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db250aW51ZXMgd2l0aCBhIGRpZmZlcmVudCBPYnNlcnZhYmxlIHdoZW4gdGhlcmUncyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiBPYnNlcnZhYmxlLm9mKCdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJykpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIEksIElJLCBJSUksIElWLCBWXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmV0cmllcyB0aGUgY2F1Z2h0IHNvdXJjZSBPYnNlcnZhYmxlIGFnYWluIGluIGNhc2Ugb2YgZXJyb3IsIHNpbWlsYXIgdG8gcmV0cnkoKSBvcGVyYXRvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiBcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goKGVyciwgY2F1Z2h0KSA9PiBjYXVnaHQpXG4gKiAgIC50YWtlKDMwKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCAxLCAyLCAzLCAuLi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaHJvd3MgYSBuZXcgZXJyb3Igd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhyb3dzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqICAgICBpZiAobiA9PSA0KSB7XG4gKiAgICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqICAgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgdGhyb3cgJ2Vycm9yIGluIHNvdXJjZS4gRGV0YWlsczogJyArIGVycjtcbiAqICAgfSlcbiAqICAgLnN1YnNjcmliZShcbiAqICAgICB4ID0+IGNvbnNvbGUubG9nKHgpLFxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpXG4gKiAgICk7XG4gKiAgIC8vIDEsIDIsIDMsIGVycm9yIGluIHNvdXJjZS4gRGV0YWlsczogZm91ciFcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzZWxlY3RvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXMgYXJndW1lbnRzIGBlcnJgLCB3aGljaCBpcyB0aGUgZXJyb3IsIGFuZCBgY2F1Z2h0YCwgd2hpY2hcbiAqICBpcyB0aGUgc291cmNlIG9ic2VydmFibGUsIGluIGNhc2UgeW91J2QgbGlrZSB0byBcInJldHJ5XCIgdGhhdCBvYnNlcnZhYmxlIGJ5IHJldHVybmluZyBpdCBhZ2Fpbi4gV2hhdGV2ZXIgb2JzZXJ2YWJsZVxuICogIGlzIHJldHVybmVkIGJ5IHRoZSBgc2VsZWN0b3JgIHdpbGwgYmUgdXNlZCB0byBjb250aW51ZSB0aGUgb2JzZXJ2YWJsZSBjaGFpbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGhlIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgdGhlXG4gKiAgY2F0Y2ggYHNlbGVjdG9yYCBmdW5jdGlvbi5cbiAqIEBuYW1lIGNhdGNoRXJyb3JcbiAqL1xuZnVuY3Rpb24gY2F0Y2hFcnJvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBjYXRjaEVycm9yT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gbmV3IENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB2YXIgY2F1Z2h0ID0gc291cmNlLmxpZnQob3BlcmF0b3IpO1xuICAgICAgICByZXR1cm4gKG9wZXJhdG9yLmNhdWdodCA9IGNhdWdodCk7XG4gICAgfTtcbn1cbmV4cG9ydHMuY2F0Y2hFcnJvciA9IGNhdGNoRXJyb3I7XG52YXIgQ2F0Y2hPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIENhdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDYXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zZWxlY3RvciwgdGhpcy5jYXVnaHQpKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRjaE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQ2F0Y2hTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2VsZWN0b3IsIGNhdWdodCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYXVnaHQgPSBjYXVnaHQ7XG4gICAgfVxuICAgIC8vIE5PVEU6IG92ZXJyaWRpbmcgYGVycm9yYCBpbnN0ZWFkIG9mIGBfZXJyb3JgIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGhhdmUgdGhpcyBmbGFnIHRoaXMgc3Vic2NyaWJlciBhcyBgaXNTdG9wcGVkYC4gV2UgY2FuIG1pbWljIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIHRoZSBSZXRyeVN1YnNjcmliZXIgKGZyb20gdGhlIGByZXRyeWAgb3BlcmF0b3IpLCB3aGVyZVxuICAgIC8vIHdlIHVuc3Vic2NyaWJlIGZyb20gb3VyIHNvdXJjZSBjaGFpbiwgcmVzZXQgb3VyIFN1YnNjcmliZXIgZmxhZ3MsXG4gICAgLy8gdGhlbiBzdWJzY3JpYmUgdG8gdGhlIHNlbGVjdG9yIHJlc3VsdC5cbiAgICBDYXRjaFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdG9yKGVyciwgdGhpcy5jYXVnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3QnKTtcbmZ1bmN0aW9uIGNvbWJpbmVBbGwocHJvamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgY29tYmluZUxhdGVzdF8xLkNvbWJpbmVMYXRlc3RPcGVyYXRvcihwcm9qZWN0KSk7IH07XG59XG5leHBvcnRzLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZUFsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgbm9uZSA9IHt9O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGUgd2hvc2UgdmFsdWVzIGFyZVxuICogY2FsY3VsYXRlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVzIG9mIGVhY2ggb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciBhbnkgaW5wdXQgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBpdFxuICogY29tcHV0ZXMgYSBmb3JtdWxhIHVzaW5nIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dHMsIHRoZW4gZW1pdHNcbiAqIHRoZSBvdXRwdXQgb2YgdGhhdCBmb3JtdWxhLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbWJpbmVMYXRlc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvbWJpbmVMYXRlc3RgIGNvbWJpbmVzIHRoZSB2YWx1ZXMgZnJvbSB0aGlzIE9ic2VydmFibGUgd2l0aCB2YWx1ZXMgZnJvbVxuICogT2JzZXJ2YWJsZXMgcGFzc2VkIGFzIGFyZ3VtZW50cy4gVGhpcyBpcyBkb25lIGJ5IHN1YnNjcmliaW5nIHRvIGVhY2hcbiAqIE9ic2VydmFibGUsIGluIG9yZGVyLCBhbmQgY29sbGVjdGluZyBhbiBhcnJheSBvZiBlYWNoIG9mIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGFueSB0aW1lIGFueSBvZiB0aGUgaW5wdXQgT2JzZXJ2YWJsZXMgZW1pdHMsIHRoZW4gZWl0aGVyIHRha2luZyB0aGF0XG4gKiBhcnJheSBhbmQgcGFzc2luZyBpdCBhcyBhcmd1bWVudHMgdG8gYW4gb3B0aW9uYWwgYHByb2plY3RgIGZ1bmN0aW9uIGFuZFxuICogZW1pdHRpbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGF0LCBvciBqdXN0IGVtaXR0aW5nIHRoZSBhcnJheSBvZiByZWNlbnRcbiAqIHZhbHVlcyBkaXJlY3RseSBpZiB0aGVyZSBpcyBubyBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RHluYW1pY2FsbHkgY2FsY3VsYXRlIHRoZSBCb2R5LU1hc3MgSW5kZXggZnJvbSBhbiBPYnNlcnZhYmxlIG9mIHdlaWdodCBhbmQgb25lIGZvciBoZWlnaHQ8L2NhcHRpb24+XG4gKiB2YXIgd2VpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZig3MCwgNzIsIDc2LCA3OSwgNzUpO1xuICogdmFyIGhlaWdodCA9IFJ4Lk9ic2VydmFibGUub2YoMS43NiwgMS43NywgMS43OCk7XG4gKiB2YXIgYm1pID0gd2VpZ2h0LmNvbWJpbmVMYXRlc3QoaGVpZ2h0LCAodywgaCkgPT4gdyAvIChoICogaCkpO1xuICogYm1pLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdCTUkgaXMgJyArIHgpKTtcbiAqXG4gKiAvLyBXaXRoIG91dHB1dCB0byBjb25zb2xlOlxuICogLy8gQk1JIGlzIDI0LjIxMjI5MzM4ODQyOTc1M1xuICogLy8gQk1JIGlzIDIzLjkzOTQ4MDk5MjA1MjA5XG4gKiAvLyBCTUkgaXMgMjMuNjcxMjUzNjI5NTkyMjIyXG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2plY3RdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHByb2plY3QgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgY29tYmluZWQgbGF0ZXN0IHZhbHVlcyBpbnRvIGEgbmV3IHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgcHJvamVjdGVkIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGZyb20gZWFjaCBpbnB1dCBPYnNlcnZhYmxlLCBvciBhbiBhcnJheSBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWVzIGZyb21cbiAqIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgY29tYmluZUxhdGVzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29tYmluZUxhdGVzdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHByb2plY3QgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvamVjdCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgb3RoZXIgYXJndW1lbnQgYmVzaWRlcyB0aGUgcmVzdWx0U2VsZWN0b3IgaXMgYW4gYXJyYXlcbiAgICAvLyBhc3N1bWUgaXQncyBiZWVuIGNhbGxlZCB3aXRoIGBjb21iaW5lTGF0ZXN0KFtvYnMxLCBvYnMyLCBvYnMzXSwgcHJvamVjdClgXG4gICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5XzEuaXNBcnJheShvYnNlcnZhYmxlc1swXSkpIHtcbiAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQuY2FsbChuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKFtzb3VyY2VdLmNvbmNhdChvYnNlcnZhYmxlcykpLCBuZXcgQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpKTsgfTtcbn1cbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XG52YXIgQ29tYmluZUxhdGVzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lTGF0ZXN0T3BlcmF0b3IocHJvamVjdCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBDb21iaW5lTGF0ZXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5Db21iaW5lTGF0ZXN0T3BlcmF0b3IgPSBDb21iaW5lTGF0ZXN0T3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tYmluZUxhdGVzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBbXTtcbiAgICB9XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMucHVzaChub25lKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUpO1xuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBsZW47XG4gICAgICAgICAgICB0aGlzLnRvUmVzcG9uZCA9IGxlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG9ic2VydmFibGVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAodW51c2VkKSB7XG4gICAgICAgIGlmICgodGhpcy5hY3RpdmUgLT0gMSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICB2YXIgb2xkVmFsID0gdmFsdWVzW291dGVySW5kZXhdO1xuICAgICAgICB2YXIgdG9SZXNwb25kID0gIXRoaXMudG9SZXNwb25kXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogb2xkVmFsID09PSBub25lID8gLS10aGlzLnRvUmVzcG9uZCA6IHRoaXMudG9SZXNwb25kO1xuICAgICAgICB2YWx1ZXNbb3V0ZXJJbmRleF0gPSBpbm5lclZhbHVlO1xuICAgICAgICBpZiAodG9SZXNwb25kID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlcy5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQ29tYmluZUxhdGVzdFN1YnNjcmliZXIgPSBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL2NvbmNhdCcpO1xudmFyIGNvbmNhdF8yID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9jb25jYXQnKTtcbmV4cG9ydHMuY29uY2F0U3RhdGljID0gY29uY2F0XzIuY29uY2F0O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBzZXF1ZW50aWFsbHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIGFmdGVyIHRoZSBjdXJyZW50IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbmNhdGVuYXRlcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieVxuICogc2VxdWVudGlhbGx5IGVtaXR0aW5nIHRoZWlyIHZhbHVlcywgb25lIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBKb2lucyB0aGlzIE9ic2VydmFibGUgd2l0aCBtdWx0aXBsZSBvdGhlciBPYnNlcnZhYmxlcyBieSBzdWJzY3JpYmluZyB0byB0aGVtXG4gKiBvbmUgYXQgYSB0aW1lLCBzdGFydGluZyB3aXRoIHRoZSBzb3VyY2UsIGFuZCBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLiBXaWxsIHdhaXQgZm9yIGVhY2ggT2JzZXJ2YWJsZSB0byBjb21wbGV0ZSBiZWZvcmUgbW92aW5nXG4gKiBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhIHRpbWVyIGNvdW50aW5nIGZyb20gMCB0byAzIHdpdGggYSBzeW5jaHJvbm91cyBzZXF1ZW5jZSBmcm9tIDEgdG8gMTA8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCk7XG4gKiB2YXIgc2VxdWVuY2UgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lci5jb25jYXQoc2VxdWVuY2UpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluOlxuICogLy8gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gMyAtaW1tZWRpYXRlLT4gMSAuLi4gMTBcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSAzIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lcjEuY29uY2F0KHRpbWVyMiwgdGltZXIzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSBhZnRlciB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIEFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gc2NoZWR1bGUgZWFjaFxuICogT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbGwgdmFsdWVzIG9mIGVhY2ggcGFzc2VkIE9ic2VydmFibGUgbWVyZ2VkIGludG8gYVxuICogc2luZ2xlIE9ic2VydmFibGUsIGluIG9yZGVyLCBpbiBzZXJpYWwgZmFzaGlvbi5cbiAqIEBtZXRob2QgY29uY2F0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdC5jYWxsKGNvbmNhdF8xLmNvbmNhdC5hcHBseSh2b2lkIDAsIFtzb3VyY2VdLmNvbmNhdChvYnNlcnZhYmxlcykpKTsgfTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgYnlcbiAqIGNvbmNhdGVuYXRpbmcgdGhlIGlubmVyIE9ic2VydmFibGVzIGluIG9yZGVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IHB1dHRpbmcgb25lXG4gKiBpbm5lciBPYnNlcnZhYmxlIGFmdGVyIHRoZSBvdGhlci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXRBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSm9pbnMgZXZlcnkgT2JzZXJ2YWJsZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgKGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUpLCBpblxuICogYSBzZXJpYWwgZmFzaGlvbi4gSXQgc3Vic2NyaWJlcyB0byBlYWNoIGlubmVyIE9ic2VydmFibGUgb25seSBhZnRlciB0aGVcbiAqIHByZXZpb3VzIGlubmVyIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZCwgYW5kIG1lcmdlcyBhbGwgb2YgdGhlaXIgdmFsdWVzIGludG9cbiAqIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlLlxuICpcbiAqIF9fV2FybmluZzpfXyBJZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgT2JzZXJ2YWJsZXMgcXVpY2tseSBhbmRcbiAqIGVuZGxlc3NseSwgYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlcyBpdCBlbWl0cyBnZW5lcmFsbHkgY29tcGxldGUgc2xvd2VyIHRoYW5cbiAqIHRoZSBzb3VyY2UgZW1pdHMsIHlvdSBjYW4gcnVuIGludG8gbWVtb3J5IGlzc3VlcyBhcyB0aGUgaW5jb21pbmcgT2JzZXJ2YWJsZXNcbiAqIGNvbGxlY3QgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlci5cbiAqXG4gKiBOb3RlOiBgY29uY2F0QWxsYCBpcyBlcXVpdmFsZW50IHRvIGBtZXJnZUFsbGAgd2l0aCBjb25jdXJyZW5jeSBwYXJhbWV0ZXIgc2V0XG4gKiB0byBgMWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHRpY2sgZXZlcnkgc2Vjb25kIGZyb20gMCB0byAzLCB3aXRoIG5vIGNvbmN1cnJlbmN5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIuY29uY2F0QWxsKCk7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAocmVzdWx0cyBhcmUgbm90IGNvbmN1cnJlbnQpXG4gKiAvLyBGb3IgZXZlcnkgY2xpY2sgb24gdGhlIFwiZG9jdW1lbnRcIiBpdCB3aWxsIGVtaXQgdmFsdWVzIDAgdG8gMyBzcGFjZWRcbiAqIC8vIG9uIGEgMTAwMG1zIGludGVydmFsXG4gKiAvLyBvbmUgY2xpY2sgPSAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzXG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgZW1pdHRpbmcgdmFsdWVzIGZyb20gYWxsIHRoZSBpbm5lclxuICogT2JzZXJ2YWJsZXMgY29uY2F0ZW5hdGVkLlxuICogQG1ldGhvZCBjb25jYXRBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEFsbCgpIHtcbiAgICByZXR1cm4gbWVyZ2VBbGxfMS5tZXJnZUFsbCgxKTtcbn1cbmV4cG9ydHMuY29uY2F0QWxsID0gY29uY2F0QWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0QWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuL21lcmdlTWFwJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLCBpbiBhIHNlcmlhbGl6ZWQgZmFzaGlvbiB3YWl0aW5nIGZvciBlYWNoIG9uZSB0byBjb21wbGV0ZSBiZWZvcmVcbiAqIG1lcmdpbmcgdGhlIG5leHQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIGNvbmNhdEFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0TWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIEVhY2ggbmV3IGlubmVyIE9ic2VydmFibGUgaXNcbiAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlLlxuICpcbiAqIF9fV2FybmluZzpfXyBpZiBzb3VyY2UgdmFsdWVzIGFycml2ZSBlbmRsZXNzbHkgYW5kIGZhc3RlciB0aGFuIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIGlubmVyIE9ic2VydmFibGVzIGNhbiBjb21wbGV0ZSwgaXQgd2lsbCByZXN1bHQgaW4gbWVtb3J5IGlzc3Vlc1xuICogYXMgaW5uZXIgT2JzZXJ2YWJsZXMgYW1hc3MgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlciB3YWl0aW5nIGZvciB0aGVpciB0dXJuIHRvXG4gKiBiZSBzdWJzY3JpYmVkIHRvLlxuICpcbiAqIE5vdGU6IGBjb25jYXRNYXBgIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlTWFwYCB3aXRoIGNvbmN1cnJlbmN5IHBhcmFtZXRlciBzZXRcbiAqIHRvIGAxYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3IgZWFjaCBjbGljayBldmVudCwgdGljayBldmVyeSBzZWNvbmQgZnJvbSAwIHRvIDMsIHdpdGggbm8gY29uY3VycmVuY3k8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5jb25jYXRNYXAoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKHJlc3VsdHMgYXJlIG5vdCBjb25jdXJyZW50KVxuICogLy8gRm9yIGV2ZXJ5IGNsaWNrIG9uIHRoZSBcImRvY3VtZW50XCIgaXQgd2lsbCBlbWl0IHZhbHVlcyAwIHRvIDMgc3BhY2VkXG4gKiAvLyBvbiBhIDEwMDBtcyBpbnRlcnZhbFxuICogLy8gb25lIGNsaWNrID0gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gM1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZUlucHV0fSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiAoYW5kIHRoZSBvcHRpb25hbCBgcmVzdWx0U2VsZWN0b3JgKSB0byBlYWNoIGl0ZW0gZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCB0YWtpbmcgdmFsdWVzIGZyb20gZWFjaCBwcm9qZWN0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGUgc2VxdWVudGlhbGx5LlxuICogQG1ldGhvZCBjb25jYXRNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdE1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBtZXJnZU1hcF8xLm1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCAxKTtcbn1cbmV4cG9ydHMuY29uY2F0TWFwID0gY29uY2F0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbmNhdE1hcF8xID0gcmVxdWlyZSgnLi9jb25jYXRNYXAnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBzYW1lIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIG11bHRpcGxlXG4gKiB0aW1lcyBpbiBhIHNlcmlhbGl6ZWQgZmFzaGlvbiBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgY29uY2F0TWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZVxuICogYWx3YXlzIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0TWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBmbGF0dGVucyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuIEVhY2ggbmV3IGBpbm5lck9ic2VydmFibGVgXG4gKiBpbnN0YW5jZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcHJldmlvdXNcbiAqIGBpbm5lck9ic2VydmFibGVgIGluc3RhbmNlLlxuICpcbiAqIF9fV2FybmluZzpfXyBpZiBzb3VyY2UgdmFsdWVzIGFycml2ZSBlbmRsZXNzbHkgYW5kIGZhc3RlciB0aGFuIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIGlubmVyIE9ic2VydmFibGVzIGNhbiBjb21wbGV0ZSwgaXQgd2lsbCByZXN1bHQgaW4gbWVtb3J5IGlzc3Vlc1xuICogYXMgaW5uZXIgT2JzZXJ2YWJsZXMgYW1hc3MgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlciB3YWl0aW5nIGZvciB0aGVpciB0dXJuIHRvXG4gKiBiZSBzdWJzY3JpYmVkIHRvLlxuICpcbiAqIE5vdGU6IGBjb25jYXRNYXBUb2AgaXMgZXF1aXZhbGVudCB0byBgbWVyZ2VNYXBUb2Agd2l0aCBjb25jdXJyZW5jeSBwYXJhbWV0ZXJcbiAqIHNldCB0byBgMWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHRpY2sgZXZlcnkgc2Vjb25kIGZyb20gMCB0byAzLCB3aXRoIG5vIGNvbmN1cnJlbmN5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuY29uY2F0TWFwVG8oUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKHJlc3VsdHMgYXJlIG5vdCBjb25jdXJyZW50KVxuICogLy8gRm9yIGV2ZXJ5IGNsaWNrIG9uIHRoZSBcImRvY3VtZW50XCIgaXQgd2lsbCBlbWl0IHZhbHVlcyAwIHRvIDMgc3BhY2VkXG4gKiAvLyBvbiBhIDEwMDBtcyBpbnRlcnZhbFxuICogLy8gb25lIGNsaWNrID0gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gM1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5uZXJPYnNlcnZhYmxlIEFuIE9ic2VydmFibGUgdG8gcmVwbGFjZSBlYWNoIHZhbHVlIGZyb21cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIG9mIHZhbHVlcyBtZXJnZWQgdG9nZXRoZXIgYnkgam9pbmluZyB0aGVcbiAqIHBhc3NlZCBvYnNlcnZhYmxlIHdpdGggaXRzZWxmLCBvbmUgYWZ0ZXIgdGhlIG90aGVyLCBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkXG4gKiBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAbWV0aG9kIGNvbmNhdE1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbmNhdE1hcF8xLmNvbmNhdE1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBpbm5lck9ic2VydmFibGU7IH0sIHJlc3VsdFNlbGVjdG9yKTtcbn1cbmV4cG9ydHMuY29uY2F0TWFwVG8gPSBjb25jYXRNYXBUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcFRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBDb3VudHMgdGhlIG51bWJlciBvZiBlbWlzc2lvbnMgb24gdGhlIHNvdXJjZSBhbmQgZW1pdHMgdGhhdCBudW1iZXIgd2hlbiB0aGVcbiAqIHNvdXJjZSBjb21wbGV0ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRlbGxzIGhvdyBtYW55IHZhbHVlcyB3ZXJlIGVtaXR0ZWQsIHdoZW4gdGhlIHNvdXJjZVxuICogY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvdW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb3VudGAgdHJhbnNmb3JtcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGludG8gYW4gT2JzZXJ2YWJsZSB0aGF0XG4gKiBlbWl0cyBhIHNpbmdsZSB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiB2YWx1ZXMgZW1pdHRlZCBieSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGUgdGVybWluYXRlcyB3aXRoIGFuIGVycm9yLCBgY291bnRgXG4gKiB3aWxsIHBhc3MgdGhpcyBlcnJvciBub3RpZmljYXRpb24gYWxvbmcgd2l0aG91dCBlbWl0dGluZyBhIHZhbHVlIGZpcnN0LiBJZlxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGRvZXMgbm90IHRlcm1pbmF0ZSBhdCBhbGwsIGBjb3VudGAgd2lsbCBuZWl0aGVyIGVtaXRcbiAqIGEgdmFsdWUgbm9yIHRlcm1pbmF0ZS4gVGhpcyBvcGVyYXRvciB0YWtlcyBhbiBvcHRpb25hbCBgcHJlZGljYXRlYCBmdW5jdGlvblxuICogYXMgYXJndW1lbnQsIGluIHdoaWNoIGNhc2UgdGhlIG91dHB1dCBlbWlzc2lvbiB3aWxsIHJlcHJlc2VudCB0aGUgbnVtYmVyIG9mXG4gKiBzb3VyY2UgdmFsdWVzIHRoYXQgbWF0Y2hlZCBgdHJ1ZWAgd2l0aCB0aGUgYHByZWRpY2F0ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnRzIGhvdyBtYW55IHNlY29uZHMgaGF2ZSBwYXNzZWQgYmVmb3JlIHRoZSBmaXJzdCBjbGljayBoYXBwZW5lZDwvY2FwdGlvbj5cbiAqIHZhciBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgc2Vjb25kc0JlZm9yZUNsaWNrID0gc2Vjb25kcy50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHZhciByZXN1bHQgPSBzZWNvbmRzQmVmb3JlQ2xpY2suY291bnQoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnRzIGhvdyBtYW55IG9kZCBudW1iZXJzIGFyZSB0aGVyZSBiZXR3ZWVuIDEgYW5kIDc8L2NhcHRpb24+XG4gKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgNyk7XG4gKiB2YXIgcmVzdWx0ID0gbnVtYmVycy5jb3VudChpID0+IGkgJSAyID09PSAxKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIDRcbiAqXG4gKiBAc2VlIHtAbGluayBtYXh9XG4gKiBAc2VlIHtAbGluayBtaW59XG4gKiBAc2VlIHtAbGluayByZWR1Y2V9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaTogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBbcHJlZGljYXRlXSBBXG4gKiBib29sZWFuIGZ1bmN0aW9uIHRvIHNlbGVjdCB3aGF0IHZhbHVlcyBhcmUgdG8gYmUgY291bnRlZC4gSXQgaXMgcHJvdmlkZWQgd2l0aFxuICogYXJndW1lbnRzIG9mOlxuICogLSBgdmFsdWVgOiB0aGUgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiAtIGBpbmRleGA6IHRoZSAoemVyby1iYXNlZCkgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIC0gYHNvdXJjZWA6IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpbnN0YW5jZSBpdHNlbGYuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIG9uZSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjb3VudCBhc1xuICogZGVzY3JpYmVkIGFib3ZlLlxuICogQG1ldGhvZCBjb3VudFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY291bnQocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBDb3VudE9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlKSk7IH07XG59XG5leHBvcnRzLmNvdW50ID0gY291bnQ7XG52YXIgQ291bnRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ291bnRPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIENvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIENvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcmVkaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuY291bnQpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgYnV0IHRoZSB0aW1lIHNwYW4gb2ZcbiAqIGVtaXNzaW9uIHNpbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzIHByZXZpb3VzXG4gKiBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgc3Bhd25zIGEgZHVyYXRpb24gT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZVxuICogYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uLiBUaGUgdmFsdWUgaXMgZW1pdHRlZCBvbmx5IHdoZW4gdGhlIGR1cmF0aW9uXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLCBhbmQgaWYgbm8gb3RoZXIgdmFsdWUgd2FzIGVtaXR0ZWQgb25cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBzaW5jZSB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSB3YXMgc3Bhd25lZC4gSWYgYSBuZXdcbiAqIHZhbHVlIGFwcGVhcnMgYmVmb3JlIHRoZSBkdXJhdGlvbiBPYnNlcnZhYmxlIGVtaXRzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbFxuICogYmUgZHJvcHBlZCBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogTGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgdGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGFuZCBhbHNvIGFcbiAqIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3QgbmVjZXNzYXJpbHkgb2NjdXIgYXQgdGhlXG4gKiBzYW1lIHRpbWUgYXMgdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2UoKCkgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFN1YnNjcmliYWJsZU9yUHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHRpbWVvdXRcbiAqIGR1cmF0aW9uIGZvciBlYWNoIHNvdXJjZSB2YWx1ZSwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBkdXJhdGlvblNlbGVjdG9yYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXIgdG9vIGZyZXF1ZW50bHkuXG4gKiBAbWV0aG9kIGRlYm91bmNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEZWJvdW5jZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpKTsgfTtcbn1cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbnZhciBEZWJvdW5jZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgRGVib3VuY2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVib3VuY2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmR1cmF0aW9uU2VsZWN0b3IuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pO1xuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLmVtaXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIGEgcGFydGljdWxhciB0aW1lIHNwYW5cbiAqIGhhcyBwYXNzZWQgd2l0aG91dCBhbm90aGVyIHNvdXJjZSBlbWlzc2lvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCBwYXNzZXMgb25seSB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlIGZyb20gZWFjaCBidXJzdCBvZiBlbWlzc2lvbnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVib3VuY2VUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZVRpbWVgIGRlbGF5cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wc1xuICogcHJldmlvdXMgcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyB2YWx1ZSBhcnJpdmVzIG9uIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoYXQgb25seSB3aGVuIGBkdWVUaW1lYCBlbm91Z2ggdGltZSBoYXMgcGFzc2VkXG4gKiB3aXRob3V0IGFueSBvdGhlciB2YWx1ZSBhcHBlYXJpbmcgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIG5ldyB2YWx1ZVxuICogYXBwZWFycyBiZWZvcmUgYGR1ZVRpbWVgIHNpbGVuY2Ugb2NjdXJzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbCBiZSBkcm9wcGVkXG4gKiBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSBmb3IgbW9yZSB0aGFuIG9uZVxuICogdmFsdWUgdG8gYmUgZW1pdHRlZCBpbiBhbnkgdGltZSB3aW5kb3cgb2YgZHVyYXRpb24gYGR1ZVRpbWVgLCBidXQgaXQgaXMgYWxzb1xuICogYSBkZWxheS1saWtlIG9wZXJhdG9yIHNpbmNlIG91dHB1dCBlbWlzc2lvbnMgZG8gbm90IG9jY3VyIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAqIHRoZXkgZGlkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gT3B0aW9uYWxseSB0YWtlcyBhIHtAbGluayBJU2NoZWR1bGVyfSBmb3JcbiAqIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhZnRlciBhIGJ1cnN0IG9mIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmRlYm91bmNlVGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1ZVRpbWUgVGhlIHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZVxuICogdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBmb3IgdGhlIHdpbmRvdyBvZlxuICogdGltZSByZXF1aXJlZCB0byB3YWl0IGZvciBlbWlzc2lvbiBzaWxlbmNlIGJlZm9yZSBlbWl0dGluZyB0aGUgbW9zdCByZWNlbnRcbiAqIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWVvdXQgZm9yIGVhY2ggdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGBkdWVUaW1lYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXJcbiAqIHRvbyBmcmVxdWVudGx5LlxuICogQG1ldGhvZCBkZWJvdW5jZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlVGltZShkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSk7IH07XG59XG5leHBvcnRzLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZTtcbnZhciBEZWJvdW5jZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdWVUaW1lLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVlVGltZSwgdGhpcykpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlZE5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuZGVib3VuY2VkTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhckRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChkZWJvdW5jZWRTdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlYm91bmNlZFN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBkZWJvdW5jZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoc3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXIuZGVib3VuY2VkTmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2VUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRW1pdHMgYSBnaXZlbiB2YWx1ZSBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzIHdpdGhvdXQgZW1pdHRpbmcgYW55XG4gKiBgbmV4dGAgdmFsdWUsIG90aGVyd2lzZSBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHR1cm5zIG91dCB0byBiZSBlbXB0eSwgdGhlblxuICogdGhpcyBvcGVyYXRvciB3aWxsIGVtaXQgYSBkZWZhdWx0IHZhbHVlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmF1bHRJZkVtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWZhdWx0SWZFbXB0eWAgZW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvciBhXG4gKiBzcGVjaWZpZWQgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgaXMgZW1wdHkgKGNvbXBsZXRlcyB3aXRob3V0XG4gKiBoYXZpbmcgZW1pdHRlZCBhbnkgYG5leHRgIHZhbHVlKS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZiBubyBjbGlja3MgaGFwcGVuIGluIDUgc2Vjb25kcywgdGhlbiBlbWl0IFwibm8gY2xpY2tzXCI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc0JlZm9yZUZpdmUgPSBjbGlja3MudGFrZVVudGlsKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwMCkpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrc0JlZm9yZUZpdmUuZGVmYXVsdElmRW1wdHkoJ25vIGNsaWNrcycpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBlbXB0eX1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKlxuICogQHBhcmFtIHthbnl9IFtkZWZhdWx0VmFsdWU9bnVsbF0gVGhlIGRlZmF1bHQgdmFsdWUgdXNlZCBpZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGlzIGVtcHR5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGVpdGhlciB0aGUgc3BlY2lmaWVkXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgbm8gaXRlbXMsIG9yIHRoZSB2YWx1ZXMgZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBkZWZhdWx0SWZFbXB0eVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdElmRW1wdHkoZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRWYWx1ZSA9IG51bGw7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSk7IH07XG59XG5leHBvcnRzLmRlZmF1bHRJZkVtcHR5ID0gZGVmYXVsdElmRW1wdHk7XG52YXIgRGVmYXVsdElmRW1wdHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdElmRW1wdHlPcGVyYXRvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IHRydWU7XG4gICAgfVxuICAgIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdElmRW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNEYXRlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRGF0ZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBOb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoJy4uL05vdGlmaWNhdGlvbicpO1xuLyoqXG4gKiBEZWxheXMgdGhlIGVtaXNzaW9uIG9mIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGEgZ2l2ZW4gdGltZW91dCBvclxuICogdW50aWwgYSBnaXZlbiBEYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UaW1lIHNoaWZ0cyBlYWNoIGl0ZW0gYnkgc29tZSBzcGVjaWZpZWQgYW1vdW50IG9mXG4gKiBtaWxsaXNlY29uZHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVsYXkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgTnVtYmVyLCB0aGlzIG9wZXJhdG9yIHRpbWUgc2hpZnRzIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhhdCBhbW91bnQgb2YgdGltZSBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzLiBUaGUgcmVsYXRpdmVcbiAqIHRpbWUgaW50ZXJ2YWxzIGJldHdlZW4gdGhlIHZhbHVlcyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBkZWxheSBhcmd1bWVudCBpcyBhIERhdGUsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHN0YXJ0IG9mIHRoZVxuICogT2JzZXJ2YWJsZSBleGVjdXRpb24gdW50aWwgdGhlIGdpdmVuIGRhdGUgb2NjdXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGVhY2ggY2xpY2sgYnkgb25lIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheSgxMDAwKTsgLy8gZWFjaCBjbGljayBlbWl0dGVkIGFmdGVyIDEgc2Vjb25kXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBhbGwgY2xpY2tzIHVudGlsIGEgZnV0dXJlIGRhdGUgaGFwcGVuczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGF0ZSA9IG5ldyBEYXRlKCdNYXJjaCAxNSwgMjA1MCAxMjowMDowMCcpOyAvLyBpbiB0aGUgZnV0dXJlXG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheShkYXRlKTsgLy8gY2xpY2sgZW1pdHRlZCBvbmx5IGFmdGVyIHRoYXQgZGF0ZVxuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGRlbGF5IFRoZSBkZWxheSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKGEgYG51bWJlcmApIG9yXG4gKiBhIGBEYXRlYCB1bnRpbCB3aGljaCB0aGUgZW1pc3Npb24gb2YgdGhlIHNvdXJjZSBpdGVtcyBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWUtc2hpZnQgZm9yIGVhY2ggaXRlbS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgdGltZW91dCBvciBEYXRlLlxuICogQG1ldGhvZCBkZWxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVsYXkoZGVsYXksIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgdmFyIGFic29sdXRlRGVsYXkgPSBpc0RhdGVfMS5pc0RhdGUoZGVsYXkpO1xuICAgIHZhciBkZWxheUZvciA9IGFic29sdXRlRGVsYXkgPyAoK2RlbGF5IC0gc2NoZWR1bGVyLm5vdygpKSA6IE1hdGguYWJzKGRlbGF5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IERlbGF5T3BlcmF0b3IoZGVsYXlGb3IsIHNjaGVkdWxlcikpOyB9O1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xudmFyIERlbGF5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5T3BlcmF0b3IoZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVsYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVsYXksIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlbGF5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlbGF5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWxheVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWxheVN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcbiAgICAgICAgdmFyIHF1ZXVlID0gc291cmNlLnF1ZXVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBzdGF0ZS5kZXN0aW5hdGlvbjtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgKHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpIDw9IDApIHtcbiAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCkubm90aWZpY2F0aW9uLm9ic2VydmUoZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsYXlfMSA9IE1hdGgubWF4KDAsIHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgZGVsYXlfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX3NjaGVkdWxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShEZWxheVN1YnNjcmliZXIuZGlzcGF0Y2gsIHRoaXMuZGVsYXksIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcywgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sIHNjaGVkdWxlcjogc2NoZWR1bGVyXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IERlbGF5TWVzc2FnZShzY2hlZHVsZXIubm93KCkgKyB0aGlzLmRlbGF5LCBub3RpZmljYXRpb24pO1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbnZhciBEZWxheU1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5TWVzc2FnZSh0aW1lLCBub3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG4gICAgfVxuICAgIHJldHVybiBEZWxheU1lc3NhZ2U7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRGVsYXlzIHRoZSBlbWlzc2lvbiBvZiBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBhIGdpdmVuIHRpbWUgc3BhblxuICogZGV0ZXJtaW5lZCBieSB0aGUgZW1pc3Npb25zIG9mIGFub3RoZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCB0aGUgdGltZSBzcGFuIG9mIHRoZVxuICogZGVsYXkgZHVyYXRpb24gaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlbGF5V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVsYXlXaGVuYCB0aW1lIHNoaWZ0cyBlYWNoIGVtaXR0ZWQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYVxuICogdGltZSBzcGFuIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLiBXaGVuIHRoZSBzb3VyY2UgZW1pdHMgYSB2YWx1ZSxcbiAqIHRoZSBgZGVsYXlEdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgc291cmNlIHZhbHVlIGFzXG4gKiBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm4gYW4gT2JzZXJ2YWJsZSwgY2FsbGVkIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS5cbiAqIFRoZSBzb3VyY2UgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgb25seSB3aGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcy5cbiAqXG4gKiBPcHRpb25hbGx5LCBgZGVsYXlXaGVuYCB0YWtlcyBhIHNlY29uZCBhcmd1bWVudCwgYHN1YnNjcmlwdGlvbkRlbGF5YCwgd2hpY2hcbiAqIGlzIGFuIE9ic2VydmFibGUuIFdoZW4gYHN1YnNjcmlwdGlvbkRlbGF5YCBlbWl0cyBpdHMgZmlyc3QgdmFsdWUgb3JcbiAqIGNvbXBsZXRlcywgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQgdG8gYW5kIHN0YXJ0cyBiZWhhdmluZyBsaWtlXG4gKiBkZXNjcmliZWQgaW4gdGhlIHByZXZpb3VzIHBhcmFncmFwaC4gSWYgYHN1YnNjcmlwdGlvbkRlbGF5YCBpcyBub3QgcHJvdmlkZWQsXG4gKiBgZGVsYXlXaGVuYCB3aWxsIHN1YnNjcmliZSB0byB0aGUgc291cmNlIE9ic2VydmFibGUgYXMgc29vbiBhcyB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgZWFjaCBjbGljayBieSBhIHJhbmRvbSBhbW91bnQgb2YgdGltZSwgYmV0d2VlbiAwIGFuZCA1IHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGRlbGF5ZWRDbGlja3MgPSBjbGlja3MuZGVsYXlXaGVuKGV2ZW50ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoTWF0aC5yYW5kb20oKSAqIDUwMDApXG4gKiApO1xuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogT2JzZXJ2YWJsZX0gZGVsYXlEdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdFxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGljaFxuICogaXMgdGhlbiB1c2VkIHRvIGRlbGF5IHRoZSBlbWlzc2lvbiBvZiB0aGF0IGl0ZW0gb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB1bnRpbCB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24gZW1pdHMgYSB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc3Vic2NyaXB0aW9uRGVsYXkgQW4gT2JzZXJ2YWJsZSB0aGF0IHRyaWdnZXJzIHRoZVxuICogc3Vic2NyaXB0aW9uIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmNlIGl0IGVtaXRzIGFueSB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IGFuIGFtb3VudCBvZiB0aW1lIHNwZWNpZmllZCBieSB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBieVxuICogYGRlbGF5RHVyYXRpb25TZWxlY3RvcmAuXG4gKiBAbWV0aG9kIGRlbGF5V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVsYXlXaGVuKGRlbGF5RHVyYXRpb25TZWxlY3Rvciwgc3Vic2NyaXB0aW9uRGVsYXkpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uRGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlKHNvdXJjZSwgc3Vic2NyaXB0aW9uRGVsYXkpXG4gICAgICAgICAgICAgICAgLmxpZnQobmV3IERlbGF5V2hlbk9wZXJhdG9yKGRlbGF5RHVyYXRpb25TZWxlY3RvcikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IERlbGF5V2hlbk9wZXJhdG9yKGRlbGF5RHVyYXRpb25TZWxlY3RvcikpOyB9O1xufVxuZXhwb3J0cy5kZWxheVdoZW4gPSBkZWxheVdoZW47XG52YXIgRGVsYXlXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5V2hlbk9wZXJhdG9yKGRlbGF5RHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3RvciA9IGRlbGF5RHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgRGVsYXlXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWxheVdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWxheVdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVsYXlXaGVuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWxheVdoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkZWxheUR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3RvciA9IGRlbGF5RHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChvdXRlclZhbHVlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oaW5uZXJTdWIpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cnlDb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkZWxheU5vdGlmaWVyID0gdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRlbGF5Tm90aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURlbGF5KGRlbGF5Tm90aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5yZW1vdmVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSWR4ID0gdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25JZHggIT09IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzW3N1YnNjcmlwdGlvbklkeF07XG4gICAgICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKHN1YnNjcmlwdGlvbklkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVsYXkgPSBmdW5jdGlvbiAoZGVsYXlOb3RpZmllciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdGlmaWVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkZWxheU5vdGlmaWVyLCB2YWx1ZSk7XG4gICAgICAgIGlmIChub3RpZmllclN1YnNjcmlwdGlvbiAmJiAhbm90aWZpZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChub3RpZmllclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLnB1c2gobm90aWZpZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlZCAmJiB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUoc291cmNlLCBzdWJzY3JpcHRpb25EZWxheSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRGVsYXkgPSBzdWJzY3JpcHRpb25EZWxheTtcbiAgICB9XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25EZWxheS5zdWJzY3JpYmUobmV3IFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlcihwYXJlbnQsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNvdXJjZVN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh1bnVzZWQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1NvdXJjZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvU291cmNlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLnN1YnNjcmliZVRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlU3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZSh0aGlzLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheVdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIENvbnZlcnRzIGFuIE9ic2VydmFibGUgb2Yge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyBpbnRvIHRoZSBlbWlzc2lvbnNcbiAqIHRoYXQgdGhleSByZXByZXNlbnQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlVud3JhcHMge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyBhcyBhY3R1YWwgYG5leHRgLFxuICogYGVycm9yYCBhbmQgYGNvbXBsZXRlYCBlbWlzc2lvbnMuIFRoZSBvcHBvc2l0ZSBvZiB7QGxpbmsgbWF0ZXJpYWxpemV9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlbWF0ZXJpYWxpemUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlbWF0ZXJpYWxpemVgIGlzIGFzc3VtZWQgdG8gb3BlcmF0ZSBhbiBPYnNlcnZhYmxlIHRoYXQgb25seSBlbWl0c1xuICoge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyBhcyBgbmV4dGAgZW1pc3Npb25zLCBhbmQgZG9lcyBub3QgZW1pdCBhbnlcbiAqIGBlcnJvcmAuIFN1Y2ggT2JzZXJ2YWJsZSBpcyB0aGUgb3V0cHV0IG9mIGEgYG1hdGVyaWFsaXplYCBvcGVyYXRpb24uIFRob3NlXG4gKiBub3RpZmljYXRpb25zIGFyZSB0aGVuIHVud3JhcHBlZCB1c2luZyB0aGUgbWV0YWRhdGEgdGhleSBjb250YWluLCBhbmQgZW1pdHRlZFxuICogYXMgYG5leHRgLCBgZXJyb3JgLCBhbmQgYGNvbXBsZXRlYCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVXNlIHRoaXMgb3BlcmF0b3IgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgbWF0ZXJpYWxpemV9LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnQgYW4gT2JzZXJ2YWJsZSBvZiBOb3RpZmljYXRpb25zIHRvIGFuIGFjdHVhbCBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIG5vdGlmQSA9IG5ldyBSeC5Ob3RpZmljYXRpb24oJ04nLCAnQScpO1xuICogdmFyIG5vdGlmQiA9IG5ldyBSeC5Ob3RpZmljYXRpb24oJ04nLCAnQicpO1xuICogdmFyIG5vdGlmRSA9IG5ldyBSeC5Ob3RpZmljYXRpb24oJ0UnLCB2b2lkIDAsXG4gKiAgIG5ldyBUeXBlRXJyb3IoJ3gudG9VcHBlckNhc2UgaXMgbm90IGEgZnVuY3Rpb24nKVxuICogKTtcbiAqIHZhciBtYXRlcmlhbGl6ZWQgPSBSeC5PYnNlcnZhYmxlLm9mKG5vdGlmQSwgbm90aWZCLCBub3RpZkUpO1xuICogdmFyIHVwcGVyQ2FzZSA9IG1hdGVyaWFsaXplZC5kZW1hdGVyaWFsaXplKCk7XG4gKiB1cHBlckNhc2Uuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIEFcbiAqIC8vIEJcbiAqIC8vIFR5cGVFcnJvcjogeC50b1VwcGVyQ2FzZSBpcyBub3QgYSBmdW5jdGlvblxuICpcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIG1hdGVyaWFsaXplfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBhbmQgbm90aWZpY2F0aW9uc1xuICogZW1iZWRkZWQgaW4gTm90aWZpY2F0aW9uIG9iamVjdHMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGRlbWF0ZXJpYWxpemVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlbWF0ZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbWF0ZXJpYWxpemVPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IERlTWF0ZXJpYWxpemVPcGVyYXRvcigpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5kZW1hdGVyaWFsaXplID0gZGVtYXRlcmlhbGl6ZTtcbnZhciBEZU1hdGVyaWFsaXplT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlTWF0ZXJpYWxpemVPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgRGVNYXRlcmlhbGl6ZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlTWF0ZXJpYWxpemVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICBEZU1hdGVyaWFsaXplU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUub2JzZXJ2ZSh0aGlzLmRlc3RpbmF0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBEZU1hdGVyaWFsaXplU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbWF0ZXJpYWxpemUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgU2V0XzEgPSByZXF1aXJlKCcuLi91dGlsL1NldCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHByZXZpb3VzIGl0ZW1zLlxuICpcbiAqIElmIGEga2V5U2VsZWN0b3IgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBwcm9qZWN0IGVhY2ggdmFsdWUgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUgaW50byBhIG5ldyB2YWx1ZSB0aGF0IGl0IHdpbGxcbiAqIGNoZWNrIGZvciBlcXVhbGl0eSB3aXRoIHByZXZpb3VzbHkgcHJvamVjdGVkIHZhbHVlcy4gSWYgYSBrZXlTZWxlY3RvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIGVhY2ggdmFsdWUgZnJvbSB0aGVcbiAqIHNvdXJjZSBvYnNlcnZhYmxlIGRpcmVjdGx5IHdpdGggYW4gZXF1YWxpdHkgY2hlY2sgYWdhaW5zdCBwcmV2aW91cyB2YWx1ZXMuXG4gKlxuICogSW4gSmF2YVNjcmlwdCBydW50aW1lcyB0aGF0IHN1cHBvcnQgYFNldGAsIHRoaXMgb3BlcmF0b3Igd2lsbCB1c2UgYSBgU2V0YCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZSBjaGVja2luZy5cbiAqXG4gKiBJbiBvdGhlciBydW50aW1lcywgdGhpcyBvcGVyYXRvciB3aWxsIHVzZSBhIG1pbmltYWwgaW1wbGVtZW50YXRpb24gb2YgYFNldGAgdGhhdCByZWxpZXMgb24gYW4gYEFycmF5YCBhbmQgYGluZGV4T2ZgIHVuZGVyIHRoZVxuICogaG9vZCwgc28gcGVyZm9ybWFuY2Ugd2lsbCBkZWdyYWRlIGFzIG1vcmUgdmFsdWVzIGFyZSBjaGVja2VkIGZvciBkaXN0aW5jdGlvbi4gRXZlbiBpbiBuZXdlciBicm93c2VycywgYSBsb25nLXJ1bm5pbmcgYGRpc3RpbmN0YFxuICogdXNlIG1pZ2h0IHJlc3VsdCBpbiBtZW1vcnkgbGVha3MuIFRvIGhlbHAgYWxsZXZpYXRlIHRoaXMgaW4gc29tZSBzY2VuYXJpb3MsIGFuIG9wdGlvbmFsIGBmbHVzaGVzYCBwYXJhbWV0ZXIgaXMgYWxzbyBwcm92aWRlZCBzb1xuICogdGhhdCB0aGUgaW50ZXJuYWwgYFNldGAgY2FuIGJlIFwiZmx1c2hlZFwiLCBiYXNpY2FsbHkgY2xlYXJpbmcgaXQgb2YgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc2ltcGxlIGV4YW1wbGUgd2l0aCBudW1iZXJzPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZigxLCAxLCAyLCAyLCAyLCAxLCAyLCAzLCA0LCAzLCAyLCAxKVxuICogICAuZGlzdGluY3QoKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAxLCAyLCAzLCA0XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSB1c2luZyBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICBhZ2U6IG51bWJlcixcbiAqICAgIG5hbWU6IHN0cmluZ1xuICogfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3QoKHA6IFBlcnNvbikgPT4gcC5uYW1lKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtrZXlTZWxlY3Rvcl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gc2VsZWN0IHdoaWNoIHZhbHVlIHlvdSB3YW50IHRvIGNoZWNrIGFzIGRpc3RpbmN0LlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBbZmx1c2hlc10gT3B0aW9uYWwgT2JzZXJ2YWJsZSBmb3IgZmx1c2hpbmcgdGhlIGludGVybmFsIEhhc2hTZXQgb2YgdGhlIG9wZXJhdG9yLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzLlxuICogQG1ldGhvZCBkaXN0aW5jdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3Qoa2V5U2VsZWN0b3IsIGZsdXNoZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IERpc3RpbmN0T3BlcmF0b3Ioa2V5U2VsZWN0b3IsIGZsdXNoZXMpKTsgfTtcbn1cbmV4cG9ydHMuZGlzdGluY3QgPSBkaXN0aW5jdDtcbnZhciBEaXN0aW5jdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdE9wZXJhdG9yKGtleVNlbGVjdG9yLCBmbHVzaGVzKSB7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5mbHVzaGVzID0gZmx1c2hlcztcbiAgICB9XG4gICAgRGlzdGluY3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmtleVNlbGVjdG9yLCB0aGlzLmZsdXNoZXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGlzdGluY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlzdGluY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwga2V5U2VsZWN0b3IsIGZsdXNoZXMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFNldF8xLlNldCgpO1xuICAgICAgICBpZiAoZmx1c2hlcykge1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBmbHVzaGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmtleVNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VLZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZU5leHQodmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdXNlS2V5U2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMua2V5U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmluYWxpemVOZXh0KGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgRGlzdGluY3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fZmluYWxpemVOZXh0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBpZiAoIXZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdmFsdWVzLmFkZChrZXkpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLkRpc3RpbmN0U3Vic2NyaWJlciA9IERpc3RpbmN0U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gdGhlIHByZXZpb3VzIGl0ZW0uXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QSBzaW1wbGUgZXhhbXBsZSB3aXRoIG51bWJlcnM8L2NhcHRpb24+XG4gKiBPYnNlcnZhYmxlLm9mKDEsIDEsIDIsIDIsIDIsIDEsIDEsIDIsIDMsIDMsIDQpXG4gKiAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIDEsIDIsIDEsIDIsIDMsIDRcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIHVzaW5nIGEgY29tcGFyZSBmdW5jdGlvbjwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgYWdlOiBudW1iZXIsXG4gKiAgICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKHA6IFBlcnNvbiwgcTogUGVyc29uKSA9PiBwLm5hbWUgPT09IHEubmFtZSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbycgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcmVdIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24gY2FsbGVkIHRvIHRlc3QgaWYgYW4gaXRlbSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcihjb21wYXJlLCBrZXlTZWxlY3RvcikpOyB9O1xufVxuZXhwb3J0cy5kaXN0aW5jdFVudGlsQ2hhbmdlZCA9IGRpc3RpbmN0VW50aWxDaGFuZ2VkO1xudmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IoY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgIH1cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY29tcGFyZSwgdGhpcy5rZXlTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNLZXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB4ID09PSB5O1xuICAgIH07XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIga2V5U2VsZWN0b3IgPSB0aGlzLmtleVNlbGVjdG9yO1xuICAgICAgICB2YXIga2V5ID0gdmFsdWU7XG4gICAgICAgIGlmIChrZXlTZWxlY3Rvcikge1xuICAgICAgICAgICAga2V5ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmtleVNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc0tleSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmNvbXBhcmUpKHRoaXMua2V5LCBrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJvb2xlYW4ocmVzdWx0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxDaGFuZ2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSByZXF1aXJlKCcuL2Rpc3RpbmN0VW50aWxDaGFuZ2VkJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLFxuICogdXNpbmcgYSBwcm9wZXJ0eSBhY2Nlc3NlZCBieSB1c2luZyB0aGUga2V5IHByb3ZpZGVkIHRvIGNoZWNrIGlmIHRoZSB0d28gaXRlbXMgYXJlIGRpc3RpbmN0LlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgYW4gZXF1YWxpdHkgY2hlY2sgaXMgdXNlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgY29tcGFyaW5nIHRoZSBuYW1lIG9mIHBlcnNvbnM8L2NhcHRpb24+XG4gKlxuICogIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgIGFnZTogbnVtYmVyLFxuICogICAgIG5hbWU6IHN0cmluZ1xuICogIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ25hbWUnKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vJyB9XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSBjb21wYXJpbmcgdGhlIGZpcnN0IGxldHRlcnMgb2YgdGhlIG5hbWU8L2NhcHRpb24+XG4gKlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0ZvbzEnfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vMid9LFxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vMyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnbmFtZScsICh4OiBzdHJpbmcsIHk6IHN0cmluZykgPT4geC5zdWJzdHJpbmcoMCwgMykgPT09IHkuc3Vic3RyaW5nKDAsIDMpKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbzEnIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbzInIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgU3RyaW5nIGtleSBmb3Igb2JqZWN0IHByb3BlcnR5IGxvb2t1cCBvbiBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgY29tcGFyaXNvbiBmdW5jdGlvbiBjYWxsZWQgdG8gdGVzdCBpZiBhbiBpdGVtIGlzIGRpc3RpbmN0IGZyb20gdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcyBiYXNlZCBvbiB0aGUga2V5IHNwZWNpZmllZC5cbiAqIEBtZXRob2QgZGlzdGluY3RVbnRpbEtleUNoYW5nZWRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKGtleSwgY29tcGFyZSkge1xuICAgIHJldHVybiBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xLmRpc3RpbmN0VW50aWxDaGFuZ2VkKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlID8gY29tcGFyZSh4W2tleV0sIHlba2V5XSkgOiB4W2tleV0gPT09IHlba2V5XTsgfSk7XG59XG5leHBvcnRzLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkID0gZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xuLyoqXG4gKiBFbWl0cyB0aGUgc2luZ2xlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YCBpbiBhIHNlcXVlbmNlIG9mIGVtaXNzaW9uc1xuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIG9ubHkgdGhlIGktdGggdmFsdWUsIHRoZW4gY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2VsZW1lbnRBdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZWxlbWVudEF0YCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkXG4gKiBgaW5kZXhgIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYSBkZWZhdWx0IHZhbHVlIGlmIHRoYXQgYGluZGV4YCBpcyBvdXRcbiAqIG9mIHJhbmdlIGFuZCB0aGUgYGRlZmF1bHRgIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiBJZiB0aGUgYGRlZmF1bHRgIGFyZ3VtZW50IGlzXG4gKiBub3QgZ2l2ZW4gYW5kIHRoZSBgaW5kZXhgIGlzIG91dCBvZiByYW5nZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBhblxuICogYEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yYCBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIHRoaXJkIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZWxlbWVudEF0KDIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gY2xpY2sgMSA9IG5vdGhpbmdcbiAqIC8vIGNsaWNrIDIgPSBub3RoaW5nXG4gKiAvLyBjbGljayAzID0gTW91c2VFdmVudCBvYmplY3QgbG9nZ2VkIHRvIGNvbnNvbGVcbiAqXG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICogQHNlZSB7QGxpbmsgc2luZ2xlfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgZWxlbWVudEF0KGkpYCwgaXQgZGVsaXZlcnMgYW5cbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmAgY2FsbGJhY2sgaWYgYGkgPCAwYCBvciB0aGVcbiAqIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZCBiZWZvcmUgZW1pdHRpbmcgdGhlIGktdGggYG5leHRgIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZSBlbWlzc2lvbiB0aGF0IGhhc1xuICogaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgZm9yIG1pc3NpbmcgaW5kaWNlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNpbmdsZSBpdGVtLCBpZiBpdCBpcyBmb3VuZC5cbiAqIE90aGVyd2lzZSwgd2lsbCBlbWl0IHRoZSBkZWZhdWx0IHZhbHVlIGlmIGdpdmVuLiBJZiBub3QsIHRoZW4gZW1pdHMgYW4gZXJyb3IuXG4gKiBAbWV0aG9kIGVsZW1lbnRBdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZWxlbWVudEF0KGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IEVsZW1lbnRBdE9wZXJhdG9yKGluZGV4LCBkZWZhdWx0VmFsdWUpKTsgfTtcbn1cbmV4cG9ydHMuZWxlbWVudEF0ID0gZWxlbWVudEF0O1xudmFyIEVsZW1lbnRBdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50QXRPcGVyYXRvcihpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVsZW1lbnRBdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRWxlbWVudEF0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmluZGV4LCB0aGlzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRWxlbWVudEF0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRBdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudEF0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIEVsZW1lbnRBdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgtLSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHgpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50QXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudEF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGV0aGVyIG9yIG5vdCBldmVyeSBpdGVtIG9mIHRoZSBzb3VyY2Ugc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gc3BlY2lmaWVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc2ltcGxlIGV4YW1wbGUgZW1pdHRpbmcgdHJ1ZSBpZiBhbGwgZWxlbWVudHMgYXJlIGxlc3MgdGhhbiA1LCBmYWxzZSBvdGhlcndpc2U8L2NhcHRpb24+XG4gKiAgT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1LCA2KVxuICogICAgIC5ldmVyeSh4ID0+IHggPCA1KVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIC0+IGZhbHNlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIGlmIGFuIGl0ZW0gbWVldHMgYSBzcGVjaWZpZWQgY29uZGl0aW9uLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBPcHRpb25hbCBvYmplY3QgdG8gdXNlIGZvciBgdGhpc2AgaW4gdGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBib29sZWFucyB0aGF0IGRldGVybWluZXMgaWYgYWxsIGl0ZW1zIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtZWV0IHRoZSBjb25kaXRpb24gc3BlY2lmaWVkLlxuICogQG1ldGhvZCBldmVyeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBFdmVyeU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSk7IH07XG59XG5leHBvcnRzLmV2ZXJ5ID0gZXZlcnk7XG52YXIgRXZlcnlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlcnlPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEV2ZXJ5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRXZlcnlTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZXJ5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBFdmVyeVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVyeVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlcnlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICB9XG4gICAgRXZlcnlTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVyeVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGV2ZXJ5VmFsdWVNYXRjaCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEV2ZXJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmluZGV4KyssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVyeVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieSBkcm9wcGluZ1xuICogaW5uZXIgT2JzZXJ2YWJsZXMgd2hpbGUgdGhlIHByZXZpb3VzIGlubmVyIE9ic2VydmFibGUgaGFzIG5vdCB5ZXQgY29tcGxldGVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGRyb3BwaW5nIHRoZVxuICogbmV4dCBpbm5lciBPYnNlcnZhYmxlcyB3aGlsZSB0aGUgY3VycmVudCBpbm5lciBpcyBzdGlsbCBleGVjdXRpbmcuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZXhoYXVzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZXhoYXVzdGAgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMsIGFsc28ga25vd24gYXMgYVxuICogaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2UgZW1pdHRlZCBpbm5lclxuICogT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhhdFxuICogaW5uZXIgT2JzZXJ2YWJsZS4gU28gZmFyLCBpdCBiZWhhdmVzIGxpa2Uge0BsaW5rIG1lcmdlQWxsfS4gSG93ZXZlcixcbiAqIGBleGhhdXN0YCBpZ25vcmVzIGV2ZXJ5IG5ldyBpbm5lciBPYnNlcnZhYmxlIGlmIHRoZSBwcmV2aW91cyBPYnNlcnZhYmxlIGhhc1xuICogbm90IHlldCBjb21wbGV0ZWQuIE9uY2UgdGhhdCBvbmUgY29tcGxldGVzLCBpdCB3aWxsIGFjY2VwdCBhbmQgZmxhdHRlbiB0aGVcbiAqIG5leHQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgcmVwZWF0IHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SdW4gYSBmaW5pdGUgdGltZXIgZm9yIGVhY2ggY2xpY2ssIG9ubHkgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGFjdGl2ZSB0aW1lcjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDUpKTtcbiAqIHZhciByZXN1bHQgPSBoaWdoZXJPcmRlci5leGhhdXN0KCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHRha2VzIGEgc291cmNlIG9mIE9ic2VydmFibGVzIGFuZCBwcm9wYWdhdGVzIHRoZSBmaXJzdCBvYnNlcnZhYmxlXG4gKiBleGNsdXNpdmVseSB1bnRpbCBpdCBjb21wbGV0ZXMgYmVmb3JlIHN1YnNjcmliaW5nIHRvIHRoZSBuZXh0LlxuICogQG1ldGhvZCBleGhhdXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU3dpdGNoRmlyc3RPcGVyYXRvcigpKTsgfTtcbn1cbmV4cG9ydHMuZXhoYXVzdCA9IGV4aGF1c3Q7XG52YXIgU3dpdGNoRmlyc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaEZpcnN0U3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoRmlyc3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaEZpcnN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaEZpcnN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgb25seSBpZiB0aGUgcHJldmlvdXMgcHJvamVjdGVkIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgZXhoYXVzdH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZXhoYXVzdE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBXaGVuIGl0IHByb2plY3RzIGEgc291cmNlIHZhbHVlIHRvXG4gKiBhbiBPYnNlcnZhYmxlLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5XG4gKiB0aGF0IHByb2plY3RlZCBPYnNlcnZhYmxlLiBIb3dldmVyLCBgZXhoYXVzdE1hcGAgaWdub3JlcyBldmVyeSBuZXcgcHJvamVjdGVkXG4gKiBPYnNlcnZhYmxlIGlmIHRoZSBwcmV2aW91cyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZSBoYXMgbm90IHlldCBjb21wbGV0ZWQuIE9uY2VcbiAqIHRoYXQgb25lIGNvbXBsZXRlcywgaXQgd2lsbCBhY2NlcHQgYW5kIGZsYXR0ZW4gdGhlIG5leHQgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIGFuZCByZXBlYXQgdGhpcyBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJ1biBhIGZpbml0ZSB0aW1lciBmb3IgZWFjaCBjbGljaywgb25seSBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgYWN0aXZlIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZXhoYXVzdE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg1KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgcHJvamVjdGVkIE9ic2VydmFibGVzXG4gKiBvZiBlYWNoIGl0ZW0gb2YgdGhlIHNvdXJjZSwgaWdub3JpbmcgcHJvamVjdGVkIE9ic2VydmFibGVzIHRoYXQgc3RhcnQgYmVmb3JlXG4gKiB0aGVpciBwcmVjZWRpbmcgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICogQG1ldGhvZCBleGhhdXN0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSk7IH07XG59XG5leHBvcnRzLmV4aGF1c3RNYXAgPSBleGhhdXN0TWFwO1xudmFyIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5U2VsZWN0UmVzdWx0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTZWxlY3RSZXN1bHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGhhdXN0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluXG4gKiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3Mgc2ltaWxhciB0byB7QGxpbmsgbWVyZ2VNYXB9LCBidXQgYXBwbGllcyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gdG8gZXZlcnkgc291cmNlIHZhbHVlIGFzIHdlbGwgYXMgZXZlcnkgb3V0cHV0IHZhbHVlLlxuICogSXQncyByZWN1cnNpdmUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZXhwYW5kLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgYW5kIHRoZW4gbWVyZ2luZyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgYW5kXG4gKiBlbWl0dGluZyB0aGUgcmVzdWx0cyBvZiB0aGlzIG1lcmdlci4gKkV4cGFuZCogd2lsbCByZS1lbWl0IG9uIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgZXZlcnkgc291cmNlIHZhbHVlLiBUaGVuLCBlYWNoIG91dHB1dCB2YWx1ZSBpcyBnaXZlbiB0byB0aGVcbiAqIGBwcm9qZWN0YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIGlubmVyIE9ic2VydmFibGUgdG8gYmUgbWVyZ2VkIG9uIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUuIFRob3NlIG91dHB1dCB2YWx1ZXMgcmVzdWx0aW5nIGZyb20gdGhlIHByb2plY3Rpb24gYXJlIGFsc29cbiAqIGdpdmVuIHRvIHRoZSBgcHJvamVjdGAgZnVuY3Rpb24gdG8gcHJvZHVjZSBuZXcgb3V0cHV0IHZhbHVlcy4gVGhpcyBpcyBob3dcbiAqICpleHBhbmQqIGJlaGF2ZXMgcmVjdXJzaXZlbHkuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U3RhcnQgZW1pdHRpbmcgdGhlIHBvd2VycyBvZiB0d28gb24gZXZlcnkgY2xpY2ssIGF0IG1vc3QgMTAgb2YgdGhlbTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG93ZXJzT2ZUd28gPSBjbGlja3NcbiAqICAgLm1hcFRvKDEpXG4gKiAgIC5leHBhbmQoeCA9PiBSeC5PYnNlcnZhYmxlLm9mKDIgKiB4KS5kZWxheSgxMDAwKSlcbiAqICAgLnRha2UoMTApO1xuICogcG93ZXJzT2ZUd28uc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGV9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIG9yIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSxcbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc3Vic2NyaWJpbmcgdG9cbiAqIGVhY2ggcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHNvdXJjZSB2YWx1ZXMgYW5kIGFsc29cbiAqIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgcHJvamVjdGlvbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGVtaXR0ZWQgb24gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZSBhbmQgYW5kIG1lcmdpbmcgdGhlIHJlc3VsdHMgb2YgdGhlIE9ic2VydmFibGVzIG9idGFpbmVkXG4gKiBmcm9tIHRoaXMgdHJhbnNmb3JtYXRpb24uXG4gKiBAbWV0aG9kIGV4cGFuZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZXhwYW5kKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSB1bmRlZmluZWQ7IH1cbiAgICBjb25jdXJyZW50ID0gKGNvbmN1cnJlbnQgfHwgMCkgPCAxID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogY29uY3VycmVudDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IEV4cGFuZE9wZXJhdG9yKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikpOyB9O1xufVxuZXhwb3J0cy5leHBhbmQgPSBleHBhbmQ7XG52YXIgRXhwYW5kT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cGFuZE9wZXJhdG9yKHByb2plY3QsIGNvbmN1cnJlbnQsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRXhwYW5kT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBFeHBhbmRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5jb25jdXJyZW50LCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cGFuZE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuRXhwYW5kT3BlcmF0b3IgPSBFeHBhbmRPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRXhwYW5kU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cGFuZFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwYW5kU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjb25jdXJyZW50IDwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEV4cGFuZFN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIHJlc3VsdCA9IGFyZy5yZXN1bHQsIHZhbHVlID0gYXJnLnZhbHVlLCBpbmRleCA9IGFyZy5pbmRleDtcbiAgICAgICAgc3Vic2NyaWJlci5zdWJzY3JpYmVUb1Byb2plY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLnByb2plY3QpKHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgcmVzdWx0OiByZXN1bHQsIHZhbHVlOiB2YWx1ZSwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoRXhwYW5kU3Vic2NyaWJlci5kaXNwYXRjaCwgMCwgc3RhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5zdWJzY3JpYmVUb1Byb2plY3Rpb24gPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgRXhwYW5kU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX25leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkICYmIHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFeHBhbmRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuRXhwYW5kU3Vic2NyaWJlciA9IEV4cGFuZFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBhbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBGaWx0ZXIgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgb25seSBlbWl0dGluZyB0aG9zZSB0aGF0XG4gKiBzYXRpc2Z5IGEgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5maWx0ZXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyKSxcbiAqIGl0IG9ubHkgZW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgaWYgaXQgcGFzc2VzIGEgY3JpdGVyaW9uIGZ1bmN0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbHRlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsLWtub3duIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2QsIHRoaXMgb3BlcmF0b3JcbiAqIHRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcGFzc2VzIHRoZW0gdGhyb3VnaCBhIGBwcmVkaWNhdGVgXG4gKiBmdW5jdGlvbiBhbmQgb25seSBlbWl0cyB0aG9zZSB2YWx1ZXMgdGhhdCB5aWVsZGVkIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgY2xpY2sgZXZlbnRzIHdob3NlIHRhcmdldCB3YXMgYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gY2xpY2tzLmZpbHRlcihldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogY2xpY2tzT25EaXZzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBpZ25vcmVFbGVtZW50c31cbiAqIEBzZWUge0BsaW5rIHBhcnRpdGlvbn1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkLCBpZiBgZmFsc2VgIHRoZSB2YWx1ZSBpcyBub3QgcGFzc2VkIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlXG4gKiBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXJcbiAqIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmVcbiAqIGFsbG93ZWQgYnkgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBmaWx0ZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmlsdGVyT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG52YXIgRmlsdGVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaWx0ZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpbHRlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbHRlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgLy8gdGhlIHRyeSBjYXRjaCBibG9jayBiZWxvdyBpcyBsZWZ0IHNwZWNpZmljYWxseSBmb3JcbiAgICAvLyBvcHRpbWl6YXRpb24gYW5kIHBlcmYgcmVhc29ucy4gYSB0cnlDYXRjaGVyIGlzIG5vdCBuZWNlc3NhcnkgaGVyZS5cbiAgICBGaWx0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHdpbGwgY2FsbCBhIHNwZWNpZmllZCBmdW5jdGlvbiB3aGVuXG4gKiB0aGUgc291cmNlIHRlcm1pbmF0ZXMgb24gY29tcGxldGUgb3IgZXJyb3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBzb3VyY2UgdGVybWluYXRlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UsIGJ1dCB3aWxsIGNhbGwgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvbiB0ZXJtaW5hdGlvbi5cbiAqIEBtZXRob2QgZmluYWxseVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmluYWxpemUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykpOyB9O1xufVxuZXhwb3J0cy5maW5hbGl6ZSA9IGZpbmFsaXplO1xudmFyIEZpbmFsbHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmluYWxseU9wZXJhdG9yKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgRmluYWxseU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluYWxseVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jYWxsYmFjaykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbmFsbHlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpbmFsbHlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmluYWxseVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmluYWxseVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hZGQobmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihjYWxsYmFjaykpO1xuICAgIH1cbiAgICByZXR1cm4gRmluYWxseVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5hbGl6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtZWV0cyBzb21lXG4gKiBjb25kaXRpb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZpbmRzIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IHBhc3NlcyBzb21lIHRlc3QgYW5kIGVtaXRzXG4gKiB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbmQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGZpbmRgIHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzIHRoZVxuICogc3BlY2lmaWVkIGNvbmRpdGlvbiBlbWJvZGllZCBieSB0aGUgYHByZWRpY2F0ZWAsIGFuZCByZXR1cm5zIHRoZSBmaXJzdFxuICogb2NjdXJyZW5jZSBpbiB0aGUgc291cmNlLiBVbmxpa2Uge0BsaW5rIGZpcnN0fSwgdGhlIGBwcmVkaWNhdGVgIGlzIHJlcXVpcmVkXG4gKiBpbiBgZmluZGAsIGFuZCBkb2VzIG5vdCBlbWl0IGFuIGVycm9yIGlmIGEgdmFsaWQgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZpbmQgYW5kIGVtaXQgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiBhIERJViBlbGVtZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZmluZChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGZpbmRJbmRleH1cbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggaXRlbSB0byB0ZXN0IGZvciBjb25kaXRpb24gbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIG9mIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGVcbiAqIGNvbmRpdGlvbi5cbiAqIEBtZXRob2QgZmluZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmluZChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaW5kVmFsdWVPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSwgZmFsc2UsIHRoaXNBcmcpKTsgfTtcbn1cbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG52YXIgRmluZFZhbHVlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbmRWYWx1ZU9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlLCB5aWVsZEluZGV4LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy55aWVsZEluZGV4ID0geWllbGRJbmRleDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmluZFZhbHVlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluZFZhbHVlU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuc291cmNlLCB0aGlzLnlpZWxkSW5kZXgsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbmRWYWx1ZU9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuRmluZFZhbHVlT3BlcmF0b3IgPSBGaW5kVmFsdWVPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmluZFZhbHVlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbmRWYWx1ZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmluZFZhbHVlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCBzb3VyY2UsIHlpZWxkSW5kZXgsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMueWllbGRJbmRleCA9IHlpZWxkSW5kZXg7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBGaW5kVmFsdWVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEZpbmRWYWx1ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByZWRpY2F0ZSA9IF9hLnByZWRpY2F0ZSwgdGhpc0FyZyA9IF9hLnRoaXNBcmc7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGUuY2FsbCh0aGlzQXJnIHx8IHRoaXMsIHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodGhpcy55aWVsZEluZGV4ID8gaW5kZXggOiB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaW5kVmFsdWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodGhpcy55aWVsZEluZGV4ID8gLTEgOiB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbmRWYWx1ZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLkZpbmRWYWx1ZVN1YnNjcmliZXIgPSBGaW5kVmFsdWVTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBmaW5kXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMvZmluZCcpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdFxuICogbWVldHMgc29tZSBjb25kaXRpb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZmluZH0sIGJ1dCBlbWl0cyB0aGUgaW5kZXggb2YgdGhlXG4gKiBmb3VuZCB2YWx1ZSwgbm90IHRoZSB2YWx1ZSBpdHNlbGYuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmluZEluZGV4LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBmaW5kSW5kZXhgIHNlYXJjaGVzIGZvciB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzXG4gKiB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbiBlbWJvZGllZCBieSB0aGUgYHByZWRpY2F0ZWAsIGFuZCByZXR1cm5zIHRoZVxuICogKHplcm8tYmFzZWQpIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIGluIHRoZSBzb3VyY2UuIFVubGlrZVxuICoge0BsaW5rIGZpcnN0fSwgdGhlIGBwcmVkaWNhdGVgIGlzIHJlcXVpcmVkIGluIGBmaW5kSW5kZXhgLCBhbmQgZG9lcyBub3QgZW1pdFxuICogYW4gZXJyb3IgaWYgYSB2YWxpZCB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgaW5kZXggb2YgZmlyc3QgY2xpY2sgdGhhdCBoYXBwZW5zIG9uIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5maW5kSW5kZXgoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZmlsdGVyfVxuICogQHNlZSB7QGxpbmsgZmluZH1cbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtIHRvIHRlc3QgZm9yIGNvbmRpdGlvbiBtYXRjaGluZy5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIHRoYXRcbiAqIG1hdGNoZXMgdGhlIGNvbmRpdGlvbi5cbiAqIEBtZXRob2QgZmluZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgZmluZF8xLkZpbmRWYWx1ZU9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlLCB0cnVlLCB0aGlzQXJnKSk7IH07XG59XG5leHBvcnRzLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmRJbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0VtcHR5RXJyb3InKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUgKG9yIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IG1lZXRzIHNvbWUgY29uZGl0aW9uKVxuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIG9ubHkgdGhlIGZpcnN0IHZhbHVlLiBPciBlbWl0cyBvbmx5IHRoZSBmaXJzdFxuICogdmFsdWUgdGhhdCBwYXNzZXMgc29tZSB0ZXN0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpcnN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIElmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgYGZpcnN0YCBlbWl0cyB0aGUgZmlyc3QgdmFsdWUgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgdGhlbiBjb21wbGV0ZXMuIElmIGNhbGxlZCB3aXRoIGEgYHByZWRpY2F0ZWAgZnVuY3Rpb24sIGBmaXJzdGBcbiAqIGVtaXRzIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgc291cmNlIHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbi4gSXRcbiAqIG1heSBhbHNvIHRha2UgYSBgcmVzdWx0U2VsZWN0b3JgIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIG91dHB1dCB2YWx1ZSBmcm9tXG4gKiB0aGUgaW5wdXQgdmFsdWUsIGFuZCBhIGBkZWZhdWx0VmFsdWVgIHRvIGVtaXQgaW4gY2FzZSB0aGUgc291cmNlIGNvbXBsZXRlc1xuICogYmVmb3JlIGl0IGlzIGFibGUgdG8gZW1pdCBhIHZhbGlkIHZhbHVlLiBUaHJvd3MgYW4gZXJyb3IgaWYgYGRlZmF1bHRWYWx1ZWBcbiAqIHdhcyBub3QgcHJvdmlkZWQgYW5kIGEgbWF0Y2hpbmcgZWxlbWVudCBpcyBub3QgZm91bmQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IHRoZSBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gdGhlIERPTTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpcnN0KCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIHRoZSBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVY8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5maXJzdChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaW5kfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtFbXB0eUVycm9yfSBEZWxpdmVycyBhbiBFbXB0eUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmBcbiAqIGNhbGxiYWNrIGlmIHRoZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBiZWZvcmUgYW55IGBuZXh0YCBub3RpZmljYXRpb24gd2FzIHNlbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogYm9vbGVhbn0gW3ByZWRpY2F0ZV1cbiAqIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggaXRlbSB0byB0ZXN0IGZvciBjb25kaXRpb24gbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gW3Jlc3VsdFNlbGVjdG9yXSBBIGZ1bmN0aW9uIHRvXG4gKiBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpc1xuICogZnVuY3Rpb24gYXJlOlxuICogLSBgdmFsdWVgOiB0aGUgdmFsdWUgdGhhdCB3YXMgZW1pdHRlZCBvbiB0aGUgc291cmNlLlxuICogLSBgaW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge1J9IFtkZWZhdWx0VmFsdWVdIFRoZSBkZWZhdWx0IHZhbHVlIGVtaXR0ZWQgaW4gY2FzZSBubyB2YWxpZCB2YWx1ZVxuICogd2FzIGZvdW5kIG9uIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFR8Uj59IEFuIE9ic2VydmFibGUgb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZVxuICogY29uZGl0aW9uLlxuICogQG1ldGhvZCBmaXJzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmlyc3QocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaXJzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSk7IH07XG59XG5leHBvcnRzLmZpcnN0ID0gZmlyc3Q7XG52YXIgRmlyc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlyc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEZpcnN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmlyc3RTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5kZWZhdWx0VmFsdWUsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlyc3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpcnN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpcnN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaXJzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1pdHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcmVkaWNhdGUodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIGluZGV4LCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVJlc3VsdFNlbGVjdG9yKHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdEZpbmFsKHZhbHVlKTtcbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RmluYWwocmVzdWx0KTtcbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2VtaXRGaW5hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuX2VtaXR0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NvbXBsZXRlZCAmJiB0eXBlb2YgdGhpcy5kZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlyc3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmlyc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE1hcF8xID0gcmVxdWlyZSgnLi4vdXRpbC9NYXAnKTtcbnZhciBGYXN0TWFwXzEgPSByZXF1aXJlKCcuLi91dGlsL0Zhc3RNYXAnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEdyb3VwcyB0aGUgaXRlbXMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBjcml0ZXJpb24sXG4gKiBhbmQgZW1pdHMgdGhlc2UgZ3JvdXBlZCBpdGVtcyBhcyBgR3JvdXBlZE9ic2VydmFibGVzYCwgb25lXG4gKiB7QGxpbmsgR3JvdXBlZE9ic2VydmFibGV9IHBlciBncm91cC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2dyb3VwQnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+R3JvdXAgb2JqZWN0cyBieSBpZCBhbmQgcmV0dXJuIGFzIGFycmF5PC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZjxPYmo+KHtpZDogMSwgbmFtZTogJ2F6ZTEnfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdzZjInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdkZzInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDEsIG5hbWU6ICdlcmcxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAxLCBuYW1lOiAnZGYxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAyLCBuYW1lOiAnc2ZxZmIyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAzLCBuYW1lOiAncWZzMyd9LFxuICogICAgICAgICAgICAgICAgICAgIHtpZDogMiwgbmFtZTogJ3FzZ3FzZmcyJ31cbiAqICAgICApXG4gKiAgICAgLmdyb3VwQnkocCA9PiBwLmlkKVxuICogICAgIC5mbGF0TWFwKCAoZ3JvdXAkKSA9PiBncm91cCQucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgY3VyXSwgW10pKVxuICogICAgIC5zdWJzY3JpYmUocCA9PiBjb25zb2xlLmxvZyhwKSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyBbIHsgaWQ6IDEsIG5hbWU6ICdhemUxJyB9LFxuICogLy8gICB7IGlkOiAxLCBuYW1lOiAnZXJnMScgfSxcbiAqIC8vICAgeyBpZDogMSwgbmFtZTogJ2RmMScgfSBdXG4gKiAvL1xuICogLy8gWyB7IGlkOiAyLCBuYW1lOiAnc2YyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnZGcyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnc2ZxZmIyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAncXNncXNmZzInIH0gXVxuICogLy9cbiAqIC8vIFsgeyBpZDogMywgbmFtZTogJ3FmczMnIH0gXVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlBpdm90IGRhdGEgb24gdGhlIGlkIGZpZWxkPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZjxPYmo+KHtpZDogMSwgbmFtZTogJ2F6ZTEnfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdzZjInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdkZzInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDEsIG5hbWU6ICdlcmcxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAxLCBuYW1lOiAnZGYxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAyLCBuYW1lOiAnc2ZxZmIyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAzLCBuYW1lOiAncWZzMSd9LFxuICogICAgICAgICAgICAgICAgICAgIHtpZDogMiwgbmFtZTogJ3FzZ3FzZmcyJ31cbiAqICAgICAgICAgICAgICAgICAgIClcbiAqICAgICAuZ3JvdXBCeShwID0+IHAuaWQsIHAgPT4gcC5uYW1lKVxuICogICAgIC5mbGF0TWFwKCAoZ3JvdXAkKSA9PiBncm91cCQucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgY3VyXSwgW1wiXCIgKyBncm91cCQua2V5XSkpXG4gKiAgICAgLm1hcChhcnIgPT4gKHsnaWQnOiBwYXJzZUludChhcnJbMF0pLCAndmFsdWVzJzogYXJyLnNsaWNlKDEpfSkpXG4gKiAgICAgLnN1YnNjcmliZShwID0+IGNvbnNvbGUubG9nKHApKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgaWQ6IDEsIHZhbHVlczogWyAnYXplMScsICdlcmcxJywgJ2RmMScgXSB9XG4gKiAvLyB7IGlkOiAyLCB2YWx1ZXM6IFsgJ3NmMicsICdkZzInLCAnc2ZxZmIyJywgJ3FzZ3FzZmcyJyBdIH1cbiAqIC8vIHsgaWQ6IDMsIHZhbHVlczogWyAncWZzMScgXSB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IEt9IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGUga2V5XG4gKiBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFJ9IFtlbGVtZW50U2VsZWN0b3JdIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGVcbiAqIHJldHVybiBlbGVtZW50IGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGdyb3VwZWQ6IEdyb3VwZWRPYnNlcnZhYmxlPEssUj4pOiBPYnNlcnZhYmxlPGFueT59IFtkdXJhdGlvblNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0byBkZXRlcm1pbmUgaG93IGxvbmcgZWFjaCBncm91cCBzaG91bGRcbiAqIGV4aXN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxHcm91cGVkT2JzZXJ2YWJsZTxLLFI+Pn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gKiBHcm91cGVkT2JzZXJ2YWJsZXMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlIGFuZCBlYWNoXG4gKiBvZiB3aGljaCBlbWl0cyB0aG9zZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IHNoYXJlIHRoYXQga2V5XG4gKiB2YWx1ZS5cbiAqIEBtZXRob2QgZ3JvdXBCeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZ3JvdXBCeShrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeTtcbnZhciBHcm91cEJ5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VsZWN0b3IgPSBzdWJqZWN0U2VsZWN0b3I7XG4gICAgfVxuICAgIEdyb3VwQnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEdyb3VwQnlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMua2V5U2VsZWN0b3IsIHRoaXMuZWxlbWVudFNlbGVjdG9yLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IsIHRoaXMuc3ViamVjdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgR3JvdXBCeVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cEJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cEJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwga2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvciwgc3ViamVjdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VsZWN0b3IgPSBzdWJqZWN0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRUb1Vuc3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH1cbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMua2V5U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ncm91cCh2YWx1ZSwga2V5KTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZ3JvdXAgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmICghZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMgPSB0aGlzLmdyb3VwcyA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gbmV3IEZhc3RNYXBfMS5GYXN0TWFwKCkgOiBuZXcgTWFwXzEuTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzLmdldChrZXkpO1xuICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5zdWJqZWN0U2VsZWN0b3IgPyB0aGlzLnN1YmplY3RTZWxlY3RvcigpIDogbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICBncm91cHMuc2V0KGtleSwgZ3JvdXApO1xuICAgICAgICAgICAgdmFyIGdyb3VwZWRPYnNlcnZhYmxlID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgZ3JvdXAsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGdyb3VwZWRPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uU2VsZWN0b3IobmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgZ3JvdXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZHVyYXRpb24uc3Vic2NyaWJlKG5ldyBHcm91cER1cmF0aW9uU3Vic2NyaWJlcihrZXksIGdyb3VwLCB0aGlzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JvdXAuY2xvc2VkKSB7XG4gICAgICAgICAgICBncm91cC5uZXh0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCwga2V5KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5ncm91cHMuZGVsZXRlKGtleSk7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwQnlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBHcm91cER1cmF0aW9uU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHBhcmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBncm91cCk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBHcm91cER1cmF0aW9uU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcGFyZW50ID0gX2EucGFyZW50LCBrZXkgPSBfYS5rZXk7XG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlR3JvdXAoa2V5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBBbiBPYnNlcnZhYmxlIHJlcHJlc2VudGluZyB2YWx1ZXMgYmVsb25naW5nIHRvIHRoZSBzYW1lIGdyb3VwIHJlcHJlc2VudGVkIGJ5XG4gKiBhIGNvbW1vbiBrZXkuIFRoZSB2YWx1ZXMgZW1pdHRlZCBieSBhIEdyb3VwZWRPYnNlcnZhYmxlIGNvbWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgY29tbW9uIGtleSBpcyBhdmFpbGFibGUgYXMgdGhlIGZpZWxkIGBrZXlgIG9uIGFcbiAqIEdyb3VwZWRPYnNlcnZhYmxlIGluc3RhbmNlLlxuICpcbiAqIEBjbGFzcyBHcm91cGVkT2JzZXJ2YWJsZTxLLCBUPlxuICovXG52YXIgR3JvdXBlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cGVkT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwU3ViamVjdCwgcmVmQ291bnRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdyb3VwU3ViamVjdCA9IGdyb3VwU3ViamVjdDtcbiAgICAgICAgdGhpcy5yZWZDb3VudFN1YnNjcmlwdGlvbiA9IHJlZkNvdW50U3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBHcm91cGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlZkNvdW50U3Vic2NyaXB0aW9uID0gX2EucmVmQ291bnRTdWJzY3JpcHRpb24sIGdyb3VwU3ViamVjdCA9IF9hLmdyb3VwU3ViamVjdDtcbiAgICAgICAgaWYgKHJlZkNvdW50U3Vic2NyaXB0aW9uICYmICFyZWZDb3VudFN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQobmV3IElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ocmVmQ291bnRTdWJzY3JpcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGdyb3VwU3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwZWRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Hcm91cGVkT2JzZXJ2YWJsZSA9IEdyb3VwZWRPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uKHBhcmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudC5jb3VudCsrO1xuICAgIH1cbiAgICBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudC5jbG9zZWQgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwYXJlbnQuY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY291bnQgPT09IDAgJiYgcGFyZW50LmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBCeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBub29wXzEgPSByZXF1aXJlKCcuLi91dGlsL25vb3AnKTtcbi8qKlxuICogSWdub3JlcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG9ubHkgcGFzc2VzIGNhbGxzIG9mIGBjb21wbGV0ZWAgb3IgYGVycm9yYC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lnbm9yZUVsZW1lbnRzLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIGVtcHR5IE9ic2VydmFibGUgdGhhdCBvbmx5IGNhbGxzIGBjb21wbGV0ZWBcbiAqIG9yIGBlcnJvcmAsIGJhc2VkIG9uIHdoaWNoIG9uZSBpcyBjYWxsZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBpZ25vcmVFbGVtZW50c1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gaWdub3JlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlnbm9yZUVsZW1lbnRzT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBJZ25vcmVFbGVtZW50c09wZXJhdG9yKCkpO1xuICAgIH07XG59XG5leHBvcnRzLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHM7XG52YXIgSWdub3JlRWxlbWVudHNPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWdub3JlRWxlbWVudHNPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgSWdub3JlRWxlbWVudHNPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSWdub3JlRWxlbWVudHNPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICBub29wXzEubm9vcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZUVsZW1lbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IElzRW1wdHlPcGVyYXRvcigpKTsgfTtcbn1cbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG52YXIgSXNFbXB0eU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJc0VtcHR5T3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIElzRW1wdHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBJc0VtcHR5U3Vic2NyaWJlcihvYnNlcnZlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIElzRW1wdHlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElzRW1wdHlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXNFbXB0eVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXNFbXB0eVN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICBJc0VtcHR5U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaXNFbXB0eSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGlzRW1wdHkpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgSXNFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUoZmFsc2UpO1xuICAgIH07XG4gICAgSXNFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBJc0VtcHR5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgRW1wdHlFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9FbXB0eUVycm9yJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBsYXN0IGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBJdCBvcHRpb25hbGx5IHRha2VzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIGFzIGEgcGFyYW1ldGVyLCBpbiB3aGljaCBjYXNlLCByYXRoZXIgdGhhbiBlbWl0dGluZ1xuICogdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlIHdpbGwgZW1pdCB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbGFzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAdGhyb3dzIHtFbXB0eUVycm9yfSBEZWxpdmVycyBhbiBFbXB0eUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmBcbiAqIGNhbGxiYWNrIGlmIHRoZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBiZWZvcmUgYW55IGBuZXh0YCBub3RpZmljYXRpb24gd2FzIHNlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBUaGUgY29uZGl0aW9uIGFueSBzb3VyY2UgZW1pdHRlZCBpdGVtIGhhcyB0byBzYXRpc2Z5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGxhc3QgaXRlbSBzYXRpc2Z5aW5nIHRoZSBnaXZlbiBjb25kaXRpb25cbiAqIGZyb20gdGhlIHNvdXJjZSwgb3IgYW4gTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiBpZiBubyBzdWNoIGl0ZW1zIGFyZSBlbWl0dGVkLlxuICogQHRocm93cyAtIFRocm93cyBpZiBubyBpdGVtcyB0aGF0IG1hdGNoIHRoZSBwcmVkaWNhdGUgYXJlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBsYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBsYXN0KHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgTGFzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSk7IH07XG59XG5leHBvcnRzLmxhc3QgPSBsYXN0O1xudmFyIExhc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGFzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgTGFzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IExhc3RTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5kZWZhdWx0VmFsdWUsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGFzdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTGFzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBMYXN0U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMYXN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEFwcGxpZXMgYSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBhcyBhbiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIFtBcnJheS5wcm90b3R5cGUubWFwKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcCksXG4gKiBpdCBwYXNzZXMgZWFjaCBzb3VyY2UgdmFsdWUgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRvIGdldFxuICogY29ycmVzcG9uZGluZyBvdXRwdXQgdmFsdWVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsIGtub3duIGBBcnJheS5wcm90b3R5cGUubWFwYCBmdW5jdGlvbiwgdGhpcyBvcGVyYXRvclxuICogYXBwbGllcyBhIHByb2plY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgZW1pdHMgdGhhdCBwcm9qZWN0aW9uIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2s8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrcy5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcFRvfVxuICogQHNlZSB7QGxpbmsgcGx1Y2t9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFJ9IHByb2plY3QgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKiB0byBlYWNoIGB2YWx1ZWAgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpc1xuICogdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZVxuICogc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZWZpbmUgd2hhdCBgdGhpc2AgaXMgaW4gdGhlXG4gKiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgbWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIHJldHVybiBmdW5jdGlvbiBtYXBPcGVyYXRpb24oc291cmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24uIEFyZSB5b3UgbG9va2luZyBmb3IgYG1hcFRvKClgPycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykpO1xuICAgIH07XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbnZhciBNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1hcE9wZXJhdG9yID0gTWFwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBOT1RFOiBUaGlzIGxvb2tzIHVub3B0aW1pemVkLCBidXQgaXQncyBhY3R1YWxseSBwdXJwb3NlZnVsbHkgTk9UXG4gICAgLy8gdXNpbmcgdHJ5L2NhdGNoIG9wdGltaXphdGlvbnMuXG4gICAgTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEVtaXRzIHRoZSBnaXZlbiBjb25zdGFudCB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgZXZlcnkgdGltZSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2Uge0BsaW5rIG1hcH0sIGJ1dCBpdCBtYXBzIGV2ZXJ5IHNvdXJjZSB2YWx1ZSB0b1xuICogdGhlIHNhbWUgb3V0cHV0IHZhbHVlIGV2ZXJ5IHRpbWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogVGFrZXMgYSBjb25zdGFudCBgdmFsdWVgIGFzIGFyZ3VtZW50LCBhbmQgZW1pdHMgdGhhdCB3aGVuZXZlciB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuIEluIG90aGVyIHdvcmRzLCBpZ25vcmVzIHRoZSBhY3R1YWwgc291cmNlIHZhbHVlLFxuICogYW5kIHNpbXBseSB1c2VzIHRoZSBlbWlzc2lvbiBtb21lbnQgdG8ga25vdyB3aGVuIHRvIGVtaXQgdGhlIGdpdmVuIGB2YWx1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGNsaWNrIHRvIHRoZSBzdHJpbmcgJ0hpJzwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZ3JlZXRpbmdzID0gY2xpY2tzLm1hcFRvKCdIaScpO1xuICogZ3JlZXRpbmdzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBtYXAgZWFjaCBzb3VyY2UgdmFsdWUgdG8uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGdpdmVuIGB2YWx1ZWAgZXZlcnkgdGltZVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIHNvbWV0aGluZy5cbiAqIEBtZXRob2QgbWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcFRvKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNYXBUb09wZXJhdG9yKHZhbHVlKSk7IH07XG59XG5leHBvcnRzLm1hcFRvID0gbWFwVG87XG52YXIgTWFwVG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwVG9PcGVyYXRvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIE1hcFRvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXBUb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFRvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNYXBUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBUb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB2YWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBUb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBUby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBOb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoJy4uL05vdGlmaWNhdGlvbicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFsbCBvZiB0aGUgbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyBgbmV4dGBcbiAqIGVtaXNzaW9ucyBtYXJrZWQgd2l0aCB0aGVpciBvcmlnaW5hbCB0eXBlcyB3aXRoaW4ge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqIG9iamVjdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldyYXBzIGBuZXh0YCwgYGVycm9yYCBhbmQgYGNvbXBsZXRlYCBlbWlzc2lvbnMgaW5cbiAqIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMsIGVtaXR0ZWQgYXMgYG5leHRgIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIDwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hdGVyaWFsaXplLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtYXRlcmlhbGl6ZWAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgbmV4dGAgbm90aWZpY2F0aW9uIGZvciBlYWNoXG4gKiBgbmV4dGAsIGBlcnJvcmAsIG9yIGBjb21wbGV0ZWAgZW1pc3Npb24gb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBXaGVuIHRoZVxuICogc291cmNlIE9ic2VydmFibGUgZW1pdHMgYGNvbXBsZXRlYCwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBgbmV4dGAgYXNcbiAqIGEgTm90aWZpY2F0aW9uIG9mIHR5cGUgXCJjb21wbGV0ZVwiLCBhbmQgdGhlbiBpdCB3aWxsIGVtaXQgYGNvbXBsZXRlYCBhcyB3ZWxsLlxuICogV2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYGVycm9yYCwgdGhlIG91dHB1dCB3aWxsIGVtaXQgYG5leHRgIGFzIGFcbiAqIE5vdGlmaWNhdGlvbiBvZiB0eXBlIFwiZXJyb3JcIiwgYW5kIHRoZW4gYGNvbXBsZXRlYC5cbiAqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgcHJvZHVjaW5nIG1ldGFkYXRhIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdG9cbiAqIGJlIGNvbnN1bWVkIGFzIGBuZXh0YCBlbWlzc2lvbnMuIFVzZSBpdCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gKiB7QGxpbmsgZGVtYXRlcmlhbGl6ZX0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBhIGZhdWx0eSBPYnNlcnZhYmxlIHRvIGFuIE9ic2VydmFibGUgb2YgTm90aWZpY2F0aW9uczwvY2FwdGlvbj5cbiAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgMTMsICdkJyk7XG4gKiB2YXIgdXBwZXJDYXNlID0gbGV0dGVycy5tYXAoeCA9PiB4LnRvVXBwZXJDYXNlKCkpO1xuICogdmFyIG1hdGVyaWFsaXplZCA9IHVwcGVyQ2FzZS5tYXRlcmlhbGl6ZSgpO1xuICogbWF0ZXJpYWxpemVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAtIE5vdGlmaWNhdGlvbiB7a2luZDogXCJOXCIsIHZhbHVlOiBcIkFcIiwgZXJyb3I6IHVuZGVmaW5lZCwgaGFzVmFsdWU6IHRydWV9XG4gKiAvLyAtIE5vdGlmaWNhdGlvbiB7a2luZDogXCJOXCIsIHZhbHVlOiBcIkJcIiwgZXJyb3I6IHVuZGVmaW5lZCwgaGFzVmFsdWU6IHRydWV9XG4gKiAvLyAtIE5vdGlmaWNhdGlvbiB7a2luZDogXCJFXCIsIHZhbHVlOiB1bmRlZmluZWQsIGVycm9yOiBUeXBlRXJyb3I6XG4gKiAvLyAgIHgudG9VcHBlckNhc2UgaXMgbm90IGEgZnVuY3Rpb24gYXQgTWFwU3Vic2NyaWJlci5sZXR0ZXJzLm1hcC54XG4gKiAvLyAgIFthcyBwcm9qZWN0XSAoaHR0cDovLzHigKYsIGhhc1ZhbHVlOiBmYWxzZX1cbiAqXG4gKiBAc2VlIHtAbGluayBOb3RpZmljYXRpb259XG4gKiBAc2VlIHtAbGluayBkZW1hdGVyaWFsaXplfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Tm90aWZpY2F0aW9uPFQ+Pn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gKiB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzIHRoYXQgd3JhcCB0aGUgb3JpZ2luYWwgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB3aXRoIG1ldGFkYXRhLlxuICogQG1ldGhvZCBtYXRlcmlhbGl6ZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWF0ZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGVyaWFsaXplT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNYXRlcmlhbGl6ZU9wZXJhdG9yKCkpO1xuICAgIH07XG59XG5leHBvcnRzLm1hdGVyaWFsaXplID0gbWF0ZXJpYWxpemU7XG52YXIgTWF0ZXJpYWxpemVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxpemVPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgTWF0ZXJpYWxpemVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hdGVyaWFsaXplU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0ZXJpYWxpemVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1hdGVyaWFsaXplU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdGVyaWFsaXplU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbGl6ZVN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgIH1cbiAgICBNYXRlcmlhbGl6ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICAgIH07XG4gICAgTWF0ZXJpYWxpemVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgTWF0ZXJpYWxpemVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdGVyaWFsaXplU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGVyaWFsaXplLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlZHVjZV8xID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbi8qKlxuICogVGhlIE1heCBvcGVyYXRvciBvcGVyYXRlcyBvbiBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbnVtYmVycyAob3IgaXRlbXMgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBhIHByb3ZpZGVkIGZ1bmN0aW9uKSxcbiAqIGFuZCB3aGVuIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBpdCBlbWl0cyBhIHNpbmdsZSBpdGVtOiB0aGUgaXRlbSB3aXRoIHRoZSBsYXJnZXN0IHZhbHVlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWF4LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkdldCB0aGUgbWF4aW1hbCB2YWx1ZSBvZiBhIHNlcmllcyBvZiBudW1iZXJzPC9jYXB0aW9uPlxuICogUnguT2JzZXJ2YWJsZS5vZig1LCA0LCA3LCAyLCA4KVxuICogICAubWF4KClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gLT4gOFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWF4aW1hbCBpdGVtPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgIGFnZTogbnVtYmVyLFxuICogICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPih7YWdlOiA3LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgICAgICAgICAgICAgICAgICAge2FnZTogNSwgbmFtZTogJ0Jhcid9LFxuICogICAgICAgICAgICAgICAgICAgICAgIHthZ2U6IDksIG5hbWU6ICdCZWVyJ30pXG4gKiAgICAgICAgICAgLm1heDxQZXJzb24+KChhOiBQZXJzb24sIGI6IFBlcnNvbikgPT4gYS5hZ2UgPCBiLmFnZSA/IC0xIDogMSlcbiAqICAgICAgICAgICAuc3Vic2NyaWJlKCh4OiBQZXJzb24pID0+IGNvbnNvbGUubG9nKHgubmFtZSkpOyAvLyAtPiAnQmVlcidcbiAqIH1cbiAqXG4gKiBAc2VlIHtAbGluayBtaW59XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAtIE9wdGlvbmFsIGNvbXBhcmVyIGZ1bmN0aW9uIHRoYXQgaXQgd2lsbCB1c2UgaW5zdGVhZCBvZiBpdHMgZGVmYXVsdCB0byBjb21wYXJlIHRoZVxuICogdmFsdWUgb2YgdHdvIGl0ZW1zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW0gd2l0aCB0aGUgbGFyZ2VzdCB2YWx1ZS5cbiAqIEBtZXRob2QgbWF4XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXgoY29tcGFyZXIpIHtcbiAgICB2YXIgbWF4ID0gKHR5cGVvZiBjb21wYXJlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgPyBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gY29tcGFyZXIoeCwgeSkgPiAwID8geCA6IHk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA+IHkgPyB4IDogeTsgfTtcbiAgICByZXR1cm4gcmVkdWNlXzEucmVkdWNlKG1heCk7XG59XG5leHBvcnRzLm1heCA9IG1heDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9tZXJnZScpO1xudmFyIG1lcmdlXzIgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL21lcmdlJyk7XG5leHBvcnRzLm1lcmdlU3RhdGljID0gbWVyZ2VfMi5tZXJnZTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggY29uY3VycmVudGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBldmVyeVxuICogZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnkgYmxlbmRpbmdcbiAqIHRoZWlyIHZhbHVlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZWAgc3Vic2NyaWJlcyB0byBlYWNoIGdpdmVuIGlucHV0IE9ic2VydmFibGUgKGVpdGhlciB0aGUgc291cmNlIG9yIGFuXG4gKiBPYnNlcnZhYmxlIGdpdmVuIGFzIGFyZ3VtZW50KSwgYW5kIHNpbXBseSBmb3J3YXJkcyAod2l0aG91dCBkb2luZyBhbnlcbiAqIHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXQgT2JzZXJ2YWJsZXMgdG8gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzIG9uY2UgYWxsIGlucHV0IE9ic2VydmFibGVzXG4gKiBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dCBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHlcbiAqIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBjbGlja3MubWVyZ2UodGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgMyBPYnNlcnZhYmxlcywgYnV0IG9ubHkgMiBydW4gY29uY3VycmVudGx5PC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciBjb25jdXJyZW50ID0gMjsgLy8gdGhlIGFyZ3VtZW50XG4gKiB2YXIgbWVyZ2VkID0gdGltZXIxLm1lcmdlKHRpbWVyMiwgdGltZXIzLCBjb25jdXJyZW50KTtcbiAqIG1lcmdlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gbWVyZ2Ugd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3IgbWFuYWdpbmdcbiAqIGNvbmN1cnJlbmN5IG9mIGlucHV0IE9ic2VydmFibGVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIHRoYXQgYXJlIHRoZSByZXN1bHQgb2ZcbiAqIGV2ZXJ5IGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1lcmdlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0LmNhbGwobWVyZ2VfMS5tZXJnZS5hcHBseSh2b2lkIDAsIFtzb3VyY2VdLmNvbmNhdChvYnNlcnZhYmxlcykpKTsgfTtcbn1cbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuL21lcmdlTWFwJyk7XG52YXIgaWRlbnRpdHlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaWRlbnRpdHknKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSB3aGljaFxuICogY29uY3VycmVudGx5IGRlbGl2ZXJzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgZW1pdHRlZCBvbiB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlQWxsYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhc1xuICogYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgaXQgc3Vic2NyaWJlcyB0byB0aGF0IGFuZCBkZWxpdmVycyBhbGwgdGhlIHZhbHVlcyBmcm9tIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5XG4gKiBjb21wbGV0ZXMgb25jZSBhbGwgaW5uZXIgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnlcbiAqIGEgaW5uZXIgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwYXduIGEgbmV3IGludGVydmFsIE9ic2VydmFibGUgZm9yIGVhY2ggY2xpY2sgZXZlbnQsIGFuZCBibGVuZCB0aGVpciBvdXRwdXRzIGFzIG9uZSBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IGZyb20gMCB0byA5IGV2ZXJ5IHNlY29uZCBmb3IgZWFjaCBjbGljaywgYnV0IG9ubHkgYWxsb3cgMiBjb25jdXJyZW50IHRpbWVyczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKDIpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbm5lclxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGNvbWluZyBmcm9tIGFsbCB0aGVcbiAqIGlubmVyIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZUFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiBtZXJnZU1hcF8xLm1lcmdlTWFwKGlkZW50aXR5XzEuaWRlbnRpdHksIG51bGwsIGNvbmN1cnJlbnQpO1xufVxuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBtZXJnZUFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBlYWNoIGxldHRlciB0byBhbiBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJyk7XG4gKiB2YXIgcmVzdWx0ID0gbGV0dGVycy5tZXJnZU1hcCh4ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkubWFwKGkgPT4geCtpKVxuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gYTBcbiAqIC8vIGIwXG4gKiAvLyBjMFxuICogLy8gYTFcbiAqIC8vIGIxXG4gKiAvLyBjMVxuICogLy8gY29udGludWVzIHRvIGxpc3QgYSxiLGMgd2l0aCByZXNwZWN0aXZlIGFzY2VuZGluZyBpbnRlZ2Vyc1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgbWVyZ2VNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlTWFwT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnQgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZU1hcCA9IG1lcmdlTWFwO1xudmFyIE1lcmdlTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZU1hcFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlTWFwT3BlcmF0b3IgPSBNZXJnZU1hcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZU1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZU1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChpc2gsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGlzaCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5UmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25vdGlmeVJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VNYXBTdWJzY3JpYmVyID0gTWVyZ2VNYXBTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBtdWx0aXBsZVxuICogdGltZXMgaW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIG1lcmdlTWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZSBhbHdheXNcbiAqIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VNYXBUby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBnaXZlbiBPYnNlcnZhYmxlIGBpbm5lck9ic2VydmFibGVgIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSBzb3VyY2UgdmFsdWUsIGFuZCB0aGVuIG1lcmdlcyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHN0YXJ0IGFuIGludGVydmFsIE9ic2VydmFibGUgdGlja2luZyBldmVyeSAxIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLm1lcmdlTWFwVG8oUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlubmVyT2JzZXJ2YWJsZSBBbiBPYnNlcnZhYmxlIHRvIHJlcGxhY2UgZWFjaCB2YWx1ZSBmcm9tXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIGdpdmVuXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCAoYW5kIG9wdGlvbmFsbHkgdHJhbnNmb3JtZWQgdGhyb3VnaCBgcmVzdWx0U2VsZWN0b3JgKSBldmVyeVxuICogdGltZSBhIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZU1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZU1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25jdXJyZW50ID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNZXJnZU1hcFRvT3BlcmF0b3IoaW5uZXJPYnNlcnZhYmxlLCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkpOyB9O1xufVxuZXhwb3J0cy5tZXJnZU1hcFRvID0gbWVyZ2VNYXBUbztcbi8vIFRPRE86IEZpZ3VyZSBvdXQgY29ycmVjdCBzaWduYXR1cmUgaGVyZTogYW4gT3BlcmF0b3I8T2JzZXJ2YWJsZTxUPiwgUj5cbi8vICAgICAgIG5lZWRzIHRvIGltcGxlbWVudCBjYWxsKG9ic2VydmVyOiBTdWJzY3JpYmVyPFI+KTogU3Vic2NyaWJlcjxPYnNlcnZhYmxlPFQ+PlxudmFyIE1lcmdlTWFwVG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBUb09wZXJhdG9yKGlzaCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlTWFwVG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZU1hcFRvU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5pc2gsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwVG9PcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlTWFwVG9PcGVyYXRvciA9IE1lcmdlTWFwVG9PcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VNYXBUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZU1hcFRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgaXNoLCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmlzaCA9IGlzaDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0U2VsZWN0b3IgPSB0aGlzLnJlc3VsdFNlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgdmFyIGlzaCA9IHRoaXMuaXNoO1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgICAgICB0aGlzLl9pbm5lclN1Yihpc2gsIGRlc3RpbmF0aW9uLCByZXN1bHRTZWxlY3RvciwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKGlzaCwgZGVzdGluYXRpb24sIHJlc3VsdFNlbGVjdG9yLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy50cnlTZWxlY3RSZXN1bHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U2VsZWN0UmVzdWx0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwVG9TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VNYXBUb1N1YnNjcmliZXIgPSBNZXJnZU1hcFRvU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwVG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZXJlIHRoZVxuICogYWNjdW11bGF0b3IgZnVuY3Rpb24gaXRzZWxmIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgdGhlbiBlYWNoIGludGVybWVkaWF0ZVxuICogT2JzZXJ2YWJsZSByZXR1cm5lZCBpcyBtZXJnZWQgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc2Nhbn0sIGJ1dCB0aGUgT2JzZXJ2YWJsZXMgcmV0dXJuZWRcbiAqIGJ5IHRoZSBhY2N1bXVsYXRvciBhcmUgbWVyZ2VkIGludG8gdGhlIG91dGVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogY29uc3QgY2xpY2skID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3Qgb25lJCA9IGNsaWNrJC5tYXBUbygxKTtcbiAqIGNvbnN0IHNlZWQgPSAwO1xuICogY29uc3QgY291bnQkID0gb25lJC5tZXJnZVNjYW4oKGFjYywgb25lKSA9PiBSeC5PYnNlcnZhYmxlLm9mKGFjYyArIG9uZSksIHNlZWQpO1xuICogY291bnQkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzOlxuICogMVxuICogMlxuICogM1xuICogNFxuICogLy8gLi4uYW5kIHNvIG9uIGZvciBlYWNoIGNsaWNrXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBUKTogT2JzZXJ2YWJsZTxSPn0gYWNjdW11bGF0b3JcbiAqIFRoZSBhY2N1bXVsYXRvciBmdW5jdGlvbiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0gc2VlZCBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZlxuICogaW5wdXQgT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBvYnNlcnZhYmxlIG9mIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIG1lcmdlU2NhblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTY2FuKGFjY3VtdWxhdG9yLCBzZWVkLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNZXJnZVNjYW5PcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgY29uY3VycmVudCkpOyB9O1xufVxuZXhwb3J0cy5tZXJnZVNjYW4gPSBtZXJnZVNjYW47XG52YXIgTWVyZ2VTY2FuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBjb25jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VTY2FuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZVNjYW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYWNjdW11bGF0b3IsIHRoaXMuc2VlZCwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VTY2FuT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZVNjYW5PcGVyYXRvciA9IE1lcmdlU2Nhbk9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZVNjYW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VTY2FuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZVNjYW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhY2N1bXVsYXRvciwgYWNjLCBjb25jdXJyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgICB0aGlzLmFjYyA9IGFjYztcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHZhciBpc2ggPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuYWNjdW11bGF0b3IpKHRoaXMuYWNjLCB2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgaWYgKGlzaCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyU3ViKGlzaCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmFjYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlU2NhblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5hY2MgPSBpbm5lclZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIE1lcmdlU2NhblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5hY2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VTY2FuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlU2NhblN1YnNjcmliZXIgPSBNZXJnZVNjYW5TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VTY2FuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlZHVjZV8xID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbi8qKlxuICogVGhlIE1pbiBvcGVyYXRvciBvcGVyYXRlcyBvbiBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbnVtYmVycyAob3IgaXRlbXMgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBhIHByb3ZpZGVkIGZ1bmN0aW9uKSxcbiAqIGFuZCB3aGVuIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBpdCBlbWl0cyBhIHNpbmdsZSBpdGVtOiB0aGUgaXRlbSB3aXRoIHRoZSBzbWFsbGVzdCB2YWx1ZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21pbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZXQgdGhlIG1pbmltYWwgdmFsdWUgb2YgYSBzZXJpZXMgb2YgbnVtYmVyczwvY2FwdGlvbj5cbiAqIFJ4Lk9ic2VydmFibGUub2YoNSwgNCwgNywgMiwgOClcbiAqICAgLm1pbigpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIC0+IDJcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYSBjb21wYXJlciBmdW5jdGlvbiB0byBnZXQgdGhlIG1pbmltYWwgaXRlbTwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICBhZ2U6IG51bWJlcixcbiAqICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oe2FnZTogNywgbmFtZTogJ0Zvbyd9LFxuICogICAgICAgICAgICAgICAgICAgICAgIHthZ2U6IDUsIG5hbWU6ICdCYXInfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICB7YWdlOiA5LCBuYW1lOiAnQmVlcid9KVxuICogICAgICAgICAgIC5taW48UGVyc29uPiggKGE6IFBlcnNvbiwgYjogUGVyc29uKSA9PiBhLmFnZSA8IGIuYWdlID8gLTEgOiAxKVxuICogICAgICAgICAgIC5zdWJzY3JpYmUoKHg6IFBlcnNvbikgPT4gY29uc29sZS5sb2coeC5uYW1lKSk7IC8vIC0+ICdCYXInXG4gKiB9XG4gKlxuICogQHNlZSB7QGxpbmsgbWF4fVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJlcl0gLSBPcHRpb25hbCBjb21wYXJlciBmdW5jdGlvbiB0aGF0IGl0IHdpbGwgdXNlIGluc3RlYWQgb2YgaXRzIGRlZmF1bHQgdG8gY29tcGFyZSB0aGVcbiAqIHZhbHVlIG9mIHR3byBpdGVtcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtIHdpdGggdGhlIHNtYWxsZXN0IHZhbHVlLlxuICogQG1ldGhvZCBtaW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1pbihjb21wYXJlcikge1xuICAgIHZhciBtaW4gPSAodHlwZW9mIGNvbXBhcmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICA/IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlcih4LCB5KSA8IDAgPyB4IDogeTsgfVxuICAgICAgICA6IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4IDwgeSA/IHggOiB5OyB9O1xuICAgIHJldHVybiByZWR1Y2VfMS5yZWR1Y2UobWluKTtcbn1cbmV4cG9ydHMubWluID0gbWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIGludm9raW5nIGEgc3BlY2lmaWVkIHNlbGVjdG9yIG9uIGl0ZW1zXG4gKiBlbWl0dGVkIGJ5IGEgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzdHJlYW0uXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tdWx0aWNhc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxTdWJqZWN0fSBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSAtIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGludGVybWVkaWF0ZSBzdWJqZWN0IHRocm91Z2hcbiAqIHdoaWNoIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBlbGVtZW50cyB3aWxsIGJlIG11bHRpY2FzdCB0byB0aGUgc2VsZWN0b3IgZnVuY3Rpb25cbiAqIG9yIFN1YmplY3QgdG8gcHVzaCBzb3VyY2UgZWxlbWVudHMgaW50by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gLSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB0aGF0IGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzdHJlYW1cbiAqIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHN0cmVhbS5cbiAqIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGFsbCBub3RpZmljYXRpb25zIG9mIHRoZSBzb3VyY2UgZnJvbSB0aGVcbiAqIHRpbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBmb3J3YXJkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIGludm9raW5nIHRoZSBzZWxlY3RvclxuICogb24gdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgYSBgQ29ubmVjdGFibGVPYnNlcnZhYmxlYCB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG9cbiAqIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS5cbiAqIEBtZXRob2QgbXVsdGljYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtdWx0aWNhc3Qoc3ViamVjdE9yU3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG11bHRpY2FzdE9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gc3ViamVjdEZhY3RvcnkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IE11bHRpY2FzdE9wZXJhdG9yKHN1YmplY3RGYWN0b3J5LCBzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IE9iamVjdC5jcmVhdGUoc291cmNlLCBDb25uZWN0YWJsZU9ic2VydmFibGVfMS5jb25uZWN0YWJsZU9ic2VydmFibGVEZXNjcmlwdG9yKTtcbiAgICAgICAgY29ubmVjdGFibGUuc291cmNlID0gc291cmNlO1xuICAgICAgICBjb25uZWN0YWJsZS5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICByZXR1cm4gY29ubmVjdGFibGU7XG4gICAgfTtcbn1cbmV4cG9ydHMubXVsdGljYXN0ID0gbXVsdGljYXN0O1xudmFyIE11bHRpY2FzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdWx0aWNhc3RPcGVyYXRvcihzdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIE11bHRpY2FzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNlbGVjdG9yKHN1YmplY3QpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChzb3VyY2Uuc3Vic2NyaWJlKHN1YmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aWNhc3RPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk11bHRpY2FzdE9wZXJhdG9yID0gTXVsdGljYXN0T3BlcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aWNhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICpcbiAqIFJlLWVtaXRzIGFsbCBub3RpZmljYXRpb25zIGZyb20gc291cmNlIE9ic2VydmFibGUgd2l0aCBzcGVjaWZpZWQgc2NoZWR1bGVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbnN1cmUgYSBzcGVjaWZpYyBzY2hlZHVsZXIgaXMgdXNlZCwgZnJvbSBvdXRzaWRlIG9mIGFuIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIGBvYnNlcnZlT25gIGlzIGFuIG9wZXJhdG9yIHRoYXQgYWNjZXB0cyBhIHNjaGVkdWxlciBhcyBhIGZpcnN0IHBhcmFtZXRlciwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlc2NoZWR1bGVcbiAqIG5vdGlmaWNhdGlvbnMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIEl0IG1pZ2h0IGJlIHVzZWZ1bCwgaWYgeW91IGRvIG5vdCBoYXZlIGNvbnRyb2wgb3ZlclxuICogaW50ZXJuYWwgc2NoZWR1bGVyIG9mIGEgZ2l2ZW4gT2JzZXJ2YWJsZSwgYnV0IHdhbnQgdG8gY29udHJvbCB3aGVuIGl0cyB2YWx1ZXMgYXJlIGVtaXR0ZWQgbmV2ZXJ0aGVsZXNzLlxuICpcbiAqIFJldHVybmVkIE9ic2VydmFibGUgZW1pdHMgdGhlIHNhbWUgbm90aWZpY2F0aW9ucyAobmV4dGVkIHZhbHVlcywgY29tcGxldGUgYW5kIGVycm9yIGV2ZW50cykgYXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLFxuICogYnV0IHJlc2NoZWR1bGVkIHdpdGggcHJvdmlkZWQgc2NoZWR1bGVyLiBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IG1lYW4gdGhhdCBzb3VyY2UgT2JzZXJ2YWJsZXMgaW50ZXJuYWxcbiAqIHNjaGVkdWxlciB3aWxsIGJlIHJlcGxhY2VkIGluIGFueSB3YXkuIE9yaWdpbmFsIHNjaGVkdWxlciBzdGlsbCB3aWxsIGJlIHVzZWQsIGJ1dCB3aGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0c1xuICogbm90aWZpY2F0aW9uLCBpdCB3aWxsIGJlIGltbWVkaWF0ZWx5IHNjaGVkdWxlZCBhZ2FpbiAtIHRoaXMgdGltZSB3aXRoIHNjaGVkdWxlciBwYXNzZWQgdG8gYG9ic2VydmVPbmAuXG4gKiBBbiBhbnRpLXBhdHRlcm4gd291bGQgYmUgY2FsbGluZyBgb2JzZXJ2ZU9uYCBvbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbG90cyBvZiB2YWx1ZXMgc3luY2hyb25vdXNseSwgdG8gc3BsaXRcbiAqIHRoYXQgZW1pc3Npb25zIGludG8gYXN5bmNocm9ub3VzIGNodW5rcy4gRm9yIHRoaXMgdG8gaGFwcGVuLCBzY2hlZHVsZXIgd291bGQgaGF2ZSB0byBiZSBwYXNzZWQgaW50byB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGRpcmVjdGx5ICh1c3VhbGx5IGludG8gdGhlIG9wZXJhdG9yIHRoYXQgY3JlYXRlcyBpdCkuIGBvYnNlcnZlT25gIHNpbXBseSBkZWxheXMgbm90aWZpY2F0aW9ucyBhXG4gKiBsaXR0bGUgYml0IG1vcmUsIHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlIGVtaXR0ZWQgYXQgZXhwZWN0ZWQgbW9tZW50cy5cbiAqXG4gKiBBcyBhIG1hdHRlciBvZiBmYWN0LCBgb2JzZXJ2ZU9uYCBhY2NlcHRzIHNlY29uZCBwYXJhbWV0ZXIsIHdoaWNoIHNwZWNpZmllcyBpbiBtaWxsaXNlY29uZHMgd2l0aCB3aGF0IGRlbGF5IG5vdGlmaWNhdGlvbnNcbiAqIHdpbGwgYmUgZW1pdHRlZC4gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBkZWxheX0gb3BlcmF0b3IgYW5kIGBvYnNlcnZlT25gIGlzIHRoYXQgYG9ic2VydmVPbmBcbiAqIHdpbGwgZGVsYXkgYWxsIG5vdGlmaWNhdGlvbnMgLSBpbmNsdWRpbmcgZXJyb3Igbm90aWZpY2F0aW9ucyAtIHdoaWxlIGBkZWxheWAgd2lsbCBwYXNzIHRocm91Z2ggZXJyb3JcbiAqIGZyb20gc291cmNlIE9ic2VydmFibGUgaW1tZWRpYXRlbHkgd2hlbiBpdCBpcyBlbWl0dGVkLiBJbiBnZW5lcmFsIGl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0byB1c2UgYGRlbGF5YCBvcGVyYXRvclxuICogZm9yIGFueSBraW5kIG9mIGRlbGF5aW5nIG9mIHZhbHVlcyBpbiB0aGUgc3RyZWFtLCB3aGlsZSB1c2luZyBgb2JzZXJ2ZU9uYCB0byBzcGVjaWZ5IHdoaWNoIHNjaGVkdWxlciBzaG91bGQgYmUgdXNlZFxuICogZm9yIG5vdGlmaWNhdGlvbiBlbWlzc2lvbnMgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbnN1cmUgdmFsdWVzIGluIHN1YnNjcmliZSBhcmUgY2FsbGVkIGp1c3QgYmVmb3JlIGJyb3dzZXIgcmVwYWludC48L2NhcHRpb24+XG4gKiBjb25zdCBpbnRlcnZhbHMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwKTsgLy8gSW50ZXJ2YWxzIGFyZSBzY2hlZHVsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGFzeW5jIHNjaGVkdWxlciBieSBkZWZhdWx0Li4uXG4gKlxuICogaW50ZXJ2YWxzXG4gKiAub2JzZXJ2ZU9uKFJ4LlNjaGVkdWxlci5hbmltYXRpb25GcmFtZSkgICAgICAgLy8gLi4uYnV0IHdlIHdpbGwgb2JzZXJ2ZSBvbiBhbmltYXRpb25GcmFtZVxuICogLnN1YnNjcmliZSh2YWwgPT4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjaGVkdWxlciB0byBlbnN1cmUgc21vb3RoIGFuaW1hdGlvbi5cbiAqICAgc29tZURpdi5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnO1xuICogfSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKlxuICogQHBhcmFtIHtJU2NoZWR1bGVyfSBzY2hlZHVsZXIgU2NoZWR1bGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlc2NoZWR1bGUgbm90aWZpY2F0aW9ucyBmcm9tIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IHN0YXRlcyB3aXRoIHdoYXQgZGVsYXkgZXZlcnkgbm90aWZpY2F0aW9uIHNob3VsZCBiZSByZXNjaGVkdWxlZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2FtZSBub3RpZmljYXRpb25zIGFzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSxcbiAqIGJ1dCB3aXRoIHByb3ZpZGVkIHNjaGVkdWxlci5cbiAqXG4gKiBAbWV0aG9kIG9ic2VydmVPblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZU9uKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gb2JzZXJ2ZU9uT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG4gICAgfTtcbn1cbmV4cG9ydHMub2JzZXJ2ZU9uID0gb2JzZXJ2ZU9uO1xudmFyIE9ic2VydmVPbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICBPYnNlcnZlT25PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zY2hlZHVsZXIsIHRoaXMuZGVsYXkpKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlT25PcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmVPbk9wZXJhdG9yID0gT2JzZXJ2ZU9uT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE9ic2VydmVPblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYnNlcnZlT25TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmVPblN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB9XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IGFyZy5ub3RpZmljYXRpb24sIGRlc3RpbmF0aW9uID0gYXJnLmRlc3RpbmF0aW9uO1xuICAgICAgICBub3RpZmljYXRpb24ub2JzZXJ2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTWVzc2FnZSA9IGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCwgdGhpcy5kZWxheSwgbmV3IE9ic2VydmVPbk1lc3NhZ2Uobm90aWZpY2F0aW9uLCB0aGlzLmRlc3RpbmF0aW9uKSkpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZU9uU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uU3Vic2NyaWJlciA9IE9ic2VydmVPblN1YnNjcmliZXI7XG52YXIgT2JzZXJ2ZU9uTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uTWVzc2FnZShub3RpZmljYXRpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlT25NZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uTWVzc2FnZSA9IE9ic2VydmVPbk1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlT24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBGcm9tT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9Gcm9tT2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFdoZW4gYW55IG9mIHRoZSBwcm92aWRlZCBPYnNlcnZhYmxlIGVtaXRzIGFuIGNvbXBsZXRlIG9yIGVycm9yIG5vdGlmaWNhdGlvbiwgaXQgaW1tZWRpYXRlbHkgc3Vic2NyaWJlcyB0byB0aGUgbmV4dCBvbmVcbiAqIHRoYXQgd2FzIHBhc3NlZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RXhlY3V0ZSBzZXJpZXMgb2YgT2JzZXJ2YWJsZXMgbm8gbWF0dGVyIHdoYXQsIGV2ZW4gaWYgaXQgbWVhbnMgc3dhbGxvd2luZyBlcnJvcnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvb25FcnJvclJlc3VtZU5leHQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YCBpcyBhbiBvcGVyYXRvciB0aGF0IGFjY2VwdHMgYSBzZXJpZXMgb2YgT2JzZXJ2YWJsZXMsIHByb3ZpZGVkIGVpdGhlciBkaXJlY3RseSBhc1xuICogYXJndW1lbnRzIG9yIGFzIGFuIGFycmF5LiBJZiBubyBzaW5nbGUgT2JzZXJ2YWJsZSBpcyBwcm92aWRlZCwgcmV0dXJuZWQgT2JzZXJ2YWJsZSB3aWxsIHNpbXBseSBiZWhhdmUgdGhlIHNhbWVcbiAqIGFzIHRoZSBzb3VyY2UuXG4gKlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzdGFydHMgYnkgc3Vic2NyaWJpbmcgYW5kIHJlLWVtaXR0aW5nIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIFdoZW4gaXRzIHN0cmVhbSBvZiB2YWx1ZXMgZW5kcyAtIG5vIG1hdHRlciBpZiBPYnNlcnZhYmxlIGNvbXBsZXRlZCBvciBlbWl0dGVkIGFuIGVycm9yIC0gYG9uRXJyb3JSZXN1bWVOZXh0YFxuICogd2lsbCBzdWJzY3JpYmUgdG8gdGhlIGZpcnN0IE9ic2VydmFibGUgdGhhdCB3YXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBtZXRob2QuIEl0IHdpbGwgc3RhcnQgcmUtZW1pdHRpbmdcbiAqIGl0cyB2YWx1ZXMgYXMgd2VsbCBhbmQgLSBhZ2FpbiAtIHdoZW4gdGhhdCBzdHJlYW0gZW5kcywgYG9uRXJyb3JSZXN1bWVOZXh0YCB3aWxsIHByb2NlZWQgdG8gc3Vic2NyaWJpbmcgeWV0IGFub3RoZXJcbiAqIE9ic2VydmFibGUgaW4gcHJvdmlkZWQgc2VyaWVzLCBubyBtYXR0ZXIgaWYgcHJldmlvdXMgT2JzZXJ2YWJsZSBjb21wbGV0ZWQgb3IgZW5kZWQgd2l0aCBhbiBlcnJvci4gVGhpcyB3aWxsXG4gKiBiZSBoYXBwZW5pbmcgdW50aWwgdGhlcmUgaXMgbm8gbW9yZSBPYnNlcnZhYmxlcyBsZWZ0IGluIHRoZSBzZXJpZXMsIGF0IHdoaWNoIHBvaW50IHJldHVybmVkIE9ic2VydmFibGUgd2lsbFxuICogY29tcGxldGUgLSBldmVuIGlmIHRoZSBsYXN0IHN1YnNjcmliZWQgc3RyZWFtIGVuZGVkIHdpdGggYW4gZXJyb3IuXG4gKlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YCBjYW4gYmUgdGhlcmVmb3JlIHRob3VnaHQgb2YgYXMgdmVyc2lvbiBvZiB7QGxpbmsgY29uY2F0fSBvcGVyYXRvciwgd2hpY2ggaXMgbW9yZSBwZXJtaXNzaXZlXG4gKiB3aGVuIGl0IGNvbWVzIHRvIHRoZSBlcnJvcnMgZW1pdHRlZCBieSBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuIFdoaWxlIGBjb25jYXRgIHN1YnNjcmliZXMgdG8gdGhlIG5leHQgT2JzZXJ2YWJsZVxuICogaW4gc2VyaWVzIG9ubHkgaWYgcHJldmlvdXMgb25lIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQsIGBvbkVycm9yUmVzdW1lTmV4dGAgc3Vic2NyaWJlcyBldmVuIGlmIGl0IGVuZGVkIHdpdGhcbiAqIGFuIGVycm9yLlxuICpcbiAqIE5vdGUgdGhhdCB5b3UgZG8gbm90IGdldCBhbnkgYWNjZXNzIHRvIGVycm9ycyBlbWl0dGVkIGJ5IHRoZSBPYnNlcnZhYmxlcy4gSW4gcGFydGljdWxhciBkbyBub3RcbiAqIGV4cGVjdCB0aGVzZSBlcnJvcnMgdG8gYXBwZWFyIGluIGVycm9yIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgc3Vic2NyaWJlfS4gSWYgeW91IHdhbnQgdG8gdGFrZVxuICogc3BlY2lmaWMgYWN0aW9ucyBiYXNlZCBvbiB3aGF0IGVycm9yIHdhcyBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUsIHlvdSBzaG91bGQgdHJ5IG91dCB7QGxpbmsgY2F0Y2h9IGluc3RlYWQuXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byB0aGUgbmV4dCBPYnNlcnZhYmxlIGFmdGVyIG1hcCBmYWlsczwvY2FwdGlvbj5cbiAqIFJ4Lk9ic2VydmFibGUub2YoMSwgMiwgMywgMClcbiAqICAgLm1hcCh4ID0+IHtcbiAqICAgICAgIGlmICh4ID09PSAwKSB7IHRocm93IEVycm9yKCk7IH1cbiAgICAgICAgIHJldHVybiAxMCAvIHg7XG4gKiAgIH0pXG4gKiAgIC5vbkVycm9yUmVzdW1lTmV4dChSeC5PYnNlcnZhYmxlLm9mKDEsIDIsIDMpKVxuICogICAuc3Vic2NyaWJlKFxuICogICAgIHZhbCA9PiBjb25zb2xlLmxvZyh2YWwpLFxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpLCAgICAgICAgICAvLyBXaWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqICAgICAoKSA9PiBjb25zb2xlLmxvZygndGhhdFxcJ3MgaXQhJylcbiAqICAgKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMTBcbiAqIC8vIDVcbiAqIC8vIDMuMzMzMzMzMzMzMzMzMzMzNVxuICogLy8gMVxuICogLy8gMlxuICogLy8gM1xuICogLy8gXCJ0aGF0J3MgaXQhXCJcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjYXRjaH1cbiAqXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZXMgT2JzZXJ2YWJsZXMgcGFzc2VkIGVpdGhlciBkaXJlY3RseSBvciBhcyBhbiBhcnJheS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgZnJvbSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IC0gaWYgaXQgZXJyb3JzIC0gc3Vic2NyaWJlc1xuICogdG8gdGhlIG5leHQgcGFzc2VkIE9ic2VydmFibGUgYW5kIHNvIG9uLCB1bnRpbCBpdCBjb21wbGV0ZXMgb3IgcnVucyBvdXQgb2YgT2JzZXJ2YWJsZXMuXG4gKiBAbWV0aG9kIG9uRXJyb3JSZXN1bWVOZXh0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dCgpIHtcbiAgICB2YXIgbmV4dFNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuZXh0U291cmNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKG5leHRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5XzEuaXNBcnJheShuZXh0U291cmNlc1swXSkpIHtcbiAgICAgICAgbmV4dFNvdXJjZXMgPSBuZXh0U291cmNlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yKG5leHRTb3VyY2VzKSk7IH07XG59XG5leHBvcnRzLm9uRXJyb3JSZXN1bWVOZXh0ID0gb25FcnJvclJlc3VtZU5leHQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWMoKSB7XG4gICAgdmFyIG5leHRTb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmV4dFNvdXJjZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBudWxsO1xuICAgIGlmIChuZXh0U291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkobmV4dFNvdXJjZXNbMF0pKSB7XG4gICAgICAgIG5leHRTb3VyY2VzID0gbmV4dFNvdXJjZXNbMF07XG4gICAgfVxuICAgIHNvdXJjZSA9IG5leHRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZV8xLkZyb21PYnNlcnZhYmxlKHNvdXJjZSwgbnVsbCkubGlmdChuZXcgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcihuZXh0U291cmNlcykpO1xufVxuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dFN0YXRpYyA9IG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljO1xudmFyIE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IobmV4dFNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5uZXh0U291cmNlcyA9IG5leHRTb3VyY2VzO1xuICAgIH1cbiAgICBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dFNvdXJjZXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yO1xufSgpKTtcbnZhciBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0U291cmNlcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5uZXh0U291cmNlcyA9IG5leHRTb3VyY2VzO1xuICAgIH1cbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gICAgfTtcbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgICB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9OZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dFNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbmV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRXJyb3JSZXN1bWVOZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBHcm91cHMgcGFpcnMgb2YgY29uc2VjdXRpdmUgZW1pc3Npb25zIHRvZ2V0aGVyIGFuZCBlbWl0cyB0aGVtIGFzIGFuIGFycmF5IG9mXG4gKiB0d28gdmFsdWVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBwcmV2aW91cyB2YWx1ZSB0b2dldGhlciBhc1xuICogYW4gYXJyYXksIGFuZCBlbWl0cyB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhaXJ3aXNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRoZSBOdGggZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHRvIGVtaXQgYW4gYXJyYXkgWyhOLTEpdGgsIE50aF0gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudCB2YWx1ZSwgYXMgYVxuICogcGFpci4gRm9yIHRoaXMgcmVhc29uLCBgcGFpcndpc2VgIGVtaXRzIG9uIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnRcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG5vdCBvbiB0aGUgZmlyc3QgZW1pc3Npb24sIGJlY2F1c2VcbiAqIHRoZXJlIGlzIG5vIHByZXZpb3VzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayAoc3RhcnRpbmcgZnJvbSB0aGUgc2Vjb25kKSwgZW1pdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgdG8gdGhlIHByZXZpb3VzIGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYWlycyA9IGNsaWNrcy5wYWlyd2lzZSgpO1xuICogdmFyIGRpc3RhbmNlID0gcGFpcnMubWFwKHBhaXIgPT4ge1xuICogICB2YXIgeDAgPSBwYWlyWzBdLmNsaWVudFg7XG4gKiAgIHZhciB5MCA9IHBhaXJbMF0uY2xpZW50WTtcbiAqICAgdmFyIHgxID0gcGFpclsxXS5jbGllbnRYO1xuICogICB2YXIgeTEgPSBwYWlyWzFdLmNsaWVudFk7XG4gKiAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDAgLSB4MSwgMikgKyBNYXRoLnBvdyh5MCAtIHkxLCAyKSk7XG4gKiB9KTtcbiAqIGRpc3RhbmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEFycmF5PFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiBwYWlycyAoYXMgYXJyYXlzKSBvZlxuICogY29uc2VjdXRpdmUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBwYWlyd2lzZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGFpcndpc2UoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBQYWlyd2lzZU9wZXJhdG9yKCkpOyB9O1xufVxuZXhwb3J0cy5wYWlyd2lzZSA9IHBhaXJ3aXNlO1xudmFyIFBhaXJ3aXNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFBhaXJ3aXNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBQYWlyd2lzZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhaXJ3aXNlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBQYWlyd2lzZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYWlyd2lzZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFpcndpc2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNQcmV2ID0gZmFsc2U7XG4gICAgfVxuICAgIFBhaXJ3aXNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJldikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KFt0aGlzLnByZXYsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc1ByZXYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldiA9IHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhaXJ3aXNlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhaXJ3aXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG5vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9ub3QnKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG4vKipcbiAqIFNwbGl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgaW50byB0d28sIG9uZSB3aXRoIHZhbHVlcyB0aGF0IHNhdGlzZnkgYVxuICogcHJlZGljYXRlLCBhbmQgYW5vdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRvbid0IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBmaWx0ZXJ9LCBidXQgcmV0dXJucyB0d28gT2JzZXJ2YWJsZXM6XG4gKiBvbmUgbGlrZSB0aGUgb3V0cHV0IG9mIHtAbGluayBmaWx0ZXJ9LCBhbmQgdGhlIG90aGVyIHdpdGggdmFsdWVzIHRoYXQgZGlkIG5vdFxuICogcGFzcyB0aGUgY29uZGl0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhcnRpdGlvbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgcGFydGl0aW9uYCBvdXRwdXRzIGFuIGFycmF5IHdpdGggdHdvIE9ic2VydmFibGVzIHRoYXQgcGFydGl0aW9uIHRoZSB2YWx1ZXNcbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRocm91Z2ggdGhlIGdpdmVuIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLiBUaGUgZmlyc3RcbiAqIE9ic2VydmFibGUgaW4gdGhhdCBhcnJheSBlbWl0cyBzb3VyY2UgdmFsdWVzIGZvciB3aGljaCB0aGUgcHJlZGljYXRlIGFyZ3VtZW50XG4gKiByZXR1cm5zIHRydWUuIFRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0cyBzb3VyY2UgdmFsdWVzIGZvciB3aGljaCB0aGVcbiAqIHByZWRpY2F0ZSByZXR1cm5zIGZhbHNlLiBUaGUgZmlyc3QgYmVoYXZlcyBsaWtlIHtAbGluayBmaWx0ZXJ9IGFuZCB0aGUgc2Vjb25kXG4gKiBiZWhhdmVzIGxpa2Uge0BsaW5rIGZpbHRlcn0gd2l0aCB0aGUgcHJlZGljYXRlIG5lZ2F0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UGFydGl0aW9uIGNsaWNrIGV2ZW50cyBpbnRvIHRob3NlIG9uIERJViBlbGVtZW50cyBhbmQgdGhvc2UgZWxzZXdoZXJlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYXJ0cyA9IGNsaWNrcy5wYXJ0aXRpb24oZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHZhciBjbGlja3NPbkRpdnMgPSBwYXJ0c1swXTtcbiAqIHZhciBjbGlja3NFbHNld2hlcmUgPSBwYXJ0c1sxXTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnRElWIGNsaWNrZWQ6ICcsIHgpKTtcbiAqIGNsaWNrc0Vsc2V3aGVyZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnT3RoZXIgY2xpY2tlZDogJywgeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGl0IHJldHVybnMgYHRydWVgLFxuICogdGhlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIGZpcnN0IE9ic2VydmFibGUgaW4gdGhlIHJldHVybmVkIGFycmF5LCBpZlxuICogYGZhbHNlYCB0aGUgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgc2Vjb25kIE9ic2VydmFibGUgaW4gdGhlIGFycmF5LiBUaGVcbiAqIGBpbmRleGAgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2UgZW1pc3Npb24gdGhhdCBoYXNcbiAqIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtbT2JzZXJ2YWJsZTxUPiwgT2JzZXJ2YWJsZTxUPl19IEFuIGFycmF5IHdpdGggdHdvIE9ic2VydmFibGVzOiBvbmVcbiAqIHdpdGggdmFsdWVzIHRoYXQgcGFzc2VkIHRoZSBwcmVkaWNhdGUsIGFuZCBhbm90aGVyIHdpdGggdmFsdWVzIHRoYXQgZGlkIG5vdFxuICogcGFzcyB0aGUgcHJlZGljYXRlLlxuICogQG1ldGhvZCBwYXJ0aXRpb25cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gW1xuICAgICAgICBmaWx0ZXJfMS5maWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKShzb3VyY2UpLFxuICAgICAgICBmaWx0ZXJfMS5maWx0ZXIobm90XzEubm90KHByZWRpY2F0ZSwgdGhpc0FyZykpKHNvdXJjZSlcbiAgICBdOyB9O1xufVxuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuL21hcCcpO1xuLyoqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIChhbiBvYmplY3QpIHRvIGl0cyBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIHtAbGluayBtYXB9LCBidXQgbWVhbnQgb25seSBmb3IgcGlja2luZyBvbmUgb2ZcbiAqIHRoZSBuZXN0ZWQgcHJvcGVydGllcyBvZiBldmVyeSBlbWl0dGVkIG9iamVjdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wbHVjay5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBHaXZlbiBhIGxpc3Qgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIGEgcGF0aCB0byBhbiBvYmplY3QgcHJvcGVydHksIHJldHJpZXZlc1xuICogdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFsbCB2YWx1ZXMgaW4gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYSBwcm9wZXJ0eSBjYW4ndCBiZSByZXNvbHZlZCwgaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gKiB0aGF0IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBjbGljayB0byB0aGUgdGFnTmFtZSBvZiB0aGUgY2xpY2tlZCB0YXJnZXQgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGFnTmFtZXMgPSBjbGlja3MucGx1Y2soJ3RhcmdldCcsICd0YWdOYW1lJyk7XG4gKiB0YWdOYW1lcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwcm9wZXJ0aWVzIFRoZSBuZXN0ZWQgcHJvcGVydGllcyB0byBwbHVjayBmcm9tIGVhY2ggc291cmNlXG4gKiB2YWx1ZSAoYW4gb2JqZWN0KS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEEgbmV3IE9ic2VydmFibGUgb2YgcHJvcGVydHkgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB2YWx1ZXMuXG4gKiBAbWV0aG9kIHBsdWNrXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwbHVjaygpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnRpZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGlzdCBvZiBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBlbXB0eS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIG1hcF8xLm1hcChwbHVja2VyKHByb3BlcnRpZXMsIGxlbmd0aCkpKHNvdXJjZSk7IH07XG59XG5leHBvcnRzLnBsdWNrID0gcGx1Y2s7XG5mdW5jdGlvbiBwbHVja2VyKHByb3BzLCBsZW5ndGgpIHtcbiAgICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQcm9wID0geDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBjdXJyZW50UHJvcFtwcm9wc1tpXV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3AgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudFByb3A7XG4gICAgfTtcbiAgICByZXR1cm4gbWFwcGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Y2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYSBDb25uZWN0YWJsZU9ic2VydmFibGUsIHdoaWNoIGlzIGEgdmFyaWV0eSBvZiBPYnNlcnZhYmxlIHRoYXQgd2FpdHMgdW50aWwgaXRzIGNvbm5lY3QgbWV0aG9kIGlzIGNhbGxlZFxuICogYmVmb3JlIGl0IGJlZ2lucyBlbWl0dGluZyBpdGVtcyB0byB0aG9zZSBPYnNlcnZlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdG8gaXQuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wdWJsaXNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gLSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lc1xuICogYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICogU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIEEgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHRoYXQgdXBvbiBjb25uZWN0aW9uIGNhdXNlcyB0aGUgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBpdGVtcyB0byBpdHMgT2JzZXJ2ZXJzLlxuICogQG1ldGhvZCBwdWJsaXNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID9cbiAgICAgICAgbXVsdGljYXN0XzEubXVsdGljYXN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpOyB9LCBzZWxlY3RvcikgOlxuICAgICAgICBtdWx0aWNhc3RfMS5tdWx0aWNhc3QobmV3IFN1YmplY3RfMS5TdWJqZWN0KCkpO1xufVxuZXhwb3J0cy5wdWJsaXNoID0gcHVibGlzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQmVoYXZpb3JTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9CZWhhdmlvclN1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybiB7Q29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBwdWJsaXNoQmVoYXZpb3JcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hCZWhhdmlvcih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QobmV3IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdCh2YWx1ZSkpKHNvdXJjZSk7IH07XG59XG5leHBvcnRzLnB1Ymxpc2hCZWhhdmlvciA9IHB1Ymxpc2hCZWhhdmlvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hCZWhhdmlvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBc3luY1N1YmplY3RfMSA9IHJlcXVpcmUoJy4uL0FzeW5jU3ViamVjdCcpO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbmZ1bmN0aW9uIHB1Ymxpc2hMYXN0KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QobmV3IEFzeW5jU3ViamVjdF8xLkFzeW5jU3ViamVjdCgpKShzb3VyY2UpOyB9O1xufVxuZXhwb3J0cy5wdWJsaXNoTGFzdCA9IHB1Ymxpc2hMYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaExhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmVwbGF5U3ViamVjdF8xID0gcmVxdWlyZSgnLi4vUmVwbGF5U3ViamVjdCcpO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5mdW5jdGlvbiBwdWJsaXNoUmVwbGF5KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNlbGVjdG9yT3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICAgIGlmIChzZWxlY3Rvck9yU2NoZWR1bGVyICYmIHR5cGVvZiBzZWxlY3Rvck9yU2NoZWR1bGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IHNlbGVjdG9yT3JTY2hlZHVsZXI7XG4gICAgfVxuICAgIHZhciBzZWxlY3RvciA9IHR5cGVvZiBzZWxlY3Rvck9yU2NoZWR1bGVyID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3JPclNjaGVkdWxlciA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc3ViamVjdCA9IG5ldyBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViamVjdDsgfSwgc2VsZWN0b3IpKHNvdXJjZSk7IH07XG59XG5leHBvcnRzLnB1Ymxpc2hSZXBsYXkgPSBwdWJsaXNoUmVwbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaFJlcGxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciByYWNlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL3JhY2UnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIGZpcnN0IHNvdXJjZSBPYnNlcnZhYmxlIHRvIGVtaXQgYW4gaXRlbVxuICogZnJvbSB0aGUgY29tYmluYXRpb24gb2YgdGhpcyBPYnNlcnZhYmxlIGFuZCBzdXBwbGllZCBPYnNlcnZhYmxlcy5cbiAqIEBwYXJhbSB7Li4uT2JzZXJ2YWJsZXN9IC4uLm9ic2VydmFibGVzIFNvdXJjZXMgdXNlZCB0byByYWNlIGZvciB3aGljaCBPYnNlcnZhYmxlIGVtaXRzIGZpcnN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIG91dHB1dCBvZiB0aGUgZmlyc3QgT2JzZXJ2YWJsZSB0byBlbWl0IGFuIGl0ZW0uXG4gKiBAbWV0aG9kIHJhY2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJhY2UoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiByYWNlT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgLy8gaWYgdGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gYXJyYXksIGl0IHdhcyBtb3N0IGxpa2VseSBjYWxsZWQgd2l0aFxuICAgICAgICAvLyBgcGFpcihbb2JzMSwgb2JzMiwgLi4uXSlgXG4gICAgICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdC5jYWxsKHJhY2VfMS5yYWNlLmFwcGx5KHZvaWQgMCwgW3NvdXJjZV0uY29uY2F0KG9ic2VydmFibGVzKSkpO1xuICAgIH07XG59XG5leHBvcnRzLnJhY2UgPSByYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzY2FuXzEgPSByZXF1aXJlKCcuL3NjYW4nKTtcbnZhciB0YWtlTGFzdF8xID0gcmVxdWlyZSgnLi90YWtlTGFzdCcpO1xudmFyIGRlZmF1bHRJZkVtcHR5XzEgPSByZXF1aXJlKCcuL2RlZmF1bHRJZkVtcHR5Jyk7XG52YXIgcGlwZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9waXBlJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgcmV0dXJucyB0aGVcbiAqIGFjY3VtdWxhdGVkIHJlc3VsdCB3aGVuIHRoZSBzb3VyY2UgY29tcGxldGVzLCBnaXZlbiBhbiBvcHRpb25hbCBzZWVkIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db21iaW5lcyB0b2dldGhlciBhbGwgdmFsdWVzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSxcbiAqIHVzaW5nIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIHRoYXQga25vd3MgaG93IHRvIGpvaW4gYSBuZXcgc291cmNlIHZhbHVlIGludG9cbiAqIHRoZSBhY2N1bXVsYXRpb24gZnJvbSB0aGUgcGFzdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZWR1Y2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5yZWR1Y2UoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlKSxcbiAqIGByZWR1Y2VgIGFwcGxpZXMgYW4gYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiBhZ2FpbnN0IGFuIGFjY3VtdWxhdGlvbiBhbmQgZWFjaFxuICogdmFsdWUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIChmcm9tIHRoZSBwYXN0KSB0byByZWR1Y2UgaXQgdG8gYSBzaW5nbGVcbiAqIHZhbHVlLCBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gTm90ZSB0aGF0IGByZWR1Y2VgIHdpbGwgb25seSBlbWl0XG4gKiBvbmUgdmFsdWUsIG9ubHkgd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzLiBJdCBpcyBlcXVpdmFsZW50IHRvXG4gKiBhcHBseWluZyBvcGVyYXRvciB7QGxpbmsgc2Nhbn0gZm9sbG93ZWQgYnkgb3BlcmF0b3Ige0BsaW5rIGxhc3R9LlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGFwcGxpZXMgYSBzcGVjaWZpZWQgYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiB0byBlYWNoXG4gKiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIGBzZWVkYCB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZW5cbiAqIHRoYXQgdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgYWNjdW11bGF0b3IuIElmIG5vIHNlZWRcbiAqIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHNvdXJjZSBpcyB1c2VkIGFzIHRoZSBzZWVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzIHRoYXQgaGFwcGVuZWQgaW4gNSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrc0luRml2ZVNlY29uZHMgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJylcbiAqICAgLnRha2VVbnRpbChSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMDApKTtcbiAqIHZhciBvbmVzID0gY2xpY2tzSW5GaXZlU2Vjb25kcy5tYXBUbygxKTtcbiAqIHZhciBzZWVkID0gMDtcbiAqIHZhciBjb3VudCA9IG9uZXMucmVkdWNlKChhY2MsIG9uZSkgPT4gYWNjICsgb25lLCBzZWVkKTtcbiAqIGNvdW50LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb3VudH1cbiAqIEBzZWUge0BsaW5rIGV4cGFuZH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHNjYW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gYWNjdW11bGF0b3IgVGhlIGFjY3VtdWxhdG9yIGZ1bmN0aW9uXG4gKiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1J9IFtzZWVkXSBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzaW5nbGUgdmFsdWUgdGhhdCBpcyB0aGVcbiAqIHJlc3VsdCBvZiBhY2N1bXVsYXRpbmcgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgcmVkdWNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZWR1Y2UoYWNjdW11bGF0b3IsIHNlZWQpIHtcbiAgICAvLyBwcm92aWRpbmcgYSBzZWVkIG9mIGB1bmRlZmluZWRgICpzaG91bGQqIGJlIHZhbGlkIGFuZCB0cmlnZ2VyXG4gICAgLy8gaGFzU2VlZCEgc28gZG9uJ3QgdXNlIGBzZWVkICE9PSB1bmRlZmluZWRgIGNoZWNrcyFcbiAgICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGhhdmUgdG8gY2hlY2sgaXQgaGVyZSBhdCB0aGUgb3JpZ2luYWwgY2FsbCBzaXRlXG4gICAgLy8gb3RoZXJ3aXNlIGluc2lkZSBPcGVyYXRvci9TdWJzY3JpYmVyIHdlIHdvbid0IGtub3cgaWYgYHVuZGVmaW5lZGBcbiAgICAvLyBtZWFucyB0aGV5IGRpZG4ndCBwcm92aWRlIGFueXRoaW5nIG9yIGlmIHRoZXkgbGl0ZXJhbGx5IHByb3ZpZGVkIGB1bmRlZmluZWRgXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVkdWNlT3BlcmF0b3JGdW5jdGlvbldpdGhTZWVkKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBpcGVfMS5waXBlKHNjYW5fMS5zY2FuKGFjY3VtdWxhdG9yLCBzZWVkKSwgdGFrZUxhc3RfMS50YWtlTGFzdCgxKSwgZGVmYXVsdElmRW1wdHlfMS5kZWZhdWx0SWZFbXB0eShzZWVkKSkoc291cmNlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlZHVjZU9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBwaXBlXzEucGlwZShzY2FuXzEuc2NhbihmdW5jdGlvbiAoYWNjLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcihhY2MsIHZhbHVlLCBpbmRleCArIDEpO1xuICAgICAgICB9KSwgdGFrZUxhc3RfMS50YWtlTGFzdCgxKSkoc291cmNlKTtcbiAgICB9O1xufVxuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG5mdW5jdGlvbiByZWZDb3VudCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVmQ291bnRPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFJlZkNvdW50T3BlcmF0b3Ioc291cmNlKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucmVmQ291bnQgPSByZWZDb3VudDtcbnZhciBSZWZDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9wZXJhdG9yKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50Kys7XG4gICAgICAgIHZhciByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHJlZkNvdW50ZXIpO1xuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZWZDb3VudGVyLmNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudE9wZXJhdG9yO1xufSgpKTtcbnZhciBSZWZDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHZhciByZWZDb3VudCA9IGNvbm5lY3RhYmxlLl9yZWZDb3VudDtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBsb2NhbCBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiB0byB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAgICAgLy8gdGhlIFJlZkNvdW50U3Vic2NyaWJlcidzIGRvd25zdHJlYW0gT2JzZXJ2ZXJzIHN5bmNocm9ub3VzbHkgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgICAgICAvLyAgIC5wdWJsaXNoKClcbiAgICAgICAgLy8gICAucmVmQ291bnQoKVxuICAgICAgICAvLyAgIC50YWtlKDUpXG4gICAgICAgIC8vICAgLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgICAvLyB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlJ3Mgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBleGlzdHMsICphbmQqIGVpdGhlcjpcbiAgICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgICAvLyAgICAgIFN1YnNjcmlwdGlvbiB5ZXQsIG9yLFxuICAgICAgICAvLyAgIGIuIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHJlZmVyZW5jZSBpcyBpZGVudGljYWxcbiAgICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAgIC8vL1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZDb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvRW1wdHlPYnNlcnZhYmxlJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHJlcGVhdHMgdGhlIHN0cmVhbSBvZiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhdCBtb3N0IGNvdW50IHRpbWVzLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmVwZWF0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGl0ZW1zIGFyZSByZXBlYXRlZCwgYSBjb3VudCBvZiAwIHdpbGwgeWllbGRcbiAqIGFuIGVtcHR5IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgcmVwZWF0cyB0aGUgc3RyZWFtIG9mIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IG1vc3RcbiAqIGNvdW50IHRpbWVzLlxuICogQG1ldGhvZCByZXBlYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7IGNvdW50ID0gLTE7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFJlcGVhdE9wZXJhdG9yKC0xLCBzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgUmVwZWF0T3BlcmF0b3IoY291bnQgLSAxLCBzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnJlcGVhdCA9IHJlcGVhdDtcbnZhciBSZXBlYXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVwZWF0T3BlcmF0b3IoY291bnQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXBlYXRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFJlcGVhdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb3VudCwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJlcGVhdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXBlYXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGVhdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvdW50LCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXBlYXRTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgc291cmNlID0gX2Euc291cmNlLCBjb3VudCA9IF9hLmNvdW50O1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZSh0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhIGBjb21wbGV0ZWAuIElmIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCwgdGhpcyBtZXRob2Qgd2lsbCBlbWl0IHRvIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb20gYG5vdGlmaWVyYC4gSWYgdGhhdCBPYnNlcnZhYmxlXG4gKiBjYWxscyBgY29tcGxldGVgIG9yIGBlcnJvcmAsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGQgc3Vic2NyaXB0aW9uLiBPdGhlcndpc2VcbiAqIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmVwZWF0V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5vdGlmaWNhdGlvbnM6IE9ic2VydmFibGUpOiBPYnNlcnZhYmxlfSBub3RpZmllciAtIFJlY2VpdmVzIGFuIE9ic2VydmFibGUgb2Ygbm90aWZpY2F0aW9ucyB3aXRoXG4gKiB3aGljaCBhIHVzZXIgY2FuIGBjb21wbGV0ZWAgb3IgYGVycm9yYCwgYWJvcnRpbmcgdGhlIHJlcGV0aXRpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCByZXBlYXQgbG9naWMuXG4gKiBAbWV0aG9kIHJlcGVhdFdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJlcGVhdFdoZW4obm90aWZpZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFJlcGVhdFdoZW5PcGVyYXRvcihub3RpZmllcikpOyB9O1xufVxuZXhwb3J0cy5yZXBlYXRXaGVuID0gcmVwZWF0V2hlbjtcbnZhciBSZXBlYXRXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGVhdFdoZW5PcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFJlcGVhdFdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFJlcGVhdFdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIsIHNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJlcGVhdFdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZWF0V2hlblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZWF0V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG8gPSB0cnVlO1xuICAgIH1cbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG8gPSB0cnVlO1xuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlSXNCZWluZ1N1YnNjcmliZWRUbyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcGVhdFdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJc0JlaW5nU3Vic2NyaWJlZFRvID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1JldHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uIHx8IHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBub3RpZmljYXRpb25zID0gX2Eubm90aWZpY2F0aW9ucywgcmV0cmllc1N1YnNjcmlwdGlvbiA9IF9hLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cmllcyA9IG51bGw7XG4gICAgfTtcbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbm90aWZpY2F0aW9ucyA9IF9hLm5vdGlmaWNhdGlvbnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG5vdGlmaWNhdGlvbnM7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLnN1YnNjcmliZVRvUmV0cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIHZhciByZXRyaWVzID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLm5vdGlmaWVyKSh0aGlzLm5vdGlmaWNhdGlvbnMpO1xuICAgICAgICBpZiAocmV0cmllcyA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJldHJpZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdFdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGVcbiAqIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGZvciBhIG1heGltdW0gb2YgYGNvdW50YCByZXN1YnNjcmlwdGlvbnMgKGdpdmVuXG4gKiBhcyBhIG51bWJlciBwYXJhbWV0ZXIpIHJhdGhlciB0aGFuIHByb3BhZ2F0aW5nIHRoZSBgZXJyb3JgIGNhbGwuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXRyeS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBBbnkgYW5kIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLCBldmVuIHRob3NlIGVtaXR0ZWRcbiAqIGR1cmluZyBmYWlsZWQgc3Vic2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIGlmIGFuIE9ic2VydmFibGUgZmFpbHMgYXQgZmlyc3QgYnV0IGVtaXRzIFsxLCAyXSB0aGVuIHN1Y2NlZWRzIHRoZSBzZWNvbmRcbiAqIHRpbWUgYW5kIGVtaXRzOiBbMSwgMiwgMywgNCwgNV0gdGhlbiB0aGUgY29tcGxldGUgc3RyZWFtIG9mIGVtaXNzaW9ucyBhbmQgbm90aWZpY2F0aW9uc1xuICogd291bGQgYmU6IFsxLCAyLCAxLCAyLCAzLCA0LCA1LCBgY29tcGxldGVgXS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIE51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBiZWZvcmUgZmFpbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHRoZSByZXRyeSBsb2dpYy5cbiAqIEBtZXRob2QgcmV0cnlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJldHJ5KGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAtMTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgUmV0cnlPcGVyYXRvcihjb3VudCwgc291cmNlKSk7IH07XG59XG5leHBvcnRzLnJldHJ5ID0gcmV0cnk7XG52YXIgUmV0cnlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV0cnlPcGVyYXRvcihjb3VudCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXRyeVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb3VudCwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmV0cnlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0cnlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY291bnQsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5U3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHNvdXJjZSA9IF9hLnNvdXJjZSwgY291bnQgPSBfYS5jb3VudDtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZSh0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2YgYW4gYGVycm9yYC4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlXG4gKiBjYWxscyBgZXJyb3JgLCB0aGlzIG1ldGhvZCB3aWxsIGVtaXQgdGhlIFRocm93YWJsZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgdG8gdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSBgbm90aWZpZXJgLlxuICogSWYgdGhhdCBPYnNlcnZhYmxlIGNhbGxzIGBjb21wbGV0ZWAgb3IgYGVycm9yYCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgY29tcGxldGVgIG9yIGBlcnJvcmAgb24gdGhlIGNoaWxkXG4gKiBzdWJzY3JpcHRpb24uIE90aGVyd2lzZSB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3JldHJ5V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yczogT2JzZXJ2YWJsZSk6IE9ic2VydmFibGV9IG5vdGlmaWVyIC0gUmVjZWl2ZXMgYW4gT2JzZXJ2YWJsZSBvZiBub3RpZmljYXRpb25zIHdpdGggd2hpY2ggYVxuICogdXNlciBjYW4gYGNvbXBsZXRlYCBvciBgZXJyb3JgLCBhYm9ydGluZyB0aGUgcmV0cnkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCByZXRyeSBsb2dpYy5cbiAqIEBtZXRob2QgcmV0cnlXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXRyeVdoZW4obm90aWZpZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCBzb3VyY2UpKTsgfTtcbn1cbmV4cG9ydHMucmV0cnlXaGVuID0gcmV0cnlXaGVuO1xudmFyIFJldHJ5V2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5PcGVyYXRvcihub3RpZmllciwgc291cmNlKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5V2hlbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmV0cnlXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJldHJ5V2hlbk9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmV0cnlXaGVuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHJ5V2hlblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmV0cnlXaGVuU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFJldHJ5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICB2YXIgcmV0cmllcyA9IHRoaXMucmV0cmllcztcbiAgICAgICAgICAgIHZhciByZXRyaWVzU3Vic2NyaXB0aW9uID0gdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgaWYgKCFyZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0cmllcyA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5ub3RpZmllcikoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0cmllcyA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHJpZXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJldHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcztcbiAgICAgICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgICAgICBlcnJvcnMubmV4dChlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXRyeVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVycm9ycyA9IF9hLmVycm9ycywgcmV0cmllc1N1YnNjcmlwdGlvbiA9IF9hLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgIGVycm9ycy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cmllcyA9IG51bGw7XG4gICAgfTtcbiAgICBSZXRyeVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVycm9ycyA9IF9hLmVycm9ycywgcmV0cmllcyA9IF9hLnJldHJpZXMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IG51bGw7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcztcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gcmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJldHJ5V2hlblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlXaGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZW5ldmVyXG4gKiBhbm90aGVyIE9ic2VydmFibGUsIHRoZSBgbm90aWZpZXJgLCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBzYW1wbGVUaW1lfSwgYnV0IHNhbXBsZXMgd2hlbmV2ZXJcbiAqIHRoZSBgbm90aWZpZXJgIE9ic2VydmFibGUgZW1pdHMgc29tZXRoaW5nLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NhbXBsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBXaGVuZXZlciB0aGUgYG5vdGlmaWVyYCBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLCBgc2FtcGxlYFxuICogbG9va3MgYXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBlbWl0cyB3aGljaGV2ZXIgdmFsdWUgaXQgaGFzIG1vc3QgcmVjZW50bHlcbiAqIGVtaXR0ZWQgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLCB1bmxlc3MgdGhlIHNvdXJjZSBoYXMgbm90IGVtaXR0ZWRcbiAqIGFueXRoaW5nIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZy4gVGhlIGBub3RpZmllcmAgaXMgc3Vic2NyaWJlZCB0byBhcyBzb29uXG4gKiBhcyB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgc2FtcGxlIHRoZSBtb3N0IHJlY2VudCBcInNlY29uZHNcIiB0aW1lcjwvY2FwdGlvbj5cbiAqIHZhciBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gc2Vjb25kcy5zYW1wbGUoY2xpY2tzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8YW55Pn0gbm90aWZpZXIgVGhlIE9ic2VydmFibGUgdG8gdXNlIGZvciBzYW1wbGluZyB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIHNhbXBsaW5nIHRoZVxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZW5ldmVyIHRoZSBub3RpZmllciBPYnNlcnZhYmxlXG4gKiBlbWl0cyB2YWx1ZSBvciBjb21wbGV0ZXMuXG4gKiBAbWV0aG9kIHNhbXBsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTYW1wbGVPcGVyYXRvcihub3RpZmllcikpOyB9O1xufVxuZXhwb3J0cy5zYW1wbGUgPSBzYW1wbGU7XG52YXIgU2FtcGxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbXBsZU9wZXJhdG9yKG5vdGlmaWVyKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICB9XG4gICAgU2FtcGxlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBzYW1wbGVTdWJzY3JpYmVyID0gbmV3IFNhbXBsZVN1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHNhbXBsZVN1YnNjcmliZXIpO1xuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQoc2FtcGxlU3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2FtcGxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhbXBsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FtcGxlU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgU2FtcGxlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgIH07XG4gICAgU2FtcGxlU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2FtcGxlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGhpblxuICogcGVyaW9kaWMgdGltZSBpbnRlcnZhbHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNhbXBsZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IHBlcmlvZGljIHRpbWVcbiAqIGludGVydmFscywgZW1pdHRpbmcgd2hhdCBpdCBzYW1wbGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NhbXBsZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNhbXBsZVRpbWVgIHBlcmlvZGljYWxseSBsb29rcyBhdCB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGVtaXRzIHdoaWNoZXZlclxuICogdmFsdWUgaXQgaGFzIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcsIHVubGVzcyB0aGVcbiAqIHNvdXJjZSBoYXMgbm90IGVtaXR0ZWQgYW55dGhpbmcgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLiBUaGUgc2FtcGxpbmdcbiAqIGhhcHBlbnMgcGVyaW9kaWNhbGx5IGluIHRpbWUgZXZlcnkgYHBlcmlvZGAgbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZSB1bml0XG4gKiBkZWZpbmVkIGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCBhcmd1bWVudCkuIFRoZSBzYW1wbGluZyBzdGFydHMgYXMgc29vbiBhc1xuICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgc2Vjb25kLCBlbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhdCBtb3N0IG9uY2U8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zYW1wbGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIFRoZSBzYW1wbGluZyBwZXJpb2QgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcyBvciB0aGVcbiAqIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgc2FtcGxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2Ygc2FtcGxpbmcgdGhlXG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgdGhlIHNwZWNpZmllZCB0aW1lIGludGVydmFsLlxuICogQG1ldGhvZCBzYW1wbGVUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzYW1wbGVUaW1lKHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikpOyB9O1xufVxuZXhwb3J0cy5zYW1wbGVUaW1lID0gc2FtcGxlVGltZTtcbnZhciBTYW1wbGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbXBsZVRpbWVPcGVyYXRvcihwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIFNhbXBsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNhbXBsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucGVyaW9kLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhbXBsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FtcGxlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FtcGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5vdGlmaWNhdGlvbiwgcGVyaW9kLCB7IHN1YnNjcmliZXI6IHRoaXMsIHBlcmlvZDogcGVyaW9kIH0pKTtcbiAgICB9XG4gICAgU2FtcGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgU2FtcGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2FtcGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmaWNhdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgcGVyaW9kID0gc3RhdGUucGVyaW9kO1xuICAgIHN1YnNjcmliZXIubm90aWZ5TmV4dCgpO1xuICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGVUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQXBwbGllcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiBvdmVyIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIHJldHVybnMgZWFjaFxuICogaW50ZXJtZWRpYXRlIHJlc3VsdCwgd2l0aCBhbiBvcHRpb25hbCBzZWVkIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIHJlZHVjZX0sIGJ1dCBlbWl0cyB0aGUgY3VycmVudFxuICogYWNjdW11bGF0aW9uIHdoZW5ldmVyIHRoZSBzb3VyY2UgZW1pdHMgYSB2YWx1ZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zY2FuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIENvbWJpbmVzIHRvZ2V0aGVyIGFsbCB2YWx1ZXMgZW1pdHRlZCBvbiB0aGUgc291cmNlLCB1c2luZyBhbiBhY2N1bXVsYXRvclxuICogZnVuY3Rpb24gdGhhdCBrbm93cyBob3cgdG8gam9pbiBhIG5ldyBzb3VyY2UgdmFsdWUgaW50byB0aGUgYWNjdW11bGF0aW9uIGZyb21cbiAqIHRoZSBwYXN0LiBJcyBzaW1pbGFyIHRvIHtAbGluayByZWR1Y2V9LCBidXQgZW1pdHMgdGhlIGludGVybWVkaWF0ZVxuICogYWNjdW11bGF0aW9ucy5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBhcHBsaWVzIGEgc3BlY2lmaWVkIGBhY2N1bXVsYXRvcmAgZnVuY3Rpb24gdG8gZWFjaFxuICogaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBgc2VlZGAgdmFsdWUgaXMgc3BlY2lmaWVkLCB0aGVuXG4gKiB0aGF0IHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGFjY3VtdWxhdG9yLiBJZiBubyBzZWVkXG4gKiB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBzb3VyY2UgaXMgdXNlZCBhcyB0aGUgc2VlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudCB0aGUgbnVtYmVyIG9mIGNsaWNrIGV2ZW50czwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgb25lcyA9IGNsaWNrcy5tYXBUbygxKTtcbiAqIHZhciBzZWVkID0gMDtcbiAqIHZhciBjb3VudCA9IG9uZXMuc2NhbigoYWNjLCBvbmUpID0+IGFjYyArIG9uZSwgc2VlZCk7XG4gKiBjb3VudC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZXhwYW5kfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgcmVkdWNlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFJ9IGFjY3VtdWxhdG9yXG4gKiBUaGUgYWNjdW11bGF0b3IgZnVuY3Rpb24gY2FsbGVkIG9uIGVhY2ggc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtUfFJ9IFtzZWVkXSBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBvYnNlcnZhYmxlIG9mIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIHNjYW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNjYW4oYWNjdW11bGF0b3IsIHNlZWQpIHtcbiAgICB2YXIgaGFzU2VlZCA9IGZhbHNlO1xuICAgIC8vIHByb3ZpZGluZyBhIHNlZWQgb2YgYHVuZGVmaW5lZGAgKnNob3VsZCogYmUgdmFsaWQgYW5kIHRyaWdnZXJcbiAgICAvLyBoYXNTZWVkISBzbyBkb24ndCB1c2UgYHNlZWQgIT09IHVuZGVmaW5lZGAgY2hlY2tzIVxuICAgIC8vIEZvciB0aGlzIHJlYXNvbiwgd2UgaGF2ZSB0byBjaGVjayBpdCBoZXJlIGF0IHRoZSBvcmlnaW5hbCBjYWxsIHNpdGVcbiAgICAvLyBvdGhlcndpc2UgaW5zaWRlIE9wZXJhdG9yL1N1YnNjcmliZXIgd2Ugd29uJ3Qga25vdyBpZiBgdW5kZWZpbmVkYFxuICAgIC8vIG1lYW5zIHRoZXkgZGlkbid0IHByb3ZpZGUgYW55dGhpbmcgb3IgaWYgdGhleSBsaXRlcmFsbHkgcHJvdmlkZWQgYHVuZGVmaW5lZGBcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gc2Nhbk9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuc2NhbiA9IHNjYW47XG52YXIgU2Nhbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2FuT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQpIHtcbiAgICAgICAgaWYgKGhhc1NlZWQgPT09IHZvaWQgMCkgeyBoYXNTZWVkID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgICAgICB0aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgIH1cbiAgICBTY2FuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTY2FuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFjY3VtdWxhdG9yLCB0aGlzLnNlZWQsIHRoaXMuaGFzU2VlZCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNjYW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2NhblN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFjY3VtdWxhdG9yLCBfc2VlZCwgaGFzU2VlZCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5fc2VlZCA9IF9zZWVkO1xuICAgICAgICB0aGlzLmhhc1NlZWQgPSBoYXNTZWVkO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZSwgXCJzZWVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzU2VlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zZWVkID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2VlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyeU5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hY2N1bXVsYXRvcih0aGlzLnNlZWQsIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlZCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2NhblN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qKlxuICogQ29tcGFyZXMgYWxsIHZhbHVlcyBvZiB0d28gb2JzZXJ2YWJsZXMgaW4gc2VxdWVuY2UgdXNpbmcgYW4gb3B0aW9uYWwgY29tcGFyb3IgZnVuY3Rpb25cbiAqIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgb2YgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZSByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIHR3byBzZXF1ZW5jZXNcbiAqIGFyZSBlcXVhbC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q2hlY2tzIHRvIHNlZSBvZiBhbGwgdmFsdWVzIGVtaXR0ZWQgYnkgYm90aCBvYnNlcnZhYmxlcyBhcmUgZXF1YWwsIGluIG9yZGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NlcXVlbmNlRXF1YWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNlcXVlbmNlRXF1YWxgIHN1YnNjcmliZXMgdG8gdHdvIG9ic2VydmFibGVzIGFuZCBidWZmZXJzIGluY29taW5nIHZhbHVlcyBmcm9tIGVhY2ggb2JzZXJ2YWJsZS4gV2hlbmV2ZXIgZWl0aGVyXG4gKiBvYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIHRoZSB2YWx1ZSBpcyBidWZmZXJlZCBhbmQgdGhlIGJ1ZmZlcnMgYXJlIHNoaWZ0ZWQgYW5kIGNvbXBhcmVkIGZyb20gdGhlIGJvdHRvbVxuICogdXA7IElmIGFueSB2YWx1ZSBwYWlyIGRvZXNuJ3QgbWF0Y2gsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgZW1pdCBgZmFsc2VgIGFuZCBjb21wbGV0ZS4gSWYgb25lIG9mIHRoZVxuICogb2JzZXJ2YWJsZXMgY29tcGxldGVzLCB0aGUgb3BlcmF0b3Igd2lsbCB3YWl0IGZvciB0aGUgb3RoZXIgb2JzZXJ2YWJsZSB0byBjb21wbGV0ZTsgSWYgdGhlIG90aGVyXG4gKiBvYnNlcnZhYmxlIGVtaXRzIGJlZm9yZSBjb21wbGV0aW5nLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYGZhbHNlYCBhbmQgY29tcGxldGUuIElmIG9uZSBvYnNlcnZhYmxlIG5ldmVyXG4gKiBjb21wbGV0ZXMgb3IgZW1pdHMgYWZ0ZXIgdGhlIG90aGVyIGNvbXBsZXRzLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIG5ldmVyIGNvbXBsZXRlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPmZpZ3VyZSBvdXQgaWYgdGhlIEtvbmFtaSBjb2RlIG1hdGNoZXM8L2NhcHRpb24+XG4gKiB2YXIgY29kZSA9IFJ4Lk9ic2VydmFibGUuZnJvbShbXG4gKiAgXCJBcnJvd1VwXCIsXG4gKiAgXCJBcnJvd1VwXCIsXG4gKiAgXCJBcnJvd0Rvd25cIixcbiAqICBcIkFycm93RG93blwiLFxuICogIFwiQXJyb3dMZWZ0XCIsXG4gKiAgXCJBcnJvd1JpZ2h0XCIsXG4gKiAgXCJBcnJvd0xlZnRcIixcbiAqICBcIkFycm93UmlnaHRcIixcbiAqICBcIktleUJcIixcbiAqICBcIktleUFcIixcbiAqICBcIkVudGVyXCIgLy8gbm8gc3RhcnQga2V5LCBjbGVhcmx5LlxuICogXSk7XG4gKlxuICogdmFyIGtleXMgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2tleXVwJylcbiAqICAubWFwKGUgPT4gZS5jb2RlKTtcbiAqIHZhciBtYXRjaGVzID0ga2V5cy5idWZmZXJDb3VudCgxMSwgMSlcbiAqICAubWVyZ2VNYXAoXG4gKiAgICBsYXN0MTEgPT5cbiAqICAgICAgUnguT2JzZXJ2YWJsZS5mcm9tKGxhc3QxMSlcbiAqICAgICAgICAuc2VxdWVuY2VFcXVhbChjb2RlKVxuICogICApO1xuICogbWF0Y2hlcy5zdWJzY3JpYmUobWF0Y2hlZCA9PiBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bCBjaGVhdCBhdCBDb250cmE/ICcsIG1hdGNoZWQpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogQHNlZSB7QGxpbmsgemlwfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBjb21wYXJlVG8gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gY29tcGFyZSB0aGUgc291cmNlIHNlcXVlbmNlIHRvLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcm9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBjb21wYXJlIGVhY2ggdmFsdWUgcGFpclxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBhIHNpbmdsZSBib29sZWFuIHZhbHVlIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdFxuICogdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IGJvdGggb2JzZXJ2YWJsZXMgd2VyZSBlcXVhbCBpbiBzZXF1ZW5jZS5cbiAqIEBtZXRob2Qgc2VxdWVuY2VFcXVhbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2VxdWVuY2VFcXVhbChjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IoY29tcGFyZVRvLCBjb21wYXJvcikpOyB9O1xufVxuZXhwb3J0cy5zZXF1ZW5jZUVxdWFsID0gc2VxdWVuY2VFcXVhbDtcbnZhciBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxPcGVyYXRvcihjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZVRvID0gY29tcGFyZVRvO1xuICAgICAgICB0aGlzLmNvbXBhcm9yID0gY29tcGFyb3I7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY29tcGFyZVRvLCB0aGlzLmNvbXBhcm9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuU2VxdWVuY2VFcXVhbE9wZXJhdG9yID0gU2VxdWVuY2VFcXVhbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb21wYXJlVG8sIGNvbXBhcm9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb21wYXJlVG8gPSBjb21wYXJlVG87XG4gICAgICAgIHRoaXMuY29tcGFyb3IgPSBjb21wYXJvcjtcbiAgICAgICAgdGhpcy5fYSA9IFtdO1xuICAgICAgICB0aGlzLl9iID0gW107XG4gICAgICAgIHRoaXMuX29uZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkKGNvbXBhcmVUby5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0aGlzKSkpO1xuICAgIH1cbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlICYmIHRoaXMuX2IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5fYS5sZW5ndGggPT09IDAgJiYgdGhpcy5fYi5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25lQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuY2hlY2tWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYyA9IHRoaXMsIF9hID0gX2MuX2EsIF9iID0gX2MuX2IsIGNvbXBhcm9yID0gX2MuY29tcGFyb3I7XG4gICAgICAgIHdoaWxlIChfYS5sZW5ndGggPiAwICYmIF9iLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBhID0gX2Euc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBiID0gX2Iuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBhcmVFcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbXBhcm9yKSB7XG4gICAgICAgICAgICAgICAgYXJlRXF1YWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNvbXBhcm9yKShhLCBiKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJlRXF1YWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJlRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0QiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fb25lQ29tcGxldGUgJiYgdGhpcy5fYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyID0gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XG52YXIgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcGFyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5uZXh0Qih2YWx1ZSk7XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnBhcmVudC5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZW5jZUVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbnZhciByZWZDb3VudF8xID0gcmVxdWlyZSgnLi9yZWZDb3VudCcpO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbmZ1bmN0aW9uIHNoYXJlU3ViamVjdEZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IE9ic2VydmFibGUgdGhhdCBtdWx0aWNhc3RzIChzaGFyZXMpIHRoZSBvcmlnaW5hbCBPYnNlcnZhYmxlLiBBcyBsb25nIGFzIHRoZXJlIGlzIGF0IGxlYXN0IG9uZVxuICogU3Vic2NyaWJlciB0aGlzIE9ic2VydmFibGUgd2lsbCBiZSBzdWJzY3JpYmVkIGFuZCBlbWl0dGluZyBkYXRhLiBXaGVuIGFsbCBzdWJzY3JpYmVycyBoYXZlIHVuc3Vic2NyaWJlZCBpdCB3aWxsXG4gKiB1bnN1YnNjcmliZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gQmVjYXVzZSB0aGUgT2JzZXJ2YWJsZSBpcyBtdWx0aWNhc3RpbmcgaXQgbWFrZXMgdGhlIHN0cmVhbSBgaG90YC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgZm9yIC5tdWx0aWNhc3QoKCkgPT4gbmV3IFN1YmplY3QoKSkucmVmQ291bnQoKS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NoYXJlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCB1cG9uIGNvbm5lY3Rpb24gY2F1c2VzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0byBlbWl0IGl0ZW1zIHRvIGl0cyBPYnNlcnZlcnMuXG4gKiBAbWV0aG9kIHNoYXJlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzaGFyZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gcmVmQ291bnRfMS5yZWZDb3VudCgpKG11bHRpY2FzdF8xLm11bHRpY2FzdChzaGFyZVN1YmplY3RGYWN0b3J5KShzb3VyY2UpKTsgfTtcbn1cbmV4cG9ydHMuc2hhcmUgPSBzaGFyZTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFJlcGxheVN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1JlcGxheVN1YmplY3QnKTtcbi8qKlxuICogQG1ldGhvZCBzaGFyZVJlcGxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2hhcmVSZXBsYXkoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KHNoYXJlUmVwbGF5T3BlcmF0b3IoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSk7IH07XG59XG5leHBvcnRzLnNoYXJlUmVwbGF5ID0gc2hhcmVSZXBsYXk7XG5mdW5jdGlvbiBzaGFyZVJlcGxheU9wZXJhdG9yKGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikge1xuICAgIHZhciBzdWJqZWN0O1xuICAgIHZhciByZWZDb3VudCA9IDA7XG4gICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiBzaGFyZVJlcGxheU9wZXJhdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmVmQ291bnQrKztcbiAgICAgICAgaWYgKCFzdWJqZWN0IHx8IGhhc0Vycm9yKSB7XG4gICAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgc3ViamVjdCA9IG5ldyBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdChidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IHN1YmplY3QubmV4dCh2YWx1ZSk7IH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJTdWIgPSBzdWJqZWN0LnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZkNvdW50LS07XG4gICAgICAgICAgICBpbm5lclN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiByZWZDb3VudCA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlUmVwbGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvRW1wdHlFcnJvcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2luZ2xlIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzIGEgc3BlY2lmaWVkXG4gKiBwcmVkaWNhdGUsIGlmIHRoYXQgT2JzZXJ2YWJsZSBlbWl0cyBvbmUgc3VjaCBpdGVtLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgbW9yZSB0aGFuIG9uZSBzdWNoIGl0ZW0gb3Igbm9cbiAqIHN1Y2ggaXRlbXMsIG5vdGlmeSBvZiBhbiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gb3IgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiByZXNwZWN0aXZlbHkuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zaW5nbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHRocm93cyB7RW1wdHlFcnJvcn0gRGVsaXZlcnMgYW4gRW1wdHlFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgXG4gKiBjYWxsYmFjayBpZiB0aGUgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgYmVmb3JlIGFueSBgbmV4dGAgbm90aWZpY2F0aW9uIHdhcyBzZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIC0gQSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZXZhbHVhdGUgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHNpbmdsZSBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlc1xuICogdGhlIHByZWRpY2F0ZS5cbiAuXG4gKiBAbWV0aG9kIHNpbmdsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2luZ2xlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU2luZ2xlT3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UpKTsgfTtcbn1cbmV4cG9ydHMuc2luZ2xlID0gc2luZ2xlO1xudmFyIFNpbmdsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW5nbGVPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFNpbmdsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2luZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNpbmdsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW5nbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbmdsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNlZW5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2luZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuYXBwbHlTaW5nbGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZWVuVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoJ1NlcXVlbmNlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWVuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5U2luZ2xlVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlKHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVNpbmdsZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbmdsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMuc2VlblZhbHVlID8gdGhpcy5zaW5nbGVWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW5nbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHRoZSBmaXJzdCBgY291bnRgIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHRpbWVzLCBpdGVtcyBlbWl0dGVkIGJ5IHNvdXJjZSBPYnNlcnZhYmxlIHNob3VsZCBiZSBza2lwcGVkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXAoY291bnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFNraXBPcGVyYXRvcihjb3VudCkpOyB9O1xufVxuZXhwb3J0cy5za2lwID0gc2tpcDtcbnZhciBTa2lwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNraXBPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgfVxuICAgIFNraXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBTa2lwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTa2lwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNraXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFNraXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICgrK3RoaXMuY291bnQgPiB0aGlzLnRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoeCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InKTtcbi8qKlxuICogU2tpcCB0aGUgbGFzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NraXBMYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBza2lwTGFzdGAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgYWNjdW11bGF0ZXMgYSBxdWV1ZSB3aXRoIGEgbGVuZ3RoXG4gKiBlbm91Z2ggdG8gc3RvcmUgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzLiBBcyBtb3JlIHZhbHVlcyBhcmUgcmVjZWl2ZWQsXG4gKiB2YWx1ZXMgYXJlIHRha2VuIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBhbmQgcHJvZHVjZWQgb24gdGhlIHJlc3VsdFxuICogc2VxdWVuY2UuIFRoaXMgY2F1c2VzIHZhbHVlcyB0byBiZSBkZWxheWVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNraXAgdGhlIGxhc3QgMiB2YWx1ZXMgb2YgYW4gT2JzZXJ2YWJsZSB3aXRoIG1hbnkgdmFsdWVzPC9jYXB0aW9uPlxuICogdmFyIG1hbnkgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDUpO1xuICogdmFyIHNraXBMYXN0VHdvID0gbWFueS5za2lwTGFzdCgyKTtcbiAqIHNraXBMYXN0VHdvLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gMSAyIDNcbiAqXG4gKiBAc2VlIHtAbGluayBza2lwfVxuICogQHNlZSB7QGxpbmsgc2tpcFVudGlsfVxuICogQHNlZSB7QGxpbmsgc2tpcFdoaWxlfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgc2tpcExhc3QoaSlgLCBpdCB0aHJvd3NcbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIHRoZSBsYXN0IGNvdW50IHZhbHVlc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHNraXBMYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBza2lwTGFzdChjb3VudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU2tpcExhc3RPcGVyYXRvcihjb3VudCkpOyB9O1xufVxuZXhwb3J0cy5za2lwTGFzdCA9IHNraXBMYXN0O1xudmFyIFNraXBMYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0T3BlcmF0b3IoX3NraXBDb3VudCkge1xuICAgICAgICB0aGlzLl9za2lwQ291bnQgPSBfc2tpcENvdW50O1xuICAgICAgICBpZiAodGhpcy5fc2tpcENvdW50IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2tpcExhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3Qgd2FudCB0byBza2lwIGFueSB2YWx1ZXMgdGhlbiBqdXN0IHN1YnNjcmliZVxuICAgICAgICAgICAgLy8gdG8gU3Vic2NyaWJlciB3aXRob3V0IGFueSBmdXJ0aGVyIGxvZ2ljLlxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTa2lwTGFzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5fc2tpcENvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwTGFzdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcExhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2tpcExhc3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNraXBMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgX3NraXBDb3VudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuX3NraXBDb3VudCA9IF9za2lwQ291bnQ7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmluZyA9IG5ldyBBcnJheShfc2tpcENvdW50KTtcbiAgICB9XG4gICAgU2tpcExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2tpcENvdW50ID0gdGhpcy5fc2tpcENvdW50O1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLl9jb3VudCsrO1xuICAgICAgICBpZiAoY291bnQgPCBza2lwQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JpbmdbY291bnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gY291bnQgJSBza2lwQ291bnQ7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHRoaXMuX3Jpbmc7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSByaW5nW2N1cnJlbnRJbmRleF07XG4gICAgICAgICAgICByaW5nW2N1cnJlbnRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwTGFzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgYSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcFVudGlsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBUaGUgc2Vjb25kIE9ic2VydmFibGUgdGhhdCBoYXMgdG8gZW1pdCBhbiBpdGVtIGJlZm9yZSB0aGUgc291cmNlIE9ic2VydmFibGUncyBlbGVtZW50cyBiZWdpbiB0b1xuICogYmUgbWlycm9yZWQgYnkgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0c1xuICogYW4gaXRlbSwgdGhlbiBlbWl0cyB0aGUgcmVtYWluaW5nIGl0ZW1zLlxuICogQG1ldGhvZCBza2lwVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXBVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgU2tpcFVudGlsT3BlcmF0b3Iobm90aWZpZXIpKTsgfTtcbn1cbmV4cG9ydHMuc2tpcFVudGlsID0gc2tpcFVudGlsO1xudmFyIFNraXBVbnRpbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFNraXBVbnRpbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFVudGlsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFVudGlsT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTa2lwVW50aWxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2tpcFVudGlsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTa2lwVW50aWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0lubmVyU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5vdGlmaWVyKSk7XG4gICAgfVxuICAgIFNraXBVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTa2lwVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5uZXJTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTa2lwVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNJbm5lclN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwVW50aWxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXBVbnRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIGxvbmcgYXMgYSBzcGVjaWZpZWQgY29uZGl0aW9uIGhvbGRzXG4gKiB0cnVlLCBidXQgZW1pdHMgYWxsIGZ1cnRoZXIgc291cmNlIGl0ZW1zIGFzIHNvb24gYXMgdGhlIGNvbmRpdGlvbiBiZWNvbWVzIGZhbHNlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2tpcFdoaWxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSAtIEEgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIGl0ZW0gZW1pdHRlZCBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBiZWdpbnMgZW1pdHRpbmcgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2hlbiB0aGVcbiAqIHNwZWNpZmllZCBwcmVkaWNhdGUgYmVjb21lcyBmYWxzZS5cbiAqIEBtZXRob2Qgc2tpcFdoaWxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTa2lwV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpKTsgfTtcbn1cbmV4cG9ydHMuc2tpcFdoaWxlID0gc2tpcFdoaWxlO1xudmFyIFNraXBXaGlsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIFNraXBXaGlsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBXaGlsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFdoaWxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2tpcFdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2tpcHBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5Q2FsbFByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNraXBwaW5nKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5Q2FsbFByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyspO1xuICAgICAgICAgICAgdGhpcy5za2lwcGluZyA9IEJvb2xlYW4ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFdoaWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL2NvbmNhdCcpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgeW91IHNwZWNpZnkgYXMgYXJndW1lbnRzIGJlZm9yZSBpdCBiZWdpbnMgdG8gZW1pdFxuICogaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zdGFydFdpdGgucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHsuLi5UfSB2YWx1ZXMgLSBJdGVtcyB5b3Ugd2FudCB0aGUgbW9kaWZpZWQgT2JzZXJ2YWJsZSB0byBlbWl0IGZpcnN0LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIC0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gKiB0aGUgZW1pc3Npb25zIG9mIHRoZSBgbmV4dGAgbm90aWZpY2F0aW9ucy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgaW4gdGhlIHNwZWNpZmllZCBJdGVyYWJsZSBhbmQgdGhlbiBlbWl0cyB0aGUgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBzdGFydFdpdGhcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2l0aCgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcnJheVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdChuZXcgU2NhbGFyT2JzZXJ2YWJsZV8xLlNjYWxhck9ic2VydmFibGUoYXJyYXlbMF0sIHNjaGVkdWxlciksIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdChuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdChuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlciksIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5zdGFydFdpdGggPSBzdGFydFdpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFydFdpdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgc3dpdGNoTWFwXzEgPSByZXF1aXJlKCcuL3N3aXRjaE1hcCcpO1xudmFyIGlkZW50aXR5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lkZW50aXR5Jyk7XG5mdW5jdGlvbiBzd2l0Y2hBbGwoKSB7XG4gICAgcmV0dXJuIHN3aXRjaE1hcF8xLnN3aXRjaE1hcChpZGVudGl0eV8xLmlkZW50aXR5KTtcbn1cbmV4cG9ydHMuc3dpdGNoQWxsID0gc3dpdGNoQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3dpdGNoTWFwT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG59XG5leHBvcnRzLnN3aXRjaE1hcCA9IHN3aXRjaE1hcDtcbnZhciBTd2l0Y2hNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnJlc3VsdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fdHJ5Tm90aWZ5TmV4dChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIGZsYXR0ZW5lZCBtdWx0aXBsZVxuICogdGltZXMgd2l0aCB7QGxpbmsgc3dpdGNofSBpbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc3dpdGNoTWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZVxuICogYWx3YXlzIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoTWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBmbGF0dGVucyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZXNcbiAqIGVtaXRzIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBpbnN0YW5jZSBvZlxuICogYGlubmVyT2JzZXJ2YWJsZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlubmVyT2JzZXJ2YWJsZSBBbiBPYnNlcnZhYmxlIHRvIHJlcGxhY2UgZWFjaCB2YWx1ZSBmcm9tXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIGdpdmVuXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCAoYW5kIG9wdGlvbmFsbHkgdHJhbnNmb3JtZWQgdGhyb3VnaCBgcmVzdWx0U2VsZWN0b3JgKSBldmVyeVxuICogdGltZSBhIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlc1xuICogZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHN3aXRjaE1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFN3aXRjaE1hcFRvT3BlcmF0b3IoaW5uZXJPYnNlcnZhYmxlLCByZXN1bHRTZWxlY3RvcikpOyB9O1xufVxuZXhwb3J0cy5zd2l0Y2hNYXBUbyA9IHN3aXRjaE1hcFRvO1xudmFyIFN3aXRjaE1hcFRvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFRvT3BlcmF0b3Iob2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBUb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoTWFwVG9TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFRvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hNYXBUb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hNYXBUb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBpbm5lciwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMuaW5uZXIsIHZhbHVlLCB0aGlzLmluZGV4KyspKTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5UmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLnRyeVJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFRvU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXBUby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UsIHRoZW5cbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcyB0aGVuXG4gKiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gQWZ0ZXIgdGhhdCwgaXQgY29tcGxldGVzLCByZWdhcmRsZXNzIGlmIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UYWtlIHRoZSBmaXJzdCA1IHNlY29uZHMgb2YgYW4gaW5maW5pdGUgMS1zZWNvbmQgaW50ZXJ2YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgZml2ZSA9IGludGVydmFsLnRha2UoNSk7XG4gKiBmaXZlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2UoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYG5leHRgIHZhbHVlcyB0byBlbWl0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGBcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBpZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YCB2YWx1ZXMuXG4gKiBAbWV0aG9kIHRha2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2UoY291bnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VPcGVyYXRvcihjb3VudCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMudGFrZSA9IHRha2U7XG52YXIgVGFrZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFRha2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB2YXIgY291bnQgPSArK3RoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCA8PSB0b3RhbCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBsYXN0IGBjb3VudGAgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5SZW1lbWJlcnMgdGhlIGxhdGVzdCBgY291bnRgIHZhbHVlcywgdGhlbiBlbWl0cyB0aG9zZVxuICogb25seSB3aGVuIHRoZSBzb3VyY2UgY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2VMYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlTGFzdGAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYXQgbW9zdCB0aGUgbGFzdCBgY291bnRgIHZhbHVlc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgXG4gKiB2YWx1ZXMgdGhlbiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gVGhpcyBvcGVyYXRvciBtdXN0IHdhaXQgdW50aWwgdGhlXG4gKiBgY29tcGxldGVgIG5vdGlmaWNhdGlvbiBlbWlzc2lvbiBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gZW1pdCB0aGUgYG5leHRgXG4gKiB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBiZWNhdXNlIG90aGVyd2lzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIGtub3dcbiAqIHdoZXRoZXIgb3Igbm90IG1vcmUgdmFsdWVzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgc291cmNlLiBGb3IgdGhpcyByZWFzb24sXG4gKiBhbGwgdmFsdWVzIGFyZSBlbWl0dGVkIHN5bmNocm9ub3VzbHksIGZvbGxvd2VkIGJ5IHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGFrZSB0aGUgbGFzdCAzIHZhbHVlcyBvZiBhbiBPYnNlcnZhYmxlIHdpdGggbWFueSB2YWx1ZXM8L2NhcHRpb24+XG4gKiB2YXIgbWFueSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTAwKTtcbiAqIHZhciBsYXN0VGhyZWUgPSBtYW55LnRha2VMYXN0KDMpO1xuICogbGFzdFRocmVlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgdGFrZUxhc3QoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgdmFsdWVzIHRvIGVtaXQgZnJvbSB0aGUgZW5kIG9mXG4gKiB0aGUgc2VxdWVuY2Ugb2YgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGF0IG1vc3QgdGhlIGxhc3QgY291bnRcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgdGFrZUxhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VMYXN0KGNvdW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRha2VMYXN0T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlTGFzdE9wZXJhdG9yKGNvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy50YWtlTGFzdCA9IHRha2VMYXN0O1xudmFyIFRha2VMYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0T3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VMYXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlTGFzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VMYXN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlTGFzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWtlTGFzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5yaW5nID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgIH1cbiAgICBUYWtlTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByaW5nID0gdGhpcy5yaW5nO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50Kys7XG4gICAgICAgIGlmIChyaW5nLmxlbmd0aCA8IHRvdGFsKSB7XG4gICAgICAgICAgICByaW5nLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gY291bnQgJSB0b3RhbDtcbiAgICAgICAgICAgIHJpbmdbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRha2VMYXN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmNvdW50ID49IHRoaXMudG90YWwgPyB0aGlzLnRvdGFsIDogdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHZhciByaW5nID0gdGhpcy5yaW5nO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IChjb3VudCsrKSAlIHRvdGFsO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmluZ1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VMYXN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VMYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIGEgYG5vdGlmaWVyYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MZXRzIHZhbHVlcyBwYXNzIHVudGlsIGEgc2Vjb25kIE9ic2VydmFibGUsXG4gKiBgbm90aWZpZXJgLCBlbWl0cyBzb21ldGhpbmcuIFRoZW4sIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VVbnRpbGAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEl0IGFsc29cbiAqIG1vbml0b3JzIGEgc2Vjb25kIE9ic2VydmFibGUsIGBub3RpZmllcmAgdGhhdCB5b3UgcHJvdmlkZS4gSWYgdGhlIGBub3RpZmllcmBcbiAqIGVtaXRzIGEgdmFsdWUgb3IgYSBjb21wbGV0ZSBub3RpZmljYXRpb24sIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdG9wc1xuICogbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRpY2sgZXZlcnkgc2Vjb25kIHVudGlsIHRoZSBmaXJzdCBjbGljayBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwudGFrZVVudGlsKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBub3RpZmllciBUaGUgT2JzZXJ2YWJsZSB3aG9zZSBmaXJzdCBlbWl0dGVkIHZhbHVlIHdpbGxcbiAqIGNhdXNlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvZiBgdGFrZVVudGlsYCB0byBzdG9wIGVtaXR0aW5nIHZhbHVlcyBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdW50aWwgc3VjaCB0aW1lIGFzIGBub3RpZmllcmAgZW1pdHMgaXRzIGZpcnN0IHZhbHVlLlxuICogQG1ldGhvZCB0YWtlVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpKTsgfTtcbn1cbmV4cG9ydHMudGFrZVVudGlsID0gdGFrZVVudGlsO1xudmFyIFRha2VVbnRpbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFRha2VVbnRpbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVVudGlsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlVW50aWxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVVudGlsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlVW50aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEVtaXRzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBzbyBsb25nIGFzIGVhY2ggdmFsdWUgc2F0aXNmaWVzXG4gKiB0aGUgZ2l2ZW4gYHByZWRpY2F0ZWAsIGFuZCB0aGVuIGNvbXBsZXRlcyBhcyBzb29uIGFzIHRoaXMgYHByZWRpY2F0ZWAgaXMgbm90XG4gKiBzYXRpc2ZpZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb25seSB3aGlsZSB0aGV5IHBhc3MgdGhlXG4gKiBjb25kaXRpb24gZ2l2ZW4uIFdoZW4gdGhlIGZpcnN0IHZhbHVlIGRvZXMgbm90IHNhdGlzZnksIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlV2hpbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VXaGlsZWAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEVhY2ggdmFsdWVcbiAqIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBpcyBnaXZlbiB0byB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhXG4gKiBib29sZWFuLCByZXByZXNlbnRpbmcgYSBjb25kaXRpb24gdG8gYmUgc2F0aXNmaWVkIGJ5IHRoZSBzb3VyY2UgdmFsdWVzLiBUaGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHRoZSBzb3VyY2UgdmFsdWVzIHVudGlsIHN1Y2ggdGltZSBhcyB0aGUgYHByZWRpY2F0ZWBcbiAqIHJldHVybnMgZmFsc2UsIGF0IHdoaWNoIHBvaW50IGB0YWtlV2hpbGVgIHN0b3BzIG1pcnJvcmluZyB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2sgZXZlbnRzIG9ubHkgd2hpbGUgdGhlIGNsaWVudFggcHJvcGVydHkgaXMgZ3JlYXRlciB0aGFuIDIwMDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRha2VXaGlsZShldiA9PiBldi5jbGllbnRYID4gMjAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGEgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHJldHVybnMgYSBib29sZWFuLlxuICogQWxzbyB0YWtlcyB0aGUgKHplcm8tYmFzZWQpIGluZGV4IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgc28gbG9uZyBhcyBlYWNoIHZhbHVlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGRlZmluZWQgYnkgdGhlXG4gKiBgcHJlZGljYXRlYCwgdGhlbiBjb21wbGV0ZXMuXG4gKiBAbWV0aG9kIHRha2VXaGlsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgVGFrZVdoaWxlT3BlcmF0b3IocHJlZGljYXRlKSk7IH07XG59XG5leHBvcnRzLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbnZhciBUYWtlV2hpbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlT3BlcmF0b3IocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIH1cbiAgICBUYWtlV2hpbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VXaGlsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlV2hpbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VXaGlsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWtlV2hpbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VXaGlsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgVGFrZVdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0T3JDb21wbGV0ZSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9O1xuICAgIFRha2VXaGlsZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHRPckNvbXBsZXRlID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVkaWNhdGVSZXN1bHQpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKEJvb2xlYW4ocHJlZGljYXRlUmVzdWx0KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVdoaWxlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VXaGlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgZW1pc3Npb24gb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgcmV0dXJuXG4gKiBhbiBPYnNlcnZhYmxlIHRoYXQgaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkludGVyY2VwdHMgZWFjaCBlbWlzc2lvbiBvbiB0aGUgc291cmNlIGFuZCBydW5zIGFcbiAqIGZ1bmN0aW9uLCBidXQgcmV0dXJucyBhbiBvdXRwdXQgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UgYXMgbG9uZyBhcyBlcnJvcnMgZG9uJ3Qgb2NjdXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhIG1pcnJvcmVkIE9ic2VydmFibGUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgbW9kaWZpZWQgc28gdGhhdFxuICogdGhlIHByb3ZpZGVkIE9ic2VydmVyIGlzIGNhbGxlZCB0byBwZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IHZhbHVlLFxuICogZXJyb3IsIGFuZCBjb21wbGV0aW9uIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZS4gQW55IGVycm9ycyB0aGF0IGFyZSB0aHJvd24gaW5cbiAqIHRoZSBhZm9yZW1lbnRpb25lZCBPYnNlcnZlciBvciBoYW5kbGVycyBhcmUgc2FmZWx5IHNlbnQgZG93biB0aGUgZXJyb3IgcGF0aFxuICogb2YgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgeW91ciBPYnNlcnZhYmxlcyBmb3IgdGhlIGNvcnJlY3QgdmFsdWVzXG4gKiBvciBwZXJmb3JtaW5nIG90aGVyIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBOb3RlOiB0aGlzIGlzIGRpZmZlcmVudCB0byBhIGBzdWJzY3JpYmVgIG9uIHRoZSBPYnNlcnZhYmxlLiBJZiB0aGUgT2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgYGRvYCBpcyBub3Qgc3Vic2NyaWJlZCwgdGhlIHNpZGUgZWZmZWN0cyBzcGVjaWZpZWQgYnkgdGhlXG4gKiBPYnNlcnZlciB3aWxsIG5ldmVyIGhhcHBlbi4gYGRvYCB0aGVyZWZvcmUgc2ltcGx5IHNwaWVzIG9uIGV4aXN0aW5nXG4gKiBleGVjdXRpb24sIGl0IGRvZXMgbm90IHRyaWdnZXIgYW4gZXhlY3V0aW9uIHRvIGhhcHBlbiBsaWtlIGBzdWJzY3JpYmVgIGRvZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2ssIHdoaWxlIGFsc28gbG9nZ2luZyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrc1xuICogICAuZG8oZXYgPT4gY29uc29sZS5sb2coZXYpKVxuICogICAubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKiBAc2VlIHtAbGluayBzdWJzY3JpYmV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbn0gW25leHRPck9ic2VydmVyXSBBIG5vcm1hbCBPYnNlcnZlciBvYmplY3Qgb3IgYVxuICogY2FsbGJhY2sgZm9yIGBuZXh0YC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgZm9yIGVycm9ycyBpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBsZXRlXSBDYWxsYmFjayBmb3IgdGhlIGNvbXBsZXRpb24gb2YgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UsIGJ1dCBydW5zIHRoZVxuICogc3BlY2lmaWVkIE9ic2VydmVyIG9yIGNhbGxiYWNrKHMpIGZvciBlYWNoIGl0ZW0uXG4gKiBAbmFtZSB0YXBcbiAqL1xuZnVuY3Rpb24gdGFwKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGFwT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpKTtcbiAgICB9O1xufVxuZXhwb3J0cy50YXAgPSB0YXA7XG52YXIgRG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMubmV4dE9yT2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIERvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5uZXh0T3JPYnNlcnZlciwgdGhpcy5lcnJvciwgdGhpcy5jb21wbGV0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzYWZlU3Vic2NyaWJlcik7XG4gICAgICAgIHRoaXMuc2FmZVN1YnNjcmliZXIgPSBzYWZlU3Vic2NyaWJlcjtcbiAgICB9XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbmV4cG9ydHMuZGVmYXVsdFRocm90dGxlQ29uZmlnID0ge1xuICAgIGxlYWRpbmc6IHRydWUsXG4gICAgdHJhaWxpbmc6IGZhbHNlXG59O1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYSBkdXJhdGlvbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXNcbiAqIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgdGhyb3R0bGVUaW1lfSwgYnV0IHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aHJvdHRsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVgIGVtaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB3aGVuIGl0cyBpbnRlcm5hbCB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZVxuICogdmFsdWUgYXJyaXZlcywgaXQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkIGJ5IGNhbGxpbmcgdGhlIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiB3aXRoIHRoZSBzb3VyY2UgdmFsdWUsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSBlbWl0cyBhXG4gKiB2YWx1ZSBvciBjb21wbGV0ZXMsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGVcbiAqIG5leHQgc291cmNlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGUoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFN1YnNjcmliYWJsZU9yUHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gZm9yIGVhY2ggc291cmNlIHZhbHVlLCByZXR1cm5lZCBhcyBhbiBPYnNlcnZhYmxlIG9yIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgYSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBkZWZpbmUgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIGJlaGF2aW9yLiBEZWZhdWx0c1xuICogdG8gYHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IGZhbHNlIH1gLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHRoZSB0aHJvdHRsZSBvcGVyYXRpb24gdG9cbiAqIGxpbWl0IHRoZSByYXRlIG9mIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAbWV0aG9kIHRocm90dGxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShkdXJhdGlvblNlbGVjdG9yLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gZXhwb3J0cy5kZWZhdWx0VGhyb3R0bGVDb25maWc7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvciwgY29uZmlnLmxlYWRpbmcsIGNvbmZpZy50cmFpbGluZykpOyB9O1xufVxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xudmFyIFRocm90dGxlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlT3BlcmF0b3IoZHVyYXRpb25TZWxlY3RvciwgbGVhZGluZywgdHJhaWxpbmcpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgICAgdGhpcy50cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgIH1cbiAgICBUaHJvdHRsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGhyb3R0bGVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb25TZWxlY3RvciwgdGhpcy5sZWFkaW5nLCB0aGlzLnRyYWlsaW5nKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2NcbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGhyb3R0bGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3RvciwgX2xlYWRpbmcsIF90cmFpbGluZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5fbGVhZGluZyA9IF9sZWFkaW5nO1xuICAgICAgICB0aGlzLl90cmFpbGluZyA9IF90cmFpbGluZztcbiAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYWlsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy50cnlEdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkdXJhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFpbGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNUcmFpbGluZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlEdXJhdGlvblNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRocm90dGxlZCA9IF9hLnRocm90dGxlZCwgX3RyYWlsaW5nVmFsdWUgPSBfYS5fdHJhaWxpbmdWYWx1ZSwgX2hhc1RyYWlsaW5nVmFsdWUgPSBfYS5faGFzVHJhaWxpbmdWYWx1ZSwgX3RyYWlsaW5nID0gX2EuX3RyYWlsaW5nO1xuICAgICAgICB0aGlzLl90cmFpbGluZ1ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUuX3NlbmRUcmFpbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbiwgdGhyb3R0bGVkID0gX2EudGhyb3R0bGVkLCBfdHJhaWxpbmcgPSBfYS5fdHJhaWxpbmcsIF90cmFpbGluZ1ZhbHVlID0gX2EuX3RyYWlsaW5nVmFsdWUsIF9oYXNUcmFpbGluZ1ZhbHVlID0gX2EuX2hhc1RyYWlsaW5nVmFsdWU7XG4gICAgICAgIGlmICh0aHJvdHRsZWQgJiYgX3RyYWlsaW5nICYmIF9oYXNUcmFpbGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KF90cmFpbGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fc2VuZFRyYWlsaW5nKCk7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZW5kVHJhaWxpbmcoKTtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIHRocm90dGxlXzEgPSByZXF1aXJlKCcuL3Rocm90dGxlJyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gaWdub3JlcyBzdWJzZXF1ZW50IHNvdXJjZVxuICogdmFsdWVzIGZvciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcywgdGhlbiByZXBlYXRzIHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGV0cyBhIHZhbHVlIHBhc3MsIHRoZW4gaWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciB0aGVcbiAqIG5leHQgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGhyb3R0bGVUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0aHJvdHRsZVRpbWVgIGVtaXRzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB3aGVuIGl0cyBpbnRlcm5hbCB0aW1lciBpcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZVxuICogdmFsdWUgYXJyaXZlcywgaXQgaXMgZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkLiBBZnRlciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkXG4gKiBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgaGFzIHBhc3NlZCwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLFxuICogYW5kIHRoaXMgcHJvY2VzcyByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuIE9wdGlvbmFsbHkgdGFrZXMgYVxuICoge0BsaW5rIElTY2hlZHVsZXJ9IGZvciBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy50aHJvdHRsZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBUaW1lIHRvIHdhaXQgYmVmb3JlIGVtaXR0aW5nIGFub3RoZXIgdmFsdWUgYWZ0ZXJcbiAqIGVtaXR0aW5nIHRoZSBsYXN0IHZhbHVlLCBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHMgb3IgdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkXG4gKiBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRocm90dGxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIHRocm90dGxlIG9wZXJhdGlvbiB0b1xuICogbGltaXQgdGhlIHJhdGUgb2YgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBtZXRob2QgdGhyb3R0bGVUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZVRpbWUoZHVyYXRpb24sIHNjaGVkdWxlciwgY29uZmlnKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gdGhyb3R0bGVfMS5kZWZhdWx0VGhyb3R0bGVDb25maWc7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFRocm90dGxlVGltZU9wZXJhdG9yKGR1cmF0aW9uLCBzY2hlZHVsZXIsIGNvbmZpZy5sZWFkaW5nLCBjb25maWcudHJhaWxpbmcpKTsgfTtcbn1cbmV4cG9ydHMudGhyb3R0bGVUaW1lID0gdGhyb3R0bGVUaW1lO1xudmFyIFRocm90dGxlVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZVRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyLCBsZWFkaW5nLCB0cmFpbGluZykge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgICB0aGlzLnRyYWlsaW5nID0gdHJhaWxpbmc7XG4gICAgfVxuICAgIFRocm90dGxlVGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGhyb3R0bGVUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uLCB0aGlzLnNjaGVkdWxlciwgdGhpcy5sZWFkaW5nLCB0aGlzLnRyYWlsaW5nKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiwgc2NoZWR1bGVyLCBsZWFkaW5nLCB0cmFpbGluZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICAgIHRoaXMudHJhaWxpbmcgPSB0cmFpbGluZztcbiAgICAgICAgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90cmFpbGluZ1ZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFpbGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWlsaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUcmFpbGluZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1cmF0aW9uLCB7IHN1YnNjcmliZXI6IHRoaXMgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVhZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyVGhyb3R0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSB0aGlzLnRocm90dGxlZDtcbiAgICAgICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhaWxpbmcgJiYgdGhpcy5faGFzVHJhaWxpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLl90cmFpbGluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFpbGluZ1ZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUcmFpbGluZ1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KGFyZykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgc3Vic2NyaWJlci5jbGVhclRocm90dGxlKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuZnVuY3Rpb24gdGltZUludGVydmFsKHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUaW1lSW50ZXJ2YWxPcGVyYXRvcihzY2hlZHVsZXIpKTsgfTtcbn1cbmV4cG9ydHMudGltZUludGVydmFsID0gdGltZUludGVydmFsO1xudmFyIFRpbWVJbnRlcnZhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZUludGVydmFsKHZhbHVlLCBpbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVJbnRlcnZhbDtcbn0oKSk7XG5leHBvcnRzLlRpbWVJbnRlcnZhbCA9IFRpbWVJbnRlcnZhbDtcbjtcbnZhciBUaW1lSW50ZXJ2YWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZUludGVydmFsT3BlcmF0b3Ioc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaW1lSW50ZXJ2YWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lSW50ZXJ2YWxTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVJbnRlcnZhbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGltZUludGVydmFsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVJbnRlcnZhbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUludGVydmFsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gc2NoZWR1bGVyLm5vdygpO1xuICAgIH1cbiAgICBUaW1lSW50ZXJ2YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5zY2hlZHVsZXIubm93KCk7XG4gICAgICAgIHZhciBzcGFuID0gbm93IC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IG5vdztcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KG5ldyBUaW1lSW50ZXJ2YWwodmFsdWUsIHNwYW4pKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lSW50ZXJ2YWxTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZUludGVydmFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL1RpbWVvdXRFcnJvcicpO1xuLyoqXG4gKlxuICogRXJyb3JzIGlmIE9ic2VydmFibGUgZG9lcyBub3QgZW1pdCBhIHZhbHVlIGluIGdpdmVuIHRpbWUgc3Bhbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGltZW91dHMgb24gT2JzZXJ2YWJsZSB0aGF0IGRvZXNuJ3QgZW1pdCB2YWx1ZXMgZmFzdCBlbm91Z2guPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZW91dC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGltZW91dGAgb3BlcmF0b3IgYWNjZXB0cyBhcyBhbiBhcmd1bWVudCBlaXRoZXIgYSBudW1iZXIgb3IgYSBEYXRlLlxuICpcbiAqIElmIG51bWJlciB3YXMgcHJvdmlkZWQsIGl0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGJlaGF2ZXMgbGlrZSBhIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgdW5sZXNzIHRoZXJlIGlzIGEgcGVyaW9kIG9mIHRpbWUgd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUgZW1pdHRlZC5cbiAqIFNvIGlmIHlvdSBwcm92aWRlIGAxMDBgIGFzIGFyZ3VtZW50IGFuZCBmaXJzdCB2YWx1ZSBjb21lcyBhZnRlciA1MG1zIGZyb21cbiAqIHRoZSBtb21lbnQgb2Ygc3Vic2NyaXB0aW9uLCB0aGlzIHZhbHVlIHdpbGwgYmUgc2ltcGx5IHJlLWVtaXR0ZWQgYnkgdGhlIHJlc3VsdGluZ1xuICogT2JzZXJ2YWJsZS4gSWYgaG93ZXZlciBhZnRlciB0aGF0IDEwMG1zIHBhc3NlcyB3aXRob3V0IGEgc2Vjb25kIHZhbHVlIGJlaW5nIGVtaXR0ZWQsXG4gKiBzdHJlYW0gd2lsbCBlbmQgd2l0aCBhbiBlcnJvciBhbmQgc291cmNlIE9ic2VydmFibGUgd2lsbCBiZSB1bnN1YnNjcmliZWQuXG4gKiBUaGVzZSBjaGVja3MgYXJlIHBlcmZvcm1lZCB0aHJvdWdob3V0IHdob2xlIGxpZmVjeWNsZSBvZiBPYnNlcnZhYmxlIC0gZnJvbSB0aGUgbW9tZW50XG4gKiBpdCB3YXMgc3Vic2NyaWJlZCB0bywgdW50aWwgaXQgY29tcGxldGVzIG9yIGVycm9ycyBpdHNlbGYuIFRodXMgZXZlcnkgdmFsdWUgbXVzdCBiZVxuICogZW1pdHRlZCB3aXRoaW4gc3BlY2lmaWVkIHBlcmlvZCBzaW5jZSBwcmV2aW91cyB2YWx1ZS5cbiAqXG4gKiBJZiBwcm92aWRlZCBhcmd1bWVudCB3YXMgRGF0ZSwgcmV0dXJuZWQgT2JzZXJ2YWJsZSBiZWhhdmVzIGRpZmZlcmVudGx5LiBJdCB0aHJvd3NcbiAqIGlmIE9ic2VydmFibGUgZGlkIG5vdCBjb21wbGV0ZSBiZWZvcmUgcHJvdmlkZWQgRGF0ZS4gVGhpcyBtZWFucyB0aGF0IHBlcmlvZHMgYmV0d2VlblxuICogZW1pc3Npb24gb2YgcGFydGljdWxhciB2YWx1ZXMgZG8gbm90IG1hdHRlciBpbiB0aGlzIGNhc2UuIElmIE9ic2VydmFibGUgZGlkIG5vdCBjb21wbGV0ZVxuICogYmVmb3JlIHByb3ZpZGVkIERhdGUsIHNvdXJjZSBPYnNlcnZhYmxlIHdpbGwgYmUgdW5zdWJzY3JpYmVkLiBPdGhlciB0aGFuIHRoYXQsIHJlc3VsdGluZ1xuICogc3RyZWFtIGJlaGF2ZXMganVzdCBhcyBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBgdGltZW91dGAgYWNjZXB0cyBhbHNvIGEgU2NoZWR1bGVyIGFzIGEgc2Vjb25kIHBhcmFtZXRlci4gSXQgaXMgdXNlZCB0byBzY2hlZHVsZSBtb21lbnQgKG9yIG1vbWVudHMpXG4gKiB3aGVuIHJldHVybmVkIE9ic2VydmFibGUgd2lsbCBjaGVjayBpZiBzb3VyY2Ugc3RyZWFtIGVtaXR0ZWQgdmFsdWUgb3IgY29tcGxldGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNoZWNrIGlmIHRpY2tzIGFyZSBlbWl0dGVkIHdpdGhpbiBjZXJ0YWluIHRpbWVzcGFuPC9jYXB0aW9uPlxuICogY29uc3Qgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKlxuICogc2Vjb25kcy50aW1lb3V0KDExMDApIC8vIExldCdzIHVzZSBiaWdnZXIgdGltZXNwYW4gdG8gYmUgc2FmZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBgaW50ZXJ2YWxgIG1pZ2h0IGZpcmUgYSBiaXQgbGF0ZXIgdGhlbiBzY2hlZHVsZWQuXG4gKiAuc3Vic2NyaWJlKFxuICogICAgIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSwgLy8gV2lsbCBlbWl0IG51bWJlcnMganVzdCBhcyByZWd1bGFyIGBpbnRlcnZhbGAgd291bGQuXG4gKiAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycikgLy8gV2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gKiApO1xuICpcbiAqIHNlY29uZHMudGltZW91dCg5MDApLnN1YnNjcmliZShcbiAqICAgICB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksIC8vIFdpbGwgbmV2ZXIgYmUgY2FsbGVkLlxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpIC8vIFdpbGwgZW1pdCBlcnJvciBiZWZvcmUgZXZlbiBmaXJzdCB2YWx1ZSBpcyBlbWl0dGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGRpZCBub3QgYXJyaXZlIHdpdGhpbiA5MDBtcyBwZXJpb2QuXG4gKiApO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBEYXRlIHRvIGNoZWNrIGlmIE9ic2VydmFibGUgY29tcGxldGVkPC9jYXB0aW9uPlxuICogY29uc3Qgc2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKlxuICogc2Vjb25kcy50aW1lb3V0KG5ldyBEYXRlKFwiRGVjZW1iZXIgMTcsIDIwMjAgMDM6MjQ6MDBcIikpXG4gKiAuc3Vic2NyaWJlKFxuICogICAgIHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSwgLy8gV2lsbCBlbWl0IHZhbHVlcyBhcyByZWd1bGFyIGBpbnRlcnZhbGAgd291bGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIERlY2VtYmVyIDE3LCAyMDIwIGF0IDAzOjI0OjAwLlxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpIC8vIE9uIERlY2VtYmVyIDE3LCAyMDIwIGF0IDAzOjI0OjAwIGl0IHdpbGwgZW1pdCBhbiBlcnJvcixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBPYnNlcnZhYmxlIGRpZCBub3QgY29tcGxldGUgYnkgdGhlbi5cbiAqICk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGltZW91dFdpdGh9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZHVlIE51bWJlciBzcGVjaWZ5aW5nIHBlcmlvZCB3aXRoaW4gd2hpY2ggT2JzZXJ2YWJsZSBtdXN0IGVtaXQgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgRGF0ZSBzcGVjaWZ5aW5nIGJlZm9yZSB3aGVuIE9ic2VydmFibGUgc2hvdWxkIGNvbXBsZXRlXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gU2NoZWR1bGVyIGNvbnRyb2xsaW5nIHdoZW4gdGltZW91dCBjaGVja3Mgb2NjdXIuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyBiZWhhdmlvdXIgb2Ygc291cmNlLCB1bmxlc3MgdGltZW91dCBjaGVja3MgZmFpbC5cbiAqIEBtZXRob2QgdGltZW91dFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdWUsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgdmFyIGFic29sdXRlVGltZW91dCA9IGlzRGF0ZV8xLmlzRGF0ZShkdWUpO1xuICAgIHZhciB3YWl0Rm9yID0gYWJzb2x1dGVUaW1lb3V0ID8gKCtkdWUgLSBzY2hlZHVsZXIubm93KCkpIDogTWF0aC5hYnMoZHVlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IFRpbWVvdXRPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHNjaGVkdWxlciwgbmV3IFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcigpKSk7IH07XG59XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xudmFyIFRpbWVvdXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZW91dE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5lcnJvckluc3RhbmNlID0gZXJyb3JJbnN0YW5jZTtcbiAgICB9XG4gICAgVGltZW91dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZW91dFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy5zY2hlZHVsZXIsIHRoaXMuZXJyb3JJbnN0YW5jZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVvdXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZVRpbWVvdXQgPSBhYnNvbHV0ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmVycm9ySW5zdGFuY2UgPSBlcnJvckluc3RhbmNlO1xuICAgICAgICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgfVxuICAgIFRpbWVvdXRTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc3Vic2NyaWJlci5lcnJvckluc3RhbmNlKTtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgLy8gUmVjeWNsZSB0aGUgYWN0aW9uIGlmIHdlJ3ZlIGFscmVhZHkgc2NoZWR1bGVkIG9uZS4gQWxsIHRoZSBwcm9kdWN0aW9uXG4gICAgICAgICAgICAvLyBTY2hlZHVsZXIgQWN0aW9ucyBtdXRhdGUgdGhlaXIgc3RhdGUvZGVsYXkgdGltZSBhbmQgcmV0dXJuIHRoZW1lc2VsdmVzLlxuICAgICAgICAgICAgLy8gVmlydHVhbEFjdGlvbnMgYXJlIGltbXV0YWJsZSwgc28gdGhleSBjcmVhdGUgYW5kIHJldHVybiBhIGNsb25lLiBJbiB0aGlzXG4gICAgICAgICAgICAvLyBjYXNlLCB3ZSBuZWVkIHRvIHNldCB0aGUgYWN0aW9uIHJlZmVyZW5jZSB0byB0aGUgbW9zdCByZWNlbnQgVmlydHVhbEFjdGlvbixcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0J3MgdGhlIG9uZSB3ZSBjbG9uZSBmcm9tIG5leHQgdGltZS5cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uLnNjaGVkdWxlKHRoaXMsIHRoaXMud2FpdEZvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLmFjdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVvdXRTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckluc3RhbmNlID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lb3V0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNEYXRlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRGF0ZScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqXG4gKiBFcnJvcnMgaWYgT2JzZXJ2YWJsZSBkb2VzIG5vdCBlbWl0IGEgdmFsdWUgaW4gZ2l2ZW4gdGltZSBzcGFuLCBpbiBjYXNlIG9mIHdoaWNoXG4gKiBzdWJzY3JpYmVzIHRvIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBhIHZlcnNpb24gb2YgYHRpbWVvdXRgIG9wZXJhdG9yIHRoYXQgbGV0J3MgeW91IHNwZWNpZnkgZmFsbGJhY2sgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aW1lb3V0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGltZW91dFdpdGhgIGlzIGEgdmFyaWF0aW9uIG9mIGB0aW1lb3V0YCBvcGVyYXRvci4gSXQgYmVoYXZlcyBleGFjdGx5IHRoZSBzYW1lLFxuICogc3RpbGwgYWNjZXB0aW5nIGFzIGEgZmlyc3QgYXJndW1lbnQgZWl0aGVyIGEgbnVtYmVyIG9yIGEgRGF0ZSwgd2hpY2ggY29udHJvbCAtIHJlc3BlY3RpdmVseSAtXG4gKiB3aGVuIHZhbHVlcyBvZiBzb3VyY2UgT2JzZXJ2YWJsZSBzaG91bGQgYmUgZW1pdHRlZCBvciB3aGVuIGl0IHNob3VsZCBjb21wbGV0ZS5cbiAqXG4gKiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgaXQgYWNjZXB0cyBhIHNlY29uZCwgcmVxdWlyZWQgcGFyYW1ldGVyLiBUaGlzIHBhcmFtZXRlclxuICogc2hvdWxkIGJlIGFuIE9ic2VydmFibGUgd2hpY2ggd2lsbCBiZSBzdWJzY3JpYmVkIHdoZW4gc291cmNlIE9ic2VydmFibGUgZmFpbHMgYW55IHRpbWVvdXQgY2hlY2suXG4gKiBTbyB3aGVuZXZlciByZWd1bGFyIGB0aW1lb3V0YCB3b3VsZCBlbWl0IGFuIGVycm9yLCBgdGltZW91dFdpdGhgIHdpbGwgaW5zdGVhZCBzdGFydCByZS1lbWl0dGluZ1xuICogdmFsdWVzIGZyb20gc2Vjb25kIE9ic2VydmFibGUuIE5vdGUgdGhhdCB0aGlzIGZhbGxiYWNrIE9ic2VydmFibGUgaXMgbm90IGNoZWNrZWQgZm9yIHRpbWVvdXRzXG4gKiBpdHNlbGYsIHNvIGl0IGNhbiBlbWl0IHZhbHVlcyBhbmQgY29tcGxldGUgYXQgYXJiaXRyYXJ5IHBvaW50cyBpbiB0aW1lLiBGcm9tIHRoZSBtb21lbnQgb2YgYSBzZWNvbmRcbiAqIHN1YnNjcmlwdGlvbiwgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGB0aW1lb3V0V2l0aGAgc2ltcGx5IG1pcnJvcnMgZmFsbGJhY2sgc3RyZWFtLiBXaGVuIHRoYXRcbiAqIHN0cmVhbSBjb21wbGV0ZXMsIGl0IGNvbXBsZXRlcyBhcyB3ZWxsLlxuICpcbiAqIFNjaGVkdWxlciwgd2hpY2ggaW4gY2FzZSBvZiBgdGltZW91dGAgaXMgcHJvdmlkZWQgYXMgYXMgc2Vjb25kIGFyZ3VtZW50LCBjYW4gYmUgc3RpbGwgcHJvdmlkZWRcbiAqIGhlcmUgLSBhcyBhIHRoaXJkLCBvcHRpb25hbCBwYXJhbWV0ZXIuIEl0IHN0aWxsIGlzIHVzZWQgdG8gc2NoZWR1bGUgdGltZW91dCBjaGVja3MgYW5kIC1cbiAqIGFzIGEgY29uc2VxdWVuY2UgLSB3aGVuIHNlY29uZCBPYnNlcnZhYmxlIHdpbGwgYmUgc3Vic2NyaWJlZCwgc2luY2Ugc3Vic2NyaXB0aW9uIGhhcHBlbnNcbiAqIGltbWVkaWF0ZWx5IGFmdGVyIGZhaWxpbmcgY2hlY2suXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QWRkIGZhbGxiYWNrIG9ic2VydmFibGU8L2NhcHRpb24+XG4gKiBjb25zdCBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIGNvbnN0IG1pbnV0ZXMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDYwICogMTAwMCk7XG4gKlxuICogc2Vjb25kcy50aW1lb3V0V2l0aCg5MDAsIG1pbnV0ZXMpXG4gKiAgICAgLnN1YnNjcmliZShcbiAqICAgICAgICAgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLCAvLyBBZnRlciA5MDBtcywgd2lsbCBzdGFydCBlbWl0dGluZyBgbWludXRlc2AsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgZmlyc3QgdmFsdWUgb2YgYHNlY29uZHNgIHdpbGwgbm90IGFycml2ZSBmYXN0IGVub3VnaC5cbiAqICAgICAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycikgLy8gV291bGQgYmUgY2FsbGVkIGFmdGVyIDkwMG1zIGluIGNhc2Ugb2YgYHRpbWVvdXRgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgaGVyZSB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqICAgICApO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGR1ZSBOdW1iZXIgc3BlY2lmeWluZyBwZXJpb2Qgd2l0aGluIHdoaWNoIE9ic2VydmFibGUgbXVzdCBlbWl0IHZhbHVlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIERhdGUgc3BlY2lmeWluZyBiZWZvcmUgd2hlbiBPYnNlcnZhYmxlIHNob3VsZCBjb21wbGV0ZVxuICogQHBhcmFtIHtPYnNlcnZhYmxlPFQ+fSB3aXRoT2JzZXJ2YWJsZSBPYnNlcnZhYmxlIHdoaWNoIHdpbGwgYmUgc3Vic2NyaWJlZCBpZiBzb3VyY2UgZmFpbHMgdGltZW91dCBjaGVjay5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBTY2hlZHVsZXIgY29udHJvbGxpbmcgd2hlbiB0aW1lb3V0IGNoZWNrcyBvY2N1ci5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIGJlaGF2aW91ciBvZiBzb3VyY2Ugb3IsIHdoZW4gdGltZW91dCBjaGVjayBmYWlscywgb2YgYW4gT2JzZXJ2YWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZCBhcyBhIHNlY29uZCBwYXJhbWV0ZXIuXG4gKiBAbWV0aG9kIHRpbWVvdXRXaXRoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lb3V0V2l0aChkdWUsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBhYnNvbHV0ZVRpbWVvdXQgPSBpc0RhdGVfMS5pc0RhdGUoZHVlKTtcbiAgICAgICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyAoK2R1ZSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkdWUpO1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMudGltZW91dFdpdGggPSB0aW1lb3V0V2l0aDtcbnZhciBUaW1lb3V0V2l0aE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZW91dFdpdGhPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVvdXRXaXRoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLndpdGhPYnNlcnZhYmxlLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRXaXRoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaW1lb3V0V2l0aFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lb3V0V2l0aFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFdpdGhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhYnNvbHV0ZVRpbWVvdXQsIHdhaXRGb3IsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHdpdGhPYnNlcnZhYmxlID0gc3Vic2NyaWJlci53aXRoT2JzZXJ2YWJsZTtcbiAgICAgICAgc3Vic2NyaWJlci5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQoc3Vic2NyaWJlciwgd2l0aE9ic2VydmFibGUpKTtcbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFJlY3ljbGUgdGhlIGFjdGlvbiBpZiB3ZSd2ZSBhbHJlYWR5IHNjaGVkdWxlZCBvbmUuIEFsbCB0aGUgcHJvZHVjdGlvblxuICAgICAgICAgICAgLy8gU2NoZWR1bGVyIEFjdGlvbnMgbXV0YXRlIHRoZWlyIHN0YXRlL2RlbGF5IHRpbWUgYW5kIHJldHVybiB0aGVtZXNlbHZlcy5cbiAgICAgICAgICAgIC8vIFZpcnR1YWxBY3Rpb25zIGFyZSBpbW11dGFibGUsIHNvIHRoZXkgY3JlYXRlIGFuZCByZXR1cm4gYSBjbG9uZS4gSW4gdGhpc1xuICAgICAgICAgICAgLy8gY2FzZSwgd2UgbmVlZCB0byBzZXQgdGhlIGFjdGlvbiByZWZlcmVuY2UgdG8gdGhlIG1vc3QgcmVjZW50IFZpcnR1YWxBY3Rpb24sXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCdzIHRoZSBvbmUgd2UgY2xvbmUgZnJvbSBuZXh0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbi5zY2hlZHVsZSh0aGlzLCB0aGlzLndhaXRGb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5hY3Rpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRXaXRoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuL21hcCcpO1xuLyoqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRpbWVzdGFtcDxhbnk+PnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVzdGFtcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGltZXN0YW1wKHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIG1hcF8xLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBUaW1lc3RhbXAodmFsdWUsIHNjaGVkdWxlci5ub3coKSk7IH0pO1xuICAgIC8vIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBzb3VyY2UubGlmdChuZXcgVGltZXN0YW1wT3BlcmF0b3Ioc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbnZhciBUaW1lc3RhbXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVzdGFtcCh2YWx1ZSwgdGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgfVxuICAgIHJldHVybiBUaW1lc3RhbXA7XG59KCkpO1xuZXhwb3J0cy5UaW1lc3RhbXAgPSBUaW1lc3RhbXA7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3RhbXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVkdWNlXzEgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuZnVuY3Rpb24gdG9BcnJheVJlZHVjZXIoYXJyLCBpdGVtLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW2l0ZW1dO1xuICAgIH1cbiAgICBhcnIucHVzaChpdGVtKTtcbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICByZXR1cm4gcmVkdWNlXzEucmVkdWNlKHRvQXJyYXlSZWR1Y2VyLCBbXSk7XG59XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9BcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHdoZW5ldmVyXG4gKiBgd2luZG93Qm91bmRhcmllc2AgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyfSwgYnV0IGVtaXRzIGEgbmVzdGVkIE9ic2VydmFibGVcbiAqIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgY29ubmVjdGVkLCBub24tb3ZlcmxhcHBpbmdcbiAqIHdpbmRvd3MuIEl0IGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgb3BlbnMgYSBuZXcgb25lIHdoZW5ldmVyIHRoZVxuICogT2JzZXJ2YWJsZSBgd2luZG93Qm91bmRhcmllc2AgZW1pdHMgYW4gaXRlbS4gQmVjYXVzZSBlYWNoIHdpbmRvdyBpcyBhblxuICogT2JzZXJ2YWJsZSwgdGhlIG91dHB1dCBpcyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkluIGV2ZXJ5IHdpbmRvdyBvZiAxIHNlY29uZCBlYWNoLCBlbWl0IGF0IG1vc3QgMiBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93KGludGVydmFsKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8YW55Pn0gd2luZG93Qm91bmRhcmllcyBBbiBPYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIHRoZVxuICogcHJldmlvdXMgd2luZG93IGFuZCBzdGFydHMgYSBuZXcgd2luZG93LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBhcmVcbiAqIE9ic2VydmFibGVzIGVtaXR0aW5nIHZhbHVlcyBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpbmRvd1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2luZG93KHdpbmRvd0JvdW5kYXJpZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gd2luZG93T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaW5kb3dPcGVyYXRvcih3aW5kb3dCb3VuZGFyaWVzKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2luZG93ID0gd2luZG93O1xudmFyIFdpbmRvd09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dPcGVyYXRvcih3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgICAgIHRoaXMud2luZG93Qm91bmRhcmllcyA9IHdpbmRvd0JvdW5kYXJpZXM7XG4gICAgfVxuICAgIFdpbmRvd09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgd2luZG93U3Vic2NyaWJlciA9IG5ldyBXaW5kb3dTdWJzY3JpYmVyKHN1YnNjcmliZXIpO1xuICAgICAgICB2YXIgc291cmNlU3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh3aW5kb3dTdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKCFzb3VyY2VTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB3aW5kb3dTdWJzY3JpYmVyLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHdpbmRvd1N1YnNjcmliZXIsIHRoaXMud2luZG93Qm91bmRhcmllcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VTdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLndpbmRvdyk7XG4gICAgfVxuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93KCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2luZG93Lm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUub3BlbldpbmRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZXaW5kb3cgPSB0aGlzLndpbmRvdztcbiAgICAgICAgaWYgKHByZXZXaW5kb3cpIHtcbiAgICAgICAgICAgIHByZXZXaW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgbmV3V2luZG93ID0gdGhpcy53aW5kb3cgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChuZXdXaW5kb3cpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgd2l0aCBlYWNoXG4gKiBuZXN0ZWQgT2JzZXJ2YWJsZSBlbWl0dGluZyBhdCBtb3N0IGB3aW5kb3dTaXplYCB2YWx1ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyQ291bnR9LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3dDb3VudC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHdpbmRvd3MgZXZlcnkgYHN0YXJ0V2luZG93RXZlcnlgXG4gKiBpdGVtcywgZWFjaCBjb250YWluaW5nIG5vIG1vcmUgdGhhbiBgd2luZG93U2l6ZWAgaXRlbXMuIFdoZW4gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBjb21wbGV0ZXMgb3IgZW5jb3VudGVycyBhbiBlcnJvciwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzXG4gKiB0aGUgY3VycmVudCB3aW5kb3cgYW5kIHByb3BhZ2F0ZXMgdGhlIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gbmV3IHdpbmRvd3MgYXJlXG4gKiBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlIGFuZCB3aGVuIGVhY2ggd2luZG93IGNvbXBsZXRlc1xuICogd2l0aCBzaXplIGB3aW5kb3dTaXplYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZ25vcmUgZXZlcnkgM3JkIGNsaWNrIGV2ZW50LCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvbmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dDb3VudCgzKVxuICogICAubWFwKHdpbiA9PiB3aW4uc2tpcCgxKSkgLy8gc2tpcCBmaXJzdCBvZiBldmVyeSAzIGNsaWNrc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZ25vcmUgZXZlcnkgM3JkIGNsaWNrIGV2ZW50LCBzdGFydGluZyBmcm9tIHRoZSB0aGlyZCBvbmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dDb3VudCgyLCAzKVxuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dTaXplIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2YWx1ZXMgZW1pdHRlZCBieSBlYWNoXG4gKiB3aW5kb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0V2luZG93RXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IHdpbmRvdy5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgd2luZG93IHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyB3aW5kb3cgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBPYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlIG9mIHZhbHVlcy5cbiAqIEBtZXRob2Qgd2luZG93Q291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvd0NvdW50KHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICBpZiAoc3RhcnRXaW5kb3dFdmVyeSA9PT0gdm9pZCAwKSB7IHN0YXJ0V2luZG93RXZlcnkgPSAwOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdpbmRvd0NvdW50T3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaW5kb3dDb3VudE9wZXJhdG9yKHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpKTtcbiAgICB9O1xufVxuZXhwb3J0cy53aW5kb3dDb3VudCA9IHdpbmRvd0NvdW50O1xudmFyIFdpbmRvd0NvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd0NvdW50T3BlcmF0b3Iod2luZG93U2l6ZSwgc3RhcnRXaW5kb3dFdmVyeSkge1xuICAgICAgICB0aGlzLndpbmRvd1NpemUgPSB3aW5kb3dTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0V2luZG93RXZlcnkgPSBzdGFydFdpbmRvd0V2ZXJ5O1xuICAgIH1cbiAgICBXaW5kb3dDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2luZG93Q291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMud2luZG93U2l6ZSwgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93Q291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd0NvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd0NvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc3RhcnRXaW5kb3dFdmVyeSA9IHN0YXJ0V2luZG93RXZlcnk7XG4gICAgICAgIHRoaXMud2luZG93cyA9IFtuZXcgU3ViamVjdF8xLlN1YmplY3QoKV07XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMud2luZG93c1swXSk7XG4gICAgfVxuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2luZG93RXZlcnkgPSAodGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID4gMCkgPyB0aGlzLnN0YXJ0V2luZG93RXZlcnkgOiB0aGlzLndpbmRvd1NpemU7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gdGhpcy53aW5kb3dTaXplO1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgdmFyIGxlbiA9IHdpbmRvd3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAmJiAhdGhpcy5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgd2luZG93c1tpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHRoaXMuY291bnQgLSB3aW5kb3dTaXplICsgMTtcbiAgICAgICAgaWYgKGMgPj0gMCAmJiBjICUgc3RhcnRXaW5kb3dFdmVyeSA9PT0gMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK3RoaXMuY291bnQgJSBzdGFydFdpbmRvd0V2ZXJ5ID09PSAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICB3aW5kb3dzLnB1c2god2luZG93XzEpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh3aW5kb3dfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgaWYgKHdpbmRvd3MpIHtcbiAgICAgICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgV2luZG93Q291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICBpZiAod2luZG93cykge1xuICAgICAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBXaW5kb3dDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMud2luZG93cyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93Q291bnRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93Q291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbmZ1bmN0aW9uIHdpbmRvd1RpbWUod2luZG93VGltZVNwYW4pIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYztcbiAgICB2YXIgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IG51bGw7XG4gICAgdmFyIG1heFdpbmRvd1NpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoYXJndW1lbnRzWzNdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbM107XG4gICAgfVxuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bWVyaWNfMS5pc051bWVyaWMoYXJndW1lbnRzWzJdKSkge1xuICAgICAgICBtYXhXaW5kb3dTaXplID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihhcmd1bWVudHNbMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgICAgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdpbmRvd1RpbWVPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFdpbmRvd1RpbWVPcGVyYXRvcih3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgbWF4V2luZG93U2l6ZSwgc2NoZWR1bGVyKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2luZG93VGltZSA9IHdpbmRvd1RpbWU7XG52YXIgV2luZG93VGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dUaW1lT3BlcmF0b3Iod2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIG1heFdpbmRvd1NpemUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLndpbmRvd1RpbWVTcGFuID0gd2luZG93VGltZVNwYW47XG4gICAgICAgIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4V2luZG93U2l6ZSA9IG1heFdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBXaW5kb3dUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLndpbmRvd1RpbWVTcGFuLCB0aGlzLndpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHRoaXMubWF4V2luZG93U2l6ZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUaW1lT3BlcmF0b3I7XG59KCkpO1xudmFyIENvdW50ZWRTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ291bnRlZFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ291bnRlZFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9udW1iZXJPZk5leHRlZFZhbHVlcyA9IDA7XG4gICAgfVxuICAgIENvdW50ZWRTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX251bWJlck9mTmV4dGVkVmFsdWVzKys7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudGVkU3ViamVjdC5wcm90b3R5cGUsIFwibnVtYmVyT2ZOZXh0ZWRWYWx1ZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZk5leHRlZFZhbHVlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvdW50ZWRTdWJqZWN0O1xufShTdWJqZWN0XzEuU3ViamVjdCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1RpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgbWF4V2luZG93U2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLndpbmRvd1RpbWVTcGFuID0gd2luZG93VGltZVNwYW47XG4gICAgICAgIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4V2luZG93U2l6ZSA9IG1heFdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndpbmRvd3MgPSBbXTtcbiAgICAgICAgdmFyIHdpbmRvdyA9IHRoaXMub3BlbldpbmRvdygpO1xuICAgICAgICBpZiAod2luZG93Q3JlYXRpb25JbnRlcnZhbCAhPT0gbnVsbCAmJiB3aW5kb3dDcmVhdGlvbkludGVydmFsID49IDApIHtcbiAgICAgICAgICAgIHZhciBjbG9zZVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCB3aW5kb3c6IHdpbmRvdywgY29udGV4dDogbnVsbCB9O1xuICAgICAgICAgICAgdmFyIGNyZWF0aW9uU3RhdGUgPSB7IHdpbmRvd1RpbWVTcGFuOiB3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbDogd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgc3Vic2NyaWJlcjogdGhpcywgc2NoZWR1bGVyOiBzY2hlZHVsZXIgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd0Nsb3NlLCB3aW5kb3dUaW1lU3BhbiwgY2xvc2VTdGF0ZSkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q3JlYXRpb24sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIGNyZWF0aW9uU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aW1lU3Bhbk9ubHlTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgd2luZG93OiB3aW5kb3csIHdpbmRvd1RpbWVTcGFuOiB3aW5kb3dUaW1lU3BhbiB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93VGltZVNwYW5Pbmx5LCB3aW5kb3dUaW1lU3BhbiwgdGltZVNwYW5Pbmx5U3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHZhciBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gd2luZG93c1tpXTtcbiAgICAgICAgICAgIGlmICghd2luZG93XzEuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93XzEubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvd18xLm51bWJlck9mTmV4dGVkVmFsdWVzID49IHRoaXMubWF4V2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHdpbmRvd18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18yID0gd2luZG93cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3dfMi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dfMi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93ID0gbmV3IENvdW50ZWRTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMud2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aW5kb3dzLnNwbGljZSh3aW5kb3dzLmluZGV4T2Yod2luZG93KSwgMSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93VGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd1RpbWVTcGFuT25seShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgd2luZG93VGltZVNwYW4gPSBzdGF0ZS53aW5kb3dUaW1lU3Bhbiwgd2luZG93ID0gc3RhdGUud2luZG93O1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jbG9zZVdpbmRvdyh3aW5kb3cpO1xuICAgIH1cbiAgICBzdGF0ZS53aW5kb3cgPSBzdWJzY3JpYmVyLm9wZW5XaW5kb3coKTtcbiAgICB0aGlzLnNjaGVkdWxlKHN0YXRlLCB3aW5kb3dUaW1lU3Bhbik7XG59XG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd0NyZWF0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHdpbmRvd1RpbWVTcGFuID0gc3RhdGUud2luZG93VGltZVNwYW4sIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBzY2hlZHVsZXIgPSBzdGF0ZS5zY2hlZHVsZXIsIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSBzdGF0ZS53aW5kb3dDcmVhdGlvbkludGVydmFsO1xuICAgIHZhciB3aW5kb3cgPSBzdWJzY3JpYmVyLm9wZW5XaW5kb3coKTtcbiAgICB2YXIgYWN0aW9uID0gdGhpcztcbiAgICB2YXIgY29udGV4dCA9IHsgYWN0aW9uOiBhY3Rpb24sIHN1YnNjcmlwdGlvbjogbnVsbCB9O1xuICAgIHZhciB0aW1lU3BhblN0YXRlID0geyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLCB3aW5kb3c6IHdpbmRvdywgY29udGV4dDogY29udGV4dCB9O1xuICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q2xvc2UsIHdpbmRvd1RpbWVTcGFuLCB0aW1lU3BhblN0YXRlKTtcbiAgICBhY3Rpb24uYWRkKGNvbnRleHQuc3Vic2NyaXB0aW9uKTtcbiAgICBhY3Rpb24uc2NoZWR1bGUoc3RhdGUsIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hXaW5kb3dDbG9zZShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgd2luZG93ID0gc3RhdGUud2luZG93LCBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmFjdGlvbiAmJiBjb250ZXh0LnN1YnNjcmlwdGlvbikge1xuICAgICAgICBjb250ZXh0LmFjdGlvbi5yZW1vdmUoY29udGV4dC5zdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyLmNsb3NlV2luZG93KHdpbmRvdyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgc3RhcnRpbmcgZnJvbVxuICogYW4gZW1pc3Npb24gZnJvbSBgb3BlbmluZ3NgIGFuZCBlbmRpbmcgd2hlbiB0aGUgb3V0cHV0IG9mIGBjbG9zaW5nU2VsZWN0b3JgXG4gKiBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJUb2dnbGV9LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3dUb2dnbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB3aW5kb3dzIHRoYXQgY29udGFpbiB0aG9zZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYmV0d2VlbiB0aGUgdGltZSB3aGVuIHRoZSBgb3BlbmluZ3NgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGFuIGl0ZW0gYW5kIHdoZW4gdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBjbG9zaW5nU2VsZWN0b3JgIGVtaXRzIGFuIGl0ZW0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgb3RoZXIgc2Vjb25kLCBlbWl0IHRoZSBjbGljayBldmVudHMgZnJvbSB0aGUgbmV4dCA1MDBtczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgb3BlbmluZ3MgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dUb2dnbGUob3BlbmluZ3MsIGkgPT5cbiAqICAgaSAlIDIgPyBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkgOiBSeC5PYnNlcnZhYmxlLmVtcHR5KClcbiAqICkubWVyZ2VBbGwoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8Tz59IG9wZW5pbmdzIEFuIG9ic2VydmFibGUgb2Ygbm90aWZpY2F0aW9ucyB0byBzdGFydCBuZXdcbiAqIHdpbmRvd3MuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPKTogT2JzZXJ2YWJsZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlc1xuICogdGhlIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIGBvcGVuaW5nc2Agb2JzZXJ2YWJsZSBhbmQgcmV0dXJucyBhbiBPYnNlcnZhYmxlLFxuICogd2hpY2gsIHdoZW4gaXQgZW1pdHMgKGVpdGhlciBgbmV4dGAgb3IgYGNvbXBsZXRlYCksIHNpZ25hbHMgdGhhdCB0aGVcbiAqIGFzc29jaWF0ZWQgd2luZG93IHNob3VsZCBjb21wbGV0ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIG9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVyblxuICogYXJlIE9ic2VydmFibGVzLlxuICogQG1ldGhvZCB3aW5kb3dUb2dnbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvd1RvZ2dsZShvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaW5kb3dUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSk7IH07XG59XG5leHBvcnRzLndpbmRvd1RvZ2dsZSA9IHdpbmRvd1RvZ2dsZTtcbnZhciBXaW5kb3dUb2dnbGVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93VG9nZ2xlT3BlcmF0b3Iob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLm9wZW5pbmdzID0gb3BlbmluZ3M7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgIH1cbiAgICBXaW5kb3dUb2dnbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vcGVuaW5ncywgdGhpcy5jbG9zaW5nU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUb2dnbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9wZW5pbmdzID0gb3BlbmluZ3M7XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgICAgIHRoaXMuYWRkKHRoaXMub3BlblN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb3BlbmluZ3MsIG9wZW5pbmdzKSk7XG4gICAgfVxuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIGlmIChjb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0c1tpXS53aW5kb3cubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LndpbmRvdy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2luZG93LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAob3V0ZXJWYWx1ZSA9PT0gdGhpcy5vcGVuaW5ncykge1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdTZWxlY3RvciA9IHRoaXMuY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goY2xvc2luZ1NlbGVjdG9yKShpbm5lclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHsgd2luZG93OiB3aW5kb3dfMSwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQod2luZG93XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh0aGlzLmNvbnRleHRzLmluZGV4T2Yob3V0ZXJWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICAgICAgaWYgKGlubmVyICE9PSB0aGlzLm9wZW5TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VXaW5kb3codGhpcy5jb250ZXh0cy5pbmRleE9mKGlubmVyLmNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICB2YXIgd2luZG93ID0gY29udGV4dC53aW5kb3csIHN1YnNjcmlwdGlvbiA9IGNvbnRleHQuc3Vic2NyaXB0aW9uO1xuICAgICAgICBjb250ZXh0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93VG9nZ2xlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUb2dnbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgdXNpbmcgYVxuICogZmFjdG9yeSBmdW5jdGlvbiBvZiBjbG9zaW5nIE9ic2VydmFibGVzIHRvIGRldGVybWluZSB3aGVuIHRvIHN0YXJ0IGEgbmV3XG4gKiB3aW5kb3cuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyV2hlbn0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd1doZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyBjb25uZWN0ZWQsIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzLlxuICogSXQgZW1pdHMgdGhlIGN1cnJlbnQgd2luZG93IGFuZCBvcGVucyBhIG5ldyBvbmUgd2hlbmV2ZXIgdGhlIE9ic2VydmFibGVcbiAqIHByb2R1Y2VkIGJ5IHRoZSBzcGVjaWZpZWQgYGNsb3NpbmdTZWxlY3RvcmAgZnVuY3Rpb24gZW1pdHMgYW4gaXRlbS4gVGhlIGZpcnN0XG4gKiB3aW5kb3cgaXMgb3BlbmVkIGltbWVkaWF0ZWx5IHdoZW4gc3Vic2NyaWJpbmcgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSB0aGUgZmlyc3QgdHdvIGNsaWNrcyBldmVudHMgaW4gZXZlcnkgd2luZG93IG9mIFsxLTVdIHJhbmRvbSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3NcbiAqICAgLndpbmRvd1doZW4oKCkgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwICsgTWF0aC5yYW5kb20oKSAqIDQwMDApKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2lnbmFscyAob24gZWl0aGVyIGBuZXh0YCBvclxuICogYGNvbXBsZXRlYCkgd2hlbiB0byBjbG9zZSB0aGUgcHJldmlvdXMgd2luZG93IGFuZCBzdGFydCBhIG5ldyBvbmUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2luZG93V2hlbihjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gd2luZG93V2hlbk9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgV2luZG93T3BlcmF0b3IoY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2luZG93V2hlbiA9IHdpbmRvd1doZW47XG52YXIgV2luZG93T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd09wZXJhdG9yKGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICB9XG4gICAgV2luZG93T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICB9XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coaW5uZXJTdWIpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdyhpbm5lclN1Yik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xvc2luZ05vdGlmaWNhdGlvbigpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUNsb3NpbmdOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIGlmIChpbm5lclN1YiA9PT0gdm9pZCAwKSB7IGlubmVyU3ViID0gbnVsbDsgfVxuICAgICAgICBpZiAoaW5uZXJTdWIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgICAgIGlubmVyU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZXaW5kb3cgPSB0aGlzLndpbmRvdztcbiAgICAgICAgaWYgKHByZXZXaW5kb3cpIHtcbiAgICAgICAgICAgIHByZXZXaW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93ID0gdGhpcy53aW5kb3cgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHdpbmRvdyk7XG4gICAgICAgIHZhciBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY2xvc2luZ1NlbGVjdG9yKSgpO1xuICAgICAgICBpZiAoY2xvc2luZ05vdGlmaWVyID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1doZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZVxuICogd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCwgb25seSB3aGVuIHRoZVxuICogc291cmNlIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGF0IHZhbHVlIHBsdXMgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBvdGhlciBpbnB1dFxuICogT2JzZXJ2YWJsZXMsIHRoZW4gZW1pdHMgdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2l0aExhdGVzdEZyb20ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHdpdGhMYXRlc3RGcm9tYCBjb21iaW5lcyBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlICh0aGVcbiAqIGluc3RhbmNlKSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIG90aGVyIGlucHV0IE9ic2VydmFibGVzIG9ubHkgd2hlblxuICogdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLCBvcHRpb25hbGx5IHVzaW5nIGEgYHByb2plY3RgIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICogdGhlIHZhbHVlIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBBbGwgaW5wdXQgT2JzZXJ2YWJsZXMgbXVzdFxuICogZW1pdCBhdCBsZWFzdCBvbmUgdmFsdWUgYmVmb3JlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayBldmVudCwgZW1pdCBhbiBhcnJheSB3aXRoIHRoZSBsYXRlc3QgdGltZXIgZXZlbnQgcGx1cyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2l0aExhdGVzdEZyb20odGltZXIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9qZWN0XSBQcm9qZWN0aW9uIGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgdmFsdWVzXG4gKiB0b2dldGhlci4gUmVjZWl2ZXMgYWxsIHZhbHVlcyBpbiBvcmRlciBvZiB0aGUgT2JzZXJ2YWJsZXMgcGFzc2VkLCB3aGVyZSB0aGVcbiAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiAoZS5nLlxuICogYGEud2l0aExhdGVzdEZyb20oYiwgYywgKGExLCBiMSwgYzEpID0+IGExICsgYjEgKyBjMSlgKS4gSWYgdGhpcyBpcyBub3RcbiAqIHBhc3NlZCwgYXJyYXlzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpdGhMYXRlc3RGcm9tXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBwcm9qZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvamVjdCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbTtcbnZhciBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlcztcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgV2l0aExhdGVzdEZyb21PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVzLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb2JzZXJ2YWJsZXMsIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudG9SZXNwb25kID0gW107XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudG9SZXNwb25kLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHZhciB0b1Jlc3BvbmQgPSB0aGlzLnRvUmVzcG9uZDtcbiAgICAgICAgaWYgKHRvUmVzcG9uZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0b1Jlc3BvbmQuaW5kZXhPZihvdXRlckluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b1Jlc3BvbmQuc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50b1Jlc3BvbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFt2YWx1ZV0uY29uY2F0KHRoaXMudmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQHBhcmFtIG9ic2VydmFibGVzXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fVxuICogQG1ldGhvZCB6aXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHppcCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHppcE9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdC5jYWxsKHppcFN0YXRpYy5hcHBseSh2b2lkIDAsIFtzb3VyY2VdLmNvbmNhdChvYnNlcnZhYmxlcykpKTtcbiAgICB9O1xufVxuZXhwb3J0cy56aXAgPSB6aXA7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdmFsdWVzLCBpbiBvcmRlciwgb2YgZWFjaFxuICogb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIElmIHRoZSBsYXRlc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjcmVhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IHZhbHVlcy5cbiAqIE90aGVyd2lzZSwgYW4gYXJyYXkgb2YgdGhlIGlucHV0IHZhbHVlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21iaW5lIGFnZSBhbmQgbmFtZSBmcm9tIGRpZmZlcmVudCBzb3VyY2VzPC9jYXB0aW9uPlxuICpcbiAqIGxldCBhZ2UkID0gT2JzZXJ2YWJsZS5vZjxudW1iZXI+KDI3LCAyNSwgMjkpO1xuICogbGV0IG5hbWUkID0gT2JzZXJ2YWJsZS5vZjxzdHJpbmc+KCdGb28nLCAnQmFyJywgJ0JlZXInKTtcbiAqIGxldCBpc0RldiQgPSBPYnNlcnZhYmxlLm9mPGJvb2xlYW4+KHRydWUsIHRydWUsIGZhbHNlKTtcbiAqXG4gKiBPYnNlcnZhYmxlXG4gKiAgICAgLnppcChhZ2UkLFxuICogICAgICAgICAgbmFtZSQsXG4gKiAgICAgICAgICBpc0RldiQsXG4gKiAgICAgICAgICAoYWdlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgaXNEZXY6IGJvb2xlYW4pID0+ICh7IGFnZSwgbmFtZSwgaXNEZXYgfSkpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBvdXRwdXRzXG4gKiAvLyB7IGFnZTogMjcsIG5hbWU6ICdGb28nLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjUsIG5hbWU6ICdCYXInLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjksIG5hbWU6ICdCZWVyJywgaXNEZXY6IGZhbHNlIH1cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLmxpZnQobmV3IFppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwU3RhdGljID0gemlwU3RhdGljO1xudmFyIFppcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaaXBPcGVyYXRvcihwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFppcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSA/IHByb2plY3QgOiBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0l0ZXJhdG9yKHZhbHVlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBaaXBCdWZmZXJJdGVyYXRvcih0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5oYXNWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXRlcmF0b3IuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlppcFN1YnNjcmliZXIgPSBaaXBTdWJzY3JpYmVyO1xudmFyIFN0YXRpY0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FycmF5SXRlcmF0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA+IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBCdWZmZXJJdGVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBCdWZmZXJJdGVyYXRvcihkZXN0aW5hdGlvbiwgcGFyZW50LCBvYnNlcnZhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAgIC8vICAgIHRoaXMgaXMgbGVnaXQgYmVjYXVzZSBgbmV4dCgpYCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBieSBhIHN1YnNjcmlwdGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4vemlwJyk7XG5mdW5jdGlvbiB6aXBBbGwocHJvamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgemlwXzEuWmlwT3BlcmF0b3IocHJvamVjdCkpOyB9O1xufVxuZXhwb3J0cy56aXBBbGwgPSB6aXBBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXBBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBBIHVuaXQgb2Ygd29yayB0byBiZSBleGVjdXRlZCBpbiBhIHtAbGluayBTY2hlZHVsZXJ9LiBBbiBhY3Rpb24gaXMgdHlwaWNhbGx5XG4gKiBjcmVhdGVkIGZyb20gd2l0aGluIGEgU2NoZWR1bGVyIGFuZCBhbiBSeEpTIHVzZXIgZG9lcyBub3QgbmVlZCB0byBjb25jZXJuXG4gKiB0aGVtc2VsdmVzIGFib3V0IGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYW4gQWN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBBY3Rpb248VD4gZXh0ZW5kcyBTdWJzY3JpcHRpb24ge1xuICogICBuZXcgKHNjaGVkdWxlcjogU2NoZWR1bGVyLCB3b3JrOiAoc3RhdGU/OiBUKSA9PiB2b2lkKTtcbiAqICAgc2NoZWR1bGUoc3RhdGU/OiBULCBkZWxheTogbnVtYmVyID0gMCk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBBY3Rpb248VD5cbiAqL1xudmFyIEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhpcyBhY3Rpb24gb24gaXRzIHBhcmVudCBTY2hlZHVsZXIgZm9yIGV4ZWN1dGlvbi4gTWF5IGJlIHBhc3NlZFxuICAgICAqIHNvbWUgY29udGV4dCBvYmplY3QsIGBzdGF0ZWAuIE1heSBoYXBwZW4gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgYGRlbGF5YCBwYXJhbWV0ZXIsIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXldIFRpbWUgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB3b3JrLCB3aGVyZSB0aGVcbiAgICAgKiB0aW1lIHVuaXQgaXMgaW1wbGljaXQgYW5kIGRlZmluZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIEFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBBY3Rpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5BY3Rpb24gPSBBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFzeW5jQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgcmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwZW5kaW5nIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoaXMgYWN0aW9uIGhhcyBiZWVuIHNjaGVkdWxlZCwgb3JcbiAgICAgICAgLy8gaGFzIHJlY3Vyc2l2ZWx5IHJlc2NoZWR1bGVkIGl0c2VsZi5cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICAvL1xuICAgICAgICAvLyBJbXBvcnRhbnQgaW1wbGVtZW50YXRpb24gbm90ZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWN0aW9ucyBvbmx5IGV4ZWN1dGUgb25jZSBieSBkZWZhdWx0LCB1bmxlc3MgcmVzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHNjaGVkdWxlZCBjYWxsYmFjay4gVGhpcyBhbGxvd3MgdXMgdG8gaW1wbGVtZW50IHNpbmdsZSBhbmQgcmVwZWF0XG4gICAgICAgIC8vIGFjdGlvbnMgdmlhIHRoZSBzYW1lIGNvZGUgcGF0aCwgd2l0aG91dCBhZGRpbmcgQVBJIHN1cmZhY2UgYXJlYSwgYXMgd2VsbFxuICAgICAgICAvLyBhcyBtaW1pYyB0cmFkaXRpb25hbCByZWN1cnNpb24gYnV0IGFjcm9zcyBhc3luY2hyb25vdXMgYm91bmRhcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgSlMgcnVudGltZXMgYW5kIHRpbWVycyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGludGVydmFscyBhY2hpZXZlZCBieVxuICAgICAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIHZzLiBhIHNpbmdsZSBgc2V0SW50ZXJ2YWxgIGNhbGwuIEFuIGludGVydmFsIG9mXG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgY2FuIGJlIGluZGl2aWR1YWxseSBkZWxheWVkLCB3aGljaCBkZWxheXNcbiAgICAgICAgLy8gc2NoZWR1bGluZyB0aGUgbmV4dCBgc2V0VGltZW91dGAsIGFuZCBzbyBvbi4gYHNldEludGVydmFsYCBhdHRlbXB0cyB0b1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhlIGludGVydmFsIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBtb3JlIHByZWNpc2VseSB0byB0aGVcbiAgICAgICAgLy8gaW50ZXJ2YWwgcGVyaW9kLCByZWdhcmRsZXNzIG9mIGxvYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2UgdXNlIGBzZXRJbnRlcnZhbGAgdG8gc2NoZWR1bGUgc2luZ2xlIGFuZCByZXBlYXQgYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiByZXNjaGVkdWxlcyBpdHNlbGYgd2l0aCB0aGUgc2FtZSBkZWxheSwgdGhlIGludGVydmFsIGlzIG5vdFxuICAgICAgICAvLyBjYW5jZWxlZC4gSWYgdGhlIGFjdGlvbiBkb2Vzbid0IHJlc2NoZWR1bGUsIG9yIHJlc2NoZWR1bGVzIHdpdGggYVxuICAgICAgICAvLyBkaWZmZXJlbnQgZGVsYXksIHRoZSBpbnRlcnZhbCB3aWxsIGJlIGNhbmNlbGVkIGFmdGVyIHNjaGVkdWxlZCBjYWxsYmFja1xuICAgICAgICAvLyBleGVjdXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBoYXMgYWxyZWFkeSBhbiBhc3luYyBJZCwgZG9uJ3QgcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IHRoaXMucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCB0aGlzLmlkLCBkZWxheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3Quc2V0SW50ZXJ2YWwoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCB0aGlzKSwgZGVsYXkpO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBpcyByZXNjaGVkdWxlZCB3aXRoIHRoZSBzYW1lIGRlbGF5IHRpbWUsIGRvbid0IGNsZWFyIHRoZSBpbnRlcnZhbCBpZC5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIHRoaXMuZGVsYXkgPT09IGRlbGF5ICYmIHRoaXMucGVuZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSBhY3Rpb24ncyBkZWxheSB0aW1lIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IGRlbGF5LFxuICAgICAgICAvLyBvciB0aGUgYWN0aW9uIGhhcyBiZWVuIHJlc2NoZWR1bGVkIGJlZm9yZSBpdCdzIGV4ZWN1dGVkLCBjbGVhciB0aGUgaW50ZXJ2YWwgaWRcbiAgICAgICAgcmV0dXJuIHJvb3RfMS5yb290LmNsZWFySW50ZXJ2YWwoaWQpICYmIHVuZGVmaW5lZCB8fCB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBleGVjdXRlcyB0aGlzIGFjdGlvbiBhbmQgdGhlIGB3b3JrYCBpdCBjb250YWlucy5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignZXhlY3V0aW5nIGEgY2FuY2VsbGVkIGFjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZyA9PT0gZmFsc2UgJiYgdGhpcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXF1ZXVlIGlmIHRoZSBhY3Rpb24gZGlkbid0IHJlc2NoZWR1bGUgaXRzZWxmLiBEb24ndCBjYWxsXG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSgpLCBiZWNhdXNlIHRoZSBhY3Rpb24gY291bGQgcmVzY2hlZHVsZSBsYXRlci5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAvLyBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gZG9Xb3JrKGNvdW50ZXIpIHtcbiAgICAgICAgICAgIC8vICAgLyogLi4uIEknbSBhIGJ1c3kgd29ya2VyIGJlZSAuLi4gKi9cbiAgICAgICAgICAgIC8vICAgdmFyIG9yaWdpbmFsQWN0aW9uID0gdGhpcztcbiAgICAgICAgICAgIC8vICAgLyogd2FpdCAxMDBtcyBiZWZvcmUgcmVzY2hlZHVsaW5nIHRoZSBhY3Rpb24gKi9cbiAgICAgICAgICAgIC8vICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAgICAgb3JpZ2luYWxBY3Rpb24uc2NoZWR1bGUoY291bnRlciArIDEpO1xuICAgICAgICAgICAgLy8gICB9LCAxMDApO1xuICAgICAgICAgICAgLy8gfSwgMTAwMCk7XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICB2YXIgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud29yayhzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9ICEhZSAmJiBlIHx8IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzY2hlZHVsZXIuYWN0aW9ucztcbiAgICAgICAgdmFyIGluZGV4ID0gYWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICB0aGlzLndvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY0FjdGlvbjtcbn0oQWN0aW9uXzEuQWN0aW9uKSk7XG5leHBvcnRzLkFzeW5jQWN0aW9uID0gQXN5bmNBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY0FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vU2NoZWR1bGVyJyk7XG52YXIgQXN5bmNTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY1NjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1NjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIFNjaGVkdWxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIGEgYmF0Y2ggb2ZcbiAgICAgICAgICogcXVldWVkIGFjdGlvbnMuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIElEIHVzZWQgdG8gdHJhY2sgdGhlIGxhdGVzdCBhc3luY2hyb25vdXMgdGFzayBzdWNoIGFzIHRob3NlXG4gICAgICAgICAqIGNvbWluZyBmcm9tIGBzZXRUaW1lb3V0YCwgYHNldEludGVydmFsYCwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsIGFuZFxuICAgICAgICAgKiBvdGhlcnMuXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSk7IC8vIGV4aGF1c3QgdGhlIHNjaGVkdWxlciBxdWV1ZVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcl8xLlNjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc3luY1NjaGVkdWxlciA9IEFzeW5jU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBRdWV1ZUFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXVlQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1ZXVlQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICB9XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlci5mbHVzaCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBRdWV1ZUFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIChkZWxheSA+IDAgfHwgdGhpcy5jbG9zZWQpID9cbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZS5jYWxsKHRoaXMsIHN0YXRlLCBkZWxheSkgOlxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgICAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZsdXNoIHRoZSBzY2hlZHVsZXIgc3RhcnRpbmcgd2l0aCB0aGlzIGFjdGlvbi5cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5mbHVzaCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBRdWV1ZUFjdGlvbjtcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xuZXhwb3J0cy5RdWV1ZUFjdGlvbiA9IFF1ZXVlQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWVBY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc3luY1NjaGVkdWxlcicpO1xudmFyIFF1ZXVlU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWVTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWVTY2hlZHVsZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gUXVldWVTY2hlZHVsZXI7XG59KEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIpKTtcbmV4cG9ydHMuUXVldWVTY2hlZHVsZXIgPSBRdWV1ZVNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXVlU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFzeW5jQWN0aW9uXzEgPSByZXF1aXJlKCcuL0FzeW5jQWN0aW9uJyk7XG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vQXN5bmNTY2hlZHVsZXInKTtcbi8qKlxuICpcbiAqIEFzeW5jIFNjaGVkdWxlclxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5TY2hlZHVsZSB0YXNrIGFzIGlmIHlvdSB1c2VkIHNldFRpbWVvdXQodGFzaywgZHVyYXRpb24pPC9zcGFuPlxuICpcbiAqIGBhc3luY2Agc2NoZWR1bGVyIHNjaGVkdWxlcyB0YXNrcyBhc3luY2hyb25vdXNseSwgYnkgcHV0dGluZyB0aGVtIG9uIHRoZSBKYXZhU2NyaXB0XG4gKiBldmVudCBsb29wIHF1ZXVlLiBJdCBpcyBiZXN0IHVzZWQgdG8gZGVsYXkgdGFza3MgaW4gdGltZSBvciB0byBzY2hlZHVsZSB0YXNrcyByZXBlYXRpbmdcbiAqIGluIGludGVydmFscy5cbiAqXG4gKiBJZiB5b3UganVzdCB3YW50IHRvIFwiZGVmZXJcIiB0YXNrLCB0aGF0IGlzIHRvIHBlcmZvcm0gaXQgcmlnaHQgYWZ0ZXIgY3VycmVudGx5XG4gKiBleGVjdXRpbmcgc3luY2hyb25vdXMgY29kZSBlbmRzIChjb21tb25seSBhY2hpZXZlZCBieSBgc2V0VGltZW91dChkZWZlcnJlZFRhc2ssIDApYCksXG4gKiBiZXR0ZXIgY2hvaWNlIHdpbGwgYmUgdGhlIHtAbGluayBhc2FwfSBzY2hlZHVsZXIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGFzeW5jIHNjaGVkdWxlciB0byBkZWxheSB0YXNrPC9jYXB0aW9uPlxuICogY29uc3QgdGFzayA9ICgpID0+IGNvbnNvbGUubG9nKCdpdCB3b3JrcyEnKTtcbiAqXG4gKiBSeC5TY2hlZHVsZXIuYXN5bmMuc2NoZWR1bGUodGFzaywgMjAwMCk7XG4gKlxuICogLy8gQWZ0ZXIgMiBzZWNvbmRzIGxvZ3M6XG4gKiAvLyBcIml0IHdvcmtzIVwiXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhc3luYyBzY2hlZHVsZXIgdG8gcmVwZWF0IHRhc2sgaW4gaW50ZXJ2YWxzPC9jYXB0aW9uPlxuICogZnVuY3Rpb24gdGFzayhzdGF0ZSkge1xuICogICBjb25zb2xlLmxvZyhzdGF0ZSk7XG4gKiAgIHRoaXMuc2NoZWR1bGUoc3RhdGUgKyAxLCAxMDAwKTsgLy8gYHRoaXNgIHJlZmVyZW5jZXMgY3VycmVudGx5IGV4ZWN1dGluZyBBY3Rpb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd2UgcmVzY2hlZHVsZSB3aXRoIG5ldyBzdGF0ZSBhbmQgZGVsYXlcbiAqIH1cbiAqXG4gKiBSeC5TY2hlZHVsZXIuYXN5bmMuc2NoZWR1bGUodGFzaywgMzAwMCwgMCk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIDAgYWZ0ZXIgM3NcbiAqIC8vIDEgYWZ0ZXIgNHNcbiAqIC8vIDIgYWZ0ZXIgNXNcbiAqIC8vIDMgYWZ0ZXIgNnNcbiAqXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGFzeW5jXG4gKiBAb3duZXIgU2NoZWR1bGVyXG4gKi9cbmV4cG9ydHMuYXN5bmMgPSBuZXcgQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcihBc3luY0FjdGlvbl8xLkFzeW5jQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFF1ZXVlQWN0aW9uXzEgPSByZXF1aXJlKCcuL1F1ZXVlQWN0aW9uJyk7XG52YXIgUXVldWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vUXVldWVTY2hlZHVsZXInKTtcbi8qKlxuICpcbiAqIFF1ZXVlIFNjaGVkdWxlclxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXQgZXZlcnkgbmV4dCB0YXNrIG9uIGEgcXVldWUsIGluc3RlYWQgb2YgZXhlY3V0aW5nIGl0IGltbWVkaWF0ZWx5PC9zcGFuPlxuICpcbiAqIGBxdWV1ZWAgc2NoZWR1bGVyLCB3aGVuIHVzZWQgd2l0aCBkZWxheSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgYXN5bmN9IHNjaGVkdWxlci5cbiAqXG4gKiBXaGVuIHVzZWQgd2l0aG91dCBkZWxheSwgaXQgc2NoZWR1bGVzIGdpdmVuIHRhc2sgc3luY2hyb25vdXNseSAtIGV4ZWN1dGVzIGl0IHJpZ2h0IHdoZW5cbiAqIGl0IGlzIHNjaGVkdWxlZC4gSG93ZXZlciB3aGVuIGNhbGxlZCByZWN1cnNpdmVseSwgdGhhdCBpcyB3aGVuIGluc2lkZSB0aGUgc2NoZWR1bGVkIHRhc2ssXG4gKiBhbm90aGVyIHRhc2sgaXMgc2NoZWR1bGVkIHdpdGggcXVldWUgc2NoZWR1bGVyLCBpbnN0ZWFkIG9mIGV4ZWN1dGluZyBpbW1lZGlhdGVseSBhcyB3ZWxsLFxuICogdGhhdCB0YXNrIHdpbGwgYmUgcHV0IG9uIGEgcXVldWUgYW5kIHdhaXQgZm9yIGN1cnJlbnQgb25lIHRvIGZpbmlzaC5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgd2hlbiB5b3UgZXhlY3V0ZSB0YXNrIHdpdGggYHF1ZXVlYCBzY2hlZHVsZXIsIHlvdSBhcmUgc3VyZSBpdCB3aWxsIGVuZFxuICogYmVmb3JlIGFueSBvdGhlciB0YXNrIHNjaGVkdWxlZCB3aXRoIHRoYXQgc2NoZWR1bGVyIHdpbGwgc3RhcnQuXG4gKlxuICogQGV4YW1wbGVzIDxjYXB0aW9uPlNjaGVkdWxlIHJlY3Vyc2l2ZWx5IGZpcnN0LCB0aGVuIGRvIHNvbWV0aGluZzwvY2FwdGlvbj5cbiAqXG4gKiBSeC5TY2hlZHVsZXIucXVldWUuc2NoZWR1bGUoKCkgPT4ge1xuICogICBSeC5TY2hlZHVsZXIucXVldWUuc2NoZWR1bGUoKCkgPT4gY29uc29sZS5sb2coJ3NlY29uZCcpKTsgLy8gd2lsbCBub3QgaGFwcGVuIG5vdywgYnV0IHdpbGwgYmUgcHV0IG9uIGEgcXVldWVcbiAqXG4gKiAgIGNvbnNvbGUubG9nKCdmaXJzdCcpO1xuICogfSk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIFwiZmlyc3RcIlxuICogLy8gXCJzZWNvbmRcIlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXNjaGVkdWxlIGl0c2VsZiByZWN1cnNpdmVseTwvY2FwdGlvbj5cbiAqXG4gKiBSeC5TY2hlZHVsZXIucXVldWUuc2NoZWR1bGUoZnVuY3Rpb24oc3RhdGUpIHtcbiAqICAgaWYgKHN0YXRlICE9PSAwKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2JlZm9yZScsIHN0YXRlKTtcbiAqICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlIC0gMSk7IC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd2UgcmVzY2hlZHVsZSB3aXRoIG5ldyBzdGF0ZVxuICogICAgIGNvbnNvbGUubG9nKCdhZnRlcicsIHN0YXRlKTtcbiAqICAgfVxuICogfSwgMCwgMyk7XG4gKlxuICogLy8gSW4gc2NoZWR1bGVyIHRoYXQgcnVucyByZWN1cnNpdmVseSwgeW91IHdvdWxkIGV4cGVjdDpcbiAqIC8vIFwiYmVmb3JlXCIsIDNcbiAqIC8vIFwiYmVmb3JlXCIsIDJcbiAqIC8vIFwiYmVmb3JlXCIsIDFcbiAqIC8vIFwiYWZ0ZXJcIiwgMVxuICogLy8gXCJhZnRlclwiLCAyXG4gKiAvLyBcImFmdGVyXCIsIDNcbiAqXG4gKiAvLyBCdXQgd2l0aCBxdWV1ZSBpdCBsb2dzOlxuICogLy8gXCJiZWZvcmVcIiwgM1xuICogLy8gXCJhZnRlclwiLCAzXG4gKiAvLyBcImJlZm9yZVwiLCAyXG4gKiAvLyBcImFmdGVyXCIsIDJcbiAqIC8vIFwiYmVmb3JlXCIsIDFcbiAqIC8vIFwiYWZ0ZXJcIiwgMVxuICpcbiAqXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHF1ZXVlXG4gKiBAb3duZXIgU2NoZWR1bGVyXG4gKi9cbmV4cG9ydHMucXVldWUgPSBuZXcgUXVldWVTY2hlZHVsZXJfMS5RdWV1ZVNjaGVkdWxlcihRdWV1ZUFjdGlvbl8xLlF1ZXVlQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290KSB7XG4gICAgdmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgPSBTeW1ib2woJ2l0ZXJhdG9yIHBvbHlmaWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFtmb3IgTW96aWxsYSBHZWNrbyAyNy0zNTpdKGh0dHBzOi8vbXpsLmxhLzJld0UxekMpXG4gICAgICAgIHZhciBTZXRfMSA9IHJvb3QuU2V0O1xuICAgICAgICBpZiAoU2V0XzEgJiYgdHlwZW9mIG5ldyBTZXRfMSgpWydAQGl0ZXJhdG9yJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1hcF8xID0gcm9vdC5NYXA7XG4gICAgICAgIC8vIHJlcXVpcmVkIGZvciBjb21wYXRhYmlsaXR5IHdpdGggZXM2LXNoaW1cbiAgICAgICAgaWYgKE1hcF8xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcF8xLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gc3BlYywgTWFwLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSBhbmQgTWFwLm9yb3RvdHlwZS5lbnRyaWVzIG11c3QgYmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmIE1hcF8xLnByb3RvdHlwZVtrZXldID09PSBNYXBfMS5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ltYm9sSXRlcmF0b3JQb255ZmlsbCA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGw7XG5leHBvcnRzLml0ZXJhdG9yID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290XzEucm9vdCk7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBpdGVyYXRvciBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMuJCRpdGVyYXRvciA9IGV4cG9ydHMuaXRlcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIGdldFN5bWJvbE9ic2VydmFibGUoY29udGV4dCkge1xuICAgIHZhciAkJG9ic2VydmFibGU7XG4gICAgdmFyIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sLm9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbiAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gJCRvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkJG9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuICQkb2JzZXJ2YWJsZTtcbn1cbmV4cG9ydHMuZ2V0U3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGU7XG5leHBvcnRzLm9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlKHJvb3RfMS5yb290KTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG9ic2VydmFibGUgaW5zdGVhZFxuICovXG5leHBvcnRzLiQkb2JzZXJ2YWJsZSA9IGV4cG9ydHMub2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgU3ltYm9sID0gcm9vdF8xLnJvb3QuU3ltYm9sO1xuZXhwb3J0cy5yeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHJ4U3Vic2NyaWJlciBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSBleHBvcnRzLnJ4U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBlbGVtZW50IHdhcyBxdWVyaWVkIGF0IGEgY2VydGFpbiBpbmRleCBvZiBhblxuICogT2JzZXJ2YWJsZSwgYnV0IG5vIHN1Y2ggaW5kZXggb3IgcG9zaXRpb24gZXhpc3RzIGluIHRoYXQgc2VxdWVuY2UuXG4gKlxuICogQHNlZSB7QGxpbmsgZWxlbWVudEF0fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICpcbiAqIEBjbGFzcyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvclxuICovXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmd1bWVudE91dE9mUmFuZ2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdhcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gT2JzZXJ2YWJsZSBvciBhIHNlcXVlbmNlIHdhcyBxdWVyaWVkIGJ1dCBoYXMgbm9cbiAqIGVsZW1lbnRzLlxuICpcbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgbGFzdH1cbiAqIEBzZWUge0BsaW5rIHNpbmdsZX1cbiAqXG4gKiBAY2xhc3MgRW1wdHlFcnJvclxuICovXG52YXIgRW1wdHlFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdubyBlbGVtZW50cyBpbiBzZXF1ZW5jZScpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdFbXB0eUVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBFbXB0eUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5FbXB0eUVycm9yID0gRW1wdHlFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5RXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRmFzdE1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFzdE1hcCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB9XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNba2V5XTtcbiAgICB9O1xuICAgIEZhc3RNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgdmFsdWVzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHZhbHVlc1trZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBGYXN0TWFwO1xufSgpKTtcbmV4cG9ydHMuRmFzdE1hcCA9IEZhc3RNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYXN0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIE1hcFBvbHlmaWxsXzEgPSByZXF1aXJlKCcuL01hcFBvbHlmaWxsJyk7XG5leHBvcnRzLk1hcCA9IHJvb3RfMS5yb290Lk1hcCB8fCAoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwUG9seWZpbGxfMS5NYXBQb2x5ZmlsbDsgfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXBQb2x5ZmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwUG9seWZpbGwoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNYXBQb2x5ZmlsbDtcbn0oKSk7XG5leHBvcnRzLk1hcFBvbHlmaWxsID0gTWFwUG9seWZpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBQb2x5ZmlsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgaW52YWxpZCBiZWNhdXNlIHRoZSBvYmplY3QgaGFzIGJlZW5cbiAqIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBTdWJqZWN0fVxuICogQHNlZSB7QGxpbmsgQmVoYXZpb3JTdWJqZWN0fVxuICpcbiAqIEBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvclxuICovXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RVbnN1YnNjcmliZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdvYmplY3QgdW5zdWJzY3JpYmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuZnVuY3Rpb24gbWluaW1hbFNldEltcGwoKSB7XG4gICAgLy8gVEhJUyBJUyBOT1QgYSBmdWxsIGltcGwgb2YgU2V0LCB0aGlzIGlzIGp1c3QgdGhlIG1pbmltdW1cbiAgICAvLyBiaXRzIG9mIGZ1bmN0aW9uYWxpdHkgd2UgbmVlZCBmb3IgdGhpcyBsaWJyYXJ5LlxuICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5pbWFsU2V0KCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pbmltYWxTZXQucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTWluaW1hbFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbmltYWxTZXQ7XG4gICAgfSgpKTtcbn1cbmV4cG9ydHMubWluaW1hbFNldEltcGwgPSBtaW5pbWFsU2V0SW1wbDtcbmV4cG9ydHMuU2V0ID0gcm9vdF8xLnJvb3QuU2V0IHx8IG1pbmltYWxTZXRJbXBsKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gZHVldGltZSBlbGFwc2VzLlxuICpcbiAqIEBzZWUge0BsaW5rIHRpbWVvdXR9XG4gKlxuICogQGNsYXNzIFRpbWVvdXRFcnJvclxuICovXG52YXIgVGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdUaW1lb3V0IGhhcyBvY2N1cnJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVvdXRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZW91dEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIG9uZSBvciBtb3JlIGVycm9ycyBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGVcbiAqIGB1bnN1YnNjcmliZWAgb2YgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufS5cbiAqL1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmlwdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgZXJyb3JzID9cbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcbiAgXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHsgcmV0dXJuICgoaSArIDEpICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCkpOyB9KS5qb2luKCdcXG4gICcpIDogJycpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbnN1YnNjcmlwdGlvbkVycm9yID0gVW5zdWJzY3JpcHRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0eXBlb2YgYW55IHNvIHRoYXQgaXQgd2UgZG9uJ3QgaGF2ZSB0byBjYXN0IHdoZW4gY29tcGFyaW5nIGEgcmVzdWx0IHRvIHRoZSBlcnJvciBvYmplY3RcbmV4cG9ydHMuZXJyb3JPYmplY3QgPSB7IGU6IHt9IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvck9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJzsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXlMaWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oK3ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNEYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG5mdW5jdGlvbiBpc051bWVyaWModmFsKSB7XG4gICAgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICAgIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcbiAgICByZXR1cm4gIWlzQXJyYXlfMS5pc0FycmF5KHZhbCkgJiYgKHZhbCAtIHBhcnNlRmxvYXQodmFsKSArIDEpID49IDA7XG59XG5leHBvcnRzLmlzTnVtZXJpYyA9IGlzTnVtZXJpYztcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTnVtZXJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzUHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNTY2hlZHVsZXIgPSBpc1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGU6bm8tZW1wdHkgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbm90KHByZWQsIHRoaXNBcmcpIHtcbiAgICBmdW5jdGlvbiBub3RQcmVkKCkge1xuICAgICAgICByZXR1cm4gIShub3RQcmVkLnByZWQuYXBwbHkobm90UHJlZC50aGlzQXJnLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgbm90UHJlZC5wcmVkID0gcHJlZDtcbiAgICBub3RQcmVkLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIHJldHVybiBub3RQcmVkO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbm9vcF8xID0gcmVxdWlyZSgnLi9ub29wJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZm5zW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZUZyb21BcnJheShmbnMpO1xufVxuZXhwb3J0cy5waXBlID0gcGlwZTtcbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcbiAgICBpZiAoIWZucykge1xuICAgICAgICByZXR1cm4gbm9vcF8xLm5vb3A7XG4gICAgfVxuICAgIGlmIChmbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBwaXBlZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZm4pIHsgcmV0dXJuIGZuKHByZXYpOyB9LCBpbnB1dCk7XG4gICAgfTtcbn1cbmV4cG9ydHMucGlwZUZyb21BcnJheSA9IHBpcGVGcm9tQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gQ29tbW9uSlMgLyBOb2RlIGhhdmUgZ2xvYmFsIGNvbnRleHQgZXhwb3NlZCBhcyBcImdsb2JhbFwiIHZhcmlhYmxlLlxuLy8gV2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIHRoZSB3aG9sZSBub2RlLmQudHMgdGhpcyB0aGlzIGNvbXBpbGF0aW9uIHVuaXQgc28gd2UnbGwganVzdCBmYWtlXG4vLyB0aGUgZ2xvYmFsIFwiZ2xvYmFsXCIgdmFyIGZvciBub3cuXG52YXIgX193aW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c7XG52YXIgX19zZWxmID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiYgc2VsZjtcbnZhciBfX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbDtcbnZhciBfcm9vdCA9IF9fd2luZG93IHx8IF9fZ2xvYmFsIHx8IF9fc2VsZjtcbmV4cG9ydHMucm9vdCA9IF9yb290O1xuLy8gV29ya2Fyb3VuZCBDbG9zdXJlIENvbXBpbGVyIHJlc3RyaWN0aW9uOiBUaGUgYm9keSBvZiBhIGdvb2cubW9kdWxlIGNhbm5vdCB1c2UgdGhyb3cuXG4vLyBUaGlzIGlzIG5lZWRlZCB3aGVuIHVzZWQgd2l0aCBhbmd1bGFyL3RzaWNrbGUgd2hpY2ggaW5zZXJ0cyBhIGdvb2cubW9kdWxlIHN0YXRlbWVudC5cbi8vIFdyYXAgaW4gSUlGRVxuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9yb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUnhKUyBjb3VsZCBub3QgZmluZCBhbnkgZ2xvYmFsIGNvbnRleHQgKHdpbmRvdywgc2VsZiwgZ2xvYmFsKScpO1xuICAgIH1cbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIGlzQXJyYXlMaWtlXzEgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG52YXIgaXNQcm9taXNlXzEgPSByZXF1aXJlKCcuL2lzUHJvbWlzZScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbnZhciBJbm5lclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL0lubmVyU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG5mdW5jdGlvbiBzdWJzY3JpYmVUb1Jlc3VsdChvdXRlclN1YnNjcmliZXIsIHJlc3VsdCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IG5ldyBJbm5lclN1YnNjcmliZXJfMS5Jbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KTtcbiAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuICYmICFkZXN0aW5hdGlvbi5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpOyB9KVxuICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXzEuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHJlc3VsdFtpdGVyYXRvcl8xLml0ZXJhdG9yXSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgb2JzID0gcmVzdWx0W29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSgpO1xuICAgICAgICBpZiAodHlwZW9mIG9icy5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIG9iamVjdCBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IFN5bWJvbC5vYnNlcnZhYmxlJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUobmV3IElubmVyU3Vic2NyaWJlcl8xLklubmVyU3Vic2NyaWJlcihvdXRlclN1YnNjcmliZXIsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXNPYmplY3RfMS5pc09iamVjdChyZXN1bHQpID8gJ2FuIGludmFsaWQgb2JqZWN0JyA6IFwiJ1wiICsgcmVzdWx0ICsgXCInXCI7XG4gICAgICAgIHZhciBtc2cgPSAoXCJZb3UgcHJvdmlkZWQgXCIgKyB2YWx1ZSArIFwiIHdoZXJlIGEgc3RyZWFtIHdhcyBleHBlY3RlZC5cIilcbiAgICAgICAgICAgICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IobXNnKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5zdWJzY3JpYmVUb1Jlc3VsdCA9IHN1YnNjcmliZVRvUmVzdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlVG9SZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZlcicpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihPYnNlcnZlcl8xLmVtcHR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL2Vycm9yT2JqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnlDYXRjaC5qcy5tYXAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXI7XG5cbi8vIFRoZSBkZWJ1ZyBmdW5jdGlvbiBpcyBleGNsdWRlZCBlbnRpcmVseSBmcm9tIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuLyogbm9taW4gKi8gdmFyIGRlYnVnO1xuLyogbm9taW4gKi8gaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52ICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAgIC8qIG5vbWluICovIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIG5vbWluICovIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAvKiBub21pbiAqLyBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpO1xuICAgIC8qIG5vbWluICovIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIC8qIG5vbWluICovIH07XG4vKiBub21pbiAqLyBlbHNlXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJztcblxudmFyIE1BWF9MRU5HVEggPSAyNTY7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbnZhciBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTY7XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG52YXIgcmUgPSBleHBvcnRzLnJlID0gW107XG52YXIgc3JjID0gZXhwb3J0cy5zcmMgPSBbXTtcbnZhciBSID0gMDtcblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxudmFyIE5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJztcbnZhciBOVU1FUklDSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdID0gJ1swLTldKyc7XG5cblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxudmFyIE5PTk5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJztcblxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxudmFyIE1BSU5WRVJTSU9OID0gUisrO1xuc3JjW01BSU5WRVJTSU9OXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgTUFJTlZFUlNJT05MT09TRSA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTkxPT1NFXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpJztcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVIgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgUFJFUkVMRUFTRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICsgJykqKSknO1xuXG52YXIgUFJFUkVMRUFTRUxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gKyAnKSopKSc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbnZhciBCVUlMRElERU5USUZJRVIgPSBSKys7XG5zcmNbQlVJTERJREVOVElGSUVSXSA9ICdbMC05QS1aYS16LV0rJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBCVUlMRCA9IFIrKztcbnNyY1tCVUlMRF0gPSAnKD86XFxcXCsoJyArIHNyY1tCVUlMRElERU5USUZJRVJdICtcbiAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW0JVSUxESURFTlRJRklFUl0gKyAnKSopKSc7XG5cblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbnZhciBGVUxMID0gUisrO1xudmFyIEZVTExQTEFJTiA9ICd2PycgKyBzcmNbTUFJTlZFUlNJT05dICtcbiAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnNyY1tGVUxMXSA9ICdeJyArIEZVTExQTEFJTiArICckJztcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxudmFyIExPT1NFUExBSU4gPSAnW3Y9XFxcXHNdKicgKyBzcmNbTUFJTlZFUlNJT05MT09TRV0gK1xuICAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICc/JyArXG4gICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnZhciBMT09TRSA9IFIrKztcbnNyY1tMT09TRV0gPSAnXicgKyBMT09TRVBMQUlOICsgJyQnO1xuXG52YXIgR1RMVCA9IFIrKztcbnNyY1tHVExUXSA9ICcoKD86PHw+KT89PyknO1xuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG52YXIgWFJBTkdFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKic7XG52YXIgWFJBTkdFSURFTlRJRklFUiA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKic7XG5cbnZhciBYUkFOR0VQTEFJTiA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTl0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFUExBSU5MT09TRSA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTkxPT1NFXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0UgPSBSKys7XG5zcmNbWFJBTkdFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBYUkFOR0VMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG52YXIgQ09FUkNFID0gUisrO1xuc3JjW0NPRVJDRV0gPSAnKD86XnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pJyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86JHxbXlxcXFxkXSknO1xuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxudmFyIExPTkVUSUxERSA9IFIrKztcbnNyY1tMT05FVElMREVdID0gJyg/On4+PyknO1xuXG52YXIgVElMREVUUklNID0gUisrO1xuc3JjW1RJTERFVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVUSUxERV0gKyAnXFxcXHMrJztcbnJlW1RJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tUSUxERVRSSU1dLCAnZycpO1xudmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcblxudmFyIFRJTERFID0gUisrO1xuc3JjW1RJTERFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBUSUxERUxPT1NFID0gUisrO1xuc3JjW1RJTERFTE9PU0VdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG52YXIgTE9ORUNBUkVUID0gUisrO1xuc3JjW0xPTkVDQVJFVF0gPSAnKD86XFxcXF4pJztcblxudmFyIENBUkVUVFJJTSA9IFIrKztcbnNyY1tDQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FQ0FSRVRdICsgJ1xcXFxzKyc7XG5yZVtDQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ0FSRVRUUklNXSwgJ2cnKTtcbnZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXic7XG5cbnZhciBDQVJFVCA9IFIrKztcbnNyY1tDQVJFVF0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgQ0FSRVRMT09TRSA9IFIrKztcbnNyY1tDQVJFVExPT1NFXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxudmFyIENPTVBBUkFUT1JMT09TRSA9IFIrKztcbnNyY1tDT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICcpJHxeJCc7XG52YXIgQ09NUEFSQVRPUiA9IFIrKztcbnNyY1tDT01QQVJBVE9SXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIEZVTExQTEFJTiArICcpJHxeJCc7XG5cblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbnZhciBDT01QQVJBVE9SVFJJTSA9IFIrKztcbnNyY1tDT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0dUTFRdICtcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJ3wnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJztcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpO1xudmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnO1xuXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG52YXIgSFlQSEVOUkFOR0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG52YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbnZhciBTVEFSID0gUisrO1xuc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConO1xuXG4vLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5mb3IgKHZhciBpID0gMDsgaSA8IFI7IGkrKykge1xuICBkZWJ1ZyhpLCBzcmNbaV0pO1xuICBpZiAoIXJlW2ldKVxuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiBwYXJzZSh2ZXJzaW9uLCBsb29zZSkge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHIgPSBsb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdO1xuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLnZhbGlkID0gdmFsaWQ7XG5mdW5jdGlvbiB2YWxpZCh2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIGxvb3NlKTtcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsO1xufVxuXG5cbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmZ1bmN0aW9uIGNsZWFuKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBsb29zZSk7XG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXI7XG5cbmZ1bmN0aW9uIFNlbVZlcih2ZXJzaW9uLCBsb29zZSkge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBsb29zZSlcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIGVsc2VcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcblxuICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgbG9vc2UpO1xuICB0aGlzLmxvb3NlID0gbG9vc2U7XG4gIHZhciBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gobG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXSk7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gIHRoaXMucmF3ID0gdmVyc2lvbjtcblxuICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICB0aGlzLm1ham9yID0gK21bMV07XG4gIHRoaXMubWlub3IgPSArbVsyXTtcbiAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuXG4gIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICBpZiAoIW1bNF0pXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gIGVsc2VcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICB2YXIgbnVtID0gK2lkO1xuICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkO1xuICAgIH0pO1xuXG4gIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVyc2lvbiA9IHRoaXMubWFqb3IgKyAnLicgKyB0aGlzLm1pbm9yICsgJy4nICsgdGhpcy5wYXRjaDtcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgdGhpcy52ZXJzaW9uICs9ICctJyArIHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJyk7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMubG9vc2UsIG90aGVyKTtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcik7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVNYWluID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaCk7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVQcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAtMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMDtcblxuICB2YXIgaSA9IDA7XG4gIGRvIHtcbiAgICB2YXIgYSA9IHRoaXMucHJlcmVsZWFzZVtpXTtcbiAgICB2YXIgYiA9IG90aGVyLnByZXJlbGVhc2VbaV07XG4gICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEgPT09IGIpXG4gICAgICBjb250aW51ZTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICB9IHdoaWxlICgrK2kpO1xufTtcblxuLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuU2VtVmVyLnByb3RvdHlwZS5pbmMgPSBmdW5jdGlvbihyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gIHN3aXRjaCAocmVsZWFzZSkge1xuICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLm1pbm9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgLy8gcHJlcGF0Y2guXG4gICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21ham9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fCB0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1pbm9yKys7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wYXRjaCsrO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgIC8vIDEuMC4wIFwicHJlXCIgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICBjYXNlICdwcmUnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKys7XG4gICAgICAgICAgICBpID0gLTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAtMSkgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApO1xuICAgICAgfVxuICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAnICsgcmVsZWFzZSk7XG4gIH1cbiAgdGhpcy5mb3JtYXQoKTtcbiAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuZXhwb3J0cy5pbmMgPSBpbmM7XG5mdW5jdGlvbiBpbmModmVyc2lvbiwgcmVsZWFzZSwgbG9vc2UsIGlkZW50aWZpZXIpIHtcbiAgaWYgKHR5cGVvZihsb29zZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IGxvb3NlO1xuICAgIGxvb3NlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb247XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5kaWZmID0gZGlmZjtcbmZ1bmN0aW9uIGRpZmYodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHYxID0gcGFyc2UodmVyc2lvbjEpO1xuICAgIHZhciB2MiA9IHBhcnNlKHZlcnNpb24yKTtcbiAgICBpZiAodjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcmUnK2tleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAncHJlcmVsZWFzZSc7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVycztcblxudmFyIG51bWVyaWMgPSAvXlswLTldKyQvO1xuZnVuY3Rpb24gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gIHZhciBibnVtID0gbnVtZXJpYy50ZXN0KGIpO1xuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2E7XG4gICAgYiA9ICtiO1xuICB9XG5cbiAgcmV0dXJuIChhbnVtICYmICFibnVtKSA/IC0xIDpcbiAgICAgICAgIChibnVtICYmICFhbnVtKSA/IDEgOlxuICAgICAgICAgYSA8IGIgPyAtMSA6XG4gICAgICAgICBhID4gYiA/IDEgOlxuICAgICAgICAgMDtcbn1cblxuZXhwb3J0cy5yY29tcGFyZUlkZW50aWZpZXJzID0gcmNvbXBhcmVJZGVudGlmaWVycztcbmZ1bmN0aW9uIHJjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpO1xufVxuXG5leHBvcnRzLm1ham9yID0gbWFqb3I7XG5mdW5jdGlvbiBtYWpvcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3I7XG59XG5cbmV4cG9ydHMubWlub3IgPSBtaW5vcjtcbmZ1bmN0aW9uIG1pbm9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vcjtcbn1cblxuZXhwb3J0cy5wYXRjaCA9IHBhdGNoO1xuZnVuY3Rpb24gcGF0Y2goYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoO1xufVxuXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xuZnVuY3Rpb24gY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSk7XG59XG5cbmV4cG9ydHMuY29tcGFyZUxvb3NlID0gY29tcGFyZUxvb3NlO1xuZnVuY3Rpb24gY29tcGFyZUxvb3NlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSk7XG59XG5cbmV4cG9ydHMucmNvbXBhcmUgPSByY29tcGFyZTtcbmZ1bmN0aW9uIHJjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGIsIGEsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbmZ1bmN0aW9uIHNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnJzb3J0ID0gcnNvcnQ7XG5mdW5jdGlvbiByc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmd0ID0gZ3Q7XG5mdW5jdGlvbiBndChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwO1xufVxuXG5leHBvcnRzLmx0ID0gbHQ7XG5mdW5jdGlvbiBsdChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwO1xufVxuXG5leHBvcnRzLmVxID0gZXE7XG5mdW5jdGlvbiBlcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDA7XG59XG5cbmV4cG9ydHMubmVxID0gbmVxO1xuZnVuY3Rpb24gbmVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMDtcbn1cblxuZXhwb3J0cy5ndGUgPSBndGU7XG5mdW5jdGlvbiBndGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDA7XG59XG5cbmV4cG9ydHMubHRlID0gbHRlO1xuZnVuY3Rpb24gbHRlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwO1xufVxuXG5leHBvcnRzLmNtcCA9IGNtcDtcbmZ1bmN0aW9uIGNtcChhLCBvcCwgYiwgbG9vc2UpIHtcbiAgdmFyIHJldDtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgPT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhICE9PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJzogY2FzZSAnPSc6IGNhc2UgJz09JzogcmV0ID0gZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICchPSc6IHJldCA9IG5lcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz4nOiByZXQgPSBndChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz49JzogcmV0ID0gZ3RlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPCc6IHJldCA9IGx0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPD0nOiByZXQgPSBsdGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydHMuQ29tcGFyYXRvciA9IENvbXBhcmF0b3I7XG5mdW5jdGlvbiBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKSB7XG4gIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIGlmIChjb21wLmxvb3NlID09PSBsb29zZSlcbiAgICAgIHJldHVybiBjb21wO1xuICAgIGVsc2VcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKVxuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG5cbiAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBsb29zZSk7XG4gIHRoaXMubG9vc2UgPSBsb29zZTtcbiAgdGhpcy5wYXJzZShjb21wKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICB0aGlzLnZhbHVlID0gJyc7XG4gIGVsc2VcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb247XG5cbiAgZGVidWcoJ2NvbXAnLCB0aGlzKTtcbn1cblxudmFyIEFOWSA9IHt9O1xuQ29tcGFyYXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihjb21wKSB7XG4gIHZhciByID0gdGhpcy5sb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTtcbiAgdmFyIG0gPSBjb21wLm1hdGNoKHIpO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNvbXBhcmF0b3I6ICcgKyBjb21wKTtcblxuICB0aGlzLm9wZXJhdG9yID0gbVsxXTtcbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9JylcbiAgICB0aGlzLm9wZXJhdG9yID0gJyc7XG5cbiAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gIGlmICghbVsyXSlcbiAgICB0aGlzLnNlbXZlciA9IEFOWTtcbiAgZWxzZVxuICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5sb29zZSk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oY29tcCwgbG9vc2UpIHtcbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB2YXIgcmFuZ2VUbXA7XG5cbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgbG9vc2UpO1xuICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIGxvb3NlKTtcbiAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKHRoaXMudmFsdWUsIGxvb3NlKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgbG9vc2UpO1xuICB9XG5cbiAgdmFyIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKTtcbiAgdmFyIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uO1xuICB2YXIgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIGxvb3NlKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKSk7XG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBsb29zZSkgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JykpO1xuXG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW47XG59O1xuXG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmZ1bmN0aW9uIFJhbmdlKHJhbmdlLCBsb29zZSkge1xuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgIGlmIChyYW5nZS5sb29zZSA9PT0gbG9vc2UpIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIGxvb3NlKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS52YWx1ZSwgbG9vc2UpO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG5cbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuXG4gIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gIHRoaXMucmF3ID0gcmFuZ2U7XG4gIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpO1xuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gIH1cblxuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24oY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKTtcbiAgfSkuam9pbignfHwnKS50cmltKCk7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICB2YXIgbG9vc2UgPSB0aGlzLmxvb3NlO1xuICByYW5nZSA9IHJhbmdlLnRyaW0oKTtcbiAgZGVidWcoJ3JhbmdlJywgcmFuZ2UsIGxvb3NlKTtcbiAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gIHZhciBociA9IGxvb3NlID8gcmVbSFlQSEVOUkFOR0VMT09TRV0gOiByZVtIWVBIRU5SQU5HRV07XG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSk7XG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKTtcbiAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSk7XG4gIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbQ09NUEFSQVRPUlRSSU1dKTtcblxuICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW1RJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpO1xuXG4gIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSk7XG5cbiAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpO1xuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgc2V0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJykuc3BsaXQoL1xccysvKTtcbiAgaWYgKHRoaXMubG9vc2UpIHtcbiAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24oY29tcCkge1xuICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChjb21wUmUpO1xuICAgIH0pO1xuICB9XG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZXQ7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJhbmdlLCBsb29zZSkge1xuICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldC5zb21lKGZ1bmN0aW9uKHRoaXNDb21wYXJhdG9ycykge1xuICAgIHJldHVybiB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByYW5nZS5zZXQuc29tZShmdW5jdGlvbihyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgbG9vc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmV4cG9ydHMudG9Db21wYXJhdG9ycyA9IHRvQ29tcGFyYXRvcnM7XG5mdW5jdGlvbiB0b0NvbXBhcmF0b3JzKHJhbmdlLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSkuc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH0pLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgfSk7XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvcihjb21wLCBsb29zZSkge1xuICBkZWJ1ZygnY29tcCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3N0YXJzJywgY29tcCk7XG4gIHJldHVybiBjb21wO1xufVxuXG5mdW5jdGlvbiBpc1goaWQpIHtcbiAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJztcbn1cblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjBcbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZXMoY29tcCwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlVGlsZGUoY29tcCwgbG9vc2UpIHtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW1RJTERFTE9PU0VdIDogcmVbVElMREVdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKVxuICAgICAgcmV0ID0gJyc7XG4gICAgZWxzZSBpZiAoaXNYKG0pKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIGVsc2UgaWYgKGlzWChwKSlcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfSBlbHNlXG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXRzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0KGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIGxvb3NlKTtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW0NBUkVUTE9PU0VdIDogcmVbQ0FSRVRdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKVxuICAgICAgcmV0ID0gJyc7XG4gICAgZWxzZSBpZiAoaXNYKG0pKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJylcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZXMoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgbG9vc2UpO1xuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2UoY29tcCwgbG9vc2UpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpO1xuICB2YXIgciA9IGxvb3NlID8gcmVbWFJBTkdFTE9PU0VdIDogcmVbWFJBTkdFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpO1xuICAgIHZhciB4TSA9IGlzWChNKTtcbiAgICB2YXIgeG0gPSB4TSB8fCBpc1gobSk7XG4gICAgdmFyIHhwID0geG0gfHwgaXNYKHApO1xuICAgIHZhciBhbnlYID0geHA7XG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpXG4gICAgICBndGx0ID0gJyc7XG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKVxuICAgICAgICBtID0gMDtcbiAgICAgIGlmICh4cClcbiAgICAgICAgcCA9IDA7XG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgLy8gPjEuMi4zID0+ID49IDEuMi40XG4gICAgICAgIGd0bHQgPSAnPj0nO1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnO1xuICAgICAgICBpZiAoeG0pXG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IGd0bHQgKyBNICsgJy4nICsgbSArICcuJyArIHA7XG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5mdW5jdGlvbiByZXBsYWNlU3RhcnMoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIGxvb3NlKTtcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW1NUQVJdLCAnJyk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW0hZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wXG5mdW5jdGlvbiBoeXBoZW5SZXBsYWNlKCQwLFxuICAgICAgICAgICAgICAgICAgICAgICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICAgICAgICAgICAgICAgICAgICAgICB0bywgdE0sIHRtLCB0cCwgdHByLCB0Yikge1xuXG4gIGlmIChpc1goZk0pKVxuICAgIGZyb20gPSAnJztcbiAgZWxzZSBpZiAoaXNYKGZtKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1goZnApKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7XG4gIGVsc2VcbiAgICBmcm9tID0gJz49JyArIGZyb207XG5cbiAgaWYgKGlzWCh0TSkpXG4gICAgdG8gPSAnJztcbiAgZWxzZSBpZiAoaXNYKHRtKSlcbiAgICB0byA9ICc8JyArICgrdE0gKyAxKSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKHRwKSlcbiAgICB0byA9ICc8JyArIHRNICsgJy4nICsgKCt0bSArIDEpICsgJy4wJztcbiAgZWxzZSBpZiAodHByKVxuICAgIHRvID0gJzw9JyArIHRNICsgJy4nICsgdG0gKyAnLicgKyB0cCArICctJyArIHRwcjtcbiAgZWxzZVxuICAgIHRvID0gJzw9JyArIHRvO1xuXG4gIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKCk7XG59XG5cblxuLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGlmICghdmVyc2lvbilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24pKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdGVzdFNldChzZXQsIHZlcnNpb24pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcik7XG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhbGxvd2VkID0gc2V0W2ldLnNlbXZlcjtcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuc2F0aXNmaWVzID0gc2F0aXNmaWVzO1xuZnVuY3Rpb24gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xufVxuXG5leHBvcnRzLm1heFNhdGlzZnlpbmcgPSBtYXhTYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWF4U2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIGxvb3NlKSB7XG4gIHZhciBtYXggPSBudWxsO1xuICB2YXIgbWF4U1YgPSBudWxsO1xuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIGxvb3NlKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHsgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHY7XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIGxvb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXg7XG59XG5cbmV4cG9ydHMubWluU2F0aXNmeWluZyA9IG1pblNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtaW5TYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgbG9vc2UpIHtcbiAgdmFyIG1pbiA9IG51bGw7XG4gIHZhciBtaW5TViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7IC8vIHNhdGlzZmllcyh2LCByYW5nZSwgbG9vc2UpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7IC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2O1xuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBsb29zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluO1xufVxuXG5leHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlO1xuZnVuY3Rpb24gdmFsaWRSYW5nZShyYW5nZSwgbG9vc2UpIHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpLnJhbmdlIHx8ICcqJztcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmV4cG9ydHMubHRyID0gbHRyO1xuZnVuY3Rpb24gbHRyKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBsb29zZSk7XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmV4cG9ydHMuZ3RyID0gZ3RyO1xuZnVuY3Rpb24gZ3RyKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBsb29zZSk7XG59XG5cbmV4cG9ydHMub3V0c2lkZSA9IG91dHNpZGU7XG5mdW5jdGlvbiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBsb29zZSkge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG5cbiAgdmFyIGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcDtcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3Q7XG4gICAgICBsdGVmbiA9IGx0ZTtcbiAgICAgIGx0Zm4gPSBsdDtcbiAgICAgIGNvbXAgPSAnPic7XG4gICAgICBlY29tcCA9ICc+PSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdDtcbiAgICAgIGx0ZWZuID0gZ3RlO1xuICAgICAgbHRmbiA9IGd0O1xuICAgICAgY29tcCA9ICc8JztcbiAgICAgIGVjb21wID0gJzw9JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpO1xuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBsb29zZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuXG4gICAgdmFyIGhpZ2ggPSBudWxsO1xuICAgIHZhciBsb3cgPSBudWxsO1xuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvcjtcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yO1xuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBsb29zZSkpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3I7XG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIGxvb3NlKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcbmZ1bmN0aW9uIHByZXJlbGVhc2UodmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIGxvb3NlKTtcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbDtcbn1cblxuZXhwb3J0cy5pbnRlcnNlY3RzID0gaW50ZXJzZWN0cztcbmZ1bmN0aW9uIGludGVyc2VjdHMocjEsIHIyLCBsb29zZSkge1xuICByMSA9IG5ldyBSYW5nZShyMSwgbG9vc2UpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBsb29zZSlcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5cbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZnVuY3Rpb24gY29lcmNlKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpXG4gICAgcmV0dXJuIHZlcnNpb247XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW0NPRVJDRV0pO1xuXG4gIGlmIChtYXRjaCA9PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBwYXJzZSgobWF0Y2hbMV0gfHwgJzAnKSArICcuJyArIChtYXRjaFsyXSB8fCAnMCcpICsgJy4nICsgKG1hdGNoWzNdIHx8ICcwJykpOyBcbn1cbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGNyeXB0ID0gcmVxdWlyZSgnY3J5cHQnKSxcbiAgICAgIHV0ZjggPSByZXF1aXJlKCdjaGFyZW5jJykudXRmOCxcbiAgICAgIGJpbiA9IHJlcXVpcmUoJ2NoYXJlbmMnKS5iaW4sXG5cbiAgLy8gVGhlIGNvcmVcbiAgc2hhMSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XG4gICAgaWYgKG1lc3NhZ2UuY29uc3RydWN0b3IgPT0gU3RyaW5nKVxuICAgICAgbWVzc2FnZSA9IHV0Zjguc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKVxuICAgICAgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UsIDApO1xuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKVxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcblxuICAgIC8vIG90aGVyd2lzZSBhc3N1bWUgYnl0ZSBhcnJheVxuXG4gICAgdmFyIG0gID0gY3J5cHQuYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpLFxuICAgICAgICBsICA9IG1lc3NhZ2UubGVuZ3RoICogOCxcbiAgICAgICAgdyAgPSBbXSxcbiAgICAgICAgSDAgPSAgMTczMjU4NDE5MyxcbiAgICAgICAgSDEgPSAtMjcxNzMzODc5LFxuICAgICAgICBIMiA9IC0xNzMyNTg0MTk0LFxuICAgICAgICBIMyA9ICAyNzE3MzM4NzgsXG4gICAgICAgIEg0ID0gLTEwMDk1ODk3NzY7XG5cbiAgICAvLyBQYWRkaW5nXG4gICAgbVtsID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbCAlIDMyKTtcbiAgICBtWygobCArIDY0ID4+PiA5KSA8PCA0KSArIDE1XSA9IGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IEgwLFxuICAgICAgICAgIGIgPSBIMSxcbiAgICAgICAgICBjID0gSDIsXG4gICAgICAgICAgZCA9IEgzLFxuICAgICAgICAgIGUgPSBINDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG5cbiAgICAgICAgaWYgKGogPCAxNilcbiAgICAgICAgICB3W2pdID0gbVtpICsgal07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuID0gd1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XTtcbiAgICAgICAgICB3W2pdID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSAoKEgwIDw8IDUpIHwgKEgwID4+PiAyNykpICsgSDQgKyAod1tqXSA+Pj4gMCkgKyAoXG4gICAgICAgICAgICAgICAgaiA8IDIwID8gKEgxICYgSDIgfCB+SDEgJiBIMykgKyAxNTE4NTAwMjQ5IDpcbiAgICAgICAgICAgICAgICBqIDwgNDAgPyAoSDEgXiBIMiBeIEgzKSArIDE4NTk3NzUzOTMgOlxuICAgICAgICAgICAgICAgIGogPCA2MCA/IChIMSAmIEgyIHwgSDEgJiBIMyB8IEgyICYgSDMpIC0gMTg5NDAwNzU4OCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgKEgxIF4gSDIgXiBIMykgLSA4OTk0OTc1MTQpO1xuXG4gICAgICAgIEg0ID0gSDM7XG4gICAgICAgIEgzID0gSDI7XG4gICAgICAgIEgyID0gKEgxIDw8IDMwKSB8IChIMSA+Pj4gMik7XG4gICAgICAgIEgxID0gSDA7XG4gICAgICAgIEgwID0gdDtcbiAgICAgIH1cblxuICAgICAgSDAgKz0gYTtcbiAgICAgIEgxICs9IGI7XG4gICAgICBIMiArPSBjO1xuICAgICAgSDMgKz0gZDtcbiAgICAgIEg0ICs9IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtIMCwgSDEsIEgyLCBIMywgSDRdO1xuICB9LFxuXG4gIC8vIFB1YmxpYyBBUElcbiAgYXBpID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGlnZXN0Ynl0ZXMgPSBjcnlwdC53b3Jkc1RvQnl0ZXMoc2hhMShtZXNzYWdlKSk7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPyBiaW4uYnl0ZXNUb1N0cmluZyhkaWdlc3RieXRlcykgOlxuICAgICAgICBjcnlwdC5ieXRlc1RvSGV4KGRpZ2VzdGJ5dGVzKTtcbiAgfTtcblxuICBhcGkuX2Jsb2Nrc2l6ZSA9IDE2O1xuICBhcGkuX2RpZ2VzdHNpemUgPSAyMDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGFwaTtcbn0pKCk7XG4iLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcbiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2ggKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQml0UGFja2VkQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CaXRQYWNrZWRCdWZmZXJcIik7XHJcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xyXG5jbGFzcyBBYnN0cmFjdERlY29kZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgdHlwZUlmbykge1xyXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBCaXRQYWNrZWRCdWZmZXJfMS5CaXRQYWNrZWRCdWZmZXIoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fdHlwZWluZm9zID0gdHlwZUlmbztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlKHR5cGVpZCkge1xyXG4gICAgICAgIGlmICh0eXBlaWQgPj0gdGhpcy5fdHlwZWluZm9zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29ycnVwdGVkRXJyb3IodGhpcy50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHlwZWluZm8gPSB0aGlzLl90eXBlaW5mb3NbdHlwZWlkXTtcclxuICAgICAgICByZXR1cm4gdGhpc1t0eXBlaW5mb1swXV0uYXBwbHkodGhpcywgdHlwZWluZm9bMV0pO1xyXG4gICAgfVxyXG4gICAgYnl0ZUFsaWduKCkge1xyXG4gICAgICAgIHRoaXMuX2J1ZmZlci5ieXRlQWxpZ24oKTtcclxuICAgIH1cclxuICAgIGdldCBpc0RvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5pc0RvbmU7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlZEJpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci51c2VkQml0cztcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2l6ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFic3RyYWN0RGVjb2RlciA9IEFic3RyYWN0RGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pUVdKemRISmhZM1JFWldOdlpHVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVFXSnpkSEpoWTNSRVpXTnZaR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRMEVzZFVSQlFXOUVPMEZCUTNCRUxIRkRRVUV3UXp0QlFVVXhRenRKUVVsSkxGbEJRVzFDTEVsQlFWa3NSVUZCUlN4UFFVRlBPMUZCUTNCRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NTVUZCU1N4cFEwRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzcERMRWxCUVVrc1EwRkJReXhWUVVGVkxFZEJRVWNzVDBGQlR5eERRVUZETzBsQlF6bENMRU5CUVVNN1NVRkZUU3hSUVVGUk8xRkJRMWdzVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8wbEJRMjVETEVOQlFVTTdTVUZGVFN4UlFVRlJMRU5CUVVNc1RVRkJUVHRSUVVOc1FpeEpRVUZKTEUxQlFVMHNTVUZCU1N4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUlVGQlJUdFpRVUZGTEUxQlFVMHNTVUZCU1N4MVFrRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRPMU5CUVVVN1VVRkZjRVlzVFVGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU42UXl4UFFVRlBMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNSRUxFTkJRVU03U1VGRlRTeFRRVUZUTzFGQlExb3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dEpRVU0zUWl4RFFVRkRPMGxCUlVRc1NVRkJWeXhOUVVGTk8xRkJRMklzVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVNdlFpeERRVUZETzBsQlJVUXNTVUZCVnl4UlFVRlJPMUZCUTJZc1QwRkJUeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXp0SlFVTnFReXhEUVVGRE8wbEJRMFFzU1VGQlZ5eEpRVUZKTzFGQlExZ3NUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU0zUWl4RFFVRkRPME5CUTBvN1FVRnNRMFFzTUVOQmEwTkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xyXG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcclxuY2xhc3MgQml0UGFja2VkQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGVuZGlhbiA9ICdiaWcnKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbmV4dEJpdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhIHx8IG5ldyBidWZmZXJfMS5CdWZmZXIoMCk7XHJcbiAgICAgICAgdGhpcy5fYmlnRW5kaWFuID0gZW5kaWFuID09PSAnYmlnJztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnYnVmZmVyKCcgK1xyXG4gICAgICAgICAgICAodGhpcy5fbmV4dEJpdHMgJiYgdGhpcy5fbmV4dCB8fCAwKS50b1N0cmluZygxNikgKyAnLycgKyB0aGlzLl9uZXh0Qml0cyArXHJcbiAgICAgICAgICAgICcsWycgKyB0aGlzLl91c2VkICsgJ109JyArICgodGhpcy5fdXNlZCA8IHRoaXMuX2RhdGEubGVuZ3RoKSA/IHRoaXMuX2RhdGEucmVhZFVJbnQ4KHRoaXMuX3VzZWQpLnRvU3RyaW5nKDE2KSA6ICctLScpICtcclxuICAgICAgICAgICAgJyknO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEJpdHMgPT09IDAgJiYgdGhpcy5fdXNlZCA+PSB0aGlzLl9kYXRhLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aCAqIDg7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlZEJpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZWQgKiA4IC0gdGhpcy5fbmV4dEJpdHM7XHJcbiAgICB9XHJcbiAgICBieXRlQWxpZ24oKSB7XHJcbiAgICAgICAgdGhpcy5fbmV4dEJpdHMgPSAwO1xyXG4gICAgfVxyXG4gICAgcmVhZEFsaWduZWRCeXRlcyhieXRlcykge1xyXG4gICAgICAgIHRoaXMuYnl0ZUFsaWduKCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fdXNlZCwgdGhpcy5fdXNlZCArIGJ5dGVzKTtcclxuICAgICAgICB0aGlzLl91c2VkICs9IGJ5dGVzO1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gYnl0ZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRydW5jYXRlRXJyb3IodGhpcy50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICByZWFkQml0cyhiaXRzKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XHJcbiAgICAgICAgbGV0IHJlc3VsdGJpdHMgPSAwO1xyXG4gICAgICAgIHdoaWxlIChyZXN1bHRiaXRzICE9PSBiaXRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXh0Qml0cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRydW5jYXRlRXJyb3IodGhpcy50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX25leHQgPSB0aGlzLl9kYXRhLnJlYWRVSW50OCh0aGlzLl91c2VkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VzZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25leHRCaXRzID0gODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb3B5Yml0cyA9IE1hdGgubWluKGJpdHMgLSByZXN1bHRiaXRzLCB0aGlzLl9uZXh0Qml0cyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSB0aGlzLl9uZXh0ICYgKCgxIDw8IGNvcHliaXRzKSAtIDEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYmlnRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gY29weSA8PCAoYml0cyAtIHJlc3VsdGJpdHMgLSBjb3B5Yml0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gY29weSA8PCByZXN1bHRiaXRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX25leHQgPj49IGNvcHliaXRzO1xyXG4gICAgICAgICAgICB0aGlzLl9uZXh0Qml0cyAtPSBjb3B5Yml0cztcclxuICAgICAgICAgICAgcmVzdWx0Yml0cyArPSBjb3B5Yml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlYWRVbmFsaWduZWRCeXRlcyhieXRlcykge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgYnVmZmVyXzEuQnVmZmVyKGJ5dGVzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KHRoaXMucmVhZEJpdHMoOCksIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVmZjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJpdFBhY2tlZEJ1ZmZlciA9IEJpdFBhY2tlZEJ1ZmZlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pUW1sMFVHRmphMlZrUW5WbVptVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVFtbDBVR0ZqYTJWa1FuVm1abVZ5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRMEVzYlVOQlFXZERPMEZCUTJoRExIRkRRVUY1UXp0QlFVTjZRenRKUVZGSkxGbEJRVzFDTEVsQlFWa3NSVUZCUlN4VFFVRXdRaXhMUVVGTE8xRkJUSGhFTEZWQlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRWaXhWUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEySXNZMEZCVXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVsc1FpeEpRVUZKTEVOQlFVTXNTMEZCU3l4SFFVRkhMRWxCUVVrc1NVRkJTU3hKUVVGSkxHVkJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEUxQlFVMHNTMEZCU3l4TFFVRkxMRU5CUVVNN1NVRkRka01zUTBGQlF6dEpRVWROTEZGQlFWRTdVVUZEV0N4UFFVRlBMRk5CUVZNN1dVRkRXaXhEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVsQlFVa3NTVUZCU1N4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTzFsQlEzWkZMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEhRVUZITEVsQlFVa3NSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTTdXVUZEY0Vnc1IwRkJSeXhEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZFTEVsQlFWY3NUVUZCVFR0UlFVTmlMRTlCUVU4c1NVRkJTU3hEUVVGRExGTkJRVk1zUzBGQlN5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRXRCUVVzc1NVRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXp0SlFVTnVSU3hEUVVGRE8wbEJSVVFzU1VGQlZ5eEpRVUZKTzFGQlExZ3NUMEZCVHl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZEYWtNc1EwRkJRenRKUVVWRUxFbEJRVmNzVVVGQlVUdFJRVU5tTEU5QlFVOHNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTXpReXhEUVVGRE8wbEJSVTBzVTBGQlV6dFJRVU5hTEVsQlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjc1EwRkJReXhEUVVGRE8wbEJRM1pDTEVOQlFVTTdTVUZGVFN4blFrRkJaMElzUTBGQlF5eExRVUZoTzFGQlEycERMRWxCUVVrc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFJRVU5xUWl4TlFVRk5MRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFbEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRPVVFzU1VGQlNTeERRVUZETEV0QlFVc3NTVUZCU1N4TFFVRkxMRU5CUVVNN1VVRkRjRUlzU1VGQlNTeEpRVUZKTEVOQlFVTXNUVUZCVFN4TFFVRkxMRXRCUVVzc1JVRkJSVHRaUVVOMlFpeE5RVUZOTEVsQlFVa3NjMEpCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTTFRenRSUVVORUxFOUJRVThzU1VGQlNTeERRVUZETzBsQlEyaENMRU5CUVVNN1NVRkZUU3hSUVVGUkxFTkJRVU1zU1VGQldUdFJRVU40UWl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRFppeEpRVUZKTEZWQlFWVXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkZia0lzVDBGQlR5eFZRVUZWTEV0QlFVc3NTVUZCU1N4RlFVRkZPMWxCUTNoQ0xFbEJRVWtzU1VGQlNTeERRVUZETEZOQlFWTXNTMEZCU3l4RFFVRkRMRVZCUVVVN1owSkJRM1JDTEVsQlFVa3NTVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSVHR2UWtGQlJTeE5RVUZOTEVsQlFVa3NjMEpCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0cFFrRkJSVHRuUWtGRE9VUXNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03WjBKQlF6bERMRWxCUVVrc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTm9RaXhKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXp0aFFVTjBRanRaUVVWRUxFMUJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hIUVVGSExGVkJRVlVzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkROMFFzVFVGQlRTeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJSV2hFTEVsQlFVa3NTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSVHRuUWtGRGFrSXNUVUZCVFN4SlFVRkpMRWxCUVVrc1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eFZRVUZWTEVkQlFVY3NVVUZCVVN4RFFVRkRMRU5CUVVNN1lVRkRjRVE3YVVKQlFVMDdaMEpCUTBnc1RVRkJUU3hKUVVGSkxFbEJRVWtzU1VGQlNTeFZRVUZWTEVOQlFVTTdZVUZEYUVNN1dVRkRSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eExRVUZMTEZGQlFWRXNRMEZCUXp0WlFVTjRRaXhKUVVGSkxFTkJRVU1zVTBGQlV5eEpRVUZKTEZGQlFWRXNRMEZCUXp0WlFVTXpRaXhWUVVGVkxFbEJRVWtzVVVGQlVTeERRVUZETzFOQlF6RkNPMUZCUlVRc1QwRkJUeXhOUVVGTkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0SlFVVk5MR3RDUVVGclFpeERRVUZETEV0QlFXRTdVVUZEYmtNc1RVRkJUU3hKUVVGSkxFZEJRVWNzU1VGQlNTeGxRVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRMMElzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFdEJRVXNzUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZPMWxCUXk5Q0xFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0VFFVTjRRenRSUVVORUxFOUJRVThzU1VGQlNTeERRVUZETzBsQlEyaENMRU5CUVVNN1EwRkRTanRCUVd4R1JDd3dRMEZyUmtNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcclxuY29uc3QgQWJzdHJhY3REZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdERlY29kZXJcIik7XHJcbmNsYXNzIEJpdFBhY2tlZERlY29kZXIgZXh0ZW5kcyBBYnN0cmFjdERlY29kZXJfMS5BYnN0cmFjdERlY29kZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgdHlwZUlmbykge1xyXG4gICAgICAgIHN1cGVyKGRhdGEsIHR5cGVJZm8pO1xyXG4gICAgfVxyXG4gICAgX2FycmF5KGJvdW5kcywgdHlwZWlkKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5faW50KGJvdW5kcyk7XHJcbiAgICAgICAgY29uc3QgYXIgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGFyW2ldID0gdGhpcy5pbnN0YW5jZSh0eXBlaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9XHJcbiAgICBfYml0YXJyYXkoYm91bmRzKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5faW50KGJvdW5kcyk7XHJcbiAgICAgICAgcmV0dXJuIFtsZW5ndGgsIHRoaXMuX2J1ZmZlci5yZWFkQml0cyhsZW5ndGgpXTtcclxuICAgIH1cclxuICAgIF9ibG9iKGJvdW5kcykge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX2ludChib3VuZHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZEFsaWduZWRCeXRlcyhsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgX2Jvb2woKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludChbMCwgMV0pICE9PSAwO1xyXG4gICAgfVxyXG4gICAgX2Nob2ljZShib3VuZHMsIGZpZWxkcykge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMuX2ludChib3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFmaWVsZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29ycnVwdGVkRXJyb3IodGhpcy50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0ID0ge307XHJcbiAgICAgICAgcmV0W2ZpZWxkWzBdXSA9IHRoaXMuaW5zdGFuY2UoZmllbGRbMV0pO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBfZm91cmNjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZFVuYWxpZ25lZEJ5dGVzKDQpO1xyXG4gICAgfVxyXG4gICAgX2ludChib3VuZHMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGJvdW5kc1swXSArIHRoaXMuX2J1ZmZlci5yZWFkQml0cyhib3VuZHNbMV0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIF9udWxsKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgX29wdGlvbmFsKHR5cGVpZCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHRoaXMuX2Jvb2woKTtcclxuICAgICAgICByZXR1cm4gZXhpc3RzID8gdGhpcy5pbnN0YW5jZSh0eXBlaWQpIDogbnVsbDtcclxuICAgIH1cclxuICAgIF9yZWFsMzIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkVW5hbGlnbmVkQnl0ZXMoNCkucmVhZEZsb2F0QkUoMCk7XHJcbiAgICB9XHJcbiAgICBfcmVhbDY0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZFVuYWxpZ25lZEJ5dGVzKDgpLnJlYWREb3VibGVCRSgwKTtcclxuICAgIH1cclxuICAgIF9zdHJ1Y3QoZmllbGRzKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkWzBdID09PSAnX19wYXJlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmluc3RhbmNlKGZpZWxkWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgdHlwZW9mIHBhcmVudCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24ocmVzdWx0LCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZFswXV0gPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRbMF1dID0gdGhpcy5pbnN0YW5jZShmaWVsZFsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQml0UGFja2VkRGVjb2RlciA9IEJpdFBhY2tlZERlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVFtbDBVR0ZqYTJWa1JHVmpiMlJsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJa0pwZEZCaFkydGxaRVJsWTI5a1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGRlFTeHhRMEZCTUVNN1FVRkRNVU1zZFVSQlFXOUVPMEZCUjNCRUxITkNRVUU0UWl4VFFVRlJMR2xEUVVGbE8wbEJSV3BFTEZsQlFXMUNMRWxCUVZrc1JVRkJSU3hQUVVGUE8xRkJRM0JETEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGVrSXNRMEZCUXp0SlFVVk5MRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzVFVGQlRUdFJRVU40UWl4TlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTJwRExFMUJRVTBzUlVGQlJTeEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVTmtMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4TlFVRk5MRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU5vUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRUUVVOcVF6dFJRVU5FTEU5QlFVOHNSVUZCUlN4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWTkxGTkJRVk1zUTBGQlF5eE5RVUZOTzFGQlEyNUNMRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRha01zVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTI1RUxFTkJRVU03U1VGRlRTeExRVUZMTEVOQlFVTXNUVUZCVFR0UlFVTm1MRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRha01zVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMR2RDUVVGblFpeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTJwRUxFTkJRVU03U1VGRlRTeExRVUZMTzFGQlExSXNUMEZCVHl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRMjVETEVOQlFVTTdTVUZGVFN4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTA3VVVGRGVrSXNUVUZCVFN4SFFVRkhMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTTVRaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRNVUlzU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlR0WlFVRkZMRTFCUVUwc1NVRkJTU3gxUWtGQll5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRVVU3VVVGRE1VUXNUVUZCVFN4SFFVRkhMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJRMllzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFTXNUMEZCVHl4SFFVRkhMRU5CUVVNN1NVRkRaaXhEUVVGRE8wbEJSVTBzVDBGQlR6dFJRVU5XTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNNVF5eERRVUZETzBsQlJVMHNTVUZCU1N4RFFVRkRMRTFCUVUwN1VVRkRaQ3hOUVVGTkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE0wUXNUMEZCVHl4TFFVRkxMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZOTEV0QlFVczdVVUZEVWl4UFFVRlBMRWxCUVVrc1EwRkJRenRKUVVOb1FpeERRVUZETzBsQlJVMHNVMEZCVXl4RFFVRkRMRTFCUVUwN1VVRkRia0lzVFVGQlRTeE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRE8xRkJRelZDTEU5QlFVOHNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU03U1VGRGFrUXNRMEZCUXp0SlFVVk5MRTlCUVU4N1VVRkRWaXhQUVVGUExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRemRFTEVOQlFVTTdTVUZGVFN4UFFVRlBPMUZCUTFZc1QwRkJUeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNNVJDeERRVUZETzBsQlJVMHNUMEZCVHl4RFFVRkRMRTFCUVUwN1VVRkRha0lzU1VGQlNTeE5RVUZOTEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUTJoQ0xFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUVVVN1dVRkRia0lzU1VGQlNTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1ZVRkJWU3hGUVVGRk8yZENRVU42UWl4TlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU4yUXl4SlFVRkpMRTFCUVUwc1NVRkJTU3hQUVVGUExFMUJRVTBzUzBGQlN5eFJRVUZSTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF5eEZRVUZGTzI5Q1FVTm9SU3hOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03YVVKQlF6RkRPM0ZDUVVGTkxFbEJRVWtzVFVGQlRTeERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRVZCUVVVN2IwSkJRelZDTEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNN2FVSkJRMjVDTzNGQ1FVRk5PMjlDUVVOSUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU03YVVKQlF6ZENPMkZCUTBvN2FVSkJRVTA3WjBKQlEwZ3NUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdZVUZET1VNN1VVRkRUQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5JTEU5QlFVOHNUVUZCVFN4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03UTBGSFNqdEJRWEJHUkN3MFEwRnZSa01pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xyXG5jb25zdCBBYnN0cmFjdERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0RGVjb2RlclwiKTtcclxuY29uc3QgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpO1xyXG5jbGFzcyBWZXJzaW9uRGVjb2RlciBleHRlbmRzIEFic3RyYWN0RGVjb2Rlcl8xLkFic3RyYWN0RGVjb2RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlSWZvKSB7XHJcbiAgICAgICAgc3VwZXIoZGF0YSwgdHlwZUlmbyk7XHJcbiAgICB9XHJcbiAgICBfZXhwZWN0U2tpcChleHBlY3RlZCkge1xyXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLl9idWZmZXIucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgaWYgKHIgIT09IGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db3JydXB0ZWRFcnJvcih0aGlzLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICB9XHJcbiAgICBfdmludCgpIHtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuX2J1ZmZlci5yZWFkQml0cyg4KTtcclxuICAgICAgICBjb25zdCBuZWdhdGl2ZSA9IGIgJiAxO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAoYiA+PiAxKSAmIDB4M2Y7XHJcbiAgICAgICAgbGV0IGJpdHMgPSA2O1xyXG4gICAgICAgIHdoaWxlICgoYiAmIDB4ODApICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLl9idWZmZXIucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgICAgIGxldCBteUxvbmcgPSBuZXcgTG9uZztcclxuICAgICAgICAgICAgbXlMb25nID0gTG9uZy5mcm9tU3RyaW5nKHJlc3VsdC50b1N0cmluZygpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG15TG9uZy5vcigoYiAmIDB4N2YpICogTWF0aC5wb3coMiwgYml0cykpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGJpdHMgKz0gNztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQocmVzdWx0LnRvU3RyaW5nKCksIDEwKTtcclxuICAgICAgICByZXR1cm4gbmVnYXRpdmUgPyAtcmVzdWx0IDogcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2FycmF5KGJvdW5kcywgdHlwZWlkKSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCgwKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgY29uc3QgYXIgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyW2ldID0gdGhpcy5pbnN0YW5jZSh0eXBlaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9XHJcbiAgICBfYml0YXJyYXkoYm91bmRzKSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCgxKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgcmV0dXJuIFtsZW5ndGgsIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKChsZW5ndGggKyA3KSAvIDgpXTtcclxuICAgIH1cclxuICAgIF9ibG9iKGJvdW5kcykge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoMik7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5fdmludCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZEFsaWduZWRCeXRlcyhsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgX2Jvb2woKSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCg2KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnJlYWRCaXRzKDgpICE9PSAwO1xyXG4gICAgfVxyXG4gICAgX2Nob2ljZShib3VuZHMsIGZpZWxkcykge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoMyk7XHJcbiAgICAgICAgY29uc3QgdGFnID0gdGhpcy5fdmludCgpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFmaWVsZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9za2lwSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXQgPSB7fTtcclxuICAgICAgICByZXRbZmllbGRbMF1dID0gdGhpcy5pbnN0YW5jZShmaWVsZFsxXSk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIF9mb3VyY2MoKSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCg3KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoNCk7XHJcbiAgICB9XHJcbiAgICBfaW50KCkge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoOSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpbnQoKTtcclxuICAgIH1cclxuICAgIF9udWxsKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgX29wdGlvbmFsKHR5cGVpZCkge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoNCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RzID0gdGhpcy5fYnVmZmVyLnJlYWRCaXRzKDgpICE9PSAwO1xyXG4gICAgICAgIHJldHVybiBleGlzdHMgPyB0aGlzLmluc3RhbmNlKHR5cGVpZCkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgX3JlYWwzMigpIHtcclxuICAgICAgICB0aGlzLl9leHBlY3RTa2lwKDcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZEFsaWduZWRCeXRlcyg0KS5yZWFkRmxvYXRCRSgwKTtcclxuICAgIH1cclxuICAgIF9yZWFsNjQoKSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCg4KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoOCkucmVhZERvdWJsZUJFKDApO1xyXG4gICAgfVxyXG4gICAgX3N0cnVjdChmaWVsZHMpIHtcclxuICAgICAgICBmdW5jdGlvbiBtYXRjaFRhZyh0YWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZyA9PT0gZmllbGRbMl07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoNSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHMuZmluZChtYXRjaFRhZyh0YWcpKTtcclxuICAgICAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRbMF0gPT09ICdfX3BhcmVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmluc3RhbmNlKGZpZWxkWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkWzBdXSA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRbMF1dID0gdGhpcy5pbnN0YW5jZShmaWVsZFsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9za2lwSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgX3NraXBJbnN0YW5jZSgpIHtcclxuICAgICAgICBjb25zdCBza2lwID0gdGhpcy5fYnVmZmVyLnJlYWRCaXRzKDgpO1xyXG4gICAgICAgIGxldCBsZW5ndGg7XHJcbiAgICAgICAgbGV0IGV4aXN0cztcclxuICAgICAgICBsZXQgdGFnO1xyXG4gICAgICAgIGlmIChza2lwID09PSAwKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2tpcEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA9PT0gMSkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKChsZW5ndGggKyA3KSAvIDgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChza2lwID09PSAyKSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMobGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA9PT0gMykge1xyXG4gICAgICAgICAgICB0YWcgPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NraXBJbnN0YW5jZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChza2lwID09PSA0KSB7XHJcbiAgICAgICAgICAgIGV4aXN0cyA9IHRoaXMuX2J1ZmZlci5yZWFkQml0cyg4KSAhPT0gMDtcclxuICAgICAgICAgICAgaWYgKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2tpcEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA9PT0gNSkge1xyXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHRhZyA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NraXBJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNraXAgPT09IDYpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNraXAgPT09IDcpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNraXAgPT09IDgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoOCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNraXAgPT09IDkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmludCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLlZlcnNpb25EZWNvZGVyID0gVmVyc2lvbkRlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVZtVnljMmx2YmtSbFkyOWtaWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SldaWEp6YVc5dVJHVmpiMlJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVWRCTEhGRFFVRXdRenRCUVVNeFF5eDFSRUZCYjBRN1FVRkRjRVFzTmtKQlFUWkNPMEZCUlRkQ0xHOUNRVUUwUWl4VFFVRlJMR2xEUVVGbE8wbEJSeTlETEZsQlFXMUNMRWxCUVZrc1JVRkJSU3hQUVVGUE8xRkJRM0JETEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGVrSXNRMEZCUXp0SlFVZE5MRmRCUVZjc1EwRkJReXhSUVVGUk8xRkJRM1pDTEUxQlFVMHNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTI1RExFbEJRVWtzUTBGQlF5eExRVUZMTEZGQlFWRXNSVUZCUlR0WlFVRkZMRTFCUVUwc1NVRkJTU3gxUWtGQll5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGQk8xTkJRVVU3VVVGQlFTeERRVUZETzBsQlEzUkZMRU5CUVVNN1NVRkZUU3hMUVVGTE8xRkJRMUlzU1VGQlNTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtNc1RVRkJUU3hSUVVGUkxFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTjJRaXhKUVVGSkxFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRE4wSXNTVUZCU1N4SlFVRkpMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJSV0lzVDBGQlR5eERRVUZETEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGRGNrSXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUlRkQ0xFbEJRVWtzVFVGQlRTeEhRVUZITEVsQlFVa3NTVUZCU1N4RFFVRkRPMWxCUTNSQ0xFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhSUVVGUkxFVkJRVVVzUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUXp0WlFVTnVSQ3hOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMWxCUXpsRUxFbEJRVWtzU1VGQlNTeERRVUZETEVOQlFVTTdVMEZEWWp0UlFVTkVMRTFCUVUwc1IwRkJSeXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEZGQlFWRXNSVUZCUlN4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRM3BETEU5QlFVOHNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTNaRExFTkJRVU03U1VGQlFTeERRVUZETzBsQlJVc3NUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSU3hOUVVGTk8xRkJRM2hDTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNFSXNUVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzFGQlF6VkNMRTFCUVUwc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF6dFJRVU5rTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1dVRkROMElzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVMEZEYWtNN1VVRkRSQ3hQUVVGUExFVkJRVVVzUTBGQlF6dEpRVU5rTEVOQlFVTTdTVUZGVFN4VFFVRlRMRU5CUVVNc1RVRkJUVHRSUVVOdVFpeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0JDTEUxQlFVMHNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dFJRVU0xUWl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU55UlN4RFFVRkRPMGxCUlUwc1MwRkJTeXhEUVVGRExFMUJRVTA3VVVGRFppeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0JDTEUxQlFVMHNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dFJRVU0xUWl4UFFVRlBMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRGFrUXNRMEZCUXp0SlFVVk5MRXRCUVVzN1VVRkRVaXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCQ0xFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZUU3hQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTEUxQlFVMDdVVUZEZWtJc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndRaXhOUVVGTkxFZEJRVWNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1VVRkRla0lzVFVGQlRTeExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJRekZDTEVsQlFVa3NRMEZCUXl4TFFVRkxMRVZCUVVVN1dVRkRVaXhKUVVGSkxFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTTdXVUZEY2tJc1QwRkJUeXhGUVVGRkxFTkJRVU03VTBGRFlqdFJRVU5FTEUxQlFVMHNSMEZCUnl4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVObUxFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM2hETEU5QlFVOHNSMEZCUnl4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVWTkxFOUJRVTg3VVVGRFZpeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0JDTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNMVF5eERRVUZETzBsQlJVMHNTVUZCU1R0UlFVTlFMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY0VJc1QwRkJUeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdTVUZEZUVJc1EwRkJRenRKUVVWTkxFdEJRVXM3VVVGRFVpeFBRVUZQTEVsQlFVa3NRMEZCUXp0SlFVTm9RaXhEUVVGRE8wbEJSVTBzVTBGQlV5eERRVUZETEUxQlFVMDdVVUZEYmtJc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndRaXhOUVVGTkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdVVUZET1VNc1QwRkJUeXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTnFSQ3hEUVVGRE8wbEJSVTBzVDBGQlR6dFJRVU5XTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNFSXNUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3hEUVVGRE8wbEJSVTBzVDBGQlR6dFJRVU5XTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNFSXNUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTFSQ3hEUVVGRE8wbEJSVTBzVDBGQlR5eERRVUZETEUxQlFVMDdVVUZEYWtJc2EwSkJRV3RDTEVkQlFVYzdXVUZEYWtJc1QwRkJUeXhWUVVGVkxFdEJRVXM3WjBKQlEyeENMRTlCUVU4c1IwRkJSeXhMUVVGTExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTFRaXhEUVVGRExFTkJRVU03VVVGRFRpeERRVUZETzFGQlEwUXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVZ3UWl4SlFVRkpMRTFCUVUwc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRGFFSXNUVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzFGQlJUVkNMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4TlFVRk5MRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU5vUXl4TlFVRk5MRWRCUVVjc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdXVUZEZWtJc1RVRkJUU3hMUVVGTExFZEJRVWNzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVY2UXl4SlFVRkpMRXRCUVVzc1JVRkJSVHRuUWtGRFVDeEpRVUZKTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhWUVVGVkxFVkJRVVU3YjBKQlEzcENMRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEzWkRMRWxCUVVrc1RVRkJUU3hKUVVGSkxFOUJRVThzVFVGQlRTeExRVUZMTEZGQlFWRXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVWQlFVVTdkMEpCUTJoRkxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dHhRa0ZETVVNN2VVSkJRVTBzU1VGQlNTeE5RVUZOTEVOQlFVTXNUVUZCVFN4TFFVRkxMRU5CUVVNc1JVRkJSVHQzUWtGRE5VSXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJRenR4UWtGRGJrSTdlVUpCUVUwN2QwSkJRMGdzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF6dHhRa0ZETjBJN2FVSkJRMG83Y1VKQlFVMDdiMEpCUTBnc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2FVSkJRemxETzJGQlEwbzdhVUpCUVUwN1owSkJRMGdzU1VGQlNTeERRVUZETEdGQlFXRXNSVUZCUlN4RFFVRkRPMkZCUTNoQ08xTkJRMG83VVVGRFJDeFBRVUZQTEUxQlFVMHNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJSVTBzWVVGQllUdFJRVU5vUWl4TlFVRk5MRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFF5eEpRVUZKTEUxQlFXTXNRMEZCUXp0UlFVTnVRaXhKUVVGSkxFMUJRV1VzUTBGQlF6dFJRVU53UWl4SlFVRkpMRWRCUVVjc1EwRkJRenRSUVVWU0xFbEJRVWtzU1VGQlNTeExRVUZMTEVOQlFVTXNSVUZCUlR0WlFVTmFMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdXVUZEZEVJc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdG5Ra0ZETjBJc1NVRkJTU3hEUVVGRExHRkJRV0VzUlVGQlJTeERRVUZETzJGQlEzaENPMU5CUTBvN1lVRkJUU3hKUVVGSkxFbEJRVWtzUzBGQlN5eERRVUZETEVWQlFVVTdXVUZEYmtJc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXp0WlFVTjBRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xTkJRMjVFTzJGQlFVMHNTVUZCU1N4SlFVRkpMRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRMjVDTEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03V1VGRGRFSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRUUVVONlF6dGhRVUZOTEVsQlFVa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1JVRkJSVHRaUVVOdVFpeEhRVUZITEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRE8xbEJRMjVDTEVsQlFVa3NRMEZCUXl4aFFVRmhMRVZCUVVVc1EwRkJRenRUUVVONFFqdGhRVUZOTEVsQlFVa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1JVRkJSVHRaUVVOdVFpeE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMWxCUTNoRExFbEJRVWtzVFVGQlRTeEZRVUZGTzJkQ1FVRkZMRWxCUVVrc1EwRkJReXhoUVVGaExFVkJRVVVzUTBGQlF6dGhRVUZGTzFOQlEzaERPMkZCUVUwc1NVRkJTU3hKUVVGSkxFdEJRVXNzUTBGQlF5eEZRVUZGTzFsQlEyNUNMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdXVUZEZEVJc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRTFCUVUwc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTzJkQ1FVTm9ReXhIUVVGSExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMmRDUVVOdVFpeEpRVUZKTEVOQlFVTXNZVUZCWVN4RlFVRkZMRU5CUVVNN1lVRkRlRUk3VTBGRFNqdGhRVUZOTEVsQlFVa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1JVRkJSVHRaUVVOdVFpeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMR2RDUVVGblFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTNCRE8yRkJRVTBzU1VGQlNTeEpRVUZKTEV0QlFVc3NRMEZCUXl4RlFVRkZPMWxCUTI1Q0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEY0VNN1lVRkJUU3hKUVVGSkxFbEJRVWtzUzBGQlN5eERRVUZETEVWQlFVVTdXVUZEYmtJc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU53UXp0aFFVRk5MRWxCUVVrc1NVRkJTU3hMUVVGTExFTkJRVU1zUlVGQlJUdFpRVU51UWl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03VTBGRGFFSTdTVUZEVEN4RFFVRkRPME5CUTBvN1FVRXZTMFFzZDBOQkswdERJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgQ29ycnVwdGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ0NvcnJ1cHRlZCBFcnJvcicpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvcnJ1cHRlZEVycm9yID0gQ29ycnVwdGVkRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVEyOXljblZ3ZEdWa1JYSnliM0l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SkRiM0p5ZFhCMFpXUkZjbkp2Y2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEc5Q1FVRTBRaXhUUVVGUkxFdEJRVXM3U1VGRGNrTXNXVUZCYlVJc1QwRkJUeXhIUVVGSExHbENRVUZwUWp0UlFVTXhReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZEYmtJc1EwRkJRenREUVVOS08wRkJTa1FzZDBOQlNVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgVHJ1bmNhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnVHJ1bmNhdGUgRXJyb3InKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UcnVuY2F0ZUVycm9yID0gVHJ1bmNhdGVFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVkhKMWJtTmhkR1ZGY25KdmNpNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWxSeWRXNWpZWFJsUlhKeWIzSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTeHRRa0ZCTWtJc1UwRkJVU3hMUVVGTE8wbEJRM0JETEZsQlFXMUNMRTlCUVU4c1IwRkJSeXhuUWtGQlowSTdVVUZEZWtNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlEyNUNMRU5CUVVNN1EwRkRTanRCUVVwRUxITkRRVWxESW4wPSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9Db3JydXB0ZWRFcnJvclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1RydW5jYXRlRXJyb3JcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3p0QlFVRkJMSE5EUVVGcFF6dEJRVU5xUXl4eFEwRkJaME1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9lcnJvcnNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9CaXRQYWNrZWRCdWZmZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9CaXRQYWNrZWREZWNvZGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vVmVyc2lvbkRlY29kZXJcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3p0QlFVRkJMRGhDUVVGNVFqdEJRVU42UWl4MVEwRkJhME03UVVGRGJFTXNkME5CUVcxRE8wRkJRMjVETEhORFFVRnBReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29scy9QeXRob25Qcm90b2NvbENvbnZlcnRlclwiKTtcclxuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9yZXBsYXkvZXJyb3JzXCIpO1xyXG5jbGFzcyBIZXJvUHJvdG9jb2wge1xyXG4gICAgc3RhdGljIGxvYWRQcm90b2NvbChwcm90b2NvbFZlcnNpb24pIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gYGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9CbGl6emFyZC9oZXJvcHJvdG9jb2wvbWFzdGVyL3Byb3RvY29sJHtwcm90b2NvbFZlcnNpb259LnB5YDtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoSGVyb1Byb3RvY29sLl9wcm90b2NvbENvZGUuaGFzKHByb3RvY29sVmVyc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoSGVyb1Byb3RvY29sLl9wcm90b2NvbENvZGUuZ2V0KHByb3RvY29sVmVyc2lvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBIZXJvUHJvdG9jb2wuY29udmVydFByb3RvY29sRnJvbVB5dGhvbihwcm90b2NvbFZlcnNpb24sIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgSGVyb1Byb3RvY29sLl9wcm90b2NvbENvZGUuc2V0KHByb3RvY29sVmVyc2lvbiwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLkZhaWxlZFRvTG9hZFByb3RvY29sRXJyb3IocHJvdG9jb2xWZXJzaW9uLCBgRmFpbGVkIHRvIGxvYWQgSGVyb2VzIFByb3RvY29sICR7cHJvdG9jb2xWZXJzaW9ufWApKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbG9hZEhlcm9EYXRhKCkge1xyXG4gICAgICAgIGlmIChIZXJvUHJvdG9jb2wuX2hlcm9EYXRhUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVyb1Byb3RvY29sLl9oZXJvRGF0YVByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEhlcm9Qcm90b2NvbC5faGVyb0RhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSAnLy9ob3RzYXBpLm5ldC9hcGkvdjEvaGVyb2VzJztcclxuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChldmVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIEhlcm9Qcm90b2NvbC5faGVyb0RhdGFQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFByb3RvY29sKHByb3RvY29sVmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChIZXJvUHJvdG9jb2wuaGFzUHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlcm9Qcm90b2NvbC5fcHJvdG9jb2xzLmdldChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB5aWVsZCBIZXJvUHJvdG9jb2wubG9hZFByb3RvY29sKHByb3RvY29sVmVyc2lvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBIZXJvUHJvdG9jb2wuY29tcGlsZShwcm90b2NvbFZlcnNpb24sIGNvZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXBpbGUocHJvdG9jb2xWZXJzaW9uLCBjb2RlKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBQeXRob25Qcm90b2NvbENvbnZlcnRlcl8xLlB5dGhvblByb3RvY29sQ29udmVydGVyLmNvbXBpbGUoY29kZSk7XHJcbiAgICAgICAgSGVyb1Byb3RvY29sLl9wcm90b2NvbHMuc2V0KHByb3RvY29sVmVyc2lvbiwgcHJvdG9jb2wpO1xyXG4gICAgICAgIHJldHVybiBwcm90b2NvbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBoYXNQcm90b2NvbChwcm90b2NvbFZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gSGVyb1Byb3RvY29sLl9wcm90b2NvbHMuaGFzKHByb3RvY29sVmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29udmVydFByb3RvY29sRnJvbVB5dGhvbih2ZXJzaW9uLCBweUNvZGUpIHtcclxuICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXJfMS5QeXRob25Qcm90b2NvbENvbnZlcnRlcih2ZXJzaW9uLCBweUNvZGUpO1xyXG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZ2V0Q29kZSgpO1xyXG4gICAgfVxyXG59XHJcbkhlcm9Qcm90b2NvbC5lbnYgPSAnZGV2ZWxvcG1lbnQnO1xyXG5IZXJvUHJvdG9jb2wuX3Byb3RvY29scyA9IG5ldyBNYXAoKTtcclxuSGVyb1Byb3RvY29sLl9wcm90b2NvbENvZGUgPSBuZXcgTWFwKCk7XHJcbmV4cG9ydHMuSGVyb1Byb3RvY29sID0gSGVyb1Byb3RvY29sO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhR1Z5YjNCeWIzUnZZMjlzTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lhR1Z5YjNCeWIzUnZZMjlzTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3pzN1FVRkRRU3hwUmtGQk9FVTdRVUZET1VVc05FTkJRVFJFTzBGQlJUVkVPMGxCVFZjc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eGxRVUYxUWp0UlFVTTVReXhOUVVGTkxFbEJRVWtzUjBGQlJ5d3dSVUZCTUVVc1pVRkJaU3hMUVVGTExFTkJRVU03VVVGRE5VY3NUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeE5RVUZOTEVWQlFVVXNSVUZCUlR0WlFVTnVReXhKUVVGSkxGbEJRVmtzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RFFVRkRMR1ZCUVdVc1EwRkJReXhGUVVGRk8yZENRVU5xUkN4UFFVRlBMRU5CUVVNc1dVRkJXU3hEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVNMVJEdHBRa0ZCVFR0blFrRkRTQ3hOUVVGTkxFOUJRVThzUjBGQlJ5eEpRVUZKTEdOQlFXTXNSVUZCUlN4RFFVRkRPMmRDUVVOeVF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTJoRExFOUJRVThzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4SFFVRkhMRVZCUVVVc1JVRkJSVHR2UWtGRGNrSXNTVUZCUnl4UFFVRlBMRU5CUVVNc1RVRkJUU3hMUVVGTExFZEJRVWNzUlVGQlF6dDNRa0ZEZEVJc1RVRkJUU3hEUVVGRExFZEJRVWNzV1VGQldTeERRVUZETEhsQ1FVRjVRaXhEUVVGRExHVkJRV1VzUlVGQlJTeFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN2QwSkJRM2hHTEZsQlFWa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSeXhEUVVGRExHVkJRV1VzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRia1FzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPM0ZDUVVOa08zbENRVUZKTzNkQ1FVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxHdERRVUY1UWl4RFFVRkRMR1ZCUVdVc1JVRkJSU3hyUTBGQmEwTXNaVUZCWlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8zRkNRVU12Unp0blFrRkRUQ3hEUVVGRExFTkJRVU03WjBKQlEwWXNUMEZCVHl4RFFVRkRMRTlCUVU4c1IwRkJSeXhEUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZGTzI5Q1FVTjRRaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdaMEpCUTJ4Q0xFTkJRVU1zUTBGQlF6dG5Ra0ZEUml4UFFVRlBMRU5CUVVNc1QwRkJUeXhIUVVGSExFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVVTdiMEpCUTNoQ0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0blFrRkRiRUlzUTBGQlF5eERRVUZETzJkQ1FVTkdMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dGhRVU5zUWp0UlFVTk1MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMUFzUTBGQlF6dEpRVVZOTEUxQlFVMHNRMEZCUXl4WlFVRlpPMUZCUTNSQ0xFbEJRVWNzV1VGQldTeERRVUZETEdkQ1FVRm5RaXhGUVVGRE8xbEJRemRDTEU5QlFVOHNXVUZCV1N4RFFVRkRMR2RDUVVGblFpeERRVUZETzFOQlEzaERPMUZCUTBRc1dVRkJXU3hEUVVGRExHZENRVUZuUWl4SFFVRkhMRWxCUVVrc1QwRkJUeXhEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEUxQlFVMHNSVUZCUXl4RlFVRkZPMWxCUXpORUxFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NZMEZCWXl4RlFVRkZMRU5CUVVNN1dVRkRja01zVFVGQlRTeEpRVUZKTEVkQlFVY3NOa0pCUVRaQ0xFTkJRVU03V1VGRE0wTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTJoRExFOUJRVThzUTBGQlF5eE5RVUZOTEVkQlFVY3NSMEZCUnl4RlFVRkZPMmRDUVVOc1FpeE5RVUZOTEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0blFrRkRPVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTJ4Q0xFTkJRVU1zUTBGQlF6dFpRVU5HTEU5QlFVOHNRMEZCUXl4UFFVRlBMRWRCUVVjc1EwRkJReXhMUVVGTExFVkJRVVVzUlVGQlJUdG5Ra0ZEZUVJc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFsQlEyeENMRU5CUVVNc1EwRkJRenRaUVVOR0xFOUJRVThzUTBGQlF5eFBRVUZQTEVkQlFVY3NRMEZCUXl4TFFVRkxMRVZCUVVVc1JVRkJSVHRuUWtGRGVFSXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRMnhDTEVOQlFVTXNRMEZCUXp0WlFVTkdMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dFJRVU51UWl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOSUxFOUJRVThzV1VGQldTeERRVUZETEdkQ1FVRm5RaXhEUVVGRE8wbEJRM3BETEVOQlFVTTdTVUZGVFN4TlFVRk5MRU5CUVU4c1YwRkJWeXhEUVVGRExHVkJRWFZDT3p0WlFVTnVSQ3hKUVVGSkxGbEJRVmtzUTBGQlF5eFhRVUZYTEVOQlFVTXNaVUZCWlN4RFFVRkRMRVZCUVVVN1owSkJRek5ETEU5QlFVOHNXVUZCV1N4RFFVRkRMRlZCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zWlVGQlpTeERRVUZETEVOQlFVTTdZVUZEZGtRN1dVRkRSQ3hOUVVGTkxFbEJRVWtzUjBGQlJ5eE5RVUZOTEZsQlFWa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU03V1VGRE9VUXNUMEZCVHl4WlFVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExHVkJRV1VzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hEUVVGRE8wdEJRVUU3U1VGRlRTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMR1ZCUVhWQ0xFVkJRVVVzU1VGQldUdFJRVU4yUkN4TlFVRk5MRkZCUVZFc1IwRkJSeXhwUkVGQmRVSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGRrUXNXVUZCV1N4RFFVRkRMRlZCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zWlVGQlpTeEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUTNaRUxFOUJRVThzVVVGQlVTeERRVUZETzBsQlEzQkNMRU5CUVVNN1NVRkZUU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEdWQlFYVkNPMUZCUXpkRExFOUJRVThzV1VGQldTeERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU03U1VGRGVFUXNRMEZCUXp0SlFVVlBMRTFCUVUwc1EwRkJReXg1UWtGQmVVSXNRMEZCUXl4UFFVRmxMRVZCUVVVc1RVRkJZenRSUVVOd1JTeE5RVUZOTEZOQlFWTXNSMEZCUnl4SlFVRkpMR2xFUVVGMVFpeERRVUZETEU5QlFVOHNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVNdlJDeFBRVUZQTEZOQlFWTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJRenRKUVVNdlFpeERRVUZET3p0QlFUZEZZU3huUWtGQlJ5eEhRVUZITEdGQlFXRXNRMEZCUXp0QlFVTnVRaXgxUWtGQlZTeEhRVUVyUWl4SlFVRkpMRWRCUVVjc1JVRkJlVUlzUTBGQlF6dEJRVU14UlN3d1FrRkJZU3hIUVVGM1FpeEpRVUZKTEVkQlFVY3NSVUZCYTBJc1EwRkJRenRCUVVoc1JpeHZRMEZwUmtNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcmVwbGF5XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdHlwZXNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZXJvcHJvdG9jb2xcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3p0QlFVRkJMRGhDUVVGNVFqdEJRVU42UWl3MlFrRkJkMEk3UVVGRGVFSXNiME5CUVN0Q0luMD0iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBkZWNvZGVycyA9IHJlcXVpcmUoXCIuL2RlY29kZXJzXCIpO1xyXG5jb25zdCBfdGVtcGxhdGUgPSBgXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICBjb25zdCBwcm9ncmVzcyA9IHtcclxuICAgICAgICBjdXJyZW50OiAtMSxcclxuICAgICAgICB0b3RhbDogLTFcclxuICAgIH1cclxuICAgIGV4cG9ydHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuXHJcbiAgICBleHBvcnRzLnZlcnNpb24gPSBcXCR7dmVyc2lvbn07XHJcbiAgICBcXCR7cGF0Y2h9XHJcblxyXG4gICAgY29uc3QgQml0UGFja2VkRGVjb2RlciA9IGRlY29kZXJzLkJpdFBhY2tlZERlY29kZXI7XHJcbiAgICBjb25zdCBWZXJzaW9uRGVjb2RlciA9IGRlY29kZXJzLlZlcnNpb25EZWNvZGVyO1xyXG5cclxuXHJcbiAgICAvLyBEZWNvZGluZyBpbnN0cnVjdGlvbnMgZm9yIGVhY2ggcHJvdG9jb2wgdHlwZS5cclxuICAgIGNvbnN0IHR5cGVpbmZvcyA9IFtcclxuICAgIFxcJHt0eXBlaW5mb3N9XHJcbiAgICBdO1xyXG5cclxuICAgIC8vIE1hcCBmcm9tIHByb3RvY29sIE5OZXQuR2FtZS4qRXZlbnQgZXZlbnRpZCB0byBbdHlwZWlkLCBuYW1lXVxyXG4gICAgY29uc3QgZ2FtZV9ldmVudF90eXBlcyA9IHtcclxuICAgIFxcJHtnYW1lZXZlbnRzVHlwZXN9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSB0eXBlaWQgb2YgdGhlIE5OZXQuR2FtZS5FRXZlbnRJZCBlbnVtLlxyXG4gICAgY29uc3QgZ2FtZV9ldmVudGlkX3R5cGVpZCA9IFxcJHtnYW1lZXZlbnRzVHlwZWlkfTtcclxuXHJcbiAgICAvLyBNYXAgZnJvbSBwcm90b2NvbCBOTmV0LkdhbWUuKk1lc3NhZ2UgZXZlbnRpZCB0byBbdHlwZWlkLCBuYW1lXVxyXG4gICAgY29uc3QgbWVzc2FnZV9ldmVudF90eXBlcyA9IHtcclxuICAgIFxcJHttZXNzYWdlZXZlbnRzVHlwZXN9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSB0eXBlaWQgb2YgdGhlIE5OZXQuR2FtZS5FTWVzc2FnZUlkIGVudW0uXHJcbiAgICBjb25zdCBtZXNzYWdlX2V2ZW50aWRfdHlwZWlkID0gXFwke21lc3NhZ2VldmVudHNUeXBlaWR9O1xyXG5cclxuICAgIC8vIE1hcCBmcm9tIHByb3RvY29sIE5OZXQuUmVwbGF5LlRyYWNrZXIuKkV2ZW50IGV2ZW50aWQgdG8gW3R5cGVpZCwgbmFtZV1cclxuICAgIGNvbnN0IHRyYWNrZXJfZXZlbnRfdHlwZXMgPSB7XHJcbiAgICBcXCR7dHJhY2tlcmV2ZW50c3R5cGVzfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIHRoZSBOTmV0LlJlcGxheS5UcmFja2VyLkVFdmVudElkIGVudW0uXHJcbiAgICBjb25zdCB0cmFja2VyX2V2ZW50aWRfdHlwZWlkID0gXFwke3RyYWNrZXJldmVudHNUeXBlaWR9O1xyXG5cclxuICAgIC8vIFRoZSB0eXBlaWQgb2YgTk5ldC5TVmFyVWludDMyICh0aGUgdHlwZSB1c2VkIHRvIGVuY29kZSBnYW1lbG9vcCBkZWx0YXMpLlxyXG4gICAgY29uc3Qgc3ZhcnVpbnQzMl90eXBlaWQgPSA3O1xyXG5cclxuICAgIC8vIFRoZSB0eXBlaWQgb2YgTk5ldC5SZXBsYXkuU0dhbWVVc2VySWQgKHRoZSB0eXBlIHVzZWQgdG8gZW5jb2RlIHBsYXllciBpZHMpLlxyXG4gICAgY29uc3QgcmVwbGF5X3VzZXJpZF90eXBlaWQgPSA4O1xyXG5cclxuICAgIC8vIFRoZSB0eXBlaWQgb2YgTk5ldC5SZXBsYXkuU0hlYWRlciAodGhlIHR5cGUgdXNlZCB0byBzdG9yZSByZXBsYXkgZ2FtZSB2ZXJzaW9uIGFuZCBsZW5ndGgpLlxyXG4gICAgY29uc3QgcmVwbGF5X2hlYWRlcl90eXBlaWQgPSBcXCR7aGVhZGVyVHlwZWlkfTtcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIE5OZXQuR2FtZS5TRGV0YWlscyAodGhlIHR5cGUgdXNlZCB0byBzdG9yZSBvdmVyYWxsIHJlcGxheSBkZXRhaWxzKS5cclxuICAgIGNvbnN0IGdhbWVfZGV0YWlsc190eXBlaWQgPSBcXCR7ZGV0YWlsc1R5cGVpZH07XHJcblxyXG4gICAgLy8gVGhlIHR5cGVpZCBvZiBOTmV0LlJlcGxheS5TSW5pdERhdGEgKHRoZSB0eXBlIHVzZWQgdG8gc3RvcmUgdGhlIGluaXRhbCBsb2JieSkuXHJcbiAgICBjb25zdCByZXBsYXlfaW5pdGRhdGFfdHlwZWlkID0gXFwke2luaXRkYXRhVHlwZWlkfTtcclxuXHJcbiAgICAvLyBub3Qgc3VyZSBpZiBjb3JyZWN0IHBvcnRcclxuICAgIGZ1bmN0aW9uIF92YXJ1aW50MzJWYWx1ZSh2YWx1ZSkge1xyXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtZXJpYyB2YWx1ZSBmcm9tIGEgU1ZhclVpbnQzMiBpbnN0YW5jZS5cclxuICAgIHJldHVybiB2YWx1ZVtPYmplY3Qua2V5cyh2YWx1ZSlbMF1dO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uKiBfZGVjb2RlX2V2ZW50X3N0cmVhbShkZWNvZGVyLCBldmVudGlkVHlwZWlkLCBldmVudFR5cGVzLCBkZWNvZGVVc2VySWQpIHtcclxuICAgIC8vIERlY29kZXMgZXZlbnRzIHByZWZpeGVkIHdpdGggYSBnYW1lbG9vcCBhbmQgcG9zc2libHkgdXNlcmlkXHJcbiAgICB2YXIgZ2FtZWxvb3AgPSAwO1xyXG4gICAgd2hpbGUgKCFkZWNvZGVyLmlzRG9uZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzdGFydEJpdHMgPSBkZWNvZGVyLnVzZWRCaXRzO1xyXG5cclxuICAgICAgICAvLyBkZWNvZGUgdGhlIGdhbWVsb29wIGRlbHRhIGJlZm9yZSBlYWNoIGV2ZW50XHJcbiAgICAgICAgdmFyIGRlbHRhID0gX3ZhcnVpbnQzMlZhbHVlKGRlY29kZXIuaW5zdGFuY2Uoc3ZhcnVpbnQzMl90eXBlaWQpKTtcclxuICAgICAgICBnYW1lbG9vcCArPSBkZWx0YTtcclxuXHJcbiAgICAgICAgLy8gZGVjb2RlIHRoZSB1c2VyaWQgYmVmb3JlIGVhY2ggZXZlbnRcclxuICAgICAgICB2YXIgdXNlcmlkID0gKGRlY29kZVVzZXJJZCA9PT0gdHJ1ZSkgPyBkZWNvZGVyLmluc3RhbmNlKHJlcGxheV91c2VyaWRfdHlwZWlkKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gZGVjb2RlIHRoZSBldmVudCBpZFxyXG4gICAgICAgIHZhciBldmVudGlkID0gZGVjb2Rlci5pbnN0YW5jZShldmVudGlkVHlwZWlkKTtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gZXZlbnRUeXBlc1tldmVudGlkXSB8fCBbbnVsbCwgbnVsbF07XHJcbiAgICAgICAgdmFyIHR5cGVpZCA9IGV2ZW50VHlwZVswXTtcclxuICAgICAgICB2YXIgdHlwZW5hbWUgPSBldmVudFR5cGVbMV07XHJcbiAgICAgICAgaWYgKHR5cGVpZCA9PT0gbnVsbCkgdGhyb3cgbmV3IGRlY29kZXJzLkNvcnJ1cHRlZEVycm9yKCdldmVudGlkKCcgKyBldmVudGlkICsgJykgYXQgJyArIGRlY29kZXIudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgIC8vIGRlY29kZSB0aGUgZXZlbnQgc3RydWN0IGluc3RhbmNlXHJcbiAgICAgICAgdmFyIGV2ZW50ID0gZGVjb2Rlci5pbnN0YW5jZSh0eXBlaWQpO1xyXG4gICAgICAgIGV2ZW50Ll9ldmVudCA9IHR5cGVuYW1lO1xyXG4gICAgICAgIGV2ZW50Ll9ldmVudGlkID0gZXZlbnRpZDtcclxuXHJcbiAgICAgICAgLy8gaW5zZXJ0IGdhbWVsb29wIGFuZCB1c2VyaWRcclxuICAgICAgICBldmVudC5fZ2FtZWxvb3AgPSBnYW1lbG9vcDtcclxuICAgICAgICBpZiAoZGVjb2RlVXNlcklkKSBldmVudC5fdXNlcmlkID0gdXNlcmlkO1xyXG5cclxuICAgICAgICAvLyB0aGUgbmV4dCBldmVudCBpcyBieXRlIGFsaWduZWRcclxuICAgICAgICBkZWNvZGVyLmJ5dGVBbGlnbigpO1xyXG5cclxuICAgICAgICAvLyBpbnNlcnQgYml0cyB1c2VkIGluIHN0cmVhbVxyXG4gICAgICAgIGV2ZW50Ll9iaXRzID0gZGVjb2Rlci51c2VkQml0cyAtIHN0YXJ0Qml0cztcclxuICAgICAgICBwcm9ncmVzcy5jdXJyZW50ID0gZGVjb2Rlci51c2VkQml0cztcclxuICAgICAgICB5aWVsZCBldmVudDtcclxuICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheUdhbWVFdmVudHMgPSBmdW5jdGlvbiogKGNvbnRlbnRzKSB7XHJcbiAgICAvLyBEZWNvZGVzIGFuZCB5aWVsZHMgZWFjaCBnYW1lIGV2ZW50IGZyb20gdGhlIGNvbnRlbnRzIGJ5dGUgc3RyaW5nLlxyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBCaXRQYWNrZWREZWNvZGVyKGNvbnRlbnRzLCB0eXBlaW5mb3MpO1xyXG4gICAgcHJvZ3Jlc3MuY3VycmVudCA9IDA7XHJcbiAgICBwcm9ncmVzcy50b3RhbCA9IGRlY29kZXIuc2l6ZTtcclxuICAgIGZvciAobGV0IGV2ZW50IG9mIF9kZWNvZGVfZXZlbnRfc3RyZWFtKGRlY29kZXIsIGdhbWVfZXZlbnRpZF90eXBlaWQsIGdhbWVfZXZlbnRfdHlwZXMsIHRydWUpKVxyXG4gICAgICAgIHlpZWxkIGV2ZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheU1lc3NhZ2VFdmVudHMgPSBmdW5jdGlvbiogKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgLy8gRGVjb2RlcyBhbmQgeWllbGRzIGVhY2ggbWVzc2FnZSBldmVudCBmcm9tIHRoZSBjb250ZW50cyBieXRlIHN0cmluZy5cclxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IEJpdFBhY2tlZERlY29kZXIoY29udGVudHMsIHR5cGVpbmZvcyk7XHJcbiAgICAgICAgcHJvZ3Jlc3MuY3VycmVudCA9IDA7XHJcbiAgICAgICAgcHJvZ3Jlc3MudG90YWwgPSBkZWNvZGVyLnNpemU7XHJcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgb2YgX2RlY29kZV9ldmVudF9zdHJlYW0oZGVjb2RlciwgbWVzc2FnZV9ldmVudGlkX3R5cGVpZCwgbWVzc2FnZV9ldmVudF90eXBlcywgdHJ1ZSkpXHJcbiAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheVRyYWNrZXJFdmVudHMgPSBmdW5jdGlvbiogKGNvbnRlbnRzKSB7XHJcbiAgICAvLyBEZWNvZGVzIGFuZCB5aWVsZHMgZWFjaCB0cmFja2VyIGV2ZW50IGZyb20gdGhlIGNvbnRlbnRzIGJ5dGUgc3RyaW5nLlxyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBWZXJzaW9uRGVjb2Rlcihjb250ZW50cywgdHlwZWluZm9zKTtcclxuICAgIHByb2dyZXNzLmN1cnJlbnQgPSAwO1xyXG4gICAgcHJvZ3Jlc3MudG90YWwgPSBkZWNvZGVyLnNpemU7XHJcbiAgICBmb3IgKGxldCBldmVudCBvZiBfZGVjb2RlX2V2ZW50X3N0cmVhbShkZWNvZGVyLCB0cmFja2VyX2V2ZW50aWRfdHlwZWlkLCB0cmFja2VyX2V2ZW50X3R5cGVzLCBmYWxzZSkpXHJcbiAgICAgICAgeWllbGQgZXZlbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZGVjb2RlUmVwbGF5SGVhZGVyID0gZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgIC8vIERlY29kZXMgYW5kIHJldHVybiB0aGUgcmVwbGF5IGhlYWRlciBmcm9tIHRoZSBjb250ZW50cyBieXRlIHN0cmluZy5cclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVmVyc2lvbkRlY29kZXIoY29udGVudHMsIHR5cGVpbmZvcyk7XHJcbiAgICByZXR1cm4gZGVjb2Rlci5pbnN0YW5jZShyZXBsYXlfaGVhZGVyX3R5cGVpZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZGVjb2RlUmVwbGF5RGV0YWlscyA9IGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAvLyBEZWNvZGVzIGFuZCByZXR1cm5zIHRoZSBnYW1lIGRldGFpbHMgZnJvbSB0aGUgY29udGVudHMgYnl0ZSBzdHJpbmcuXHJcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFZlcnNpb25EZWNvZGVyKGNvbnRlbnRzLCB0eXBlaW5mb3MpO1xyXG4gICAgcmV0dXJuIGRlY29kZXIuaW5zdGFuY2UoZ2FtZV9kZXRhaWxzX3R5cGVpZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZGVjb2RlUmVwbGF5SW5pdGRhdGEgPSBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgLy8gRGVjb2RlcyBhbmQgcmV0dXJuIHRoZSByZXBsYXkgaW5pdCBkYXRhIGZyb20gdGhlIGNvbnRlbnRzIGJ5dGUgc3RyaW5nLlxyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBCaXRQYWNrZWREZWNvZGVyKGNvbnRlbnRzLCB0eXBlaW5mb3MpO1xyXG4gICAgcmV0dXJuIGRlY29kZXIuaW5zdGFuY2UocmVwbGF5X2luaXRkYXRhX3R5cGVpZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZGVjb2RlUmVwbGF5QXR0cmlidXRlc0V2ZW50cyA9IGZ1bmN0aW9uIChjb250ZW50cykge1xyXG4gICAgLy8gRGVjb2RlcyBhbmQgeWllbGRzIGVhY2ggYXR0cmlidXRlIGZyb20gdGhlIGNvbnRlbnRzIGJ5dGUgc3RyaW5nLlxyXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IGRlY29kZXJzLkJpdFBhY2tlZEJ1ZmZlcihjb250ZW50cywgJ2xpdHRsZScpO1xyXG4gICAgcHJvZ3Jlc3MuY3VycmVudCA9IDA7XHJcbiAgICBwcm9ncmVzcy50b3RhbCA9IGJ1ZmZlci5zaXplO1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuICAgIGlmICghYnVmZmVyLmlzRG9uZSkge1xyXG4gICAgICAgIGF0dHJpYnV0ZXMuc291cmNlID0gYnVmZmVyLnJlYWRCaXRzKDgpO1xyXG4gICAgICAgIGF0dHJpYnV0ZXMubWFwTmFtZVNwYWNlID0gYnVmZmVyLnJlYWRCaXRzKDMyKTtcclxuICAgICAgICB2YXIgY291bnQgPSBidWZmZXIucmVhZEJpdHMoMzIpO1xyXG4gICAgICAgIGF0dHJpYnV0ZXMuc2NvcGVzID0ge307XHJcblxyXG4gICAgICAgIHdoaWxlICghYnVmZmVyLmlzRG9uZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHt9O1xyXG4gICAgICAgIHZhbHVlLm5hbWVzcGFjZSA9IGJ1ZmZlci5yZWFkQml0cygzMik7XHJcbiAgICAgICAgdmFyIGF0dHJpZCA9IHZhbHVlLmF0dHJpZCA9IGJ1ZmZlci5yZWFkQml0cygzMik7XHJcbiAgICAgICAgdmFyIHNjb3BlID0gYnVmZmVyLnJlYWRCaXRzKDgpO1xyXG4gICAgICAgIHZhbHVlLnZhbHVlID0gYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoNCkucmV2ZXJzZSgpO1xyXG4gICAgICAgIHdoaWxlICh2YWx1ZS52YWx1ZVswXSA9PT0gMCkgdmFsdWUudmFsdWUgPSB2YWx1ZS52YWx1ZS5zbGljZSgxKTtcclxuICAgICAgICB3aGlsZSAodmFsdWUudmFsdWVbdmFsdWUudmFsdWUubGVuZ3RoIC0gMV0gPT09IDApIHZhbHVlLnZhbHVlID0gdmFsdWUudmFsdWUuc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgIGlmICghYXR0cmlidXRlcy5zY29wZXNbc2NvcGVdKVxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnNjb3Blc1tzY29wZV0gPSB7fTtcclxuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuc2NvcGVzW3Njb3BlXVthdHRyaWRdKVxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnNjb3Blc1tzY29wZV1bYXR0cmlkXSA9IFtdO1xyXG4gICAgICAgIGF0dHJpYnV0ZXMuc2NvcGVzW3Njb3BlXVthdHRyaWRdLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHByb2dyZXNzLmN1cnJlbnQgPSBidWZmZXIudXNlZEJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLnVuaXRUYWcgPSBmdW5jdGlvbih1bml0VGFnSW5kZXgsIHVuaXRUYWdSZWN5Y2xlKSB7XHJcbiAgICByZXR1cm4gKHVuaXRUYWdJbmRleCA8PCAxOCkgKyB1bml0VGFnUmVjeWNsZTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy51bml0VGFnSW5kZXggPSBmdW5jdGlvbih1bml0VGFnKSB7XHJcbiAgICByZXR1cm4gKHVuaXRUYWcgPj4gMTgpICYgMHgwMDAwM0ZGRjtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy51bml0VGFnUmVjeWNsZSA9IGZ1bmN0aW9uKHVuaXRUYWcpIHtcclxuICAgIHJldHVybiB1bml0VGFnICYgMHgwMDAzRkZGRjtcclxuICAgIH07XHJcbmA7XHJcbmNvbnN0IHR5cGVzID0ge1xyXG4gICAgdHVwbGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLm1hdGNoKC8oLT9cXHcrKS9nKTtcclxuICAgIH0sXHJcbiAgICB0dXBsZXM6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLm1hdGNoKC8oXFwoLio/XFwpKS9nKTtcclxuICAgIH0sXHJcbiAgICBfaW50OiB7XHJcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0eXBlcy50dXBsZShzdHIpO1xyXG4gICAgICAgICAgICByZXRbJ2JvdW5kcyddID0gW3Jlc1swXSwgcmVzWzFdXTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgWyR7aW5mb3MuYm91bmRzWzBdfSwgJHtpbmZvcy5ib3VuZHNbMV19XWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jaG9pY2U6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0ID0geyBib3VuZHM6IFtdLCBjaG9pY2VzOiBbXSB9O1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0eXBlcy50dXBsZXMoc3RyKTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXQsIHR5cGVzLl9pbnQuZGVjb2RlKHJlc1swXSkpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGUgPSB0eXBlcy50dXBsZShyZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmV0LmNob2ljZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHR1cGxlWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmRleDogdHVwbGVbMV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFske2luZm9zLmJvdW5kc1swXX0sICR7aW5mb3MuYm91bmRzWzFdfV0sIHsgJHtpbmZvcy5jaG9pY2VzLm1hcCgoY2hvaWNlLCBpbmRleCwgYXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtpbmRleH06IFsnJHtjaG9pY2UubGFiZWx9JywgJHtjaG9pY2UudHlwZUluZGV4fV0keyhpbmRleCA9PT0gYXIubGVuZ3RoIC0gMSkgPyAnJyA6ICcsICd9YDtcclxuICAgICAgICAgICAgfSkuam9pbignJyl9fWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9zdHJ1Y3Q6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0ID0geyBpdGVtczogW10gfTtcclxuICAgICAgICAgICAgY29uc3QgdHVwbGVzID0gdHlwZXMudHVwbGVzKHN0cik7XHJcbiAgICAgICAgICAgIGlmICh0dXBsZXMpIHtcclxuICAgICAgICAgICAgICAgIHR1cGxlcy5mb3JFYWNoKHR1cGxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0dXBsZSA9IHR5cGVzLnR1cGxlKHR1cGxlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXQuaXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0dXBsZVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZGV4OiB0dXBsZVsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiB0dXBsZVsyXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgWyR7aW5mb3MuaXRlbXMubWFwKChpdGVtLCBpbmRleCwgYXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgWycke2l0ZW0ubGFiZWx9JywgJHtpdGVtLnR5cGVJbmRleH0sICR7aXRlbS50YWd9XSR7KGluZGV4ID09PSBhci5sZW5ndGggLSAxKSA/ICcnIDogJywgJ31gO1xyXG4gICAgICAgICAgICB9KS5qb2luKCcnKX1dYDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2Jsb2I6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzLl9pbnQuZGVjb2RlKHN0cik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZXMuX2ludC5lbmNvZGUoaW5mb3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfYm9vbDoge1xyXG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9hcnJheToge1xyXG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHR5cGVJbmRleDogc3RyLm1hdGNoKC9cXGQrJC8pWzBdIH0sIHR5cGVzLl9pbnQuZGVjb2RlKHN0cikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBbJHtpbmZvcy5ib3VuZHNbMF19LCAke2luZm9zLmJvdW5kc1sxXX1dLCAke2luZm9zLnR5cGVJbmRleH1gO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfb3B0aW9uYWw6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZUluZGV4OiBOdW1iZXIoc3RyKSB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke2luZm9zLnR5cGVJbmRleH1gO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZm91cmNjOiB7XHJcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2JpdGFycmF5OiB7XHJcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlcy5faW50LmRlY29kZShzdHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzLl9pbnQuZW5jb2RlKGluZm9zKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX251bGw6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgdG9rZW5zID0ge1xyXG4gICAgbmV3bGluZTogJ1xcbicsXHJcbiAgICBpbmRlbnQ6ICcgICcsXHJcbiAgICB0eXBlaW5mb3NTdGFydDogJ3R5cGVpbmZvcyA9IFsnLFxyXG4gICAgdHlwZWluZm9zRW5kOiAnXScsXHJcbiAgICBnYW1lZXZlbnRzU3RhcnQ6ICdnYW1lX2V2ZW50X3R5cGVzID0geycsXHJcbiAgICBnYW1lZXZlbnRzRW5kOiAnfScsXHJcbiAgICBtZXNzYWdlZXZlbnRzU3RhcnQ6ICdtZXNzYWdlX2V2ZW50X3R5cGVzID0geycsXHJcbiAgICBtZXNzYWdlZXZlbnRzRW5kOiAnfScsXHJcbiAgICB0cmFja2VyZXZlbnRzU3RhcnQ6ICd0cmFja2VyX2V2ZW50X3R5cGVzID0geycsXHJcbiAgICB0cmFja2VyZXZlbnRzRW5kOiAnfScsXHJcbiAgICBnYW1lZXZlbnRzVHlwZWlkOiAnZ2FtZV9ldmVudGlkX3R5cGVpZCA9JyxcclxuICAgIG1lc3NhZ2VldmVudHNUeXBlaWQ6ICdtZXNzYWdlX2V2ZW50aWRfdHlwZWlkID0nLFxyXG4gICAgdHJhY2tlcmV2ZW50c1R5cGVpZDogJ3RyYWNrZXJfZXZlbnRpZF90eXBlaWQgPScsXHJcbiAgICBoZWFkZXJUeXBlaWQ6ICdyZXBsYXlfaGVhZGVyX3R5cGVpZCA9JyxcclxuICAgIGRldGFpbHNUeXBlaWQ6ICdnYW1lX2RldGFpbHNfdHlwZWlkID0nLFxyXG4gICAgaW5pdGRhdGFUeXBlaWQ6ICdyZXBsYXlfaW5pdGRhdGFfdHlwZWlkID0nXHJcbn07XHJcbmNvbnN0IF9kYXRhID0ge1xyXG4gICAgcmVhbG1zOiBbdW5kZWZpbmVkLCAnbGl2ZSddLFxyXG4gICAgcmVnaW9uczogW1xyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgJ0V1cm9wZSdcclxuICAgIF0sXHJcbiAgICBoZXJvZXM6IFtdLFxyXG4gICAgbW91bnRzOiBbXSxcclxuICAgIG1hcHM6IFtdLFxyXG4gICAgYnVpbGRzOiBbXVxyXG59O1xyXG5jbGFzcyBQeXRob25Qcm90b2NvbENvbnZlcnRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBweUNvZGUpIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMucHlDb2RlID0gcHlDb2RlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXBpbGUocHJvdG9jb2xDb2RlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGZuID0gRnVuY3Rpb24oJ2V4cG9ydHMnLCAnZGVjb2RlcnMnLCBwcm90b2NvbENvZGUpO1xyXG4gICAgICAgIGZuKHByb3RvY29sLCBkZWNvZGVycyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Byb3RvY29sIENvbXBpbGUgVGltZTogJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHByb3RvY29sO1xyXG4gICAgfVxyXG4gICAgY29udmVydCgpIHtcclxuICAgICAgICByZXR1cm4gUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXIuY29tcGlsZSh0aGlzLmdldENvZGUoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb2RlKCkge1xyXG4gICAgICAgIHRoaXMucGFyc2UodGhpcy5weUNvZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKCk7XHJcbiAgICB9XHJcbiAgICBwYXJzZShyYXcpIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gcmF3LnNwbGl0KHRva2Vucy5uZXdsaW5lKTtcclxuICAgICAgICBsZXQgbGluZSA9IDAsIHN0cjtcclxuICAgICAgICB0aGlzLnR5cGVpbmZvcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2FtZWV2ZW50c1R5cGVzID0gW107XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlZXZlbnRzVHlwZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnRyYWNrZXJldmVudHN0eXBlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChsaW5lIDwgbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKHN0ciA9PT0gdG9rZW5zLnR5cGVpbmZvc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBsaW5lc1tsaW5lXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlaW5mb3MucHVzaCh0aGlzLnBhcnNlVHlwZWluZm9zKHN0cikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBsaW5lc1tsaW5lXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChzdHIgIT09IHRva2Vucy50eXBlaW5mb3NFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2Vucy5nYW1lZXZlbnRzU3RhcnQgPT09IHN0cikge1xyXG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gbGluZXNbbGluZV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZWV2ZW50c1R5cGVzLnB1c2godGhpcy5wYXJzZUV2ZW50KHN0cikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBsaW5lc1tsaW5lXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0b2tlbnMuZ2FtZWV2ZW50c0VuZCAhPT0gc3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbnMubWVzc2FnZWV2ZW50c1N0YXJ0ID09PSBzdHIpIHtcclxuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VldmVudHNUeXBlcy5wdXNoKHRoaXMucGFyc2VFdmVudChzdHIpKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gbGluZXNbbGluZV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW5zLm1lc3NhZ2VldmVudHNFbmQgIT09IHN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5zLnRyYWNrZXJldmVudHNTdGFydCA9PT0gc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBsaW5lc1tsaW5lXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja2VyZXZlbnRzdHlwZXMucHVzaCh0aGlzLnBhcnNlRXZlbnQoc3RyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2Vucy50cmFja2VyZXZlbnRzRW5kICE9PSBzdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5zdGFydHNXaXRoKHRva2Vucy5nYW1lZXZlbnRzVHlwZWlkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lZXZlbnRzVHlwZWlkID0gc3RyLm1hdGNoKC9cXGQrLylbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyLnN0YXJ0c1dpdGgodG9rZW5zLm1lc3NhZ2VldmVudHNUeXBlaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VldmVudHNUeXBlaWQgPSBzdHIubWF0Y2goL1xcZCsvKVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdHIuc3RhcnRzV2l0aCh0b2tlbnMudHJhY2tlcmV2ZW50c1R5cGVpZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tlcmV2ZW50c1R5cGVpZCA9IHN0ci5tYXRjaCgvXFxkKy8pWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5zdGFydHNXaXRoKHRva2Vucy5oZWFkZXJUeXBlaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlclR5cGVpZCA9IHN0ci5tYXRjaCgvXFxkKy8pWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5zdGFydHNXaXRoKHRva2Vucy5kZXRhaWxzVHlwZWlkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhaWxzVHlwZWlkID0gc3RyLm1hdGNoKC9cXGQrLylbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyLnN0YXJ0c1dpdGgodG9rZW5zLmluaXRkYXRhVHlwZWlkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0ZGF0YVR5cGVpZCA9IHN0ci5tYXRjaCgvXFxkKy8pWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Byb3RvY29sIFBhcnNlIFRpbWU6ICcsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnQpO1xyXG4gICAgfVxyXG4gICAgcGFyc2VFdmVudChzdHIpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBzdHIubWF0Y2goL14oXFxkKyk6XFxzXFwoKFxcZCspLFxcc1xcJyguKilcXCcvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXk6IHJlc1sxXSxcclxuICAgICAgICAgICAgdHlwZUluZGV4OiByZXNbMl0sXHJcbiAgICAgICAgICAgIG5hbWU6IHJlc1szXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwYXJzZVR5cGVpbmZvcyhzdHIpIHtcclxuICAgICAgICBjb25zdCB0eXBlUmVnZXggPSAvXlxcKCcoLio/KScsXFxbKC4qKVxcXVxcKSxcXHMqIyhcXGQrKSQvO1xyXG4gICAgICAgIGNvbnN0IGluZm9zID0geyBzdHI6IHN0ciB9O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHR5cGVSZWdleC5leGVjKHN0cik7XHJcbiAgICAgICAgaW5mb3MudHlwZSA9IHJlc1sxXTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGluZm9zLCB0eXBlc1tpbmZvcy50eXBlXS5kZWNvZGUocmVzWzJdKSk7XHJcbiAgICAgICAgaW5mb3MuaW5kZXggPSByZXNbM107XHJcbiAgICAgICAgcmV0dXJuIGluZm9zO1xyXG4gICAgfVxyXG4gICAgd3JpdGUoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICBjb25zdCBidWlsZEluZm9zID0gX2RhdGEuYnVpbGRzW3RoaXMudmVyc2lvbl07XHJcbiAgICAgICAgbGV0IG91dCA9IF90ZW1wbGF0ZTtcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHtkYXRlfScsIG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSk7XHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7dmVyc2lvbn0nLCB0aGlzLnZlcnNpb24pO1xyXG4gICAgICAgIGlmIChidWlsZEluZm9zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gYnVpbGRJbmZvcy5saXZlID8gYnVpbGRJbmZvcy5saXZlLnBhdGNoIDogYnVpbGRJbmZvcy5wdHIucGF0Y2g7XHJcbiAgICAgICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke3BhdGNofScsIGBleHBvcnRzLnBhdGNoID0gXFwnJHtwYXRjaH1cXCc7JHt0b2tlbnMubmV3bGluZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke3BhdGNofScsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7dHlwZWluZm9zfScsIHRoaXMudHlwZWluZm9zLm1hcCgoaW5mb3MsIGluZGV4LCBhcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gdG9rZW5zLmluZGVudDtcclxuICAgICAgICAgICAgc3RyICs9IGBbJyR7aW5mb3MudHlwZX0nLCBbYDtcclxuICAgICAgICAgICAgc3RyICs9IHR5cGVzW2luZm9zLnR5cGVdLmVuY29kZShpbmZvcyk7XHJcbiAgICAgICAgICAgIHN0ciArPSBgXV0ke2luZGV4ID09PSAoYXIubGVuZ3RoIC0gMSkgPyAnJyA6ICcsJ31gO1xyXG4gICAgICAgICAgICBzdHIgKz0gYCAgLy8ke2luZm9zLmluZGV4fWA7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfSkuam9pbih0b2tlbnMubmV3bGluZSkpO1xyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke2dhbWVldmVudHNUeXBlc30nLCB0aGlzLmdhbWVldmVudHNUeXBlcy5tYXAoKGV2ZW50LCBpbmRleCwgYXIpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0ciA9IHRva2Vucy5pbmRlbnQ7XHJcbiAgICAgICAgICAgIHN0ciArPSBgJHtldmVudC5rZXl9OiBbJHtldmVudC50eXBlSW5kZXh9LCBcXCcke2V2ZW50Lm5hbWV9XFwnXWA7XHJcbiAgICAgICAgICAgIHN0ciArPSBpbmRleCA9PT0gYXIubGVuZ3RoIC0gMSA/ICcnIDogJywnO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pLmpvaW4odG9rZW5zLm5ld2xpbmUpKTtcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHttZXNzYWdlZXZlbnRzVHlwZXN9JywgdGhpcy5tZXNzYWdlZXZlbnRzVHlwZXMubWFwKChldmVudCwgaW5kZXgsIGFyKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSB0b2tlbnMuaW5kZW50O1xyXG4gICAgICAgICAgICBzdHIgKz0gYCR7ZXZlbnQua2V5fTogWyR7ZXZlbnQudHlwZUluZGV4fSwgXFwnJHtldmVudC5uYW1lfVxcJ11gO1xyXG4gICAgICAgICAgICBzdHIgKz0gaW5kZXggPT09IGFyLmxlbmd0aCAtIDEgPyAnJyA6ICcsJztcclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9KS5qb2luKHRva2Vucy5uZXdsaW5lKSk7XHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7dHJhY2tlcmV2ZW50c3R5cGVzfScsIHRoaXMudHJhY2tlcmV2ZW50c3R5cGVzLm1hcCgoZXZlbnQsIGluZGV4LCBhcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gdG9rZW5zLmluZGVudCArIHRva2Vucy5pbmRlbnQ7XHJcbiAgICAgICAgICAgIHN0ciArPSBgJHtldmVudC5rZXl9OiBbJHtldmVudC50eXBlSW5kZXh9LCBcXCcke2V2ZW50Lm5hbWV9XFwnXWA7XHJcbiAgICAgICAgICAgIHN0ciArPSBpbmRleCA9PT0gYXIubGVuZ3RoIC0gMSA/ICcnIDogJywnO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pLmpvaW4odG9rZW5zLm5ld2xpbmUpKTtcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHtnYW1lZXZlbnRzVHlwZWlkfScsIHRoaXMuZ2FtZWV2ZW50c1R5cGVpZCk7XHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7bWVzc2FnZWV2ZW50c1R5cGVpZH0nLCB0aGlzLm1lc3NhZ2VldmVudHNUeXBlaWQpO1xyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke3RyYWNrZXJldmVudHNUeXBlaWR9JywgdGhpcy50cmFja2VyZXZlbnRzVHlwZWlkKTtcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHtoZWFkZXJUeXBlaWR9JywgdGhpcy5oZWFkZXJUeXBlaWQpO1xyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke2RldGFpbHNUeXBlaWR9JywgdGhpcy5kZXRhaWxzVHlwZWlkKTtcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHtpbml0ZGF0YVR5cGVpZH0nLCB0aGlzLmluaXRkYXRhVHlwZWlkKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnUHJvdG9jb2wgV3JpdGUgVGltZTogJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlB5dGhvblByb3RvY29sQ29udmVydGVyID0gUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVVIbDBhRzl1VUhKdmRHOWpiMnhEYjI1MlpYSjBaWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SlFlWFJvYjI1UWNtOTBiMk52YkVOdmJuWmxjblJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEhWRFFVRjFRenRCUVVWMlF5eE5RVUZOTEZOQlFWTXNSMEZCUnpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPME5CYlUxcVFpeERRVUZETzBGQlIwWXNUVUZCVFN4TFFVRkxMRWRCUVVjN1NVRkRWaXhMUVVGTExFVkJRVVVzVlVGQlZTeEhRVUZITzFGQlEyaENMRTlCUVU4c1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0SlFVTnFReXhEUVVGRE8wbEJRMFFzVFVGQlRTeEZRVUZGTEZWQlFWVXNSMEZCUnp0UlFVTnFRaXhQUVVGUExFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1NVRkRia01zUTBGQlF6dEpRVU5FTEVsQlFVa3NSVUZCUlR0UlFVTkdMRTFCUVUwc1JVRkJSU3hWUVVGVkxFZEJRVWM3V1VGRGFrSXNUVUZCVFN4SFFVRkhMRWRCUVVjc1JVRkJSU3hEUVVGRE8xbEJRMllzVFVGQlRTeEhRVUZITEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU0zUWl4SFFVRkhMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtNc1QwRkJUeXhIUVVGSExFTkJRVU03VVVGRFppeERRVUZETzFGQlEwUXNUVUZCVFN4RlFVRkZMRlZCUVZVc1MwRkJTenRaUVVOdVFpeFBRVUZQTEVsQlFVa3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU03VVVGRGRFUXNRMEZCUXp0TFFVTktPMGxCUTBRc1QwRkJUeXhGUVVGRk8xRkJRMHdzVFVGQlRTeEZRVUZGTEZWQlFWVXNSMEZCUnp0WlFVTnFRaXhOUVVGTkxFZEJRVWNzUjBGQlJ5eEZRVUZGTEUxQlFVMHNSVUZCUlN4RlFVRkZMRVZCUVVVc1QwRkJUeXhGUVVGRkxFVkJRVVVzUlVGQlJTeERRVUZETzFsQlEzaERMRTFCUVUwc1IwRkJSeXhIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkZPVUlzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU01UXl4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTzJkQ1FVTndReXhOUVVGTkxFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnNReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXp0dlFrRkRZaXhMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRaaXhUUVVGVExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0cFFrRkRkRUlzUTBGQlF5eERRVUZETzJGQlEwNDdXVUZEUkN4UFFVRlBMRWRCUVVjc1EwRkJRenRSUVVObUxFTkJRVU03VVVGRFJDeE5RVUZOTEVWQlFVVXNWVUZCVlN4TFFVRkxPMWxCUTI1Q0xFOUJRVThzU1VGQlNTeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTeXhGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTzJkQ1FVTXhSaXhQUVVGUExFZEJRVWNzUzBGQlN5eFBRVUZQTEUxQlFVMHNRMEZCUXl4TFFVRkxMRTFCUVUwc1RVRkJUU3hEUVVGRExGTkJRVk1zU1VGQlNTeERRVUZETEV0QlFVc3NTMEZCU3l4RlFVRkZMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzFsQlEzaEhMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRPMUZCUTI1Q0xFTkJRVU03UzBGRFNqdEpRVU5FTEU5QlFVOHNSVUZCUlR0UlFVTk1MRTFCUVUwc1JVRkJSU3hWUVVGVkxFZEJRVWM3V1VGRGFrSXNUVUZCVFN4SFFVRkhMRWRCUVVjc1JVRkJSU3hMUVVGTExFVkJRVVVzUlVGQlJTeEZRVUZGTEVOQlFVTTdXVUZETVVJc1RVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVOcVF5eEpRVUZKTEUxQlFVMHNSVUZCUlR0blFrRkRVaXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4RlFVRkZPMjlDUVVOdVFpeExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dHZRa0ZETTBJc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTTdkMEpCUTFnc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdkMEpCUTJZc1UwRkJVeXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdkMEpCUTI1Q0xFZEJRVWNzUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPM0ZDUVVOb1FpeERRVUZETEVOQlFVTTdaMEpCUTFBc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRFRqdFpRVU5FTEU5QlFVOHNSMEZCUnl4RFFVRkRPMUZCUTJZc1EwRkJRenRSUVVORUxFMUJRVTBzUlVGQlJTeFZRVUZWTEV0QlFVczdXVUZEYmtJc1QwRkJUeXhKUVVGSkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFdEJRVXNzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlR0blFrRkRNME1zVDBGQlR5eExRVUZMTEVsQlFVa3NRMEZCUXl4TFFVRkxMRTFCUVUwc1NVRkJTU3hEUVVGRExGTkJRVk1zUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhMUVVGTExFVkJRVVVzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1dVRkRka2NzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU03VVVGRGJrSXNRMEZCUXp0TFFVTktPMGxCUTBRc1MwRkJTeXhGUVVGRk8xRkJRMGdzVFVGQlRTeEZRVUZGTEZWQlFWVXNSMEZCUnp0WlFVTnFRaXhQUVVGUExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJRMnhETEVOQlFVTTdVVUZEUkN4TlFVRk5MRVZCUVVVc1ZVRkJWU3hMUVVGTE8xbEJRMjVDTEU5QlFVOHNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdVVUZEY0VNc1EwRkJRenRMUVVOS08wbEJRMFFzUzBGQlN5eEZRVUZGTzFGQlEwZ3NUVUZCVFN4RlFVRkZMRlZCUVZVc1IwRkJSenRaUVVOcVFpeFBRVUZQTEVWQlFVVXNRMEZCUXp0UlFVTmtMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFVkJRVVVzVlVGQlZTeExRVUZMTzFsQlEyNUNMRTlCUVU4c1JVRkJSU3hEUVVGRE8xRkJRMlFzUTBGQlF6dExRVU5LTzBsQlEwUXNUVUZCVFN4RlFVRkZPMUZCUTBvc1RVRkJUU3hGUVVGRkxGVkJRVlVzUjBGQlJ6dFpRVU5xUWl4UFFVRlBMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRMmhDTEVWQlFVVXNVMEZCVXl4RlFVRkZMRWRCUVVjc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkRia01zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRM3BDTEVOQlFVTTdVVUZEVGl4RFFVRkRPMUZCUTBRc1RVRkJUU3hGUVVGRkxGVkJRVlVzUzBGQlN6dFpRVU51UWl4UFFVRlBMRWxCUVVrc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRSUVVNeFJTeERRVUZETzB0QlEwbzdTVUZEUkN4VFFVRlRMRVZCUVVVN1VVRkRVQ3hOUVVGTkxFVkJRVVVzVlVGQlZTeEhRVUZITzFsQlEycENMRTlCUVU4c1JVRkJSU3hUUVVGVExFVkJRVVVzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNN1VVRkRkRU1zUTBGQlF6dFJRVU5FTEUxQlFVMHNSVUZCUlN4VlFVRlZMRXRCUVVzN1dVRkRia0lzVDBGQlR5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRSUVVOb1F5eERRVUZETzB0QlEwbzdTVUZEUkN4UFFVRlBMRVZCUVVVN1VVRkRUQ3hOUVVGTkxFVkJRVVVzVlVGQlZTeEhRVUZITzFsQlEycENMRTlCUVU4c1JVRkJSU3hEUVVGRE8xRkJRMlFzUTBGQlF6dFJRVU5FTEUxQlFVMHNSVUZCUlN4VlFVRlZMRXRCUVVzN1dVRkRia0lzVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEWkN4RFFVRkRPMHRCUTBvN1NVRkRSQ3hUUVVGVExFVkJRVVU3VVVGRFVDeE5RVUZOTEVWQlFVVXNWVUZCVlN4SFFVRkhPMWxCUTJwQ0xFOUJRVThzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGJFTXNRMEZCUXp0UlFVTkVMRTFCUVUwc1JVRkJSU3hWUVVGVkxFdEJRVXM3V1VGRGJrSXNUMEZCVHl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0UlFVTndReXhEUVVGRE8wdEJRMG83U1VGRFJDeExRVUZMTEVWQlFVVTdVVUZEU0N4TlFVRk5MRVZCUVVVc1ZVRkJWU3hIUVVGSE8xbEJRMnBDTEU5QlFVOHNSVUZCUlN4RFFVRkRPMUZCUTJRc1EwRkJRenRSUVVORUxFMUJRVTBzUlVGQlJTeFZRVUZWTEV0QlFVczdXVUZEYmtJc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRFpDeERRVUZETzB0QlEwbzdRMEZEU2l4RFFVRkRPMEZCUlVZc1RVRkJUU3hOUVVGTkxFZEJRVWM3U1VGRFdDeFBRVUZQTEVWQlFVVXNTVUZCU1R0SlFVTmlMRTFCUVUwc1JVRkJSU3hKUVVGSk8wbEJRMW9zWTBGQll5eEZRVUZGTEdWQlFXVTdTVUZETDBJc1dVRkJXU3hGUVVGRkxFZEJRVWM3U1VGRGFrSXNaVUZCWlN4RlFVRkZMSE5DUVVGelFqdEpRVU4yUXl4aFFVRmhMRVZCUVVVc1IwRkJSenRKUVVOc1FpeHJRa0ZCYTBJc1JVRkJSU3g1UWtGQmVVSTdTVUZETjBNc1owSkJRV2RDTEVWQlFVVXNSMEZCUnp0SlFVTnlRaXhyUWtGQmEwSXNSVUZCUlN4NVFrRkJlVUk3U1VGRE4wTXNaMEpCUVdkQ0xFVkJRVVVzUjBGQlJ6dEpRVU55UWl4blFrRkJaMElzUlVGQlJTeDFRa0ZCZFVJN1NVRkRla01zYlVKQlFXMUNMRVZCUVVVc01FSkJRVEJDTzBsQlF5OURMRzFDUVVGdFFpeEZRVUZGTERCQ1FVRXdRanRKUVVNdlF5eFpRVUZaTEVWQlFVVXNkMEpCUVhkQ08wbEJRM1JETEdGQlFXRXNSVUZCUlN4MVFrRkJkVUk3U1VGRGRFTXNZMEZCWXl4RlFVRkZMREJDUVVFd1FqdERRVU0zUXl4RFFVRkRPMEZCUlVZc1RVRkJUU3hMUVVGTExFZEJRVWM3U1VGRFZpeE5RVUZOTEVWQlFVVXNRMEZCUXl4VFFVRlRMRVZCUVVVc1RVRkJUU3hEUVVGRE8wbEJRek5DTEU5QlFVOHNSVUZCUlR0UlFVTk1MRk5CUVZNN1VVRkRWQ3hUUVVGVE8xRkJRMVFzVVVGQlVUdExRVU5ZTzBsQlEwUXNUVUZCVFN4RlFVRkZMRVZCUVVVN1NVRkRWaXhOUVVGTkxFVkJRVVVzUlVGQlJUdEpRVU5XTEVsQlFVa3NSVUZCUlN4RlFVRkZPMGxCUTFJc1RVRkJUU3hGUVVGRkxFVkJRVVU3UTBGRFlpeERRVUZETzBGQlJVWTdTVUYzUWtrc1dVRkJNa0lzVDBGQlpTeEZRVUZGTEUxQlFXTTdVVUZCTDBJc1dVRkJUeXhIUVVGUUxFOUJRVThzUTBGQlVUdFJRVU4wUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF6dEpRVU42UWl4RFFVRkRPMGxCV0Uwc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eFpRVUZ2UWp0UlFVTjBReXhOUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVsQlFVa3NSVUZCUlN4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8xRkJRMjVETEUxQlFVMHNVVUZCVVN4SFFVRnBReXhGUVVGRkxFTkJRVU03VVVGRGJFUXNUVUZCVFN4RlFVRkZMRWRCUVVjc1VVRkJVU3hEUVVGRExGTkJRVk1zUlVGQlJTeFZRVUZWTEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNN1VVRkRla1FzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVOMlFpeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMSGxDUVVGNVFpeEZRVUZGTEVsQlFVa3NTVUZCU1N4RlFVRkZMRU5CUVVNc1QwRkJUeXhGUVVGRkxFZEJRVWNzUzBGQlN5eERRVUZETEVOQlFVTTdVVUZEY2tVc1QwRkJUeXhSUVVGUkxFTkJRVU03U1VGRGNFSXNRMEZCUXp0SlFVMU5MRTlCUVU4N1VVRkRWaXhQUVVGUExIVkNRVUYxUWl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3hEUVVGRE8wbEJSVTBzVDBGQlR6dFJRVU5XTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEzaENMRTlCUVU4c1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzBsQlEzaENMRU5CUVVNN1NVRkpUeXhMUVVGTExFTkJRVU1zUjBGQlZ6dFJRVU55UWl4TlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxFbEJRVWtzUlVGQlJTeERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMUZCUTI1RExFMUJRVTBzUzBGQlN5eEhRVUZITEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlEzaERMRWxCUVVrc1NVRkJTU3hIUVVGSExFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTTdVVUZEYkVJc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZEY0VJc1NVRkJTU3hEUVVGRExHVkJRV1VzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZETVVJc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVNM1FpeEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFZEJRVWNzUlVGQlJTeERRVUZETzFGQlF6ZENMRTlCUVU4c1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZEZUVJc1IwRkJSeXhIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRaUVVONlFpeEpRVUZKTEVkQlFVY3NTMEZCU3l4TlFVRk5MRU5CUVVNc1kwRkJZeXhGUVVGRk8yZENRVU12UWl4SlFVRkpMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5XTEVkQlFVY3NSMEZCUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdaMEpCUTNwQ0xFZEJRVWM3YjBKQlEwTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU01UXl4SlFVRkpMRWxCUVVrc1EwRkJReXhEUVVGRE8yOUNRVU5XTEVkQlFVY3NSMEZCUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdhVUpCUXpWQ0xGRkJRVkVzUjBGQlJ5eExRVUZMTEUxQlFVMHNRMEZCUXl4WlFVRlpMRVZCUVVVN1lVRkRla003YVVKQlFVMHNTVUZCU1N4TlFVRk5MRU5CUVVNc1pVRkJaU3hMUVVGTExFZEJRVWNzUlVGQlJUdG5Ra0ZEZGtNc1NVRkJTU3hKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEVml4SFFVRkhMRWRCUVVjc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRPMmRDUVVONlFpeEhRVUZITzI5Q1FVTkRMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEYUVRc1NVRkJTU3hKUVVGSkxFTkJRVU1zUTBGQlF6dHZRa0ZEVml4SFFVRkhMRWRCUVVjc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRPMmxDUVVNMVFpeFJRVUZSTEUxQlFVMHNRMEZCUXl4aFFVRmhMRXRCUVVzc1IwRkJSeXhGUVVGRk8yRkJRekZETzJsQ1FVRk5MRWxCUVVrc1RVRkJUU3hEUVVGRExHdENRVUZyUWl4TFFVRkxMRWRCUVVjc1JVRkJSVHRuUWtGRE1VTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFZpeEhRVUZITEVkQlFVY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzJkQ1FVTjZRaXhIUVVGSE8yOUNRVU5ETEVsQlFVa3NRMEZCUXl4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTnVSQ3hKUVVGSkxFbEJRVWtzUTBGQlF5eERRVUZETzI5Q1FVTldMRWRCUVVjc1IwRkJSeXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN2FVSkJRelZDTEZGQlFWRXNUVUZCVFN4RFFVRkRMR2RDUVVGblFpeExRVUZMTEVkQlFVY3NSVUZCUlR0aFFVTTNRenRwUWtGQlRTeEpRVUZKTEUxQlFVMHNRMEZCUXl4clFrRkJhMElzUzBGQlN5eEhRVUZITEVWQlFVVTdaMEpCUXpGRExFbEJRVWtzU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTFZc1IwRkJSeXhIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRuUWtGRGVrSXNSMEZCUnp0dlFrRkRReXhKUVVGSkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGJrUXNTVUZCU1N4SlFVRkpMRU5CUVVNc1EwRkJRenR2UWtGRFZpeEhRVUZITEVkQlFVY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzJsQ1FVTTFRaXhSUVVGUkxFMUJRVTBzUTBGQlF5eG5Ra0ZCWjBJc1MwRkJTeXhIUVVGSExFVkJRVVU3WVVGRE4wTTdhVUpCUVUwc1NVRkJTU3hIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4blFrRkJaMElzUTBGQlF5eEZRVUZGTzJkQ1FVTm9SQ3hKUVVGSkxFTkJRVU1zWjBKQlFXZENMRWRCUVVjc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVNdlF6dHBRa0ZCVFN4SlFVRkpMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeERRVUZETEcxQ1FVRnRRaXhEUVVGRExFVkJRVVU3WjBKQlEyNUVMRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNSMEZCUnl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMkZCUTJ4RU8ybENRVUZOTEVsQlFVa3NSMEZCUnl4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1JVRkJSVHRuUWtGRGJrUXNTVUZCU1N4RFFVRkRMRzFDUVVGdFFpeEhRVUZITEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdZVUZEYkVRN2FVSkJRVTBzU1VGQlNTeEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUlVGQlJUdG5Ra0ZETlVNc1NVRkJTU3hEUVVGRExGbEJRVmtzUjBGQlJ5eEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJGQlF6TkRPMmxDUVVGTkxFbEJRVWtzUjBGQlJ5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExFVkJRVVU3WjBKQlF6ZERMRWxCUVVrc1EwRkJReXhoUVVGaExFZEJRVWNzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dGhRVU0xUXp0cFFrRkJUU3hKUVVGSkxFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJReXhGUVVGRk8yZENRVU01UXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhIUVVGSExFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRE4wTTdXVUZGUkN4SlFVRkpMRWxCUVVrc1EwRkJReXhEUVVGRE8xTkJRMkk3VVVGRFJDeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMSFZDUVVGMVFpeEZRVUZGTEVsQlFVa3NTVUZCU1N4RlFVRkZMRU5CUVVNc1QwRkJUeXhGUVVGRkxFZEJRVWNzUzBGQlN5eERRVUZETEVOQlFVTTdTVUZEZGtVc1EwRkJRenRKUVVWUExGVkJRVlVzUTBGQlF5eEhRVUZYTzFGQlF6RkNMRTFCUVUwc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eExRVUZMTEVOQlFVTXNOa0pCUVRaQ0xFTkJRVU1zUTBGQlF6dFJRVU55UkN4UFFVRlBPMWxCUTBnc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEV0N4VFFVRlRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUWl4SlFVRkpMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU5tTEVOQlFVTTdTVUZEVGl4RFFVRkRPMGxCUlU4c1kwRkJZeXhEUVVGRExFZEJRVmM3VVVGRE9VSXNUVUZCVFN4VFFVRlRMRWRCUVVjc2EwTkJRV3RETEVOQlFVTTdVVUZEY2tRc1RVRkJUU3hMUVVGTExFZEJRVzFFTEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJRek5GTEUxQlFVMHNSMEZCUnl4SFFVRkhMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZEYUVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRjRUlzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hMUVVGTExFTkJRVU1zUzBGQlN5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVFpeFBRVUZQTEV0QlFVc3NRMEZCUXp0SlFVTnFRaXhEUVVGRE8wbEJSVThzUzBGQlN6dFJRVU5VTEUxQlFVMHNTMEZCU3l4SFFVRkhMRWxCUVVrc1NVRkJTU3hGUVVGRkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEYmtNc1RVRkJUU3hWUVVGVkxFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRk9VTXNTVUZCU1N4SFFVRkhMRWRCUVZjc1UwRkJVeXhEUVVGRE8xRkJSVFZDTEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExGTkJRVk1zUlVGQlJTeEpRVUZKTEVsQlFVa3NSVUZCUlN4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRmRrUXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVTBzV1VGQldTeEZRVUZQTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVWNFJDeEpRVUZKTEZWQlFWVXNSVUZCUlR0WlFVTmFMRTFCUVUwc1MwRkJTeXhIUVVGSExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF6dFpRVU0zUlN4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZWTEVWQlFVVXNjVUpCUVhGQ0xFdEJRVXNzVFVGQlRTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVOdVJqdGhRVUZOTzFsQlEwZ3NSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlZTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMU5CUTNKRE8xRkJSVVFzUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1kwRkJZeXhGUVVGRkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlR0WlFVTjBSU3hKUVVGSkxFZEJRVWNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUlhoQ0xFZEJRVWNzU1VGQlNTeExRVUZMTEV0QlFVc3NRMEZCUXl4SlFVRkpMRTFCUVUwc1EwRkJRenRaUVVNM1FpeEhRVUZITEVsQlFVa3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkRka01zUjBGQlJ5eEpRVUZKTEV0QlFVc3NTMEZCU3l4TFFVRkxMRU5CUVVNc1JVRkJSU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXp0WlFVTnVSQ3hIUVVGSExFbEJRVWtzVDBGQlR5eExRVUZMTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1dVRkZOVUlzVDBGQlR5eEhRVUZITEVOQlFVTTdVVUZEWml4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkZla0lzUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc2IwSkJRVzlDTEVWQlFVVXNTVUZCU1N4RFFVRkRMR1ZCUVdVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRk8xbEJRMnhHTEVsQlFVa3NSMEZCUnl4SFFVRkhMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03V1VGRmVFSXNSMEZCUnl4SlFVRkpMRWRCUVVjc1MwRkJTeXhEUVVGRExFZEJRVWNzVFVGQlRTeExRVUZMTEVOQlFVTXNVMEZCVXl4UFFVRlBMRXRCUVVzc1EwRkJReXhKUVVGSkxFdEJRVXNzUTBGQlF6dFpRVU12UkN4SFFVRkhMRWxCUVVrc1MwRkJTeXhMUVVGTExFVkJRVVVzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXp0WlFVVXhReXhQUVVGUExFZEJRVWNzUTBGQlF6dFJRVU5tTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVjZRaXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4MVFrRkJkVUlzUlVGQlJTeEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJUdFpRVU40Uml4SlFVRkpMRWRCUVVjc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzFsQlJYaENMRWRCUVVjc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEUxQlFVMHNTMEZCU3l4RFFVRkRMRk5CUVZNc1QwRkJUeXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTTdXVUZETDBRc1IwRkJSeXhKUVVGSkxFdEJRVXNzUzBGQlN5eEZRVUZGTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNN1dVRkZNVU1zVDBGQlR5eEhRVUZITEVOQlFVTTdVVUZEWml4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkZla0lzUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc2RVSkJRWFZDTEVWQlFVVXNTVUZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVTdXVUZEZUVZc1NVRkJTU3hIUVVGSExFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRE8xbEJSWGhETEVkQlFVY3NTVUZCU1N4SFFVRkhMRXRCUVVzc1EwRkJReXhIUVVGSExFMUJRVTBzUzBGQlN5eERRVUZETEZOQlFWTXNUMEZCVHl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFTkJRVU03V1VGREwwUXNSMEZCUnl4SlFVRkpMRXRCUVVzc1MwRkJTeXhGUVVGRkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTTdXVUZGTVVNc1QwRkJUeXhIUVVGSExFTkJRVU03VVVGRFppeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGZWtJc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNjVUpCUVhGQ0xFVkJRVVVzU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU03VVVGRGFFVXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zZDBKQlFYZENMRVZCUVVVc1NVRkJTU3hEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRU5CUVVNN1VVRkRkRVVzUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc2QwSkJRWGRDTEVWQlFVVXNTVUZCU1N4RFFVRkRMRzFDUVVGdFFpeERRVUZETEVOQlFVTTdVVUZEZEVVc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNhVUpCUVdsQ0xFVkJRVVVzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRPMUZCUTNoRUxFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR3RDUVVGclFpeEZRVUZGTEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVNeFJDeEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXh0UWtGQmJVSXNSVUZCUlN4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU03VVVGRE5VUXNUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXgxUWtGQmRVSXNSVUZCUlN4SlFVRkpMRWxCUVVrc1JVRkJSU3hEUVVGRExFOUJRVThzUlVGQlJTeEhRVUZITEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUTI1RkxFOUJRVThzUjBGQlJ5eERRVUZETzBsQlEyWXNRMEZCUXp0RFFVVktPMEZCZUV4RUxEQkVRWGRNUXlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGRlY29kZXJfMSA9IHJlcXVpcmUoXCIuLi9kZWNvZGVyXCIpO1xyXG5leHBvcnRzLkJpdFBhY2tlZEJ1ZmZlciA9IGRlY29kZXJfMS5CaXRQYWNrZWRCdWZmZXI7XHJcbmV4cG9ydHMuVmVyc2lvbkRlY29kZXIgPSBkZWNvZGVyXzEuVmVyc2lvbkRlY29kZXI7XHJcbmV4cG9ydHMuQml0UGFja2VkRGVjb2RlciA9IGRlY29kZXJfMS5CaXRQYWNrZWREZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laR1ZqYjJSbGNuTXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKa1pXTnZaR1Z5Y3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEhkRFFVRTJSVHRCUVVWNFJTd3dRa0ZHUnl4NVFrRkJaU3hEUVVWSU8wRkJRMllzZVVKQlNHOUNMSGRDUVVGakxFTkJSM0JDTzBGQlEyUXNNa0pCU205RExEQkNRVUZuUWl4RFFVbHdReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcclxuY29uc3QgbXBxXzEgPSByZXF1aXJlKFwiQGhlcm9lc2Jyb3dzZXIvbXBxXCIpO1xyXG5jb25zdCBoZXJvcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi9oZXJvcHJvdG9jb2xcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XHJcbmNvbnN0IGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XHJcbmNvbnN0IEJlaGF2aW9yU3ViamVjdF8xID0gcmVxdWlyZShcInJ4anMvQmVoYXZpb3JTdWJqZWN0XCIpO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ3MoZGF0YSkge1xyXG4gICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgYnVmZmVyXzEuQnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoaXRlbSA9PiBwYXJzZVN0cmluZ3MoaXRlbSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICBkYXRhW2tleV0gPSBwYXJzZVN0cmluZ3MoZGF0YVtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG47XHJcbnZhciBSZXBsYXlGaWxlcztcclxuKGZ1bmN0aW9uIChSZXBsYXlGaWxlcykge1xyXG4gICAgUmVwbGF5RmlsZXNbXCJERVRBSUxTXCJdID0gXCJyZXBsYXkuZGV0YWlsc1wiO1xyXG4gICAgUmVwbGF5RmlsZXNbXCJJTklUREFUQVwiXSA9IFwicmVwbGF5LmluaXRkYXRhXCI7XHJcbiAgICBSZXBsYXlGaWxlc1tcIkdBTUVfRVZFTlRTXCJdID0gXCJyZXBsYXkuZ2FtZS5ldmVudHNcIjtcclxuICAgIFJlcGxheUZpbGVzW1wiTUVTU0FHRV9FVkVOVFNcIl0gPSBcInJlcGxheS5tZXNzYWdlLmV2ZW50c1wiO1xyXG4gICAgUmVwbGF5RmlsZXNbXCJUUkFDS0VSX0VWRU5UU1wiXSA9IFwicmVwbGF5LnRyYWNrZXIuZXZlbnRzXCI7XHJcbiAgICBSZXBsYXlGaWxlc1tcIkFUVFJJQlVURVNfRVZFTlRTXCJdID0gXCJyZXBsYXkuYXR0cmlidXRlcy5ldmVudHNcIjtcclxufSkoUmVwbGF5RmlsZXMgPSBleHBvcnRzLlJlcGxheUZpbGVzIHx8IChleHBvcnRzLlJlcGxheUZpbGVzID0ge30pKTtcclxuY29uc3QgZGVjb2Rlck1hcCA9IHtcclxuICAgIFtSZXBsYXlGaWxlcy5ERVRBSUxTXTogJ2RlY29kZVJlcGxheURldGFpbHMnLFxyXG4gICAgW1JlcGxheUZpbGVzLklOSVREQVRBXTogJ2RlY29kZVJlcGxheUluaXRkYXRhJyxcclxuICAgIFtSZXBsYXlGaWxlcy5HQU1FX0VWRU5UU106ICdkZWNvZGVSZXBsYXlHYW1lRXZlbnRzJyxcclxuICAgIFtSZXBsYXlGaWxlcy5NRVNTQUdFX0VWRU5UU106ICdkZWNvZGVSZXBsYXlNZXNzYWdlRXZlbnRzJyxcclxuICAgIFtSZXBsYXlGaWxlcy5UUkFDS0VSX0VWRU5UU106ICdkZWNvZGVSZXBsYXlUcmFja2VyRXZlbnRzJyxcclxuICAgIFtSZXBsYXlGaWxlcy5BVFRSSUJVVEVTX0VWRU5UU106ICdkZWNvZGVSZXBsYXlBdHRyaWJ1dGVzRXZlbnRzJyxcclxufTtcclxubGV0IFJlcGxheSA9IGNsYXNzIFJlcGxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtcHFEYXRhKSB7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3RfMS5CZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NUaW1lID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRQcm90b2NvbCA9IChwcm90b2NvbFZlcnNpb24pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGhlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5sb2FkUHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxvYWRIZXJvRGF0YSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGhlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5sb2FkSGVyb0RhdGEoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tcHEgPSBuZXcgbXBxXzEuTVBRQXJjaGl2ZShtcHFEYXRhKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl9tcHEuZmlsZXMpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlU3RhdHVzKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RhdHVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNTdWJqZWN0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHByb3RvY29sKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm90b2NvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc1Byb21pc2UodGhpcy5fcHJvdG9jb2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUhlYWRlcigpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc1Byb21pc2UodGhpcy5fcHJvdG9jb2wpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlcm9EYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlcm9EYXRhKCk7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGFyc2VIZWFkZXIoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ1JFUExBWV9SRUFEWScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlYWRlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5faGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXNQcm9taXNlKHRoaXMuX2hlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGVhZGVyKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgZGV0YWlscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKFJlcGxheUZpbGVzLkRFVEFJTFMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGluaXREYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoUmVwbGF5RmlsZXMuSU5JVERBVEEpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdhbWVFdmVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzKFJlcGxheUZpbGVzLkdBTUVfRVZFTlRTKTtcclxuICAgIH1cclxuICAgIGdldCBtZXNzYWdlRXZlbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50cyhSZXBsYXlGaWxlcy5NRVNTQUdFX0VWRU5UUyk7XHJcbiAgICB9XHJcbiAgICBnZXQgdHJhY2tlckV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMoUmVwbGF5RmlsZXMuVFJBQ0tFUl9FVkVOVFMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF0dHJpYnV0ZUV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKFJlcGxheUZpbGVzLkFUVFJJQlVURVNfRVZFTlRTKTtcclxuICAgIH1cclxuICAgIG1hbmFnZVN0YXR1cygpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZVN1YiA9IHRoaXMuX3N0YXRlU3ViamVjdC5zdWJzY3JpYmUoKG5leHQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzU3ViamVjdC5uZXh0KG5leHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU3RhdHVzKHN0YXR1cywgY3VycmVudCA9IDAsIHRvdGFsID0gLTEpIHtcclxuICAgICAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdyZXBsYXktc3RhdHVzJyxcclxuICAgICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgICBjdXJyZW50LFxyXG4gICAgICAgICAgICB0b3RhbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRvdGFsID09PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVN1YmplY3QubmV4dCh0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3ViamVjdC5uZXh0KG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBub3cgLSB0aGlzLl9sYXN0UHJvZ3Jlc3NUaW1lO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAxMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVTdWJqZWN0Lm5leHQobXNnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1RpbWUgPSBub3c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBtc2c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJzZUhlYWRlcigpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygncGFyc2VIZWFkZXInKTtcclxuICAgICAgICAgICAgY29uc3QgaGVhZFByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbCgyOTQwNik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd0hlYWRlciA9IHBhcnNlU3RyaW5ncyhoZWFkUHJvdG9jb2wuZGVjb2RlUmVwbGF5SGVhZGVyKHRoaXMuX21wcS5oZWFkZXIudXNlckRhdGFIZWFkZXIuY29udGVudCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbFByb21pc2UgPSB0aGlzLmdldFByb3RvY29sKHJhd0hlYWRlci5tX3ZlcnNpb24ubV9iYXNlQnVpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHlpZWxkIHRoaXMuX3Byb3RvY29sUHJvbWlzZTtcclxuICAgICAgICAgICAgdGhpcy5faGVhZGVyID0gcGFyc2VTdHJpbmdzKHRoaXMuX3Byb3RvY29sLmRlY29kZVJlcGxheUhlYWRlcih0aGlzLl9tcHEuaGVhZGVyLnVzZXJEYXRhSGVhZGVyLmNvbnRlbnQpKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ3BhcnNlSGVhZGVyJywgLTEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2dldFByb3RvY29sJyk7XHJcbiAgICAgICAgICAgIGlmIChoZXJvcHJvdG9jb2xfMS5IZXJvUHJvdG9jb2wuaGFzUHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5nZXRQcm90b2NvbChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB5aWVsZCB0aGlzLmxvYWRQcm90b2NvbChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IGhlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5jb21waWxlKHByb3RvY29sVmVyc2lvbiwgY29kZSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdnZXRQcm90b2NvbCcsIC0xKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0SGVyb0RhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2dldEhlcm9EYXRhJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCB0aGlzLmxvYWRIZXJvRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnZ2V0SGVyb0RhdGEnLCAtMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGFyc2UodHlwZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5wcm90b2NvbDtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHBhcnNlU3RyaW5ncyhwcm90b2NvbFtkZWNvZGVyTWFwW3R5cGVdXSh0aGlzLl9tcHEucmVhZEZpbGUodHlwZSkpKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YS5zZXQodHlwZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGFyc2VFdmVudHModHlwZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5wcm90b2NvbDtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRHZW4gPSBwcm90b2NvbFtkZWNvZGVyTWFwW3R5cGVdXSh0aGlzLl9tcHEucmVhZEZpbGUodHlwZSkpO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ3BhcnNlLWV2ZW50LScgKyB0eXBlLCAwLCBwcm90b2NvbC5wcm9ncmVzcy50b3RhbCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRHZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlc18xLkZpbHRlcmVkRXZlbnRzLmluZGV4T2YoZXZlbnQuX2V2ZW50KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChwYXJzZVN0cmluZ3MoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdwYXJzZS1ldmVudC0nICsgdHlwZSwgcHJvdG9jb2wucHJvZ3Jlc3MuY3VycmVudCwgcHJvdG9jb2wucHJvZ3Jlc3MudG90YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuc2V0KHR5cGUsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdwYXJzZS1ldmVudC0nICsgdHlwZSwgLTEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGF0YSh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzUHJvbWlzZSh0aGlzLl9kYXRhLmdldCh0eXBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKHR5cGUpO1xyXG4gICAgfVxyXG4gICAgZXZlbnRzKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGF0YS5oYXModHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNQcm9taXNlKHRoaXMuX2RhdGEuZ2V0KHR5cGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFdmVudHModHlwZSk7XHJcbiAgICB9XHJcbiAgICBhc1Byb21pc2UodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcyh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX21wcSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgUmVwbGF5LnByb3RvdHlwZSwgXCJoZWFkZXJcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIFJlcGxheS5wcm90b3R5cGUsIFwiZGV0YWlsc1wiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgUmVwbGF5LnByb3RvdHlwZSwgXCJpbml0RGF0YVwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgUmVwbGF5LnByb3RvdHlwZSwgXCJnYW1lRXZlbnRzXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBSZXBsYXkucHJvdG90eXBlLCBcIm1lc3NhZ2VFdmVudHNcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIFJlcGxheS5wcm90b3R5cGUsIFwidHJhY2tlckV2ZW50c1wiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgUmVwbGF5LnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVFdmVudHNcIiwgbnVsbCk7XHJcblJlcGxheSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJlcGxheVdvcmtlckNvbnRleHQoJzAwOERDRjcwLUI3RTQtNDJERi1BM0Y5LTREMkFERTEzRTcxOCcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheUJ1ZmZlcl0pXHJcbl0sIFJlcGxheSk7XHJcbmV4cG9ydHMuUmVwbGF5ID0gUmVwbGF5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVbVZ3YkdGNUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpVW1Wd2JHRjVMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPenM3T3pzN096czdPenM3UVVGQlFTeHRRMEZCWjBNN1FVRkRhRU1zTkVOQlFXZEVPMEZCUTJoRUxHdEVRVUVyUXp0QlFVTXZReXh2UTBGTmEwSTdRVUZEYkVJc05rTkJRV2RGTzBGQlEyaEZMREJFUVVGMVJEdEJRVTkyUkN4elFrRkJlVUlzU1VGQlNUdEpRVU42UWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hGUVVGRk8xRkJRMUFzVDBGQlR5eEpRVUZKTEVOQlFVTTdTMEZEWmp0VFFVRk5MRWxCUVVrc1NVRkJTU3haUVVGWkxHVkJRVTBzUlVGQlJUdFJRVU12UWl4UFFVRlBMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dExRVU14UWp0VFFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0UlFVTTFRaXhQUVVGUExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0TFFVTXZRenRUUVVGTkxFbEJRVWtzVDBGQlR5eEpRVUZKTEV0QlFVc3NVVUZCVVN4RlFVRkZPMUZCUldwRExFdEJRVXNzVFVGQlRTeEhRVUZITEVsQlFVa3NTVUZCU1N4RlFVRkZPMWxCUTNCQ0xFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEZGtNN1MwRkRTanRKUVVORUxFOUJRVThzU1VGQlNTeERRVUZETzBGQlEyaENMRU5CUVVNN1FVRkJRU3hEUVVGRE8wRkJSMFlzU1VGQldTeFhRVkZZTzBGQlVrUXNWMEZCV1N4WFFVRlhPMGxCUTI1Q0xIbERRVUV3UWl4RFFVRkJPMGxCUXpGQ0xESkRRVUUwUWl4RFFVRkJPMGxCUXpWQ0xHbEVRVUZyUXl4RFFVRkJPMGxCUTJ4RExIVkVRVUYzUXl4RFFVRkJPMGxCUTNoRExIVkVRVUYzUXl4RFFVRkJPMGxCUTNoRExEWkVRVUU0UXl4RFFVRkJPMEZCUld4RUxFTkJRVU1zUlVGU1Z5eFhRVUZYTEVkQlFWZ3NiVUpCUVZjc1MwRkJXQ3h0UWtGQlZ5eFJRVkYwUWp0QlFVVkVMRTFCUVUwc1ZVRkJWU3hIUVVGSE8wbEJRMllzUTBGQlF5eFhRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVc2NVSkJRWEZDTzBsQlF6VkRMRU5CUVVNc1YwRkJWeXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEhOQ1FVRnpRanRKUVVNNVF5eERRVUZETEZkQlFWY3NRMEZCUXl4WFFVRlhMRU5CUVVNc1JVRkJSU3gzUWtGQmQwSTdTVUZEYmtRc1EwRkJReXhYUVVGWExFTkJRVU1zWTBGQll5eERRVUZETEVWQlFVVXNNa0pCUVRKQ08wbEJRM3BFTEVOQlFVTXNWMEZCVnl4RFFVRkRMR05CUVdNc1EwRkJReXhGUVVGRkxESkNRVUV5UWp0SlFVTjZSQ3hEUVVGRExGZEJRVmNzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhGUVVGRkxEaENRVUU0UWp0RFFVTnNSU3hEUVVGRE8wRkJSMFlzU1VGQllTeE5RVUZOTEVkQlFXNUNPMGxCZFVWSkxGbEJRVzFDTEU5QlFXOUNPMUZCYWtVdlFpeFZRVUZMTEVkQlFUQkNMRWxCUVVrc1IwRkJSeXhGUVVGdlFpeERRVUZETzFGQlF6TkVMRzFDUVVGakxFZEJRVEJETEVsQlFVa3NhVU5CUVdVc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF6dFJRVU4yUml4clFrRkJZU3hIUVVFd1F5eEpRVUZKTEdsRFFVRmxMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU03VVVGM1JuUkdMSE5DUVVGcFFpeEhRVUZITEVOQlFVTXNRMEZCUXp0UlFXbEVka0lzYVVKQlFWa3NSMEZCUnl4RFFVRlBMR1ZCUVhWQ0xFVkJRVzFDTEVWQlFVVTdXVUZEY2tVc1QwRkJUeXhOUVVGTkxESkNRVUZaTEVOQlFVTXNXVUZCV1N4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRE8xRkJRelZFTEVOQlFVTXNRMEZCUVN4RFFVRkJPMUZCUlUwc2FVSkJRVmtzUjBGQlJ5eEhRVUUyUWl4RlFVRkZPMWxCUTJwRUxFOUJRVThzVFVGQlRTd3lRa0ZCV1N4RFFVRkRMRmxCUVZrc1JVRkJSU3hEUVVGRE8xRkJRemRETEVOQlFVTXNRMEZCUVN4RFFVRkJPMUZCTDBWSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVkQlFVY3NTVUZCU1N4blFrRkJWU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlEzQkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVrM1FpeEpRVUZKTEVOQlFVTXNXVUZCV1N4RlFVRkZMRU5CUVVNN1NVRkRlRUlzUTBGQlF6dEpRV3hGUkN4SlFVRlhMRTFCUVUwN1VVRkRZaXhQUVVGUExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTTdTVUZETDBJc1EwRkJRenRKUVVORUxFbEJRVmNzVVVGQlVUdFJRVU5tTEVsQlFVa3NTVUZCU1N4RFFVRkRMRk5CUVZNc1JVRkJSVHRaUVVOb1FpeFBRVUZQTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzFOQlEzcERPMUZCUTBRc1QwRkJUeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1JVRkJSVHRaUVVOb1F5eFBRVUZQTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzFGQlF6RkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMUFzUTBGQlF6dEpRVVZFTEVsQlFWY3NVVUZCVVR0UlFVTm1MRTlCUVU4c1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETzBsQlF6bENMRU5CUVVNN1NVRkZXU3hWUVVGVk96dFpRVU51UWl4TlFVRk5MRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF6dFpRVU42UWl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETzFGQlEzSkRMRU5CUVVNN1MwRkJRVHRKUVVkR0xFbEJRVmNzVFVGQlRUdFJRVU5pTEVsQlFVa3NTVUZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSVHRaUVVOa0xFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xTkJRMmhETzFGQlEwUXNUMEZCVHl4SlFVRkpMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU03U1VGRE9VSXNRMEZCUXp0SlFVZEVMRWxCUVZjc1QwRkJUenRSUVVOa0xFOUJRVThzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCYVVJc1YwRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlF6RkVMRU5CUVVNN1NVRkhSQ3hKUVVGWExGRkJRVkU3VVVGRFppeFBRVUZQTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVd0Q0xGZEJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTTFSQ3hEUVVGRE8wbEJSMFFzU1VGQlZ5eFZRVUZWTzFGQlEycENMRTlCUVU4c1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQmFVSXNWMEZCVnl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8wbEJRMmhGTEVOQlFVTTdTVUZIUkN4SlFVRlhMR0ZCUVdFN1VVRkRjRUlzVDBGQlR5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRnBRaXhYUVVGWExFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdTVUZEYmtVc1EwRkJRenRKUVVkRUxFbEJRVmNzWVVGQllUdFJRVU53UWl4UFFVRlBMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRWE5DTEZkQlFWY3NRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJRenRKUVVONFJTeERRVUZETzBsQlIwUXNTVUZCVnl4bFFVRmxPMUZCUTNSQ0xFOUJRVThzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCYVVJc1YwRkJWeXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRU5CUVVNN1NVRkRjRVVzUTBGQlF6dEpRVmRQTEZsQlFWazdVVUZMYUVJc1RVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhKUVVGSkxFVkJRVVVzUlVGQlJUdFpRVWx1UkN4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVbHVReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5RTEVOQlFVTTdTVUZMVXl4WlFVRlpMRU5CUVVNc1RVRkJZeXhGUVVGRkxFOUJRVThzUjBGQlJ5eERRVUZETEVWQlFVVXNTMEZCU3l4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVNeFJDeE5RVUZOTEVkQlFVY3NSMEZCZVVJN1dVRkRPVUlzU1VGQlNTeEZRVUZGTEdWQlFXVTdXVUZEY2tJc1RVRkJUVHRaUVVOT0xFOUJRVTg3V1VGRFVDeExRVUZMTzFOQlExSXNRMEZCUXp0UlFVVkdMRWxCUVVrc1MwRkJTeXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTzFsQlEyUXNTVUZCU1N4SlFVRkpMRU5CUVVNc1lVRkJZU3hGUVVGRk8yZENRVU53UWl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1owSkJRelZETEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1UwRkJVeXhEUVVGRE8yRkJRMnhETzFsQlEwUXNTVUZCU1N4RFFVRkRMR0ZCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVMEZEYUVNN1lVRkJUVHRaUVVOSUxFMUJRVTBzUjBGQlJ5eEhRVUZITEVsQlFVa3NTVUZCU1N4RlFVRkZMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU03V1VGRGFrTXNUVUZCVFN4TFFVRkxMRWRCUVVjc1IwRkJSeXhIUVVGSExFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1EwRkJRenRaUVVNelF5eEpRVUZKTEV0QlFVc3NSMEZCUnl4RlFVRkZMRVZCUVVVN1owSkJRMW9zU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03WjBKQlF6ZENMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNSMEZCUnl4SFFVRkhMRU5CUVVNN1lVRkRhRU03YVVKQlFVMDdaMEpCUTBnc1NVRkJTU3hEUVVGRExHRkJRV0VzUjBGQlJ5eEhRVUZITEVOQlFVTTdZVUZETlVJN1UwRlJTanRKUVVWTUxFTkJRVU03U1VGRllTeFhRVUZYT3p0WlFVTnlRaXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRPMWxCUTJwRExFMUJRVTBzV1VGQldTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFpRVU51UkN4TlFVRk5MRk5CUVZNc1IwRkJSeXhaUVVGWkxFTkJRVU1zV1VGQldTeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcEhMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1dVRkRNVVVzU1VGQlNTeERRVUZETEZOQlFWTXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXp0WlFVTTNReXhKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hITEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1lVRkJZU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tNc1QwRkJUeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEzaENMRU5CUVVNN1MwRkJRVHRKUVZkaExGZEJRVmNzUTBGQlF5eGxRVUYxUWpzN1dVRkROME1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRaUVVOcVF5eEpRVUZKTERKQ1FVRlpMRU5CUVVNc1YwRkJWeXhEUVVGRExHVkJRV1VzUTBGQlF5eEZRVUZGTzJkQ1FVTXpReXhQUVVGUExESkNRVUZaTEVOQlFVTXNWMEZCVnl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRE8yRkJRM0JFTzFsQlEwUXNUVUZCVFN4SlFVRkpMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMWxCUTNSRUxFMUJRVTBzVVVGQlVTeEhRVUZITERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExHVkJRV1VzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTTNSQ3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEdGQlFXRXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pETEU5QlFVOHNVVUZCVVN4RFFVRkRPMUZCUTNCQ0xFTkJRVU03UzBGQlFUdEpRVVZoTEZkQlFWYzdPMWxCUTNKQ0xFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1dVRkRha01zVFVGQlRTeEpRVUZKTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFTkJRVU03V1VGRGRrTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhoUVVGaExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnlReXhQUVVGUExFbEJRVWtzUTBGQlF6dFJRVU5vUWl4RFFVRkRPMHRCUVVFN1NVRkZZU3hMUVVGTExFTkJRVWtzU1VGQmFVSTdPMWxCUTNCRExFMUJRVTBzVVVGQlVTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJRenRaUVVOeVF5eE5RVUZOTEVsQlFVa3NSMEZCUnl4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1JpeEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdXVUZETTBJc1QwRkJUeXhKUVVGSkxFTkJRVU03VVVGRGFFSXNRMEZCUXp0TFFVRkJPMGxCUldFc1YwRkJWeXhEUVVGSkxFbEJRV2xDT3p0WlFVTXhReXhOUVVGTkxGRkJRVkVzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNN1dVRkRja01zVFVGQlRTeFJRVUZSTEVkQlFVY3NVVUZCVVN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVVc1RVRkJUU3hOUVVGTkxFZEJRVkVzUlVGQlJTeERRVUZETzFsQlJYWkNMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zWTBGQll5eEhRVUZITEVsQlFVa3NSVUZCUlN4RFFVRkRMRVZCUVVVc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0WlFVTnlSU3hMUVVGTExFMUJRVTBzUzBGQlN5eEpRVUZKTEZGQlFWRXNSVUZCUlR0blFrRkRNVUlzU1VGQlNTeHpRa0ZCWXl4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRVZCUVVVN2IwSkJRemRETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdhVUpCUTNCRE8yZENRVU5FTEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1kwRkJZeXhIUVVGSExFbEJRVWtzUlVGQlJTeFJRVUZSTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMkZCUTJoSE8xbEJRMFFzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzFsQlF6ZENMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zWTBGQll5eEhRVUZITEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRETEU5QlFVOHNUVUZCVFN4RFFVRkRPMUZCUTJ4Q0xFTkJRVU03UzBGQlFUdEpRVVZQTEVsQlFVa3NRMEZCU1N4SlFVRnBRanRSUVVNM1FpeEpRVUZKTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTzFsQlEzUkNMRTlCUVU4c1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlNTeEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFOQlEyeEVPMUZCUTBRc1QwRkJUeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZKTEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXk5Q0xFTkJRVU03U1VGRlR5eE5RVUZOTEVOQlFVa3NTVUZCYVVJN1VVRkRMMElzU1VGQlNTeEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU4wUWl4UFFVRlBMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVTBzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU53UkR0UlFVTkVMRTlCUVU4c1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlNTeEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTnlReXhEUVVGRE8wbEJSMDhzVTBGQlV5eERRVUZKTEV0QlFWRTdVVUZEZWtJc1QwRkJUeXhKUVVGSkxFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1JVRkJSVHRaUVVNMVFpeEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRaaXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5RTEVOQlFVTTdTVUZGVFN4UFFVRlBPMUZCUTFZc1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eFRRVUZUTEVOQlFVTTdVVUZEZEVJc1NVRkJTU3hEUVVGRExFdEJRVXNzUjBGQlJ5eFRRVUZUTEVOQlFVTTdVVUZEZGtJc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eFRRVUZUTEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eFRRVUZUTEVOQlFVTTdTVUZETDBJc1EwRkJRenREUVVOS0xFTkJRVUU3UVVFMVRFYzdTVUZFUXl4M1FrRkJWeXhGUVVGRk96czdiME5CVFdJN1FVRkhSRHRKUVVSRExIZENRVUZYTEVWQlFVVTdPenR4UTBGSFlqdEJRVWRFTzBsQlJFTXNkMEpCUVZjc1JVRkJSVHM3TzNORFFVZGlPMEZCUjBRN1NVRkVReXgzUWtGQlZ5eEZRVUZGT3pzN2QwTkJSMkk3UVVGSFJEdEpRVVJETEhkQ1FVRlhMRVZCUVVVN096c3lRMEZIWWp0QlFVZEVPMGxCUkVNc2QwSkJRVmNzUlVGQlJUczdPekpEUVVkaU8wRkJSMFE3U1VGRVF5eDNRa0ZCVnl4RlFVRkZPenM3TmtOQlIySTdRVUZ5UlZFc1RVRkJUVHRKUVVSc1FpeG5RMEZCYlVJc1EwRkJReXh6UTBGQmMwTXNRMEZCUXp0eFEwRjNSVFZDTEZkQlFWYzdSMEYyUlRsQ0xFMUJRVTBzUTBFNFRteENPMEZCT1U1WkxIZENRVUZOSW4wPSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi4vZGVjb3JhdG9yc1wiKTtcclxuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xyXG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XHJcbmNvbnN0IGxpbnEgPSByZXF1aXJlKFwibGlucVwiKTtcclxuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcclxuY2xhc3MgQWJzdHJhY3RSZXBsYXlBbmFseXNlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXBsYXkpIHtcclxuICAgICAgICB0aGlzLnJlcGxheSA9IHJlcGxheTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX3JlcGxheUhlYWRlciA9IHlpZWxkIHRoaXMucmVwbGF5LmhlYWRlcjtcclxuICAgICAgICAgICAgdGhpcy5fcmVwbGF5VmVyc2lvbiA9IHtcclxuICAgICAgICAgICAgICAgIHByb3RvY29sOiBoZWFkLm1fdmVyc2lvbi5tX2Jhc2VCdWlsZCxcclxuICAgICAgICAgICAgICAgIGJ1aWxkOiBoZWFkLm1fdmVyc2lvbi5tX2J1aWxkLFxyXG4gICAgICAgICAgICAgICAgbWFqb3I6IGhlYWQubV92ZXJzaW9uLm1fbWFqb3IsXHJcbiAgICAgICAgICAgICAgICBtaW5vcjogaGVhZC5tX3ZlcnNpb24ubV9taW5vcixcclxuICAgICAgICAgICAgICAgIHJldmlzaW9uOiBoZWFkLm1fdmVyc2lvbi5tX3JldmlzaW9uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5faW5pdERhdGEgPSB5aWVsZCB0aGlzLnJlcGxheS5pbml0RGF0YTtcclxuICAgICAgICAgICAgdGhpcy5fZ2FtZVR5cGUgPSB0aGlzLmdldEdhbWVUeXBlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRHYW1lVHlwZSgpIHtcclxuICAgICAgICBjb25zdCBpbml0ID0gdGhpcy5faW5pdERhdGE7XHJcbiAgICAgICAgY29uc3QgZ2FtZURlc2MgPSBpbml0Lm1fc3luY0xvYmJ5U3RhdGUubV9nYW1lRGVzY3JpcHRpb247XHJcbiAgICAgICAgc3dpdGNoIChnYW1lRGVzYy5tX2dhbWVPcHRpb25zLm1fYW1tSWQpIHtcclxuICAgICAgICAgICAgY2FzZSA1MDAyMTpcclxuICAgICAgICAgICAgY2FzZSA1MDAyMTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLkdhbWVUeXBlLk1PREVfQUk7XHJcbiAgICAgICAgICAgIGNhc2UgNTAwMDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5HYW1lVHlwZS5RVUlDS19NQVRDSDtcclxuICAgICAgICAgICAgY2FzZSA1MDAzMTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLkdhbWVUeXBlLkJSQVdMO1xyXG4gICAgICAgICAgICBjYXNlIDUwMDUxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuR2FtZVR5cGUuVU5SQU5LRURfRFJBRlQ7XHJcbiAgICAgICAgICAgIGNhc2UgNTAwNjE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5HYW1lVHlwZS5IRVJPX0xFQUdVRTtcclxuICAgICAgICAgICAgY2FzZSA1MDA3MTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLkdhbWVUeXBlLlRFQU1fTEVBR1VFO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKCFnYW1lRGVzYy5tX2dhbWVPcHRpb25zLm1fY29tcGV0aXRpdmUgJiYgIWdhbWVEZXNjLm1fZ2FtZU9wdGlvbnMubV9jb29wZXJhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnYW1lRGVzYy5tX2dhbWVPcHRpb25zLm1faGVyb0R1cGxpY2F0ZXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLkdhbWVUeXBlLkNVU1RPTTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLkdhbWVUeXBlLkNVU1RPTV9EUkFGVDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5HYW1lVHlwZS5VTktOT1dOO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBwcm90b2NvbFZlcnNpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxheVZlcnNpb24ucHJvdG9jb2w7XHJcbiAgICB9XHJcbiAgICBnZXQgdmVyc2lvbigpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxheVZlcnNpb247XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVyb0RhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGF5Lmhlcm9EYXRhO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdhbWVUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2FtZVR5cGU7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgdGlja1JhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxNjtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGlzR2FtZVR5cGUodHlwZSkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBnYW1lVHlwZSA9IHlpZWxkIHRoaXMuZ2FtZVR5cGU7XHJcbiAgICAgICAgICAgIHJldHVybiAoZ2FtZVR5cGUgJiB0eXBlKSA9PT0gdHlwZTtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGNoZWNrTWluVmVyc2lvbihtaW5WZXIsIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmVyc2lvbk1hdGNoZXMoJz49JyArIG1pblZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJlcGxheVZlcnNpb25PdXRPZlJhbmdlRXJyb3IobWVzc2FnZSB8fCBcIlJlcGxheSB0byBPbGRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmVyc2lvbk1hdGNoZXMoc2VtVmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModGhpcy5wcm90b2NvbFZlcnNpb24gKyAnLjAuMCcsIHNlbVZlcik7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVhZGVyKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcmVwbGF5SGVhZGVyKTtcclxuICAgIH1cclxuICAgIGdldCBpbml0RGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2luaXREYXRhKTtcclxuICAgIH1cclxuICAgIGdldCBkZXRhaWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxheS5kZXRhaWxzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF0dHJpYnV0ZUV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYXkuYXR0cmlidXRlRXZlbnRzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRyYWNrZXJFdmVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGF5LnRyYWNrZXJFdmVudHM7XHJcbiAgICB9XHJcbiAgICBnZXQgbWVzc2FnZUV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYXkubWVzc2FnZUV2ZW50cztcclxuICAgIH1cclxuICAgIGdldCBnYW1lRXZlbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxheS5nYW1lRXZlbnRzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRyYWNrZXJFdmVudHNRdWVyaWFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5xLmZyb20oeWllbGQgdGhpcy50cmFja2VyRXZlbnRzKTtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGdldCBtZXNzYWdlRXZlbnRzUXVlcmlhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlucS5mcm9tKHlpZWxkIHRoaXMubWVzc2FnZUV2ZW50cyk7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgZ2FtZUV2ZW50c1F1ZXJpYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbnEuZnJvbSh5aWVsZCB0aGlzLmdhbWVFdmVudHMpO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHsgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcImluaXRpYWxpemVcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIE51bWJlcilcclxuXSwgQWJzdHJhY3RSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwiZ2V0R2FtZVR5cGVcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyLnByb3RvdHlwZSwgXCJwcm90b2NvbFZlcnNpb25cIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcInZlcnNpb25cIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcImdhbWVUeXBlXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyLnByb3RvdHlwZSwgXCJ0aWNrUmF0ZVwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuV29ya2VyT25seSgpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyLCBTdHJpbmddKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcImNoZWNrTWluVmVyc2lvblwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuV29ya2VyT25seSgpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgQm9vbGVhbilcclxuXSwgQWJzdHJhY3RSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwidmVyc2lvbk1hdGNoZXNcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQWJzdHJhY3RSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5Xb3JrZXJPbmx5KCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcImluaXREYXRhXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5Xb3JrZXJPbmx5KCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcImRldGFpbHNcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQWJzdHJhY3RSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwiYXR0cmlidXRlRXZlbnRzXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5Xb3JrZXJPbmx5KCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcInRyYWNrZXJFdmVudHNcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQWJzdHJhY3RSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwibWVzc2FnZUV2ZW50c1wiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuV29ya2VyT25seSgpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyLnByb3RvdHlwZSwgXCJnYW1lRXZlbnRzXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5Xb3JrZXJPbmx5KCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEFic3RyYWN0UmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcInRyYWNrZXJFdmVudHNRdWVyaWFibGVcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLldvcmtlck9ubHkoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQWJzdHJhY3RSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwibWVzc2FnZUV2ZW50c1F1ZXJpYWJsZVwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuV29ya2VyT25seSgpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyLnByb3RvdHlwZSwgXCJnYW1lRXZlbnRzUXVlcmlhYmxlXCIsIG51bGwpO1xyXG5leHBvcnRzLkFic3RyYWN0UmVwbGF5QW5hbHlzZXIgPSBBYnN0cmFjdFJlcGxheUFuYWx5c2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lRV0p6ZEhKaFkzUlNaWEJzWVhsQmJtRnNlWE5sY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJa0ZpYzNSeVlXTjBVbVZ3YkdGNVFXNWhiSGx6WlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096dEJRVVZCTERoRFFVRjNSRHRCUVVWNFJDeHRRMEZCYlVRN1FVRkRia1FzYzBOQlFYbEVPMEZCUTNwRUxEWkNRVUUyUWp0QlFVTTNRaXhwUTBGQmFVTTdRVUZGYWtNN1NVRlBTU3haUVVFMlFpeE5RVUZqTzFGQlFXUXNWMEZCVFN4SFFVRk9MRTFCUVUwc1EwRkJVVHRKUVVGSkxFTkJRVU03U1VGSGJrTXNWVUZCVlRzN1dVRkRia0lzVFVGQlRTeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMR0ZCUVdFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUXpORUxFbEJRVWtzUTBGQlF5eGpRVUZqTEVkQlFVYzdaMEpCUTJ4Q0xGRkJRVkVzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRmRCUVZjN1owSkJRM0JETEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVTg3WjBKQlF6ZENMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVODdaMEpCUXpkQ0xFdEJRVXNzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4N1owSkJRemRDTEZGQlFWRXNSVUZCUlN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGVkJRVlU3WVVGRGRFTXNRMEZCUXp0WlFVTkdMRTFCUVUwc1VVRkJVU3hIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF6dFpRVU0zUkN4SlFVRkpMRU5CUVVNc1UwRkJVeXhIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXp0UlFVTjRReXhEUVVGRE8wdEJRVUU3U1VGSFR5eFhRVUZYTzFGQlEyWXNUVUZCVFN4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF6dFJRVU0xUWl4TlFVRk5MRkZCUVZFc1IwRkJSeXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTTdVVUZEZWtRc1VVRkJVU3hSUVVGUkxFTkJRVU1zWVVGQllTeERRVUZETEU5QlFVOHNSVUZCUlR0WlFVTndReXhMUVVGTExFdEJRVXNzUTBGQlF6dFpRVU5ZTEV0QlFVc3NTMEZCU3p0blFrRkRUaXhQUVVGUExHZENRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUXpWQ0xFdEJRVXNzUzBGQlN6dG5Ra0ZEVGl4UFFVRlBMR2RDUVVGUkxFTkJRVU1zVjBGQlZ5eERRVUZETzFsQlEyaERMRXRCUVVzc1MwRkJTenRuUWtGRFRpeFBRVUZQTEdkQ1FVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRE8xbEJRekZDTEV0QlFVc3NTMEZCU3p0blFrRkRUaXhQUVVGUExHZENRVUZSTEVOQlFVTXNZMEZCWXl4RFFVRkRPMWxCUTI1RExFdEJRVXNzUzBGQlN6dG5Ra0ZEVGl4UFFVRlBMR2RDUVVGUkxFTkJRVU1zVjBGQlZ5eERRVUZETzFsQlEyaERMRXRCUVVzc1MwRkJTenRuUWtGRFRpeFBRVUZQTEdkQ1FVRlJMRU5CUVVNc1YwRkJWeXhEUVVGRE8xbEJRMmhETzJkQ1FVTkpMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zWVVGQllTeERRVUZETEdGQlFXRXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhoUVVGaExFTkJRVU1zWVVGQllTeEZRVUZGTzI5Q1FVTm9SaXhKUVVGSkxGRkJRVkVzUTBGQlF5eGhRVUZoTEVOQlFVTXNkVUpCUVhWQ0xFVkJRVVU3ZDBKQlEyaEVMRTlCUVU4c1owSkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTTdjVUpCUXpGQ08zbENRVUZOTzNkQ1FVTklMRTlCUVU4c1owSkJRVkVzUTBGQlF5eFpRVUZaTEVOQlFVTTdjVUpCUTJoRE8ybENRVU5LTzJkQ1FVTkVMRTlCUVU4c1owSkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTTdVMEZETDBJN1NVRkRUQ3hEUVVGRE8wbEJSMFFzU1VGQll5eGxRVUZsTzFGQlEzcENMRTlCUVU4c1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eFJRVUZSTEVOQlFVTTdTVUZEZUVNc1EwRkJRenRKUVVkRUxFbEJRVmNzVDBGQlR6dFJRVU5rTEU5QlFVOHNRMEZCUXl4SFFVRnJReXhGUVVGRk8xbEJRM2hETEU5QlFVOHNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJRenRSUVVNdlFpeERRVUZETEVOQlFVRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRWQ3hEUVVGRE8wbEJSVVFzU1VGQlZ5eFJRVUZSTzFGQlEyWXNUMEZCVHl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF6dEpRVU5vUXl4RFFVRkRPMGxCUjBRc1NVRkJWeXhSUVVGUk8xRkJRMllzVDBGQlR5eERRVUZETEVkQlFUUkNMRVZCUVVVN1dVRkRiRU1zVDBGQlR5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUXpGQ0xFTkJRVU1zUTBGQlFTeERRVUZETEVWQlFVVXNRMEZCUXp0SlFVTlVMRU5CUVVNN1NVRkhSQ3hKUVVGWExGRkJRVkU3VVVGRFppeFBRVUZQTEVOQlFVTXNSMEZCTUVJc1JVRkJSVHRaUVVOb1F5eFBRVUZQTEVWQlFVVXNRMEZCUXp0UlFVTmtMRU5CUVVNc1EwRkJRU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZGVFN4VlFVRlZMRU5CUVVNc1NVRkJZenRSUVVNMVFpeFBRVUZQTEVOQlFVTXNSMEZCTWtJc1JVRkJSVHRaUVVOcVF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU03V1VGRGNrTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTTdVVUZEZEVNc1EwRkJReXhEUVVGQkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlExUXNRMEZCUXp0SlFVZFRMR1ZCUVdVc1EwRkJReXhOUVVGakxFVkJRVVVzVDBGQlowSTdVVUZEZEVRc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNTVUZCU1N4SFFVRkhMRTFCUVUwc1EwRkJReXhGUVVGRk8xbEJRM0pETEUxQlFVMHNTVUZCU1N4eFEwRkJORUlzUTBGQlF5eFBRVUZQTEVsQlFVa3NaVUZCWlN4RFFVRkRMRU5CUVVNN1UwRkRkRVU3U1VGRFRDeERRVUZETzBsQlIwMHNZMEZCWXl4RFFVRkRMRTFCUVdNN1VVRkRhRU1zVDBGQlR5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhsUVVGbExFZEJRVWNzVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTI1RkxFTkJRVU03U1VGSFJDeEpRVUZqTEUxQlFVMDdVVUZEYUVJc1QwRkJUeXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRKUVVNdlF5eERRVUZETzBsQlIwUXNTVUZCWXl4UlFVRlJPMUZCUTJ4Q0xFOUJRVThzVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU03U1VGRE0wTXNRMEZCUXp0SlFVZEVMRWxCUVdNc1QwRkJUenRSUVVOcVFpeFBRVUZQTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8wbEJReTlDTEVOQlFVTTdTVUZIUkN4SlFVRmpMR1ZCUVdVN1VVRkRla0lzVDBGQlR5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1EwRkJRenRKUVVOMlF5eERRVUZETzBsQlIwUXNTVUZCWXl4aFFVRmhPMUZCUTNaQ0xFOUJRVThzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNN1NVRkRja01zUTBGQlF6dEpRVWRFTEVsQlFXTXNZVUZCWVR0UlFVTjJRaXhQUVVGUExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRPMGxCUTNKRExFTkJRVU03U1VGSFJDeEpRVUZqTEZWQlFWVTdVVUZEY0VJc1QwRkJUeXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0SlFVTnNReXhEUVVGRE8wbEJSMFFzU1VGQll5eHpRa0ZCYzBJN1VVRkRhRU1zVDBGQlR5eERRVUZETEVkQlFYbEVMRVZCUVVVN1dVRkRMMFFzVDBGQlR5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzFGQlF5OURMRU5CUVVNc1EwRkJRU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZIUkN4SlFVRmpMSE5DUVVGelFqdFJRVU5vUXl4UFFVRlBMRU5CUVVNc1IwRkJlVU1zUlVGQlJUdFpRVU12UXl4UFFVRlBMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkRMME1zUTBGQlF5eERRVUZCTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVkRUxFbEJRV01zYlVKQlFXMUNPMUZCUXpkQ0xFOUJRVThzUTBGQlF5eEhRVUY1UXl4RlFVRkZPMWxCUXk5RExFOUJRVThzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFJRVU0xUXl4RFFVRkRMRU5CUVVFc1EwRkJReXhGUVVGRkxFTkJRVU03U1VGRFZDeERRVUZETzBsQlJVMHNUMEZCVHl4TFFVRlhMRU5CUVVNN1EwRkZOMEk3UVVGMFNrYzdTVUZFUXl4MVFrRkJWU3hGUVVGRk96czdPM2RFUVZsYU8wRkJSMFE3U1VGRVF5eDFRa0ZCVlN4RlFVRkZPenM3TzNsRVFUUkNXanRCUVVkRU8wbEJSRU1zZFVKQlFWVXNSVUZCUlRzN096WkVRVWRhTzBGQlIwUTdTVUZFUXl4M1FrRkJWeXhGUVVGRk96czdjVVJCUzJJN1FVRlBSRHRKUVVSRExIZENRVUZYTEVWQlFVVTdPenR6UkVGTFlqdEJRVWRFTzBsQlJFTXNkMEpCUVZjc1JVRkJSVHM3TzNORVFVdGlPMEZCVlVRN1NVRkVReXgxUWtGQlZTeEZRVUZGT3pzN096WkVRVXRhTzBGQlIwUTdTVUZFUXl4MVFrRkJWU3hGUVVGRk96czdPelJFUVVkYU8wRkJSMFE3U1VGRVF5eDFRa0ZCVlN4RlFVRkZPenM3YjBSQlIxbzdRVUZIUkR0SlFVUkRMSFZDUVVGVkxFVkJRVVU3T3p0elJFRkhXanRCUVVkRU8wbEJSRU1zZFVKQlFWVXNSVUZCUlRzN08zRkVRVWRhTzBGQlIwUTdTVUZFUXl4MVFrRkJWU3hGUVVGRk96czdOa1JCUjFvN1FVRkhSRHRKUVVSRExIVkNRVUZWTEVWQlFVVTdPenN5UkVGSFdqdEJRVWRFTzBsQlJFTXNkVUpCUVZVc1JVRkJSVHM3T3pKRVFVZGFPMEZCUjBRN1NVRkVReXgxUWtGQlZTeEZRVUZGT3pzN2QwUkJSMW83UVVGSFJEdEpRVVJETEhWQ1FVRlZMRVZCUVVVN096dHZSVUZMV2p0QlFVZEVPMGxCUkVNc2RVSkJRVlVzUlVGQlJUczdPMjlGUVV0YU8wRkJSMFE3U1VGRVF5eDFRa0ZCVlN4RlFVRkZPenM3YVVWQlMxbzdRVUUxU2t3c2QwUkJaMHRESW4wPSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZXBsYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXBsYXlcIik7XHJcbmNvbnN0IGxpbnEgPSByZXF1aXJlKFwibGlucVwiKTtcclxuY29uc3Qgc2hhMSA9IHJlcXVpcmUoXCJzaGExXCIpO1xyXG5jb25zdCBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi4vLi4vZGVjb3JhdG9yc1wiKTtcclxuY29uc3QgQWJzdHJhY3RSZXBsYXlBbmFseXNlcl8xID0gcmVxdWlyZShcIi4uL0Fic3RyYWN0UmVwbGF5QW5hbHlzZXJcIik7XHJcbmNvbnN0IFBsYXllckFuYWx5c2VyXzEgPSByZXF1aXJlKFwiLi9QbGF5ZXJBbmFseXNlclwiKTtcclxubGV0IEJhc2ljUmVwbGF5QW5hbHlzZXIgPSBjbGFzcyBCYXNpY1JlcGxheUFuYWx5c2VyIGV4dGVuZHMgQWJzdHJhY3RSZXBsYXlBbmFseXNlcl8xLkFic3RyYWN0UmVwbGF5QW5hbHlzZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVwbGF5KSB7XHJcbiAgICAgICAgc3VwZXIocmVwbGF5KTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gbmFtZSA9PiBzdXBlcltuYW1lXTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCBfc3VwZXIoXCJpbml0aWFsaXplXCIpLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheWVyQW5hbHlzZXIgPSBuZXcgUGxheWVyQW5hbHlzZXJfMS5QbGF5ZXJBbmFseXNlcih0aGlzLnJlcGxheSk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheWVyQW5hbHlzZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZpbmdlclByaW50KCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgZnAgPSAnJztcclxuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHlpZWxkIHRoaXMuaGVhZGVyO1xyXG4gICAgICAgICAgICBjb25zdCBpbml0ID0geWllbGQgdGhpcy5pbml0RGF0YTtcclxuICAgICAgICAgICAgZnAgPSBoZWFkLm1fZWxhcHNlZEdhbWVMb29wcy50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIGZwICs9ICd8JyArIGluaXQubV9zeW5jTG9iYnlTdGF0ZS5tX2dhbWVEZXNjcmlwdGlvbi5tX3JhbmRvbVZhbHVlO1xyXG4gICAgICAgICAgICBmcCArPSAnfCcgKyBpbml0Lm1fc3luY0xvYmJ5U3RhdGUubV9nYW1lRGVzY3JpcHRpb24ubV9nYW1lT3B0aW9ucy5tX2FtbUlkO1xyXG4gICAgICAgICAgICBmcCArPSAnfCcgKyBsaW5xLmZyb20oaW5pdC5tX3N5bmNMb2JieVN0YXRlLm1fbG9iYnlTdGF0ZS5tX3Nsb3RzKVxyXG4gICAgICAgICAgICAgICAgLnRvSm9pbmVkU3RyaW5nKCcjJywgZWxtID0+IGVsbS5tX2hlcm8gKyAnficgKyBlbG0ubV90ZWFtSWQgKyAnficgKyBlbG0ubV90b29uSGFuZGxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYTEoZnApO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdhbWVEdXJhdGlvblRpY2tzKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkID0geWllbGQgdGhpcy5oZWFkZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkLm1fZWxhcHNlZEdhbWVMb29wcztcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGdldCBnYW1lRHVyYXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgdGhpcy5nYW1lRHVyYXRpb25UaWNrcykgLyAxNjtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGdldCBtYXBOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0geWllbGQgdGhpcy5kZXRhaWxzO1xyXG4gICAgICAgICAgICByZXR1cm4gZGV0YWlscy5tX3RpdGxlO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpbm5pbmdUZWFtKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJzID0geWllbGQgdGhpcy5wbGF5ZXJMaXN0O1xyXG4gICAgICAgICAgICByZXR1cm4gbGlucS5mcm9tKHBsYXllcnMpLmZpcnN0KF8gPT4gXy50ZWFtID09PSAwKS53b24gPyAwIDogMTtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGdldCB0aW1lWm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IHlpZWxkIHRoaXMuZGV0YWlscztcclxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHMubV90aW1lTG9jYWxPZmZzZXQgLyAxMDAwMDAwMCAvIDYwIC8gNjA7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGxheWVkT24oKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSB5aWVsZCB0aGlzLmRldGFpbHM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkZXRhaWxzLm1fdGltZVVUQyAvIDEwMDAwIC0gMTE2NDQ0NzM2MDAwMDApO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBsYXllckxpc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheWVyQW5hbHlzZXIucGxheWVyU2xvdERhdGE7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVwbGF5RGVzY3JpcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmaW5nZXJQcmludDogeWllbGQgdGhpcy5maW5nZXJQcmludCxcclxuICAgICAgICAgICAgICAgIGdhbWVUeXBlOiB5aWVsZCB0aGlzLmdhbWVUeXBlLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogeWllbGQgdGhpcy52ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgZ2FtZUR1cmF0aW9uVGlja3M6IHlpZWxkIHRoaXMuZ2FtZUR1cmF0aW9uVGlja3MsXHJcbiAgICAgICAgICAgICAgICBnYW1lRHVyYXRpb246IHlpZWxkIHRoaXMuZ2FtZUR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgbWFwTmFtZTogeWllbGQgdGhpcy5tYXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmU6IHlpZWxkIHRoaXMudGltZVpvbmUsXHJcbiAgICAgICAgICAgICAgICBwbGF5ZWRPbjogeWllbGQgdGhpcy5wbGF5ZWRPbixcclxuICAgICAgICAgICAgICAgIHdpbm5pbmdUZWFtOiB5aWVsZCB0aGlzLndpbm5pbmdUZWFtLFxyXG4gICAgICAgICAgICAgICAgcGxheWVyczogeWllbGQgdGhpcy5wbGF5ZXJMaXN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbn07XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEJhc2ljUmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcImZpbmdlclByaW50XCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBCYXNpY1JlcGxheUFuYWx5c2VyLnByb3RvdHlwZSwgXCJnYW1lRHVyYXRpb25UaWNrc1wiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQmFzaWNSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwibWFwTmFtZVwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQmFzaWNSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwid2lubmluZ1RlYW1cIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIEJhc2ljUmVwbGF5QW5hbHlzZXIucHJvdG90eXBlLCBcInRpbWVab25lXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBCYXNpY1JlcGxheUFuYWx5c2VyLnByb3RvdHlwZSwgXCJwbGF5ZWRPblwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQmFzaWNSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwicGxheWVyTGlzdFwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgQmFzaWNSZXBsYXlBbmFseXNlci5wcm90b3R5cGUsIFwicmVwbGF5RGVzY3JpcHRpb25cIiwgbnVsbCk7XHJcbkJhc2ljUmVwbGF5QW5hbHlzZXIgPSBfX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SZXBsYXlBbmFseXNlckNvbnRleHQoJzFCOTBCQzc2LThDRTgtNDk1Qy1BOTc4LUFCRkQ3OERCQjcyQScpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZXBsYXlfMS5SZXBsYXldKVxyXG5dLCBCYXNpY1JlcGxheUFuYWx5c2VyKTtcclxuZXhwb3J0cy5CYXNpY1JlcGxheUFuYWx5c2VyID0gQmFzaWNSZXBsYXlBbmFseXNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pUW1GemFXTlNaWEJzWVhsQmJtRnNlWE5sY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJa0poYzJsalVtVndiR0Y1UVc1aGJIbHpaWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3p0QlFVRkJMSGxEUVVGelF6dEJRVU4wUXl3MlFrRkJOa0k3UVVGRE4wSXNOa0pCUVRaQ08wRkJSVGRDTEdsRVFVRnpSVHRCUVVOMFJTeHpSVUZCYlVVN1FVRkZia1VzY1VSQlFTdEVPMEZCYTBJdlJDeEpRVUZoTEcxQ1FVRnRRaXhIUVVGb1F5eDVRa0ZCYVVNc1UwRkJVU3dyUTBGQmMwSTdTVUZITTBRc1dVRkJiVUlzVFVGQll6dFJRVU0zUWl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRmJFSXNRMEZCUXp0SlFVVlpMRlZCUVZVN096dFpRVU51UWl4TlFVRk5MRzlDUVVGblFpeFhRVUZGTEVOQlFVTTdXVUZEZWtJc1NVRkJTU3hEUVVGRExHTkJRV01zUjBGQlJ5eEpRVUZKTEN0Q1FVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlEzUkVMRTFCUVUwc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0UlFVTXpReXhEUVVGRE8wdEJRVUU3U1VGSFJDeEpRVUZYTEZkQlFWYzdVVUZEYkVJc1QwRkJUeXhEUVVGRExFZEJRVEJDTEVWQlFVVTdXVUZEYUVNc1NVRkJTU3hGUVVGRkxFZEJRVWNzUlVGQlJTeERRVUZETzFsQlExb3NUVUZCVFN4SlFVRkpMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETzFsQlF5OUNMRTFCUVUwc1NVRkJTU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXp0WlFVTnFReXhGUVVGRkxFZEJRVWNzU1VGQlNTeERRVUZETEd0Q1FVRnJRaXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTXhReXhGUVVGRkxFbEJRVWtzUjBGQlJ5eEhRVUZITEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhoUVVGaExFTkJRVU03V1VGRGJFVXNSVUZCUlN4SlFVRkpMRWRCUVVjc1IwRkJSeXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNZVUZCWVN4RFFVRkRMRTlCUVU4c1EwRkJRenRaUVVNeFJTeEZRVUZGTEVsQlFVa3NSMEZCUnl4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExGbEJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTTdhVUpCUXpWRUxHTkJRV01zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zVFVGQlRTeEhRVUZITEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1VVRkJVU3hIUVVGSExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1dVRkRNVVlzVDBGQlR5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRjRUlzUTBGQlF5eERRVUZCTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVkRUxFbEJRVmNzYVVKQlFXbENPMUZCUTNoQ0xFOUJRVThzUTBGQlF5eEhRVUV3UWl4RlFVRkZPMWxCUTJoRExFMUJRVTBzU1VGQlNTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRaUVVNdlFpeFBRVUZQTEVsQlFVa3NRMEZCUXl4clFrRkJhMElzUTBGQlF6dFJRVU51UXl4RFFVRkRMRU5CUVVFc1EwRkJReXhGUVVGRkxFTkJRVU03U1VGRFZDeERRVUZETzBsQlJVUXNTVUZCVnl4WlFVRlpPMUZCUTI1Q0xFOUJRVThzUTBGQlF5eEhRVUV3UWl4RlFVRkZPMWxCUTJoRExFOUJRVThzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVTXZReXhEUVVGRExFTkJRVUVzUTBGQlF5eEZRVUZGTEVOQlFVTTdTVUZEVkN4RFFVRkRPMGxCUjBRc1NVRkJWeXhQUVVGUE8xRkJRMlFzVDBGQlR5eERRVUZETEVkQlFUQkNMRVZCUVVVN1dVRkRhRU1zVFVGQlRTeFBRVUZQTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRE8xbEJRMjVETEU5QlFVOHNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJRenRSUVVNelFpeERRVUZETEVOQlFVRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRWQ3hEUVVGRE8wbEJSMFFzU1VGQlZ5eFhRVUZYTzFGQlEyeENMRTlCUVU4c1EwRkJReXhIUVVFd1FpeEZRVUZGTzFsQlEyaERMRTFCUVUwc1QwRkJUeXhIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXp0WlFVTjBReXhQUVVGUExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyNUZMRU5CUVVNc1EwRkJRU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZIUkN4SlFVRlhMRkZCUVZFN1VVRkRaaXhQUVVGUExFTkJRVU1zUjBGQk1FSXNSVUZCUlR0WlFVTm9ReXhOUVVGTkxFOUJRVThzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNN1dVRkRia01zVDBGQlR5eFBRVUZQTEVOQlFVTXNhVUpCUVdsQ0xFZEJRVWNzVVVGQlVTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRNVVFzUTBGQlF5eERRVUZCTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVkRUxFbEJRVmNzVVVGQlVUdFJRVU5tTEU5QlFVOHNRMEZCUXl4SFFVRjNRaXhGUVVGRk8xbEJRemxDTEUxQlFVMHNUMEZCVHl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dFpRVU51UXl4UFFVRlBMRWxCUVVrc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVkQlFVY3NTMEZCU3l4SFFVRkhMR05CUVdNc1EwRkJReXhEUVVGRE8xRkJRMmhGTEVOQlFVTXNRMEZCUVN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVOVUxFTkJRVU03U1VGSFJDeEpRVUZYTEZWQlFWVTdVVUZEYWtJc1QwRkJUeXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEdOQlFXTXNRMEZCUXp0SlFVTTVReXhEUVVGRE8wbEJSMFFzU1VGQlZ5eHBRa0ZCYVVJN1VVRkRlRUlzVDBGQlR5eERRVUZETEVkQlFYRkRMRVZCUVVVN1dVRkRNME1zVDBGQlR6dG5Ra0ZEU0N4WFFVRlhMRVZCUVVVc1RVRkJUU3hKUVVGSkxFTkJRVU1zVjBGQlZ6dG5Ra0ZEYmtNc1VVRkJVU3hGUVVGRkxFMUJRVTBzU1VGQlNTeERRVUZETEZGQlFWRTdaMEpCUXpkQ0xFOUJRVThzUlVGQlJTeE5RVUZOTEVsQlFVa3NRMEZCUXl4UFFVRlBPMmRDUVVNelFpeHBRa0ZCYVVJc1JVRkJSU3hOUVVGTkxFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJN1owSkJReTlETEZsQlFWa3NSVUZCUlN4TlFVRk5MRWxCUVVrc1EwRkJReXhaUVVGWk8yZENRVU55UXl4UFFVRlBMRVZCUVVVc1RVRkJUU3hKUVVGSkxFTkJRVU1zVDBGQlR6dG5Ra0ZETTBJc1VVRkJVU3hGUVVGRkxFMUJRVTBzU1VGQlNTeERRVUZETEZGQlFWRTdaMEpCUXpkQ0xGRkJRVkVzUlVGQlJTeE5RVUZOTEVsQlFVa3NRMEZCUXl4UlFVRlJPMmRDUVVNM1FpeFhRVUZYTEVWQlFVVXNUVUZCVFN4SlFVRkpMRU5CUVVNc1YwRkJWenRuUWtGRGJrTXNUMEZCVHl4RlFVRkZMRTFCUVUwc1NVRkJTU3hEUVVGRExGVkJRVlU3WVVGRGFrTXNRMEZCUXp0UlFVTk9MRU5CUVVNc1EwRkJRU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5VTEVOQlFVTTdRMEZEU2l4RFFVRkJPMEZCYkVaSE8wbEJSRU1zZDBKQlFWY3NSVUZCUlRzN08zTkVRV0ZpTzBGQlIwUTdTVUZFUXl4M1FrRkJWeXhGUVVGRk96czdORVJCVFdJN1FVRlRSRHRKUVVSRExIZENRVUZYTEVWQlFVVTdPenRyUkVGTllqdEJRVWRFTzBsQlJFTXNkMEpCUVZjc1JVRkJSVHM3TzNORVFVMWlPMEZCUjBRN1NVRkVReXgzUWtGQlZ5eEZRVUZGT3pzN2JVUkJUV0k3UVVGSFJEdEpRVVJETEhkQ1FVRlhMRVZCUVVVN096dHRSRUZOWWp0QlFVZEVPMGxCUkVNc2QwSkJRVmNzUlVGQlJUczdPM0ZFUVVkaU8wRkJSMFE3U1VGRVF5eDNRa0ZCVnl4RlFVRkZPenM3TkVSQlowSmlPMEZCYUVkUkxHMUNRVUZ0UWp0SlFVUXZRaXhyUTBGQmNVSXNRMEZCUXl4elEwRkJjME1zUTBGQlF6dHhRMEZKTDBJc1pVRkJUVHRIUVVoNFFpeHRRa0ZCYlVJc1EwRnBSeTlDTzBGQmFrZFpMR3RFUVVGdFFpSjkiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4uLy4uL2RlY29yYXRvcnNcIik7XHJcbmNvbnN0IFJlcGxheV8xID0gcmVxdWlyZShcIi4uLy4uL1JlcGxheVwiKTtcclxuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcclxuY29uc3QgbGlucSA9IHJlcXVpcmUoXCJsaW5xXCIpO1xyXG5jb25zdCBQbGF5ZXJBbmFseXNlcl8xID0gcmVxdWlyZShcIi4vUGxheWVyQW5hbHlzZXJcIik7XHJcbmNvbnN0IEFic3RyYWN0UmVwbGF5QW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdFJlcGxheUFuYWx5c2VyXCIpO1xyXG5sZXQgQ2hhdEFuYWx5c2VyID0gY2xhc3MgQ2hhdEFuYWx5c2VyIGV4dGVuZHMgQWJzdHJhY3RSZXBsYXlBbmFseXNlcl8xLkFic3RyYWN0UmVwbGF5QW5hbHlzZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVwbGF5KSB7XHJcbiAgICAgICAgc3VwZXIocmVwbGF5KTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gbmFtZSA9PiBzdXBlcltuYW1lXTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCBfc3VwZXIoXCJpbml0aWFsaXplXCIpLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheWVyQW5hbHlzZXIgPSBuZXcgUGxheWVyQW5hbHlzZXJfMS5QbGF5ZXJBbmFseXNlcih0aGlzLnJlcGxheSk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheWVyQW5hbHlzZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNoYXRNZXNzYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVEgPSB5aWVsZCB0aGlzLm1lc3NhZ2VFdmVudHNRdWVyaWFibGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYXllclEgPSBsaW5xLmZyb20odGhpcy5wbGF5ZXJBbmFseXNlci5wbGF5ZXJTbG90RGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2tSYXRlID0geWllbGQgdGhpcy50aWNrUmF0ZTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWVzc2FnZVFcclxuICAgICAgICAgICAgICAgIC53aGVyZShfID0+IHR5cGVzXzEuaXNJU0NoYXRNZXNzYWdlKF8pKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4ocGxheWVyUSwgbSA9PiBtLl91c2VyaWQubV91c2VySWQsIHAgPT4gcC51c2VySWQsIChtLCBwKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbS5tX3N0cmluZyxcclxuICAgICAgICAgICAgICAgIHRpbWU6IG0uX2dhbWVsb29wIC8gdGlja1JhdGUsXHJcbiAgICAgICAgICAgICAgICByZWNpcGllbnQ6IG0ubV9yZWNpcGllbnQsXHJcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxyXG4gICAgICAgICAgICAgICAgcGxheWVyTmFtZTogcC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdGVhbTogcC50ZWFtXHJcbiAgICAgICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGluZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VRID0geWllbGQgdGhpcy5tZXNzYWdlRXZlbnRzUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJRID0gbGlucS5mcm9tKHRoaXMucGxheWVyQW5hbHlzZXIucGxheWVyU2xvdERhdGEpO1xyXG4gICAgICAgICAgICBjb25zdCB0aWNrUmF0ZSA9IHlpZWxkIHRoaXMudGlja1JhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1lc3NhZ2VRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoXyA9PiB0eXBlc18xLmlzSVNQaW5nTWVzc2FnZShfKSlcclxuICAgICAgICAgICAgICAgIC5qb2luKHBsYXllclEsIG0gPT4gbS5fdXNlcmlkLm1fdXNlcklkLCBwID0+IHAudXNlcklkLCAobSwgcCkgPT4gKHtcclxuICAgICAgICAgICAgICAgIHBvaW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogbS5tX3BvaW50LnggLyA0MDk2LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IG0ubV9wb2ludC55IC8gNDA5NlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRpbWU6IG0uX2dhbWVsb29wIC8gdGlja1JhdGUsXHJcbiAgICAgICAgICAgICAgICByZWNpcGllbnQ6IG0ubV9yZWNpcGllbnQsXHJcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxyXG4gICAgICAgICAgICAgICAgcGxheWVyTmFtZTogcC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdGVhbTogcC50ZWFtXHJcbiAgICAgICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbn07XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIENoYXRBbmFseXNlci5wcm90b3R5cGUsIFwiY2hhdE1lc3NhZ2VzXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBDaGF0QW5hbHlzZXIucHJvdG90eXBlLCBcInBpbmdzXCIsIG51bGwpO1xyXG5DaGF0QW5hbHlzZXIgPSBfX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SZXBsYXlBbmFseXNlckNvbnRleHQoJzgwMDIxODEwLTNBRDQtNDE4RC05RkI1LTQ5MDgxMzU1MDE5QScpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZXBsYXlfMS5SZXBsYXldKVxyXG5dLCBDaGF0QW5hbHlzZXIpO1xyXG5leHBvcnRzLkNoYXRBbmFseXNlciA9IENoYXRBbmFseXNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pUTJoaGRFRnVZV3g1YzJWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpUTJoaGRFRnVZV3g1YzJWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096czdPenM3T3pzN096czdRVUZEUVN4cFJFRkJjMFU3UVVGRGRFVXNlVU5CUVhORE8wRkJRM1JETERCRFFVbDNRanRCUVVONFFpdzJRa0ZCTmtJN1FVRkROMElzY1VSQlFTdEVPMEZCUlM5RUxITkZRVUZ0UlR0QlFYbENia1VzU1VGQllTeFpRVUZaTEVkQlFYcENMR3RDUVVFd1FpeFRRVUZSTEN0RFFVRnpRanRKUVVWd1JDeFpRVUZ0UWl4TlFVRmpPMUZCUXpkQ0xFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJRMWtzVlVGQlZUczdPMWxCUTI1Q0xFMUJRVTBzYjBKQlFXZENMRmRCUVVVc1EwRkJRenRaUVVONlFpeEpRVUZKTEVOQlFVTXNZMEZCWXl4SFFVRkhMRWxCUVVrc0swSkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkRkRVFzVFVGQlRTeEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRek5ETEVOQlFVTTdTMEZCUVR0SlFVZEVMRWxCUVZjc1dVRkJXVHRSUVVOdVFpeFBRVUZQTEVOQlFVTXNSMEZCYTBNc1JVRkJSVHRaUVVONFF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXh6UWtGQmMwSXNRMEZCUXp0WlFVTnVSQ3hOUVVGTkxFOUJRVThzUjBGQmRVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRPMWxCUTJ4SExFMUJRVTBzVVVGQlVTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJRenRaUVVOeVF5eE5RVUZOTEUxQlFVMHNSMEZCUnl4UlFVRlJPMmxDUVVOc1FpeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXgxUWtGQlpTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmxDUVVNNVFpeEpRVUZKTEVOQlEwUXNUMEZCVHl4RlFVTlFMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUTNaQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1JVRkRZaXhEUVVGRExFTkJRV2RDTEVWQlFVVXNRMEZCWXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU51UXl4UFFVRlBMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkU3WjBKQlEyNUNMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eEhRVUZITEZGQlFWRTdaMEpCUXpWQ0xGTkJRVk1zUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnp0blFrRkRlRUlzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5PMmRDUVVOb1FpeFZRVUZWTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrN1owSkJRMnhDTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTVHRoUVVObUxFTkJRVU1zUTBGRFRDeERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMWxCUTJoQ0xFOUJRVThzVFVGQlRTeERRVUZETzFGQlEyeENMRU5CUVVNc1EwRkJRU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZIUkN4SlFVRlhMRXRCUVVzN1VVRkRXaXhQUVVGUExFTkJRVU1zUjBGQk1rSXNSVUZCUlR0WlFVTnFReXhOUVVGTkxGRkJRVkVzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4elFrRkJjMElzUTBGQlF6dFpRVU51UkN4TlFVRk5MRTlCUVU4c1IwRkJkVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETzFsQlEyeEhMRTFCUVUwc1VVRkJVU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXp0WlFVTnlReXhOUVVGTkxFMUJRVTBzUjBGQlJ5eFJRVUZSTzJsQ1FVTnNRaXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4MVFrRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJsQ1FVTTVRaXhKUVVGSkxFTkJRMFFzVDBGQlR5eEZRVU5RTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlEzWkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNSVUZEWWl4RFFVRkRMRU5CUVdkQ0xFVkJRVVVzUTBGQll5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOdVF5eExRVUZMTEVWQlFVVTdiMEpCUTBnc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrN2IwSkJRM0pDTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTzJsQ1FVTjRRanRuUWtGRFJDeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRk5CUVZNc1IwRkJSeXhSUVVGUk8yZENRVU0xUWl4VFFVRlRMRVZCUVVVc1EwRkJReXhEUVVGRExGZEJRVmM3WjBKQlEzaENMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRUdG5Ra0ZEYUVJc1ZVRkJWU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTzJkQ1FVTnNRaXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVazdZVUZEWml4RFFVRkRMRU5CUTB3c1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF6dFpRVU5vUWl4UFFVRlBMRTFCUVUwc1EwRkJRenRSUVVOc1FpeERRVUZETEVOQlFVRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRWQ3hEUVVGRE8wTkJRMG9zUTBGQlFUdEJRVzVFUnp0SlFVUkRMSGRDUVVGWExFVkJRVVU3T3p0blJFRjFRbUk3UVVGSFJEdEpRVVJETEhkQ1FVRlhMRVZCUVVVN096dDVRMEV3UW1JN1FVRTVSRkVzV1VGQldUdEpRVVI0UWl4clEwRkJjVUlzUTBGQlF5eHpRMEZCYzBNc1EwRkJRenR4UTBGSEwwSXNaVUZCVFR0SFFVWjRRaXhaUVVGWkxFTkJLMFI0UWp0QlFTOUVXU3h2UTBGQldTSjkiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4uLy4uL2RlY29yYXRvcnNcIik7XHJcbmNvbnN0IFJlcGxheV8xID0gcmVxdWlyZShcIi4uLy4uL1JlcGxheVwiKTtcclxuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcclxuY29uc3QgbGlucSA9IHJlcXVpcmUoXCJsaW5xXCIpO1xyXG5jb25zdCBQbGF5ZXJBbmFseXNlcl8xID0gcmVxdWlyZShcIi4vUGxheWVyQW5hbHlzZXJcIik7XHJcbmNvbnN0IFJlcGxheUF0dHJpYnV0ZUhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvUmVwbGF5QXR0cmlidXRlSGVscGVyXCIpO1xyXG5jb25zdCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyXzEgPSByZXF1aXJlKFwiLi4vQWJzdHJhY3RSZXBsYXlBbmFseXNlclwiKTtcclxubGV0IERyYWZ0QW5hbHlzZXIgPSBjbGFzcyBEcmFmdEFuYWx5c2VyIGV4dGVuZHMgQWJzdHJhY3RSZXBsYXlBbmFseXNlcl8xLkFic3RyYWN0UmVwbGF5QW5hbHlzZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVwbGF5KSB7XHJcbiAgICAgICAgc3VwZXIocmVwbGF5KTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gbmFtZSA9PiBzdXBlcltuYW1lXTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCBfc3VwZXIoXCJpbml0aWFsaXplXCIpLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheWVyQW5hbHlzZXIgPSBuZXcgUGxheWVyQW5hbHlzZXJfMS5QbGF5ZXJBbmFseXNlcih0aGlzLnJlcGxheSk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGxheWVyQW5hbHlzZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJhbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlcm9EYXRhID0gbGlucS5mcm9tKHlpZWxkIHRoaXMuaGVyb0RhdGEpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWxwZXIgPSBuZXcgUmVwbGF5QXR0cmlidXRlSGVscGVyXzEuUmVwbGF5QXR0cmlidXRlSGVscGVyKHlpZWxkIHRoaXMuYXR0cmlidXRlRXZlbnRzKTtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2tRID0geWllbGQgdGhpcy50cmFja2VyRXZlbnRzUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0cmFja1FcclxuICAgICAgICAgICAgICAgIC53aGVyZShfID0+IHR5cGVzXzEuaXNTSGVyb0Jhbm5lZEV2ZW50KF8pKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXywgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVhbSA9IF8ubV9jb250cm9sbGluZ1RlYW0gLSAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVyb1Nob3J0ID0gaGVscGVyLmdldEJhbih0ZWFtLCBpIDwgMiA/IDAgOiAxKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhlcm8gPSBoZXJvRGF0YS5maXJzdCgoXykgPT4gXy5hdHRyaWJ1dGVfaWQgPT09IGhlcm9TaG9ydCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiYW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sbGluZ1RlYW0gLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlcm86IGhlcm8ubmFtZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGlja3MoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrUSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVycyA9IGxpbnEuZnJvbSh5aWVsZCB0aGlzLnBsYXllckFuYWx5c2VyLnBsYXllclNsb3REYXRhKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJhY2tRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoXyA9PiB0eXBlc18xLmlzU0hlcm9QaWNrZWRFdmVudChfKSlcclxuICAgICAgICAgICAgICAgIC5qb2luKHBsYXllcnMsIChwaWNrKSA9PiBwaWNrLm1fY29udHJvbGxpbmdQbGF5ZXIsIChwbGF5ZXIpID0+IHBsYXllci51c2VySWQsIChwaWNrLCBwbGF5ZXIpID0+ICh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAncGljaycsXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiBwbGF5ZXIudGVhbSxcclxuICAgICAgICAgICAgICAgIHVzZXJJZDogcGxheWVyLnVzZXJJZCxcclxuICAgICAgICAgICAgICAgIHBsYXllck5hbWU6IHBsYXllci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgaGVybzogcGxheWVyLmhlcm9cclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRyYWZ0KCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBiYW5zID0geWllbGQgdGhpcy5iYW5zO1xyXG4gICAgICAgICAgICBjb25zdCBwaWNrcyA9IHlpZWxkIHRoaXMucGlja3M7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlbHBlciA9IG5ldyBSZXBsYXlBdHRyaWJ1dGVIZWxwZXJfMS5SZXBsYXlBdHRyaWJ1dGVIZWxwZXIoeWllbGQgdGhpcy5hdHRyaWJ1dGVFdmVudHMpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGhlbHBlci5iYW5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcxYmFuJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yZGVyMWJhbkRyYWZ0KGJhbnMsIHBpY2tzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJzJiYW4nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JkZXIyYmFuRHJhZnQoYmFucywgcGlja3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnTWJhbic6IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmRlck1iYW5EcmFmdChiYW5zLCBwaWNrcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIG9yZGVyTWJhbkRyYWZ0KGJhbnMsIHBpY2tzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgcmVzdWx0LnB1c2goYmFuc1swXSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goYmFuc1sxXSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocGlja3NbMF0pO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBpY2tzWzFdKTtcclxuICAgICAgICByZXN1bHQucHVzaChwaWNrc1syXSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocGlja3NbM10pO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBpY2tzWzRdKTtcclxuICAgICAgICByZXN1bHQucHVzaChiYW5zWzJdKTtcclxuICAgICAgICByZXN1bHQucHVzaChiYW5zWzNdKTtcclxuICAgICAgICByZXN1bHQucHVzaChwaWNrc1s1XSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocGlja3NbNl0pO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBpY2tzWzddKTtcclxuICAgICAgICByZXN1bHQucHVzaChwaWNrc1s4XSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocGlja3NbOV0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBvcmRlcjFiYW5EcmFmdChiYW5zLCBwaWNrcykge1xyXG4gICAgICAgIHJldHVybiBbLi4uYmFucywgLi4ucGlja3NdO1xyXG4gICAgfVxyXG4gICAgb3JkZXIyYmFuRHJhZnQoYmFucywgcGlja3MpIHtcclxuICAgICAgICByZXR1cm4gWy4uLmJhbnMsIC4uLnBpY2tzXTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgRHJhZnRBbmFseXNlci5wcm90b3R5cGUsIFwiYmFuc1wiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgRHJhZnRBbmFseXNlci5wcm90b3R5cGUsIFwicGlja3NcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIERyYWZ0QW5hbHlzZXIucHJvdG90eXBlLCBcImRyYWZ0XCIsIG51bGwpO1xyXG5EcmFmdEFuYWx5c2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUmVwbGF5QW5hbHlzZXJDb250ZXh0KCdERjI0RkFDMy1EMjczLTRDQTAtODNBMy1FOEQzNjVGMTUyODMnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVwbGF5XzEuUmVwbGF5XSlcclxuXSwgRHJhZnRBbmFseXNlcik7XHJcbmV4cG9ydHMuRHJhZnRBbmFseXNlciA9IERyYWZ0QW5hbHlzZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVJISmhablJCYm1Gc2VYTmxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklrUnlZV1owUVc1aGJIbHpaWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3p0QlFVTkJMR2xFUVVGelJUdEJRVU4wUlN4NVEwRkJjME03UVVGRGRFTXNNRU5CUjNkQ08wRkJRM2hDTERaQ1FVRTJRanRCUVVNM1FpeHhSRUZCSzBRN1FVRkRMMFFzTkVWQlFYbEZPMEZCUTNwRkxITkZRVUZ0UlR0QlFXbENia1VzU1VGQllTeGhRVUZoTEVkQlFURkNMRzFDUVVFeVFpeFRRVUZSTEN0RFFVRnpRanRKUVVWeVJDeFpRVUZ0UWl4TlFVRmpPMUZCUXpkQ0xFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJRMWtzVlVGQlZUczdPMWxCUTI1Q0xFMUJRVTBzYjBKQlFXZENMRmRCUVVVc1EwRkJRenRaUVVONlFpeEpRVUZKTEVOQlFVTXNZMEZCWXl4SFFVRkhMRWxCUVVrc0swSkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkRkRVFzVFVGQlRTeEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRek5ETEVOQlFVTTdTMEZCUVR0SlFVZEVMRWxCUVZjc1NVRkJTVHRSUVVOWUxFOUJRVThzUTBGQlF5eEhRVUU0UWl4RlFVRkZPMWxCUTNCRExFMUJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdXVUZGYUVRc1RVRkJUU3hOUVVGTkxFZEJRVWNzU1VGQlNTdzJRMEZCY1VJc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0WlFVTnlSU3hOUVVGTkxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4elFrRkJjMElzUTBGQlF6dFpRVU5xUkN4TlFVRk5MRTFCUVUwc1IwRkJSeXhOUVVGTk8ybENRVU5vUWl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5d3dRa0ZCYTBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHBRa0ZEYWtNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQmIwSXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRuUWtGRGFFTXNUVUZCVFN4SlFVRkpMRWRCUVVjc1EwRkJReXhEUVVGRExHbENRVUZwUWl4SFFVRkhMRU5CUVVNc1EwRkJRenRuUWtGRGNrTXNUVUZCVFN4VFFVRlRMRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrUXNUVUZCVFN4SlFVRkpMRWRCUVU4c1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExGbEJRVmtzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXp0blFrRkRNVVVzVDBGQmEwSTdiMEpCUTJRc1NVRkJTU3hGUVVGRkxFdEJRVXM3YjBKQlExZ3NTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhwUWtGQmFVSXNSMEZCUnl4RFFVRkRPMjlDUVVNM1FpeEpRVUZKTEVWQlFVVXNTVUZCU1N4RFFVRkRMRWxCUVVrN2FVSkJRMnBDTEVOQlFVRTdXVUZEVGl4RFFVRkRMRU5CUVVNN2FVSkJRMFFzVDBGQlR5eEZRVUZGTEVOQlFVTTdXVUZEWml4UFFVRlBMRTFCUVUwc1EwRkJRenRSUVVOc1FpeERRVUZETEVOQlFVRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRWQ3hEUVVGRE8wbEJSMFFzU1VGQlZ5eExRVUZMTzFGQlExb3NUMEZCVHl4RFFVRkRMRWRCUVN0Q0xFVkJRVVU3V1VGRGNrTXNUVUZCVFN4TlFVRk5MRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYzBKQlFYTkNMRU5CUVVNN1dVRkRha1FzVFVGQlRTeFBRVUZQTEVkQlFVY3NTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNN1dVRkRjRVVzVFVGQlRTeE5RVUZOTEVkQlFVY3NUVUZCVFR0cFFrRkRhRUlzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc01FSkJRV3RDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2FVSkJRMnBETEVsQlFVa3NRMEZEUkN4UFFVRlBMRVZCUTFBc1EwRkJReXhKUVVGMVFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVWQlEzSkVMRU5CUVVNc1RVRkJUU3hGUVVGRkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RlFVTjZRaXhEUVVGRExFbEJRWFZDTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGWk8yZENRVU0zUXl4SlFVRkpMRVZCUVVVc1RVRkJUVHRuUWtGRFdpeEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWxCUVVrN1owSkJRMnBDTEUxQlFVMHNSVUZCUlN4TlFVRk5MRU5CUVVNc1RVRkJUVHRuUWtGRGNrSXNWVUZCVlN4RlFVRkZMRTFCUVUwc1EwRkJReXhKUVVGSk8yZENRVU4yUWl4SlFVRkpMRVZCUVVVc1RVRkJUU3hEUVVGRExFbEJRVWs3WVVGRGJrSXNRMEZCUVN4RFFVTk1PMmxDUVVOQkxFOUJRVThzUlVGQlJTeERRVUZETzFsQlEyWXNUMEZCVHl4TlFVRk5MRU5CUVVNN1VVRkRiRUlzUTBGQlF5eERRVUZCTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVkRUxFbEJRVmNzUzBGQlN6dFJRVU5hTEU5QlFVOHNRMEZCUXl4SFFVRXJReXhGUVVGRk8xbEJRM0pFTEUxQlFVMHNTVUZCU1N4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dFpRVU0zUWl4TlFVRk5MRXRCUVVzc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTTdXVUZETDBJc1RVRkJUU3hOUVVGTkxFZEJRVWNzU1VGQlNTdzJRMEZCY1VJc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0WlFVVnlSU3hSUVVGUkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVTdaMEpCUTNCQ0xFdEJRVXNzVFVGQlRTeERRVUZETEVOQlFVTTdiMEpCUTFRc1QwRkJUeXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRwUWtGRE0wTTdaMEpCUVVNc1MwRkJTeXhOUVVGTkxFTkJRVU1zUTBGQlF6dHZRa0ZEV0N4UFFVRlBMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMmxDUVVNelF6dG5Ra0ZCUXl4TFFVRkxMRTFCUVUwc1EwRkJReXhEUVVGRE8yOUNRVU5ZTEU5QlFVOHNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdhVUpCUXpORE8yRkJRMG83VVVGRlRDeERRVUZETEVOQlFVRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRWQ3hEUVVGRE8wbEJSVThzWTBGQll5eERRVUZETEVsQlFXZENMRVZCUVVVc1MwRkJhMEk3VVVGRGRrUXNUVUZCVFN4TlFVRk5MRWRCUVdkRExFVkJRVVVzUTBGQlF6dFJRVU12UXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRja0lzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVJc1QwRkJUeXhOUVVGTkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0SlFVVlBMR05CUVdNc1EwRkJReXhKUVVGblFpeEZRVUZGTEV0QlFXdENPMUZCUTNaRUxFOUJRVThzUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJReTlDTEVOQlFVTTdTVUZGVHl4alFVRmpMRU5CUVVNc1NVRkJaMElzUlVGQlJTeExRVUZyUWp0UlFVTjJSQ3hQUVVGUExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlFVVXNSMEZCUnl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVNdlFpeERRVUZETzBOQlEwb3NRMEZCUVR0QlFUZEdSenRKUVVSRExIZENRVUZYTEVWQlFVVTdPenQ1UTBGelFtSTdRVUZIUkR0SlFVUkRMSGRDUVVGWExFVkJRVVU3T3pzd1EwRnpRbUk3UVVGSFJEdEpRVVJETEhkQ1FVRlhMRVZCUVVVN096c3dRMEZyUW1JN1FVRTNSVkVzWVVGQllUdEpRVVI2UWl4clEwRkJjVUlzUTBGQlF5eHpRMEZCYzBNc1EwRkJRenR4UTBGSEwwSXNaVUZCVFR0SFFVWjRRaXhoUVVGaExFTkJlVWQ2UWp0QlFYcEhXU3h6UTBGQllTSjkiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4uLy4uL2RlY29yYXRvcnNcIik7XHJcbmNvbnN0IFJlcGxheV8xID0gcmVxdWlyZShcIi4uLy4uL1JlcGxheVwiKTtcclxuY29uc3QgbGlucSA9IHJlcXVpcmUoXCJsaW5xXCIpO1xyXG5jb25zdCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyXzEgPSByZXF1aXJlKFwiLi4vQWJzdHJhY3RSZXBsYXlBbmFseXNlclwiKTtcclxudmFyIFNsb3RUeXBlO1xyXG4oZnVuY3Rpb24gKFNsb3RUeXBlKSB7XHJcbiAgICBTbG90VHlwZVtTbG90VHlwZVtcIkVNUFRZXCJdID0gMF0gPSBcIkVNUFRZXCI7XHJcbiAgICBTbG90VHlwZVtTbG90VHlwZVtcIlBMQVlFUlwiXSA9IDFdID0gXCJQTEFZRVJcIjtcclxuICAgIFNsb3RUeXBlW1Nsb3RUeXBlW1wiT0JTRVJWRVJcIl0gPSAyXSA9IFwiT0JTRVJWRVJcIjtcclxuICAgIFNsb3RUeXBlW1Nsb3RUeXBlW1wiQUlcIl0gPSAzXSA9IFwiQUlcIjtcclxufSkoU2xvdFR5cGUgPSBleHBvcnRzLlNsb3RUeXBlIHx8IChleHBvcnRzLlNsb3RUeXBlID0ge30pKTtcclxubGV0IFBsYXllckFuYWx5c2VyID0gY2xhc3MgUGxheWVyQW5hbHlzZXIgZXh0ZW5kcyBBYnN0cmFjdFJlcGxheUFuYWx5c2VyXzEuQWJzdHJhY3RSZXBsYXlBbmFseXNlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXBsYXkpIHtcclxuICAgICAgICBzdXBlcihyZXBsYXkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBsYXllclNsb3REYXRhKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbml0RGF0YSA9IHlpZWxkIHRoaXMuaW5pdERhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSB5aWVsZCB0aGlzLmRldGFpbHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RJbmZvID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYmJ5U2xvdHMgPSBpbml0RGF0YS5tX3N5bmNMb2JieVN0YXRlLm1fbG9iYnlTdGF0ZS5tX3Nsb3RzO1xyXG4gICAgICAgICAgICBjb25zdCB1c2VySW5pdCA9IGluaXREYXRhLm1fc3luY0xvYmJ5U3RhdGUubV91c2VySW5pdGlhbERhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbFBsYXllcmxpc3QgPSBkZXRhaWxzLm1fcGxheWVyTGlzdDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gbG9iYnlTbG90c1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgbV9hbm5vdW5jZXJQYWNrOiBzbG90Lm1fYW5ub3VuY2VyUGFjayxcclxuICAgICAgICAgICAgICAgICAgICBtX2Jhbm5lcjogc2xvdC5tX2Jhbm5lcixcclxuICAgICAgICAgICAgICAgICAgICBtX2NvbnRyb2w6IHNsb3QubV9jb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgIG1faGFzU2lsZW5jZVBlbmFsdHk6IHNsb3QubV9oYXNTaWxlbmNlUGVuYWx0eSxcclxuICAgICAgICAgICAgICAgICAgICBtX2hhc1ZvaWNlU2lsZW5jZVBlbmFsdHk6IHNsb3QubV9oYXNWb2ljZVNpbGVuY2VQZW5hbHR5LFxyXG4gICAgICAgICAgICAgICAgICAgIG1faGVyb0hhbmRsZTogc2xvdC5tX2hlcm8sXHJcbiAgICAgICAgICAgICAgICAgICAgbV9tb3VudDogc2xvdC5tX21vdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIG1fb2JzZXJ2ZTogc2xvdC5tX29ic2VydmUsXHJcbiAgICAgICAgICAgICAgICAgICAgbV9za2luOiBzbG90Lm1fc2tpbixcclxuICAgICAgICAgICAgICAgICAgICBtX3NwcmF5OiBzbG90Lm1fc3ByYXksXHJcbiAgICAgICAgICAgICAgICAgICAgbV90ZWFtSWQ6IHNsb3QubV90ZWFtSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbV90b29uSGFuZGxlOiBzbG90Lm1fdG9vbkhhbmRsZSxcclxuICAgICAgICAgICAgICAgICAgICBtX3VzZXJJZDogc2xvdC5tX3VzZXJJZCxcclxuICAgICAgICAgICAgICAgICAgICBtX3ZvaWNlTGluZTogc2xvdC5tX3ZvaWNlTGluZSxcclxuICAgICAgICAgICAgICAgICAgICBtX3dvcmtpbmdTZXRTbG90SWQ6IHNsb3QubV93b3JraW5nU2V0U2xvdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1fbmFtZTogc2xvdC5tX3VzZXJJZCAhPT0gbnVsbCA/IHVzZXJJbml0W3Nsb3QubV91c2VySWRdLm1fbmFtZSA6IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBzbG90SW5mby5wdXNoKGluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RJbmZvUSA9IGxpbnEuZnJvbShzbG90SW5mbyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGV0YWlsUGxheWVybGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGV0YWlsID0gZGV0YWlsUGxheWVybGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBzbG90SW5mb1Euc2luZ2xlT3JEZWZhdWx0KF8gPT4gXy5tX3dvcmtpbmdTZXRTbG90SWQgPT09IGRldGFpbC5tX3dvcmtpbmdTZXRTbG90SWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Lm1fdG9vbl9pZCA9IGRldGFpbC5tX3Rvb24ubV9pZDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Lm1fcHJvZ3JhbUlkID0gZGV0YWlsLm1fdG9vbi5tX3Byb2dyYW1JZDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Lm1fcmVhbG0gPSBkZXRhaWwubV90b29uLm1fcmVhbG07XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5tX3JlZ2lvbiA9IGRldGFpbC5tX3Rvb24ubV9yZWdpb247XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5tX3Jlc3VsdCA9IGRldGFpbC5tX3Jlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICBzbG90Lm1faGVybyA9IGRldGFpbC5tX2hlcm87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2xvdExpc3QgPSBzbG90SW5mb1FcclxuICAgICAgICAgICAgICAgIC5vcmRlckJ5KF8gPT4gXy5tX3dvcmtpbmdTZXRTbG90SWQpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KF8gPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNsb3RUeXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8ubV90b29uSGFuZGxlICYmIF8ubV9vYnNlcnZlID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90VHlwZSA9IFNsb3RUeXBlLk9CU0VSVkVSO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXy5tX3Rvb25IYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90VHlwZSA9IFNsb3RUeXBlLlBMQVlFUjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF8ubV9oZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdFR5cGUgPSBTbG90VHlwZS5BSTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsb3RUeXBlID0gU2xvdFR5cGUuRU1QVFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHNsb3RUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBfLm1fdG9vbl9pZCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogXy5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICByZWFsbTogXy5tX3JlYWxtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogXy5tX3JlZ2lvbixcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGU6IF8ubV90b29uSGFuZGxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogXy5tX3VzZXJJZCxcclxuICAgICAgICAgICAgICAgICAgICB3b246IF8ubV9yZXN1bHQgPT09IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdDogXy5tX3dvcmtpbmdTZXRTbG90SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXy5tX25hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGVhbTogc2xvdFR5cGUgPT09IFNsb3RUeXBlLlBMQVlFUiB8fCBzbG90VHlwZSA9PT0gU2xvdFR5cGUuQUkgPyBfLm1fdGVhbUlkIDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVybzogXy5tX2hlcm8sXHJcbiAgICAgICAgICAgICAgICAgICAgaGVyb0hhbmRsZTogXy5tX2hlcm9IYW5kbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpbjogXy5tX3NraW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnQ6IF8ubV9tb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBzcHJheTogXy5tX3NwcmF5LFxyXG4gICAgICAgICAgICAgICAgICAgIGFubm91bmNlclBhY2s6IF8ubV9hbm5vdW5jZXJQYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhbm5lcjogXy5tX2Jhbm5lcixcclxuICAgICAgICAgICAgICAgICAgICB2b2ljZUxpbmU6IF8ubV92b2ljZUxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhdFNpbGVuY2U6IF8ubV9oYXNTaWxlbmNlUGVuYWx0eSxcclxuICAgICAgICAgICAgICAgICAgICBoYXNWb2ljZVNpbGVuY2U6IF8ubV9oYXNWb2ljZVNpbGVuY2VQZW5hbHR5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsb3Q7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2xvdExpc3Q7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbn07XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIFBsYXllckFuYWx5c2VyLnByb3RvdHlwZSwgXCJwbGF5ZXJTbG90RGF0YVwiLCBudWxsKTtcclxuUGxheWVyQW5hbHlzZXIgPSBfX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SZXBsYXlBbmFseXNlckNvbnRleHQoJzA5RTEzRTJELTU4MUUtNDkyOS1BRURBLUZFOERBM0ZGM0FDRicpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZXBsYXlfMS5SZXBsYXldKVxyXG5dLCBQbGF5ZXJBbmFseXNlcik7XHJcbmV4cG9ydHMuUGxheWVyQW5hbHlzZXIgPSBQbGF5ZXJBbmFseXNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVUd4aGVXVnlRVzVoYkhselpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKUWJHRjVaWEpCYm1Gc2VYTmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN096czdPenM3TzBGQlEwRXNhVVJCUVhORk8wRkJRM1JGTEhsRFFVRnpRenRCUVVWMFF5dzJRa0ZCTmtJN1FVRkhOMElzYzBWQlFXMUZPMEZCUlc1RkxFbEJRVmtzVVVGTFdEdEJRVXhFTEZkQlFWa3NVVUZCVVR0SlFVTm9RaXg1UTBGQlN5eERRVUZCTzBsQlEwd3NNa05CUVUwc1EwRkJRVHRKUVVOT0xDdERRVUZSTEVOQlFVRTdTVUZEVWl4dFEwRkJSU3hEUVVGQk8wRkJRMDRzUTBGQlF5eEZRVXhYTEZGQlFWRXNSMEZCVWl4blFrRkJVU3hMUVVGU0xHZENRVUZSTEZGQlMyNUNPMEZCTUVSRUxFbEJRV0VzWTBGQll5eEhRVUV6UWl4dlFrRkJORUlzVTBGQlVTd3JRMEZCYzBJN1NVRkZkRVFzV1VGQmJVSXNUVUZCWXp0UlFVTTNRaXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVsRUxFbEJRVmNzWTBGQll6dFJRVU55UWl4UFFVRlBMRU5CUVVNc1IwRkJhVU1zUlVGQlJUdFpRVU4yUXl4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hQUVVGUExFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUlc1RExFMUJRVTBzVVVGQlVTeEhRVUY1UWl4RlFVRkZMRU5CUVVNN1dVRkhNVU1zVFVGQlRTeFZRVUZWTEVkQlFVY3NVVUZCVVN4RFFVRkRMR2RDUVVGblFpeERRVUZETEZsQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNN1dVRkhiRVVzVFVGQlRTeFJRVUZSTEVkQlFVY3NVVUZCVVN4RFFVRkRMR2RDUVVGblFpeERRVUZETEdsQ1FVRnBRaXhEUVVGRE8xbEJSemRFTEUxQlFVMHNaMEpCUVdkQ0xFZEJRVWNzVDBGQlR5eERRVUZETEZsQlFWa3NRMEZCUXp0WlFVVTVReXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzJkQ1FVTjZRaXhOUVVGTkxFbEJRVWtzUjBGQlJ5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJSVE5DTEUxQlFVMHNTVUZCU1N4SFFVRjFRanR2UWtGRE4wSXNTMEZCU3l4RlFVRkZMRU5CUVVNN2IwSkJRMUlzWlVGQlpTeEZRVUZGTEVsQlFVa3NRMEZCUXl4bFFVRmxPMjlDUVVOeVF5eFJRVUZSTEVWQlFVVXNTVUZCU1N4RFFVRkRMRkZCUVZFN2IwSkJRM1pDTEZOQlFWTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1UwRkJVenR2UWtGRGVrSXNiVUpCUVcxQ0xFVkJRVVVzU1VGQlNTeERRVUZETEcxQ1FVRnRRanR2UWtGRE4wTXNkMEpCUVhkQ0xFVkJRVVVzU1VGQlNTeERRVUZETEhkQ1FVRjNRanR2UWtGRGRrUXNXVUZCV1N4RlFVRkZMRWxCUVVrc1EwRkJReXhOUVVGTk8yOUNRVU42UWl4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRExFOUJRVTg3YjBKQlEzSkNMRk5CUVZNc1JVRkJSU3hKUVVGSkxFTkJRVU1zVTBGQlV6dHZRa0ZEZWtJc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eE5RVUZOTzI5Q1FVTnVRaXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVODdiMEpCUTNKQ0xGRkJRVkVzUlVGQlJTeEpRVUZKTEVOQlFVTXNVVUZCVVR0dlFrRkRka0lzV1VGQldTeEZRVUZGTEVsQlFVa3NRMEZCUXl4WlFVRlpPMjlDUVVNdlFpeFJRVUZSTEVWQlFVVXNTVUZCU1N4RFFVRkRMRkZCUVZFN2IwSkJRM1pDTEZkQlFWY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1YwRkJWenR2UWtGRE4wSXNhMEpCUVd0Q0xFVkJRVVVzU1VGQlNTeERRVUZETEd0Q1FVRnJRanR2UWtGRE0wTXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhSUVVGUkxFdEJRVXNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTVHRwUWtGRGVrVXNRMEZCUXp0blFrRkRSaXhSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMkZCUTNaQ08xbEJSVVFzVFVGQlRTeFRRVUZUTEVkQlFVY3NTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFpRVVYwUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NaMEpCUVdkQ0xFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMmRDUVVNNVF5eE5RVUZOTEUxQlFVMHNSMEZCUnl4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRia01zVFVGQlRTeEpRVUZKTEVkQlFVY3NVMEZCVXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4clFrRkJhMElzUzBGQlN5eE5RVUZOTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF6dG5Ra0ZEYUVjc1NVRkJSeXhKUVVGSkxFVkJRVU03YjBKQlEwb3NTVUZCU1N4RFFVRkRMRk5CUVZNc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0dlFrRkRjRU1zU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF6dHZRa0ZETjBNc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJRenR2UWtGRGNrTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXp0dlFrRkRka01zU1VGQlNTeERRVUZETEZGQlFWRXNSMEZCUnl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRE8yOUNRVU5vUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdhVUpCUXk5Q08yRkJRMG83V1VGRlJDeE5RVUZOTEZGQlFWRXNSMEZCYTBJc1UwRkJVenRwUWtGRGNFTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEd0Q1FVRnJRaXhEUVVGRE8ybENRVU5zUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVU3WjBKQlExSXNTVUZCU1N4UlFVRnJRaXhEUVVGRE8yZENRVU4yUWl4SlFVRkpMRU5CUVVNc1EwRkJReXhaUVVGWkxFbEJRVWtzUTBGQlF5eERRVUZETEZOQlFWTXNTVUZCU1N4RFFVRkRMRVZCUVVVN2IwSkJRM0JETEZGQlFWRXNSMEZCUnl4UlFVRlJMRU5CUVVNc1VVRkJVU3hEUVVGRE8ybENRVU5vUXp0eFFrRkJUU3hKUVVGSkxFTkJRVU1zUTBGQlF5eFpRVUZaTEVWQlFVVTdiMEpCUTNaQ0xGRkJRVkVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRPMmxDUVVNNVFqdHhRa0ZCVFN4SlFVRkpMRU5CUVVNc1EwRkJReXhOUVVGTkxFVkJRVVU3YjBKQlEycENMRkZCUVZFc1IwRkJSeXhSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETzJsQ1FVTXhRanR4UWtGRFNUdHZRa0ZEUkN4UlFVRlJMRWRCUVVjc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF6dHBRa0ZETjBJN1owSkJRMFFzVFVGQlRTeEpRVUZKTEVkQlFXZENPMjlDUVVOMFFpeEpRVUZKTEVWQlFVVXNVVUZCVVR0dlFrRkRaQ3hGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTTdiMEpCUTJZc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTzI5Q1FVTmtMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR6dHZRa0ZEYUVJc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTzI5Q1FVTnNRaXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETEZsQlFWazdiMEpCUTNSQ0xFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVR0dlFrRkRiRUlzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1EwRkJRenR2UWtGRGNrSXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhyUWtGQmEwSTdiMEpCUXpGQ0xFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFR0dlFrRkRaQ3hKUVVGSkxFVkJRVVVzVVVGQlVTeExRVUZMTEZGQlFWRXNRMEZCUXl4TlFVRk5MRWxCUVVrc1VVRkJVU3hMUVVGTExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRhRVlzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5PMjlDUVVOa0xGVkJRVlVzUlVGQlJTeERRVUZETEVOQlFVTXNXVUZCV1R0dlFrRkRNVUlzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5PMjlDUVVOa0xFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHp0dlFrRkRhRUlzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBPMjlDUVVOb1FpeGhRVUZoTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVN2IwSkJRMmhETEUxQlFVMHNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVVHR2UWtGRGJFSXNVMEZCVXl4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGWE8yOUNRVU40UWl4alFVRmpMRVZCUVVVc1EwRkJReXhEUVVGRExHMUNRVUZ0UWp0dlFrRkRja01zWlVGQlpTeEZRVUZGTEVOQlFVTXNRMEZCUXl4M1FrRkJkMEk3YVVKQlF6bERMRU5CUVVNN1owSkJRMFlzVDBGQlR5eEpRVUZKTEVOQlFVTTdXVUZEYUVJc1EwRkJReXhEUVVGRE8ybENRVU5FTEU5QlFVOHNSVUZCUlN4RFFVRkRPMWxCUTJZc1QwRkJUeXhSUVVGUkxFTkJRVU03VVVGRGNFSXNRMEZCUXl4RFFVRkJMRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMVFzUTBGQlF6dERRVWRLTEVOQlFVRTdRVUZ5UjBjN1NVRkVReXgzUWtGQlZ5eEZRVUZGT3pzN2IwUkJiVWRpTzBGQk1VZFJMR05CUVdNN1NVRkVNVUlzYTBOQlFYRkNMRU5CUVVNc2MwTkJRWE5ETEVOQlFVTTdjVU5CUnk5Q0xHVkJRVTA3UjBGR2VFSXNZMEZCWXl4RFFUWkhNVUk3UVVFM1Ixa3NkME5CUVdNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVwbGF5XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVwbGF5XCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xyXG5jb25zdCBsaW5xID0gcmVxdWlyZShcImxpbnFcIik7XHJcbmNvbnN0IGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9kZWNvcmF0b3JzXCIpO1xyXG5jb25zdCBQbGF5ZXJBbmFseXNlcl8xID0gcmVxdWlyZShcIi4vUGxheWVyQW5hbHlzZXJcIik7XHJcbmNvbnN0IEFic3RyYWN0UmVwbGF5QW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdFJlcGxheUFuYWx5c2VyXCIpO1xyXG5sZXQgUmVwbGF5TWFwQW5hbHlzZXIgPSBjbGFzcyBSZXBsYXlNYXBBbmFseXNlciBleHRlbmRzIEFic3RyYWN0UmVwbGF5QW5hbHlzZXJfMS5BYnN0cmFjdFJlcGxheUFuYWx5c2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcGxheSkge1xyXG4gICAgICAgIHN1cGVyKHJlcGxheSk7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IG5hbWUgPT4gc3VwZXJbbmFtZV07XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgX3N1cGVyKFwiaW5pdGlhbGl6ZVwiKS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXllckFuYWx5c2VyID0gbmV3IFBsYXllckFuYWx5c2VyXzEuUGxheWVyQW5hbHlzZXIodGhpcy5yZXBsYXkpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXllckFuYWx5c2VyLmluaXRpYWxpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBtYXBOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0geWllbGQgdGhpcy5kZXRhaWxzO1xyXG4gICAgICAgICAgICByZXR1cm4gZGV0YWlscy5tX3RpdGxlO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1hcFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluaXQgPSB5aWVsZCB0aGlzLmluaXREYXRhO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYWNrZXJRLndoZXJlKF8gPT4gdHlwZXNfMS5pc0dhbWVTdGFydFNTdGF0R2FtZUV2ZW50KF8pKS5zZWxlY3QoKF8pID0+ICh7XHJcbiAgICAgICAgICAgICAgICB4OiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ01hcFNpemVYJywgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICB5OiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ01hcFNpemVZJywgdHJ1ZSlcclxuICAgICAgICAgICAgfSkpLmZpcnN0KCk7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWFwRGVzY3JpcHRvcigpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHlpZWxkIHRoaXMubWFwTmFtZSxcclxuICAgICAgICAgICAgICAgIGJ1aWxkOiB0aGlzLnByb3RvY29sVmVyc2lvbixcclxuICAgICAgICAgICAgICAgIHNpemU6IHlpZWxkIHRoaXMubWFwU2l6ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWluaW9uU3Bhd25zKHRlYW0pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IHlpZWxkIHRoaXMucmVwbGF5LnByb3RvY29sO1xyXG4gICAgICAgICAgICBsZXQgcSA9ICh5aWVsZCB0aGlzLnRyYWNrZXJFdmVudHNRdWVyaWFibGUpXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV9jb250cm9sUGxheWVySWQgPT09IDExIHx8IGUubV9jb250cm9sUGxheWVySWQgPT09IDEyKSAmJiBlLm1fdW5pdFR5cGVOYW1lLmVuZHNXaXRoKCdNaW5pb24nKSk7XHJcbiAgICAgICAgICAgIGlmICh0ZWFtID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBxID0gcS53aGVyZShlID0+IGUubV9jb250cm9sUGxheWVySWQgPT09IDExKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0ZWFtID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBxID0gcS53aGVyZShlID0+IGUubV9jb250cm9sUGxheWVySWQgPT09IDEyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBxLnNlbGVjdChlID0+ICh7XHJcbiAgICAgICAgICAgICAgICB0YWc6IHByb3RvY29sLnVuaXRUYWcoZS5tX3VuaXRUYWdJbmRleCwgZS5tX3VuaXRUYWdSZWN5Y2xlKSxcclxuICAgICAgICAgICAgICAgIHVuaXRUeXBlOiBlLm1fdW5pdFR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGltZTogZS5fZ2FtZWxvb3AgLyAxNixcclxuICAgICAgICAgICAgICAgIHRlYW06IGUubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMSA6IDIsXHJcbiAgICAgICAgICAgICAgICB4OiBlLm1feCxcclxuICAgICAgICAgICAgICAgIHk6IGUubV95XHJcbiAgICAgICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRNZXJjU3Bhd25zKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5yZXBsYXkucHJvdG9jb2w7XHJcbiAgICAgICAgICAgIGxldCBxID0gKHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZSlcclxuICAgICAgICAgICAgICAgIC53aGVyZShlID0+IHR5cGVzXzEuaXNTVW5pdEJvcm5FdmVudChlKVxyXG4gICAgICAgICAgICAgICAgJiYgKGUubV91bml0VHlwZU5hbWUuc3RhcnRzV2l0aCgnS2luZycpIHx8IGUubV91bml0VHlwZU5hbWUuc3RhcnRzV2l0aCgnVG93bicpIHx8IGUubV91bml0VHlwZU5hbWUuc3RhcnRzV2l0aCgnVW5kZXJ3b3JsZCcpKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHEuc2VsZWN0KGUgPT4gKHtcclxuICAgICAgICAgICAgICAgIHRhZzogcHJvdG9jb2wudW5pdFRhZyhlLm1fdW5pdFRhZ0luZGV4LCBlLm1fdW5pdFRhZ1JlY3ljbGUpLFxyXG4gICAgICAgICAgICAgICAgdW5pdFR5cGU6IGUubV91bml0VHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICB0aW1lOiBlLl9nYW1lbG9vcCAvIDE2LFxyXG4gICAgICAgICAgICAgICAgeDogZS5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBlLm1feVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9BcnJheSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TWluaW9uU3Bhd25IZWF0bWFwKHRlYW0pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IHlpZWxkIHRoaXMucmVwbGF5LnByb3RvY29sO1xyXG4gICAgICAgICAgICBsZXQgcSA9ICh5aWVsZCB0aGlzLnRyYWNrZXJFdmVudHNRdWVyaWFibGUpXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkpO1xyXG4gICAgICAgICAgICBpZiAodGVhbSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcSA9IHEud2hlcmUoZSA9PiBlLm1fY29udHJvbFBsYXllcklkID09PSAxMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGVhbSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcSA9IHEud2hlcmUoZSA9PiBlLm1fY29udHJvbFBsYXllcklkID09PSAxMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcS5ncm91cEJ5KGkgPT4gYCR7aS5tX3h9LCR7aS5tX3l9YClcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoZyA9PiAoe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGcuY291bnQoKSxcclxuICAgICAgICAgICAgICAgIHg6IGcuZmlyc3QoKS5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBnLmZpcnN0KCkubV95XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b0FycmF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZW5Vbml0VHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl91bml0VHlwZXNCeVRhZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLnJlcGxheS5wcm90b2NvbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRUeXBlc0J5VGFnID0ge307XHJcbiAgICAgICAgICAgICAgICBsZXQgcSA9ICh5aWVsZCB0aGlzLnRyYWNrZXJFdmVudHNRdWVyaWFibGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcS53aGVyZShfID0+IHR5cGVzXzEuaXNTVW5pdEJvcm5FdmVudChfKSlcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KF8gPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogcHJvdG9jb2wudW5pdFRhZyhfLm1fdW5pdFRhZ0luZGV4LCBfLm1fdW5pdFRhZ1JlY3ljbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF8ubV91bml0VHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25Db250cm9sUGxheWVySWQ6IF8ubV9jb250cm9sUGxheWVySWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25YOiBfLm1feCxcclxuICAgICAgICAgICAgICAgICAgICBzcGF3blk6IF8ubV95LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYXduVGltZTogXy5fZ2FtZWxvb3BcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRUeXBlc0J5VGFnID0gcmVzdWx0LnRvT2JqZWN0KF8gPT4gXy5pZCwgXyA9PiBfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRUeXBlcyA9IHJlc3VsdC50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFVuaXREZWF0aHMoZmlsdGVyUHJlZGljYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh5aWVsZCB0aGlzLmdldFVuaXREZWF0aHNRdWVyeShmaWx0ZXJQcmVkaWNhdGUpKS50b0FycmF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRVbml0RGVhdGhzUXVlcnkoZmlsdGVyUHJlZGljYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5nZW5Vbml0VHlwZXMoKTtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVycyA9IHlpZWxkIHRoaXMucGxheWVyQW5hbHlzZXIucGxheWVyU2xvdERhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5yZXBsYXkucHJvdG9jb2w7XHJcbiAgICAgICAgICAgIGxldCBxID0geWllbGQgdGhpcy50cmFja2VyRXZlbnRzUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBxLndoZXJlKF8gPT4gdHlwZXNfMS5pc1NVbml0RGllZEV2ZW50KF8pKS5qb2luKGxpbnEuZnJvbSh0aGlzLl91bml0VHlwZXMpLCAoZGllZCkgPT4gcHJvdG9jb2wudW5pdFRhZyhkaWVkLm1fdW5pdFRhZ0luZGV4LCBkaWVkLm1fdW5pdFRhZ1JlY3ljbGUpLCBib3JuID0+IGJvcm4uaWQsIChkaWVkLCBib3JuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBraWxsUGxheWVySWR4ID0gZGllZC5tX2tpbGxlclBsYXllcklkID8gZGllZC5tX2tpbGxlclBsYXllcklkIC0gMSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBraWxsaW5nVW5pdElkID0gZGllZC5tX2tpbGxlclVuaXRUYWdJbmRleCA/IHByb3RvY29sLnVuaXRUYWcoZGllZC5tX2tpbGxlclVuaXRUYWdJbmRleCwgZGllZC5tX2tpbGxlclVuaXRUYWdSZWN5Y2xlKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQga2lsbGluZ1BsYXllciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQga2lsbGluZ1RlYW0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGtpbGxpbmdVbml0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChraWxsUGxheWVySWR4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbGxQbGF5ZXJJZHggPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBraWxsaW5nUGxheWVyID0gcGxheWVyc1traWxsUGxheWVySWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2lsbGluZ1RlYW0gPSBraWxsaW5nUGxheWVyLnRlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtpbGxQbGF5ZXJJZHggPT09IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbGxpbmdUZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2lsbFBsYXllcklkeCA9PT0gMTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2lsbGluZ1RlYW0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VOS05PV04ga2lsbCBpbmRleDonLCBraWxsUGxheWVySWR4LCBkaWVkLCBib3JuLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOVUxMIGtpbGwgaW5kZXg6JywgZGllZCwgYm9ybi50eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChraWxsaW5nVW5pdElkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBraWxsaW5nVW5pdCA9IHRoaXMuX3VuaXRUeXBlc0J5VGFnW2tpbGxpbmdVbml0SWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25QbGF5ZXJJZHggPSBib3JuLnNwYXduQ29udHJvbFBsYXllcklkID8gYm9ybi5zcGF3bkNvbnRyb2xQbGF5ZXJJZCAtIDEgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNwYXduUGxheWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBzcGF3blRlYW0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwYXduUGxheWVySWR4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYXduUGxheWVySWR4IDwgMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhd25QbGF5ZXIgPSBwbGF5ZXJzW3NwYXduUGxheWVySWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhd25UZWFtID0gc3Bhd25QbGF5ZXIudGVhbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3Bhd25QbGF5ZXJJZHggPT09IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYXduVGVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNwYXduUGxheWVySWR4ID09PSAxMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGF3blRlYW0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VOS05PV04gc3Bhd24gY29udHJvbCBpbmRleDonLCBzcGF3blBsYXllcklkeCwgZGllZCwgYm9ybi50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYm9ybiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGtpbGxpbmdQbGF5ZXJJZDoga2lsbFBsYXllcklkeCxcclxuICAgICAgICAgICAgICAgICAgICBraWxsaW5nVW5pdFRhZzoga2lsbGluZ1VuaXRJZCxcclxuICAgICAgICAgICAgICAgICAgICBraWxsaW5nVW5pdFR5cGU6IGtpbGxpbmdVbml0ID8ga2lsbGluZ1VuaXQudHlwZSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAga2lsbGluZ1RlYW06IGtpbGxpbmdUZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYXduVGVhbTogc3Bhd25UZWFtLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYXduUGxheWVySWQ6IHNwYXduUGxheWVySWR4LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlYXRoWDogZGllZC5tX3gsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVhdGhZOiBkaWVkLm1feSxcclxuICAgICAgICAgICAgICAgICAgICBkZWF0aFRpbWU6IGRpZWQuX2dhbWVsb29wXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJQcmVkaWNhdGUpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoZmlsdGVyUHJlZGljYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjaGVja1VuaXRMaWZlRmlsdGVyKHVuaXQsIGZpbHRlcikge1xyXG4gICAgICAgIGlmICghZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyLmtpbGxlZEJ5UGxheWVycyA9PT0gdHJ1ZSAmJiB1bml0LmtpbGxpbmdQbGF5ZXJJZCA+IDkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIua2lsbGVkQnlQbGF5ZXJzKSAmJiBmaWx0ZXIua2lsbGVkQnlQbGF5ZXJzLmluZGV4T2YodW5pdC5raWxsaW5nUGxheWVySWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bml0LmtpbGxpbmdVbml0VHlwZSA9PT0gJ1JhbmdlZE1pbmlvbicgfHwgdW5pdC5raWxsaW5nVW5pdFR5cGUgPT09ICdGb290bWFuTWluaW9uJyB8fCB1bml0LmtpbGxpbmdVbml0VHlwZSA9PT0gJ1dpemFyZE1pbmlvbicpIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlci5raWxsZWRCeU1pbmlvbnMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIua2lsbGVkQnlNaW5pb25zID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlci5raWxsZWRCeVRlYW1zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlci5raWxsZWRCeVRlYW1zKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLmtpbGxlZEJ5VGVhbXMgPSBbZmlsdGVyLmtpbGxlZEJ5VGVhbXNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIua2lsbGVkQnlUZWFtcy5pbmRleE9mKHVuaXQua2lsbGluZ1RlYW0pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWx0ZXIuaXNPblRlYW0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyLmlzT25UZWFtKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyLmlzT25UZWFtID0gW2ZpbHRlci5pc09uVGVhbV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpbHRlci5pc09uVGVhbS5pbmRleE9mKHVuaXQuc3Bhd25UZWFtKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyLmlzT3duZWRCeVBsYXllcnMgPT09IHRydWUgJiYgdW5pdC5zcGF3blBsYXllcklkID4gOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlci5pc093bmVkQnlQbGF5ZXJzKSAmJiBmaWx0ZXIuaXNPd25lZEJ5UGxheWVycy5pbmRleE9mKHVuaXQuc3Bhd25QbGF5ZXJJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRNaW5pb25EZWF0aHMoZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZ2V0VW5pdERlYXRocygoXykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoXy50eXBlID09PSAnUmFuZ2VkTWluaW9uJyB8fCBfLnR5cGUgPT09ICdGb290bWFuTWluaW9uJyB8fCBfLnR5cGUgPT09ICdXaXphcmRNaW5pb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrVW5pdExpZmVGaWx0ZXIoXywgZmlsdGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRHbG9iZURlYXRocygpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgY29uc3QgcSA9IHlpZWxkIHRoaXMuZ2V0VW5pdERlYXRoc1F1ZXJ5KChfKSA9PiBfLnR5cGUgPT09ICdSZWdlbkdsb2JlJyB8fFxyXG4gICAgICAgICAgICAgICAgXy50eXBlID09PSAnUmVnZW5HbG9iZU5ldXRyYWwnKTtcclxuICAgICAgICAgICAgY29uc3QgZ2xvYmVzUSA9IHEuZ3JvdXBCeShfID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChfLnR5cGUgPT09ICdSZWdlbkdsb2JlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IF8uZGVhdGhYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBfLmRlYXRoWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogXy5kZWF0aFRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IF8uc3Bhd25Db250cm9sUGxheWVySWRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogXy5zcGF3blgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogXy5zcGF3blksXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogXy5zcGF3blRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogXy5zcGF3bkNvbnRyb2xQbGF5ZXJJZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIF8gPT4gXywgKGtleSwgXykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd24gPSBfLmZpcnN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXV0cmFsID0gXy5sYXN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnbG9iZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZ2xvYmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IHNwYXduLnNwYXduWCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBzcGF3bi5zcGF3blksXHJcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25UaW1lOiBzcGF3bi5zcGF3blRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVhdGhUaW1lOiBuZXV0cmFsLmRlYXRoVGltZSxcclxuICAgICAgICAgICAgICAgICAgICBsaWZlRHVyYXRpb246IChuZXV0cmFsLmRlYXRoVGltZSAtIHNwYXduLnNwYXduVGltZSkgLyAxNixcclxuICAgICAgICAgICAgICAgICAgICBsaWZlRHVyYXRpb25UaWNrczogKG5ldXRyYWwuZGVhdGhUaW1lIC0gc3Bhd24uc3Bhd25UaW1lKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXV0cmFsOiBfLmNvdW50KCkgPiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0b2xlbjogbmV1dHJhbC5zcGF3bkNvbnRyb2xQbGF5ZXJJZCAhPT0gbmV1dHJhbC5raWxsaW5nUGxheWVySWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGVhbTogbmV1dHJhbC5raWxsaW5nUGxheWVySWQgPT09IDExID8gMCA6IDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBwaWNrdXBRID0gdHJhY2tlclEud2hlcmUoXyA9PiB0eXBlc18xLmlzU1N0YXRHYW1lRXZlbnQoXykgJiYgXy5tX2V2ZW50TmFtZSA9PT0gJ1JlZ2VuR2xvYmVQaWNrZWRVcCcpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1BpY2t1cCcsXHJcbiAgICAgICAgICAgICAgICBkZWF0aFRpbWU6IF8uX2dhbWVsb29wLFxyXG4gICAgICAgICAgICAgICAgcGxheWVySWQ6IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1faW50RGF0YSwgJ1BsYXllcklEJylcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBsaW5xLmZyb20oWy4uLmdsb2Jlc1EudG9BcnJheSgpLCAuLi5waWNrdXBRLnRvQXJyYXkoKV0pLm9yZGVyQnkoXyA9PiBfLmRlYXRoVGltZSkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TWluaW9uRGVhdGhIZWF0bWFwKGZpbHRlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbmlvbkRlYXRocyA9IGxpbnEuZnJvbSh5aWVsZCB0aGlzLmdldE1pbmlvbkRlYXRocyhmaWx0ZXIpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWluaW9uRGVhdGhzLmdyb3VwQnkoXyA9PiBgJHtfLmRlYXRoWH0sJHtfLmRlYXRoWX1gKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdChnID0+ICh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZy5jb3VudCgpLFxyXG4gICAgICAgICAgICAgICAgeDogZy5maXJzdCgpLmRlYXRoWCxcclxuICAgICAgICAgICAgICAgIHk6IGcuZmlyc3QoKS5kZWF0aFlcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvQXJyYXkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFBvaW50c09mSW50ZXJlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2tlclEgPSB5aWVsZCB0aGlzLnRyYWNrZXJFdmVudHNRdWVyaWFibGU7XHJcbiAgICAgICAgICAgIGxldCBjb3JlcyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgZS5tX3VuaXRUeXBlTmFtZSA9PT0gJ0tpbmdzQ29yZScpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMCA6IDEsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ29yZSdcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBsZXQgd2VsbHMgPSB0cmFja2VyUVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NVbml0Qm9ybkV2ZW50KGUpICYmIGUubV91bml0VHlwZU5hbWUuc3RhcnRzV2l0aCgnVG93bk1vb253ZWxsJykpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMCA6IDEsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnTW9vbldlbGwnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbGV0IHRvd2VycyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgZS5tX3VuaXRUeXBlTmFtZS5zdGFydHNXaXRoKCdUb3duQ2Fubm9uVG93ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKF8pID0+ICh7XHJcbiAgICAgICAgICAgICAgICB4OiBfLm1feCxcclxuICAgICAgICAgICAgICAgIHk6IF8ubV95LFxyXG4gICAgICAgICAgICAgICAgdGVhbTogXy5tX2NvbnRyb2xQbGF5ZXJJZCA9PT0gMTEgPyAwIDogMSxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdUb3dlcidcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBsZXQgdG93bnMgPSB0cmFja2VyUVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NVbml0Qm9ybkV2ZW50KGUpICYmIGUubV91bml0VHlwZU5hbWUuc3RhcnRzV2l0aCgnVG93blRvd25IYWxsJykpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMCA6IDEsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnVG93bidcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBsZXQgd2F0Y2hUb3dlcnMgPSB0cmFja2VyUVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NVbml0Qm9ybkV2ZW50KGUpICYmIGUubV91bml0VHlwZU5hbWUuZW5kc1dpdGgoJ1dhdGNoVG93ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKF8pID0+ICh7XHJcbiAgICAgICAgICAgICAgICB4OiBfLm1feCxcclxuICAgICAgICAgICAgICAgIHk6IF8ubV95LFxyXG4gICAgICAgICAgICAgICAgdGVhbTogMixcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdXYXRjaFRvd2VyJ1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGxldCBjYW1wcyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1N0YXRHYW1lRXZlbnQoZSkgJiYgZS5tX2V2ZW50TmFtZSA9PT0gJ0p1bmdsZUNhbXBJbml0JylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKF8pID0+ICh7XHJcbiAgICAgICAgICAgICAgICB4OiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ1Bvc2l0aW9uWCcsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgeTogdHlwZXNfMS5nZXRTU3RhdFZhbHVlKF8ubV9maXhlZERhdGEsICdQb3NpdGlvblknLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIHRlYW06IDIsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnSnVuZ2xlQ2FtcCdcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXBTcGVjaWZpY1BPSXMgPSB5aWVsZCB0aGlzLmdldE1hcFNwZWNpZmljUE9JcygpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZXMubWVyZ2Uod2VsbHMsIHRvd2VycywgdG93bnMsIHdhdGNoVG93ZXJzLCBjYW1wcywgLi4ubWFwU3BlY2lmaWNQT0lzKS50b0FycmF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRNYXBTcGVjaWZpY1BPSXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWFwTmFtZSA9IHlpZWxkIHRoaXMubWFwTmFtZTtcclxuICAgICAgICAgICAgc3dpdGNoIChtYXBOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdCYXR0bGVmaWVsZCBvZiBFdGVybml0eSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZ2V0QmF0dGxlZmlsZWRPZkV0ZXJuaXR5UE9JcygpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQmxhY2toZWFydFxcJ3MgQmF5JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRCbGFja2hlYXJ0c0JheVBPSXMoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0N1cnNlZCBIb2xsb3cnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldEN1cnNlZEhvbGxvd1BPSXMoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0hhdW50ZWQgTWluZXMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldEhhdW50ZWRNaW5lc1BPSXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRCYXR0bGVmaWxlZE9mRXRlcm5pdHlQT0lzKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgbGV0IGltbW9ydGFscyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV91bml0VHlwZU5hbWUgPT09ICdCb3NzRHVlbEJvc3NIZWF2ZW4nIHx8IGUubV91bml0VHlwZU5hbWUgPT09ICdCb3NzRHVlbEJvc3NIZWxsJykpXHJcbiAgICAgICAgICAgICAgICAuZGlzdGluY3QoKF8pID0+IF8ubV94ICogMTAwMCArIF8ubV95KVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXykgPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IF8ubV94LFxyXG4gICAgICAgICAgICAgICAgeTogXy5tX3ksXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiAzLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0JvRV9JbW1vcnRhbCdcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpbW1vcnRhbHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0QmxhY2toZWFydHNCYXlQT0lzKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgbGV0IGNoZXN0cyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV91bml0VHlwZU5hbWUgPT09ICdEb2Nrc1RyZWFzdXJlQ2hlc3QnKSlcclxuICAgICAgICAgICAgICAgIC5kaXN0aW5jdCgoXykgPT4gXy5tX3ggKiAxMDAwICsgXy5tX3kpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IDMsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQkhCX1RyZWFzdXJlQ2hlc3QnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hlc3RzKTtcclxuICAgICAgICAgICAgbGV0IHR1cm5pbiA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV91bml0VHlwZU5hbWUgPT09ICdHaG9zdFNoaXBCZWFjb24nKSlcclxuICAgICAgICAgICAgICAgIC5kaXN0aW5jdCgoXykgPT4gXy5tX3ggKiAxMDAwICsgXy5tX3kpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IDMsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQkhCX0JsYWNraGVhcnQnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHVybmluKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEN1cnNlZEhvbGxvd1BPSXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZXJRID0geWllbGQgdGhpcy50cmFja2VyRXZlbnRzUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBsZXQgdHJpYiA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV91bml0VHlwZU5hbWUgPT09ICdSYXZlbkxvcmRUcmlidXRlJykpXHJcbiAgICAgICAgICAgICAgICAuZGlzdGluY3QoKF8pID0+IF8ubV94ICogMTAwMCArIF8ubV95KVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXykgPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IF8ubV94LFxyXG4gICAgICAgICAgICAgICAgeTogXy5tX3ksXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiAzLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIX1RyaWJ1dGUnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHJpYik7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRIYXVudGVkTWluZXNQT0lzKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgbGV0IG1pbmVFbnRyYW5jZXMgPSB0cmFja2VyUVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NVbml0Qm9ybkV2ZW50KGUpICYmIChlLm1fdW5pdFR5cGVOYW1lID09PSAnSG9sZUxhZGRlckRvd24nIHx8IGUubV91bml0VHlwZU5hbWUgPT09ICdIb2xlTGFkZGVyVXAnKSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKF8pID0+ICh7XHJcbiAgICAgICAgICAgICAgICB4OiBfLm1feCxcclxuICAgICAgICAgICAgICAgIHk6IF8ubV95LFxyXG4gICAgICAgICAgICAgICAgdGVhbTogMixcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdITV9NaW5lRW50cmFuY2UnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWluZUVudHJhbmNlcyk7XHJcbiAgICAgICAgICAgIGxldCB1bmRlcndvcmxkQm9zcyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV91bml0VHlwZU5hbWUgPT09ICdVbmRlcndvcmxkQm9zcycpKVxyXG4gICAgICAgICAgICAgICAgLmRpc3RpbmN0KChfKSA9PiBfLm1fdW5pdFR5cGVOYW1lKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXykgPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IF8ubV94LFxyXG4gICAgICAgICAgICAgICAgeTogXy5tX3ksXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiAzLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0hNX1VuZGVyd29ybGRCb3NzJ1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVyd29ybGRCb3NzKTtcclxuICAgICAgICAgICAgbGV0IHVuZGVyd29ybGRCb3NzU3VtbW9uID0gdHJhY2tlclFcclxuICAgICAgICAgICAgICAgIC53aGVyZShlID0+IHR5cGVzXzEuaXNTVW5pdEJvcm5FdmVudChlKSAmJiAoZS5tX3VuaXRUeXBlTmFtZSA9PT0gJ1VuZGVyd29ybGRTdW1tb25lZEJvc3MnKSlcclxuICAgICAgICAgICAgICAgIC5kaXN0aW5jdCgoXykgPT4gXy5tX3ggKiAxMDAwICsgXy5tX3kpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMCA6IDEsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnSE1fVW5kZXJ3b3JsZEJvc3MnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZXJ3b3JsZEJvc3NTdW1tb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TWFqb3JMb2NhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2tlclEgPSB5aWVsZCB0aGlzLnRyYWNrZXJFdmVudHNRdWVyaWFibGU7XHJcbiAgICAgICAgICAgIGxldCBjb3JlcyA9IHRyYWNrZXJRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoZSA9PiB0eXBlc18xLmlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgZS5tX3VuaXRUeXBlTmFtZSA9PT0gJ0tpbmdzQ29yZScpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMCA6IDFcclxuICAgICAgICAgICAgfSkpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgbGV0IHdlbGxzID0gdHJhY2tlclFcclxuICAgICAgICAgICAgICAgIC53aGVyZShlID0+IHR5cGVzXzEuaXNTVW5pdEJvcm5FdmVudChlKSAmJiBlLm1fdW5pdFR5cGVOYW1lLnN0YXJ0c1dpdGgoJ1Rvd25Nb29ud2VsbCcpKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXykgPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IF8ubV94LFxyXG4gICAgICAgICAgICAgICAgeTogXy5tX3ksXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiBfLm1fY29udHJvbFBsYXllcklkID09PSAxMSA/IDAgOiAxXHJcbiAgICAgICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGxldCB0b3dlcnMgPSB0cmFja2VyUVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NVbml0Qm9ybkV2ZW50KGUpICYmIGUubV91bml0VHlwZU5hbWUuc3RhcnRzV2l0aCgnVG93bkNhbm5vblRvd2VyJykpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KChfKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogXy5tX3gsXHJcbiAgICAgICAgICAgICAgICB5OiBfLm1feSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8ubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMCA6IDFcclxuICAgICAgICAgICAgfSkpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgbGV0IHRvd25zID0gdHJhY2tlclFcclxuICAgICAgICAgICAgICAgIC53aGVyZShlID0+IHR5cGVzXzEuaXNTVW5pdEJvcm5FdmVudChlKSAmJiBlLm1fdW5pdFR5cGVOYW1lLnN0YXJ0c1dpdGgoJ1Rvd25Ub3duSGFsbCcpKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXykgPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IF8ubV94LFxyXG4gICAgICAgICAgICAgICAgeTogXy5tX3ksXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiBfLm1fY29udHJvbFBsYXllcklkID09PSAxMSA/IDAgOiAxXHJcbiAgICAgICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb3JlcyxcclxuICAgICAgICAgICAgICAgIHdlbGxzLFxyXG4gICAgICAgICAgICAgICAgdG93ZXJzLFxyXG4gICAgICAgICAgICAgICAgdG93bnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgUmVwbGF5TWFwQW5hbHlzZXIucHJvdG90eXBlLCBcIm1hcE5hbWVcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIFJlcGxheU1hcEFuYWx5c2VyLnByb3RvdHlwZSwgXCJtYXBTaXplXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBSZXBsYXlNYXBBbmFseXNlci5wcm90b3R5cGUsIFwibWFwRGVzY3JpcHRvclwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXHJcbl0sIFJlcGxheU1hcEFuYWx5c2VyLnByb3RvdHlwZSwgXCJnZXRNaW5pb25TcGF3bnNcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxyXG5dLCBSZXBsYXlNYXBBbmFseXNlci5wcm90b3R5cGUsIFwiZ2V0TWVyY1NwYXduc1wiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXHJcbl0sIFJlcGxheU1hcEFuYWx5c2VyLnByb3RvdHlwZSwgXCJnZXRNaW5pb25TcGF3bkhlYXRtYXBcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxyXG5dLCBSZXBsYXlNYXBBbmFseXNlci5wcm90b3R5cGUsIFwiZ2V0TWluaW9uRGVhdGhzXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcclxuXSwgUmVwbGF5TWFwQW5hbHlzZXIucHJvdG90eXBlLCBcImdldEdsb2JlRGVhdGhzXCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcclxuXSwgUmVwbGF5TWFwQW5hbHlzZXIucHJvdG90eXBlLCBcImdldE1pbmlvbkRlYXRoSGVhdG1hcFwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXHJcbl0sIFJlcGxheU1hcEFuYWx5c2VyLnByb3RvdHlwZSwgXCJnZXRQb2ludHNPZkludGVyZXN0XCIsIG51bGwpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGRlY29yYXRvcnNfMS5SdW5PbldvcmtlcigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcclxuXSwgUmVwbGF5TWFwQW5hbHlzZXIucHJvdG90eXBlLCBcImdldE1ham9yTG9jYXRpb25zXCIsIG51bGwpO1xyXG5SZXBsYXlNYXBBbmFseXNlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJlcGxheUFuYWx5c2VyQ29udGV4dCgnRDkwREM5RUYtQjAxNi00N0YxLTk4NEItQjlCQTA5OTg2OUU2JyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlcGxheV8xLlJlcGxheV0pXHJcbl0sIFJlcGxheU1hcEFuYWx5c2VyKTtcclxuZXhwb3J0cy5SZXBsYXlNYXBBbmFseXNlciA9IFJlcGxheU1hcEFuYWx5c2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVbVZ3YkdGNVRXRndRVzVoYkhselpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKU1pYQnNZWGxOWVhCQmJtRnNlWE5sY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenM3T3pzN096czdPenM3T3pzN08wRkJRVUVzZVVOQlFYTkRPMEZCUTNSRExEQkRRVmwzUWp0QlFVTjRRaXcyUWtGQk5rSTdRVUZGTjBJc2FVUkJRWE5GTzBGQlEzUkZMSEZFUVVFclJEdEJRVVV2UkN4elJVRkJiVVU3UVVFMFEyNUZMRWxCUVdFc2FVSkJRV2xDTEVkQlFUbENMSFZDUVVFclFpeFRRVUZSTEN0RFFVRnpRanRKUVV0NlJDeFpRVUZ0UWl4TlFVRmpPMUZCUXpkQ0xFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJSVmtzVlVGQlZUczdPMWxCUTI1Q0xFMUJRVTBzYjBKQlFXZENMRmRCUVVVc1EwRkJRenRaUVVONlFpeEpRVUZKTEVOQlFVTXNZMEZCWXl4SFFVRkhMRWxCUVVrc0swSkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkRkRVFzVFVGQlRTeEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRek5ETEVOQlFVTTdTMEZCUVR0SlFVZEVMRWxCUVZjc1QwRkJUenRSUVVOa0xFOUJRVThzUTBGQlF5eEhRVUV3UWl4RlFVRkZPMWxCUTJoRExFMUJRVTBzVDBGQlR5eEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJRenRaUVVOdVF5eFBRVUZQTEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNN1VVRkRNMElzUTBGQlF5eERRVUZCTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVsRUxFbEJRVmNzVDBGQlR6dFJRVU5rTEU5QlFVOHNRMEZCUXl4SFFVRXdRaXhGUVVGRk8xbEJRMmhETEUxQlFVMHNTVUZCU1N4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF6dFpRVU5xUXl4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJRenRaUVVOdVJDeFBRVUZQTEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eHBRMEZCZVVJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVd0Q0xFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdaMEpCUTNKR0xFTkJRVU1zUlVGQlJTeHhRa0ZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFVkJRVVVzVlVGQlZTeEZRVUZGTEVsQlFVa3NRMEZCUXp0blFrRkRha1FzUTBGQlF5eEZRVUZGTEhGQ1FVRmhMRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUlVGQlJTeFZRVUZWTEVWQlFVVXNTVUZCU1N4RFFVRkRPMkZCUTNCRUxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMUZCUTJoQ0xFTkJRVU1zUTBGQlFTeERRVUZETEVWQlFVVXNRMEZCUXp0SlFVTlVMRU5CUVVNN1NVRkhSQ3hKUVVGWExHRkJRV0U3VVVGRGNFSXNUMEZCVHl4RFFVRkRMRWRCUVd0RExFVkJRVVU3V1VGRGVFTXNUMEZCVHp0blFrRkRTQ3hKUVVGSkxFVkJRVVVzVFVGQlRTeEpRVUZKTEVOQlFVTXNUMEZCVHp0blFrRkRlRUlzUzBGQlN5eEZRVUZGTEVsQlFVa3NRMEZCUXl4bFFVRmxPMmRDUVVNelFpeEpRVUZKTEVWQlFVVXNUVUZCVFN4SlFVRkpMRU5CUVVNc1QwRkJUenRoUVVNelFpeERRVUZETzFGQlEwNHNRMEZCUXl4RFFVRkJMRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMVFzUTBGQlF6dEpRVWRaTEdWQlFXVXNRMEZCUXl4SlFVRmhPenRaUVVOMFF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETzFsQlF6VkRMRWxCUVVrc1EwRkJReXhIUVVGelF5eERRVUZETEUxQlFVMHNTVUZCU1N4RFFVRkRMSE5DUVVGelFpeERRVUZETzJsQ1FVTjZSU3hMUVVGTExFTkJRMFlzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4M1FrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhwUWtGQmFVSXNTMEZCU3l4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExHbENRVUZwUWl4TFFVRkxMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eGpRVUZqTEVOQlFVTXNVVUZCVVN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVOb1NTeERRVUZETzFsQlEwNHNTVUZCU1N4SlFVRkpMRXRCUVVzc1EwRkJReXhGUVVGRk8yZENRVU5hTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMR2xDUVVGcFFpeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMkZCUTJoRU8ybENRVUZOTEVsQlFVa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1JVRkJSVHRuUWtGRGJrSXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1lVRkRhRVE3V1VGRFJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkRNVUlzUjBGQlJ5eEZRVUZGTEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExHTkJRV01zUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU03WjBKQlF6TkVMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zWTBGQll6dG5Ra0ZETVVJc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFRRVUZUTEVkQlFVY3NSVUZCUlR0blFrRkRkRUlzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4cFFrRkJhVUlzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITzJkQ1FVTlNMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ6dGhRVU5ZTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8xbEJRMlFzVDBGQlR5eE5RVUZOTEVOQlFVTTdVVUZEYkVJc1EwRkJRenRMUVVGQk8wbEJSMWtzWVVGQllUczdXVUZEZEVJc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRaUVVNMVF5eEpRVUZKTEVOQlFVTXNSMEZCYzBNc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJRenRwUWtGRGVrVXNTMEZCU3l4RFFVTkdMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zZDBKQlFXZENMRU5CUVVNc1EwRkJReXhEUVVGRE8yMUNRVU5xUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhqUVVGakxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhqUVVGakxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhqUVVGakxFTkJRVU1zVlVGQlZTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUTI1SkxFTkJRVU03V1VGRlRpeE5RVUZOTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkRNVUlzUjBGQlJ5eEZRVUZGTEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExHTkJRV01zUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU03WjBKQlF6TkVMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zWTBGQll6dG5Ra0ZETVVJc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFRRVUZUTEVkQlFVY3NSVUZCUlR0blFrRkRkRUlzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmRDUVVOU0xFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnp0aFFVTllMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMG9zVDBGQlR5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkROVUlzUTBGQlF6dExRVUZCTzBsQlIxa3NjVUpCUVhGQ0xFTkJRVU1zU1VGQllUczdXVUZETlVNc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRaUVVNMVF5eEpRVUZKTEVOQlFVTXNSMEZCYzBNc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJRenRwUWtGRGVrVXNTMEZCU3l4RFFVTkdMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zZDBKQlFXZENMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRek5DTEVOQlFVTTdXVUZEVGl4SlFVRkpMRWxCUVVrc1MwRkJTeXhEUVVGRExFVkJRVVU3WjBKQlExb3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1lVRkRhRVE3YVVKQlFVMHNTVUZCU1N4SlFVRkpMRXRCUVVzc1EwRkJReXhGUVVGRk8yZENRVU51UWl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhwUWtGQmFVSXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRoUVVOb1JEdFpRVVZFTEUxQlFVMHNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4RFFVRkRPMmxDUVVNM1F5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU5XTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRk8yZENRVU5vUWl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVkQlFVYzdaMEpCUTJoQ0xFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1IwRkJSenRoUVVOdVFpeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVVlNMRTlCUVU4c1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzFGQlF6VkNMRU5CUVVNN1MwRkJRVHRKUVVkWkxGbEJRVms3TzFsQlEzSkNMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeEZRVUZGTzJkQ1FVTjJRaXhOUVVGTkxGRkJRVkVzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRE8yZENRVU0xUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hIUVVGSExFVkJRVVVzUTBGQlF6dG5Ra0ZETVVJc1NVRkJTU3hEUVVGRExFZEJRWE5ETEVOQlFVTXNUVUZCVFN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNRMEZCUXp0blFrRkRMMFVzVFVGQlRTeE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEhkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzNGQ1FVTXpReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRmhPMjlDUVVOMFFpeEZRVUZGTEVWQlFVVXNVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zWTBGQll5eEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF6dHZRa0ZETVVRc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eGpRVUZqTzI5Q1FVTjBRaXh2UWtGQmIwSXNSVUZCUlN4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTzI5Q1FVTjZReXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVYzdiMEpCUTJJc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITzI5Q1FVTmlMRk5CUVZNc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV6dHBRa0ZEZUVJc1EwRkJRU3hEUVVGRExFTkJRVU03WjBKQlExSXNTVUZCU1N4RFFVRkRMR1ZCUVdVc1IwRkJhME1zVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZWtZc1NVRkJTU3hEUVVGRExGVkJRVlVzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVFN1lVRkRja003VVVGRFRDeERRVUZETzB0QlFVRTdTVUZEWVN4aFFVRmhMRU5CUVVNc1pVRkJaVHM3V1VGRGRrTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEZEVVc1EwRkJRenRMUVVGQk8wbEJSV0VzYTBKQlFXdENMRU5CUVVNc1pVRkJaVHM3V1VGRE5VTXNUVUZCVFN4SlFVRkpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFTkJRVU03V1VGRE1VSXNUVUZCVFN4UFFVRlBMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEdOQlFXTXNRMEZCUXp0WlFVTjZSQ3hOUVVGTkxGRkJRVkVzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRE8xbEJRelZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExITkNRVUZ6UWl4RFFVRkRPMWxCUXpGRExFbEJRVWtzUzBGQlN5eEhRVUZITEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eDNRa0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZET1VNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRVZCUXpGQ0xFTkJRVU1zU1VGQmNVSXNSVUZCUlN4RlFVRkZMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RlFVRkZMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RlFVTjJSaXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRVZCUTJZc1EwRkJReXhKUVVGeFFpeEZRVUZGTEVsQlFVa3NSVUZCUlN4RlFVRkZPMmRDUVVNMVFpeE5RVUZOTEdGQlFXRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF6dG5Ra0ZETDBVc1RVRkJUU3hoUVVGaExFZEJRVWNzU1VGQlNTeERRVUZETEc5Q1FVRnZRaXhEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXh2UWtGQmIwSXNSVUZCUlN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRE8yZENRVU5zU1N4SlFVRkpMR0ZCUVdFc1IwRkJSeXhKUVVGSkxFTkJRVU03WjBKQlEzcENMRWxCUVVrc1YwRkJWeXhIUVVGSExFbEJRVWtzUTBGQlF6dG5Ra0ZGZGtJc1NVRkJTU3hYUVVGWExFZEJRV1VzU1VGQlNTeERRVUZETzJkQ1FVTnVReXhKUVVGSkxHRkJRV0VzUzBGQlN5eEpRVUZKTEVWQlFVVTdiMEpCUTNoQ0xFbEJRVWtzWVVGQllTeEhRVUZITEVWQlFVVXNSVUZCUlR0M1FrRkRjRUlzWVVGQllTeEhRVUZITEU5QlFVOHNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenQzUWtGRGRrTXNWMEZCVnl4SFFVRkhMR0ZCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU03Y1VKQlEzQkRPM2xDUVVGTkxFbEJRVWtzWVVGQllTeExRVUZMTEVWQlFVVXNSVUZCUlR0M1FrRkROMElzVjBGQlZ5eEhRVUZITEVOQlFVTXNRMEZCUXp0eFFrRkRia0k3ZVVKQlFVMHNTVUZCU1N4aFFVRmhMRXRCUVVzc1JVRkJSU3hGUVVGRk8zZENRVU0zUWl4WFFVRlhMRWRCUVVjc1EwRkJReXhEUVVGRE8zRkNRVU51UWp0NVFrRkJUVHQzUWtGRFNDeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMSEZDUVVGeFFpeEZRVUZGTEdGQlFXRXNSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZCTzNGQ1FVTnlSVHRwUWtGRFNqdHhRa0ZCVFR0dlFrRkRTQ3hQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEd0Q1FVRnJRaXhGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVFN2FVSkJRMjVFTzJkQ1FVVkVMRWxCUVVrc1lVRkJZU3hKUVVGSkxFbEJRVWtzUlVGQlJUdHZRa0ZEZGtJc1YwRkJWeXhIUVVGSExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN2FVSkJRM0pFTzJkQ1FVVkVMRTFCUVUwc1kwRkJZeXhIUVVGSExFbEJRVWtzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEc5Q1FVRnZRaXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRPMmRDUVVONFJpeEpRVUZKTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRM1pDTEVsQlFVa3NVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJRenRuUWtGRmNrSXNTVUZCU1N4alFVRmpMRXRCUVVzc1NVRkJTU3hGUVVGRk8yOUNRVU42UWl4SlFVRkpMR05CUVdNc1IwRkJSeXhGUVVGRkxFVkJRVVU3ZDBKQlEzSkNMRmRCUVZjc1IwRkJSeXhQUVVGUExFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdkMEpCUTNSRExGTkJRVk1zUjBGQlJ5eFhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRPM0ZDUVVOb1F6dDVRa0ZCVFN4SlFVRkpMR05CUVdNc1MwRkJTeXhGUVVGRkxFVkJRVVU3ZDBKQlF6bENMRk5CUVZNc1IwRkJSeXhEUVVGRExFTkJRVU03Y1VKQlEycENPM2xDUVVGTkxFbEJRVWtzWTBGQll5eExRVUZMTEVWQlFVVXNSVUZCUlR0M1FrRkRPVUlzVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXp0eFFrRkRha0k3ZVVKQlFVMDdkMEpCUTBnc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5dzRRa0ZCT0VJc1JVRkJSU3hqUVVGakxFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRVHR4UWtGREwwVTdhVUpCUTBvN1owSkJRMFFzVDBGQmEwSXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhGUVVGRkxFVkJRVVVzU1VGQlNTeEZRVUZGTzI5Q1FVTjBReXhsUVVGbExFVkJRVVVzWVVGQllUdHZRa0ZET1VJc1kwRkJZeXhGUVVGRkxHRkJRV0U3YjBKQlF6ZENMR1ZCUVdVc1JVRkJSU3hYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWs3YjBKQlEzUkVMRmRCUVZjc1JVRkJSU3hYUVVGWE8yOUNRVU40UWl4VFFVRlRMRVZCUVVVc1UwRkJVenR2UWtGRGNFSXNZVUZCWVN4RlFVRkZMR05CUVdNN2IwSkJRemRDTEUxQlFVMHNSVUZCUlN4SlFVRkpMRU5CUVVNc1IwRkJSenR2UWtGRGFFSXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhIUVVGSE8yOUNRVU5vUWl4VFFVRlRMRVZCUVVVc1NVRkJTU3hEUVVGRExGTkJRVk03YVVKQlF6VkNMRU5CUVVNc1EwRkJRVHRaUVVOT0xFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExQXNTVUZCU1N4bFFVRmxMRVZCUVVVN1owSkJRMnBDTEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETzJGQlEzaERPMWxCUTBRc1QwRkJUeXhMUVVGTExFTkJRVU03VVVGRGFrSXNRMEZCUXp0TFFVRkJPMGxCUlU4c2JVSkJRVzFDTEVOQlFVTXNTVUZCWlN4RlFVRkZMRTFCUVhWQ08xRkJRMmhGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVN1dVRkRWQ3hQUVVGUExFbEJRVWtzUTBGQlF6dFRRVU5tTzFGQlEwUXNTVUZCU1N4TlFVRk5MRU5CUVVNc1pVRkJaU3hMUVVGTExFbEJRVWtzU1VGQlNTeEpRVUZKTEVOQlFVTXNaVUZCWlN4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVNM1JDeFBRVUZQTEV0QlFVc3NRMEZCUXp0VFFVTm9RanRSUVVORUxFbEJRVWtzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRExFbEJRVWtzVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZPMWxCUTNSSExFOUJRVThzUzBGQlN5eERRVUZETzFOQlEyaENPMUZCUTBRc1NVRkJTU3hKUVVGSkxFTkJRVU1zWlVGQlpTeExRVUZMTEdOQlFXTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1pVRkJaU3hMUVVGTExHVkJRV1VzU1VGQlNTeEpRVUZKTEVOQlFVTXNaVUZCWlN4TFFVRkxMR05CUVdNc1JVRkJSVHRaUVVOb1NTeEpRVUZKTEUxQlFVMHNRMEZCUXl4bFFVRmxMRXRCUVVzc1MwRkJTeXhGUVVGRk8yZENRVU5zUXl4UFFVRlBMRXRCUVVzc1EwRkJRenRoUVVOb1FqdFRRVU5LTzJGQlFVMDdXVUZEU0N4SlFVRkpMRTFCUVUwc1EwRkJReXhsUVVGbExFdEJRVXNzU1VGQlNTeEZRVUZGTzJkQ1FVTnFReXhQUVVGUExFdEJRVXNzUTBGQlF6dGhRVU5vUWp0VFFVTktPMUZCUTBRc1NVRkJTU3hOUVVGTkxFTkJRVU1zWVVGQllTeExRVUZMTEZOQlFWTXNSVUZCUlR0WlFVTndReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExFVkJRVVU3WjBKQlEzUkRMRTFCUVUwc1EwRkJReXhoUVVGaExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1lVRkRha1E3V1VGRFJDeEpRVUZKTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1JVRkJSVHRuUWtGRGRrUXNUMEZCVHl4TFFVRkxMRU5CUVVNN1lVRkRhRUk3VTBGRFNqdFJRVVZFTEVsQlFVY3NUVUZCVFN4RFFVRkRMRkZCUVZFc1MwRkJTeXhUUVVGVExFVkJRVU03V1VGRE4wSXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRkZPMmRDUVVOcVF5eE5RVUZOTEVOQlFVTXNVVUZCVVN4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzJGQlEzWkRPMWxCUTBRc1NVRkJTU3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVWQlFVVTdaMEpCUTJoRUxFOUJRVThzUzBGQlN5eERRVUZETzJGQlEyaENPMU5CUTBvN1VVRkZSQ3hKUVVGSExFMUJRVTBzUTBGQlF5eG5Ra0ZCWjBJc1MwRkJTeXhKUVVGSkxFbEJRVWtzU1VGQlNTeERRVUZETEdGQlFXRXNSMEZCUnl4RFFVRkRMRVZCUVVNN1dVRkRNVVFzVDBGQlR5eExRVUZMTEVOQlFVTTdVMEZEYUVJN1VVRkZSQ3hKUVVGSkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMR2RDUVVGblFpeERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMR2RDUVVGblFpeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVWQlFVVTdXVUZEZEVjc1QwRkJUeXhMUVVGTExFTkJRVU03VTBGRGFFSTdVVUZGUkN4UFFVRlBMRWxCUVVrc1EwRkJRenRKUVVOb1FpeERRVUZETzBsQlIxa3NaVUZCWlN4RFFVRkRMRTFCUVhkQ096dFpRVU5xUkN4UFFVRlBMRTFCUVUwc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETEVOQlFWa3NSVUZCUlN4RlFVRkZPMmRDUVVNM1F5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExHTkJRV01zU1VGQlNTeERRVUZETEVOQlFVTXNTVUZCU1N4TFFVRkxMR1ZCUVdVc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEdOQlFXTXNRMEZCUXl4RlFVRkZPMjlDUVVONlJpeFBRVUZQTEV0QlFVc3NRMEZCUXp0cFFrRkRhRUk3WjBKQlEwUXNUMEZCVHl4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNRMEZCUXl4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJReTlETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTFBc1EwRkJRenRMUVVGQk8wbEJSMWtzWTBGQll6czdXVUZEZGtJc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU03V1VGRGJrUXNUVUZCVFN4RFFVRkRMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1EwRkJReXhEUVVGWkxFVkJRVVVzUlVGQlJTeERRVU55UkN4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExGbEJRVms3WjBKQlEzWkNMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzYlVKQlFXMUNMRU5CUTJwRExFTkJRVU03V1VGRFJpeE5RVUZOTEU5QlFVOHNSMEZCUnl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTzJkQ1FVTXhRaXhKUVVGSkxFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NXVUZCV1N4RlFVRkZPMjlDUVVONlFpeFBRVUZQTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNN2QwSkJRMnhDTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUVHQzUWtGRFdDeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwN2QwSkJRMWdzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4VFFVRlRPM2RDUVVOcVFpeFBRVUZQTEVWQlFVVXNRMEZCUXl4RFFVRkRMRzlDUVVGdlFqdHhRa0ZEYkVNc1EwRkJReXhEUVVGRE8ybENRVU5PTzJkQ1FVTkVMRTlCUVU4c1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF6dHZRa0ZEYkVJc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTzI5Q1FVTllMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRUdHZRa0ZEV0N4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRExGTkJRVk03YjBKQlEycENMRTlCUVU4c1JVRkJSU3hEUVVGRExFTkJRVU1zYjBKQlFXOUNPMmxDUVVOc1F5eERRVUZETEVOQlFVTTdXVUZEVUN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3WjBKQlEyeENMRTFCUVUwc1MwRkJTeXhIUVVGSExFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXp0blFrRkRlRUlzVFVGQlRTeFBRVUZQTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8yZENRVU42UWl4TlFVRk5MRXRCUVVzc1IwRkJSenR2UWtGRFZpeEpRVUZKTEVWQlFVVXNUMEZCVHp0dlFrRkRZaXhEUVVGRExFVkJRVVVzUzBGQlN5eERRVUZETEUxQlFVMDdiMEpCUTJZc1EwRkJReXhGUVVGRkxFdEJRVXNzUTBGQlF5eE5RVUZOTzI5Q1FVTm1MRk5CUVZNc1JVRkJSU3hMUVVGTExFTkJRVU1zVTBGQlV6dHZRa0ZETVVJc1UwRkJVeXhGUVVGRkxFOUJRVThzUTBGQlF5eFRRVUZUTzI5Q1FVTTFRaXhaUVVGWkxFVkJRVVVzUTBGQlF5eFBRVUZQTEVOQlFVTXNVMEZCVXl4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zUjBGQlJ5eEZRVUZGTzI5Q1FVTjRSQ3hwUWtGQmFVSXNSVUZCUlN4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFZEJRVWNzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXp0dlFrRkRlRVFzVDBGQlR5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1IwRkJSeXhEUVVGRE8yOUNRVU4wUWl4TlFVRk5MRVZCUVVVc1QwRkJUeXhEUVVGRExHOUNRVUZ2UWl4TFFVRkxMRTlCUVU4c1EwRkJReXhsUVVGbE8yOUNRVU5vUlN4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExHVkJRV1VzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHBRa0ZETDBNc1EwRkJRVHRuUWtGRFJDeFBRVUZQTEV0QlFVc3NRMEZCUXp0WlFVTnFRaXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVZJTEUxQlFVMHNUMEZCVHl4SFFVRkhMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4M1FrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1YwRkJWeXhMUVVGTExHOUNRVUZ2UWl4RFFVRkRPMmxDUVVNM1JpeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRnJRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzJkQ1FVTTNRaXhKUVVGSkxFVkJRVVVzVVVGQlVUdG5Ra0ZEWkN4VFFVRlRMRVZCUVVVc1EwRkJReXhEUVVGRExGTkJRVk03WjBKQlEzUkNMRkZCUVZFc1JVRkJSU3h4UWtGQllTeERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRVZCUVVVc1ZVRkJWU3hEUVVGRE8yRkJRMjVFTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUjFJc1RVRkJUU3hOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWRCUVVjc1QwRkJUeXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZGTEVkQlFVY3NUMEZCVHl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1dVRkZNMGNzVDBGQlR5eE5RVUZOTEVOQlFVTTdVVUZEYkVJc1EwRkJRenRMUVVGQk8wbEJSMWtzY1VKQlFYRkNMRU5CUVVNc1RVRkJkMEk3TzFsQlEzWkVMRTFCUVUwc1dVRkJXU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtVc1RVRkJUU3hOUVVGTkxFZEJRVWNzV1VGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEUxQlFVMHNTVUZCU1N4RFFVRkRMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU03YVVKQlF6bEVMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdaMEpCUTFZc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFVVTdaMEpCUTJoQ0xFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1RVRkJUVHRuUWtGRGJrSXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eE5RVUZOTzJGQlEzUkNMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJSVklzVDBGQlR5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkROVUlzUTBGQlF6dExRVUZCTzBsQlNWa3NiVUpCUVcxQ096dFpRVU0xUWl4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJRenRaUVVWdVJDeEpRVUZKTEV0QlFVc3NSMEZCUnl4UlFVRlJPMmxDUVVObUxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMSGRDUVVGblFpeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhqUVVGakxFdEJRVXNzVjBGQlZ5eERRVUZETzJsQ1FVTnVSU3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZyUWl4RlFVRlhMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU4wUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWM3WjBKQlExSXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSE8yZENRVU5TTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoRExFbEJRVWtzUlVGQlJTeE5RVUZOTzJGQlEyWXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZVaXhKUVVGSkxFdEJRVXNzUjBGQlJ5eFJRVUZSTzJsQ1FVTm1MRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEhkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4alFVRmpMRU5CUVVNc1ZVRkJWU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETzJsQ1FVTTVSU3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZyUWl4RlFVRlhMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU4wUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWM3WjBKQlExSXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSE8yZENRVU5TTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoRExFbEJRVWtzUlVGQlJTeFZRVUZWTzJGQlEyNUNMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJSVklzU1VGQlNTeE5RVUZOTEVkQlFVY3NVVUZCVVR0cFFrRkRhRUlzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc2QwSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExHTkJRV01zUTBGQlF5eFZRVUZWTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU1zUTBGQlF6dHBRa0ZEYWtZc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQmEwSXNSVUZCVnl4RlFVRkZMRU5CUVVNc1EwRkJRenRuUWtGRGRFTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSE8yZENRVU5TTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSenRuUWtGRFVpeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2xDUVVGcFFpeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjRReXhKUVVGSkxFVkJRVVVzVDBGQlR6dGhRVU5vUWl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVWU0xFbEJRVWtzUzBGQlN5eEhRVUZITEZGQlFWRTdhVUpCUTJZc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNkMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMR05CUVdNc1EwRkJReXhWUVVGVkxFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdhVUpCUXpsRkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFXdENMRVZCUVZjc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlEzUkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ6dG5Ra0ZEVWl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWM3WjBKQlExSXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhwUWtGQmFVSXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRlRU1zU1VGQlNTeEZRVUZGTEUxQlFVMDdZVUZEWml4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVWU0xFbEJRVWtzVjBGQlZ5eEhRVUZITEZGQlFWRTdhVUpCUTNKQ0xFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMSGRDUVVGblFpeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhqUVVGakxFTkJRVU1zVVVGQlVTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRPMmxDUVVNeFJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRnJRaXhGUVVGWExFVkJRVVVzUTBGQlF5eERRVUZETzJkQ1FVTjBReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVYzdaMEpCUTFJc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITzJkQ1FVTlNMRWxCUVVrc1JVRkJSU3hEUVVGRE8yZENRVU5RTEVsQlFVa3NSVUZCUlN4WlFVRlpPMkZCUTNKQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFsQlJWSXNTVUZCU1N4TFFVRkxMRWRCUVVjc1VVRkJVVHRwUWtGRFppeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXgzUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zVjBGQlZ5eExRVUZMTEdkQ1FVRm5RaXhEUVVGRE8ybENRVU55UlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGclFpeEZRVUZYTEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOMFF5eERRVUZETEVWQlFVVXNjVUpCUVdFc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEZkQlFWY3NSVUZCUlN4SlFVRkpMRU5CUVVNN1owSkJRMnhFTEVOQlFVTXNSVUZCUlN4eFFrRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNWMEZCVnl4RlFVRkZMRWxCUVVrc1EwRkJRenRuUWtGRGJFUXNTVUZCU1N4RlFVRkZMRU5CUVVNN1owSkJRMUFzU1VGQlNTeEZRVUZGTEZsQlFWazdZVUZEY2tJc1EwRkJReXhEUVVGRExFTkJRVU03V1VGSFVpeE5RVUZOTEdWQlFXVXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhyUWtGQmEwSXNSVUZCUlN4RFFVRkRPMWxCUlhoRUxFOUJRVThzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFhRVUZYTEVWQlFVVXNTMEZCU3l4RlFVRkZMRWRCUVVjc1pVRkJaU3hEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZETDBZc1EwRkJRenRMUVVGQk8wbEJSV0VzYTBKQlFXdENPenRaUVVNMVFpeE5RVUZOTEU5QlFVOHNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU03V1VGRGJrTXNVVUZCVVN4UFFVRlBMRVZCUVVVN1owSkJRMklzUzBGQlN5eDVRa0ZCZVVJN2IwSkJRekZDTEU5QlFVOHNUVUZCVFN4SlFVRkpMRU5CUVVNc05FSkJRVFJDTEVWQlFVVXNRMEZCUXp0blFrRkRja1FzUzBGQlN5eHRRa0ZCYlVJN2IwSkJRM0JDTEU5QlFVOHNUVUZCVFN4SlFVRkpMRU5CUVVNc2NVSkJRWEZDTEVWQlFVVXNRMEZCUXp0blFrRkRPVU1zUzBGQlN5eGxRVUZsTzI5Q1FVTm9RaXhQUVVGUExFMUJRVTBzU1VGQlNTeERRVUZETEcxQ1FVRnRRaXhGUVVGRkxFTkJRVU03WjBKQlF6VkRMRXRCUVVzc1pVRkJaVHR2UWtGRGFFSXNUMEZCVHl4TlFVRk5MRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNSVUZCUlN4RFFVRkRPMkZCUXk5RE8xbEJRMFFzVDBGQlR5eEZRVUZGTEVOQlFVTTdVVUZEWkN4RFFVRkRPMHRCUVVFN1NVRkZZU3cwUWtGQk5FSTdPMWxCUTNSRExFMUJRVTBzVFVGQlRTeEhRVUZuUXl4RlFVRkZMRU5CUVVNN1dVRkRMME1zVFVGQlRTeFJRVUZSTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTTdXVUZEYmtRc1NVRkJTU3hUUVVGVExFZEJRVWNzVVVGQlVUdHBRa0ZEYmtJc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNkMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1kwRkJZeXhMUVVGTExHOUNRVUZ2UWl4SlFVRkpMRU5CUVVNc1EwRkJReXhqUVVGakxFdEJRVXNzYTBKQlFXdENMRU5CUVVNc1EwRkJRenRwUWtGRGVrZ3NVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJhMElzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhKUVVGSkxFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXp0cFFrRkRkRVFzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCYTBJc1JVRkJWeXhGUVVGRkxFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITzJkQ1FVTlNMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ6dG5Ra0ZEVWl4SlFVRkpMRVZCUVVVc1EwRkJRenRuUWtGRFVDeEpRVUZKTEVWQlFVVXNZMEZCWXp0aFFVTjJRaXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5TTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU03V1VGRGRrSXNUMEZCVHl4TlFVRk5MRU5CUVVNN1VVRkRiRUlzUTBGQlF6dExRVUZCTzBsQlJXRXNjVUpCUVhGQ096dFpRVU12UWl4TlFVRk5MRTFCUVUwc1IwRkJaME1zUlVGQlJTeERRVUZETzFsQlF5OURMRTFCUVUwc1VVRkJVU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEhOQ1FVRnpRaXhEUVVGRE8xbEJRMjVFTEVsQlFVa3NUVUZCVFN4SFFVRkhMRkZCUVZFN2FVSkJRMmhDTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExIZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEdOQlFXTXNTMEZCU3l4dlFrRkJiMElzUTBGQlF5eERRVUZETzJsQ1FVTTVSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZyUWl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVsQlFVa3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRE8ybENRVU4wUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGclFpeEZRVUZYTEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOMFF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjN1owSkJRMUlzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmRDUVVOU0xFbEJRVWtzUlVGQlJTeERRVUZETzJkQ1FVTlFMRWxCUVVrc1JVRkJSU3h0UWtGQmJVSTdZVUZETlVJc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFVpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJSWEJDTEVsQlFVa3NUVUZCVFN4SFFVRkhMRkZCUVZFN2FVSkJRMmhDTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExIZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEdOQlFXTXNTMEZCU3l4cFFrRkJhVUlzUTBGQlF5eERRVUZETzJsQ1FVTXpSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZyUWl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVsQlFVa3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRE8ybENRVU4wUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGclFpeEZRVUZYTEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOMFF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjN1owSkJRMUlzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmRDUVVOU0xFbEJRVWtzUlVGQlJTeERRVUZETzJkQ1FVTlFMRWxCUVVrc1JVRkJSU3huUWtGQlowSTdZVUZEZWtJc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFVpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJSWEJDTEU5QlFVOHNUVUZCVFN4RFFVRkRPMUZCUTJ4Q0xFTkJRVU03UzBGQlFUdEpRVVZoTEcxQ1FVRnRRanM3V1VGRE4wSXNUVUZCVFN4TlFVRk5MRWRCUVdkRExFVkJRVVVzUTBGQlF6dFpRVU12UXl4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJRenRaUVVOdVJDeEpRVUZKTEVsQlFVa3NSMEZCUnl4UlFVRlJPMmxDUVVOa0xFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMSGRDUVVGblFpeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExHTkJRV01zUzBGQlN5eHJRa0ZCYTBJc1EwRkJReXhEUVVGRE8ybENRVU0xUlN4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGclFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFbEJRVWtzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRPMmxDUVVOMFJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRnJRaXhGUVVGWExFVkJRVVVzUTBGQlF5eERRVUZETzJkQ1FVTjBReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVYzdaMEpCUTFJc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITzJkQ1FVTlNMRWxCUVVrc1JVRkJSU3hEUVVGRE8yZENRVU5RTEVsQlFVa3NSVUZCUlN4WlFVRlpPMkZCUTNKQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5zUWl4UFFVRlBMRTFCUVUwc1EwRkJRenRSUVVOc1FpeERRVUZETzB0QlFVRTdTVUZEWVN4dFFrRkJiVUk3TzFsQlF6ZENMRTFCUVUwc1RVRkJUU3hIUVVGblF5eEZRVUZGTEVOQlFVTTdXVUZETDBNc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU03V1VGRGJrUXNTVUZCU1N4aFFVRmhMRWRCUVVjc1VVRkJVVHRwUWtGRGRrSXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zZDBKQlFXZENMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNZMEZCWXl4TFFVRkxMR2RDUVVGblFpeEpRVUZKTEVOQlFVTXNRMEZCUXl4alFVRmpMRXRCUVVzc1kwRkJZeXhEUVVGRExFTkJRVU03YVVKQlEycElMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRV3RDTEVWQlFWY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRM1JETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSenRuUWtGRFVpeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjN1owSkJRMUlzU1VGQlNTeEZRVUZGTEVOQlFVTTdaMEpCUTFBc1NVRkJTU3hGUVVGRkxHbENRVUZwUWp0aFFVTXhRaXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5TTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03V1VGRk0wSXNTVUZCU1N4alFVRmpMRWRCUVVjc1VVRkJVVHRwUWtGRGVFSXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zZDBKQlFXZENMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNZMEZCWXl4TFFVRkxMR2RDUVVGblFpeERRVUZETEVOQlFVTTdhVUpCUXpGRkxGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFXdENMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eGpRVUZqTEVOQlFVTTdhVUpCUTJ4RUxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFXdENMRVZCUVZjc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlEzUkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ6dG5Ra0ZEVWl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWM3WjBKQlExSXNTVUZCU1N4RlFVRkZMRU5CUVVNN1owSkJRMUFzU1VGQlNTeEZRVUZGTEcxQ1FVRnRRanRoUVVNMVFpeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTlNMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdXVUZGTlVJc1NVRkJTU3h2UWtGQmIwSXNSMEZCUnl4UlFVRlJPMmxDUVVNNVFpeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXgzUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eGpRVUZqTEV0QlFVc3NkMEpCUVhkQ0xFTkJRVU1zUTBGQlF6dHBRa0ZEYkVZc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQmEwSXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEpRVUZKTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJRenRwUWtGRGRFUXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJhMElzUlVGQlZ5eEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkRkRU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmRDUVVOU0xFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnp0blFrRkRVaXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETEdsQ1FVRnBRaXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU40UXl4SlFVRkpMRVZCUVVVc2JVSkJRVzFDTzJGQlF6VkNMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMUlzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eERRVUZETzFsQlEyeERMRTlCUVU4c1RVRkJUU3hEUVVGRE8xRkJRMnhDTEVOQlFVTTdTMEZCUVR0SlFVZFpMR2xDUVVGcFFqczdXVUZGTVVJc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU03V1VGRGJrUXNTVUZCU1N4TFFVRkxMRWRCUVVjc1VVRkJVVHRwUWtGRFppeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXgzUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zWTBGQll5eExRVUZMTEZkQlFWY3NRMEZCUXp0cFFrRkRia1VzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCYTBJc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dG5Ra0ZETjBJc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITzJkQ1FVTlNMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ6dG5Ra0ZEVWl4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRExHbENRVUZwUWl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMkZCUXpORExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMWxCUld4Q0xFbEJRVWtzUzBGQlN5eEhRVUZITEZGQlFWRTdhVUpCUTJZc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNkMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMR05CUVdNc1EwRkJReXhWUVVGVkxFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTTdhVUpCUXpsRkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFXdENMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlF6ZENMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ6dG5Ra0ZEVWl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWM3WjBKQlExSXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhwUWtGQmFVSXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0aFFVTXpReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVVnNRaXhKUVVGSkxFMUJRVTBzUjBGQlJ5eFJRVUZSTzJsQ1FVTm9RaXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4M1FrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1kwRkJZeXhEUVVGRExGVkJRVlVzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8ybENRVU5xUml4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGclFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVNM1FpeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjN1owSkJRMUlzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmRDUVVOU0xFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNhVUpCUVdsQ0xFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRE0wTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU03V1VGSGJFSXNTVUZCU1N4TFFVRkxMRWRCUVVjc1VVRkJVVHRwUWtGRFppeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXgzUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zWTBGQll5eERRVUZETEZWQlFWVXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJRenRwUWtGRE9VVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJhMElzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkROMElzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhPMmRDUVVOU0xFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnp0blFrRkRVaXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETEdsQ1FVRnBRaXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yRkJRek5ETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8xbEJSV3hDTEU5QlFVODdaMEpCUTBnc1MwRkJTenRuUWtGRFRDeExRVUZMTzJkQ1FVTk1MRTFCUVUwN1owSkJRMDRzUzBGQlN6dGhRVU5TTEVOQlFVTTdVVUZEVGl4RFFVRkRPMHRCUVVFN1EwRkRTaXhEUVVGQk8wRkJjR2hDUnp0SlFVUkRMSGRDUVVGWExFVkJRVVU3T3p0blJFRk5ZanRCUVVsRU8wbEJSRU1zZDBKQlFWY3NSVUZCUlRzN08yZEVRVlZpTzBGQlIwUTdTVUZFUXl4M1FrRkJWeXhGUVVGRk96czdjMFJCVTJJN1FVRkhSRHRKUVVSRExIZENRVUZYTEVWQlFVVTdPenM3ZDBSQmNVSmlPMEZCUjBRN1NVRkVReXgzUWtGQlZ5eEZRVUZGT3pzN08zTkVRV2xDWWp0QlFVZEVPMGxCUkVNc2QwSkJRVmNzUlVGQlJUczdPenM0UkVGeFFtSTdRVUVyU1VRN1NVRkVReXgzUWtGQlZ5eEZRVUZGT3pzN08zZEVRVkZpTzBGQlIwUTdTVUZFUXl4M1FrRkJWeXhGUVVGRk96czdPM1ZFUVcxRVlqdEJRVWRFTzBsQlJFTXNkMEpCUVZjc1JVRkJSVHM3T3pzNFJFRlhZanRCUVVsRU8wbEJSRU1zZDBKQlFWY3NSVUZCUlRzN096czBSRUU0UkdJN1FVRnJTRVE3U1VGRVF5eDNRa0ZCVnl4RlFVRkZPenM3T3pCRVFUSkRZanRCUVc1cFFsRXNhVUpCUVdsQ08wbEJSRGRDTEd0RFFVRnhRaXhEUVVGRExITkRRVUZ6UXl4RFFVRkRPM0ZEUVUwdlFpeGxRVUZOTzBkQlRIaENMR2xDUVVGcFFpeERRVzlwUWpkQ08wRkJjR2xDV1N3NFEwRkJhVUlpZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi4vLi4vZGVjb3JhdG9yc1wiKTtcclxuY29uc3QgUmVwbGF5XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVwbGF5XCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xyXG5jb25zdCBsaW5xID0gcmVxdWlyZShcImxpbnFcIik7XHJcbmNvbnN0IEJhc2ljUmVwbGF5QW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2ljUmVwbGF5QW5hbHlzZXJcIik7XHJcbmNvbnN0IEFic3RyYWN0UmVwbGF5QW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdFJlcGxheUFuYWx5c2VyXCIpO1xyXG5jb25zdCBkZWNvcmF0b3JzXzIgPSByZXF1aXJlKFwiLi4vZGVjb3JhdG9yc1wiKTtcclxubGV0IFNjb3JlQW5hbHlzZXIgPSBjbGFzcyBTY29yZUFuYWx5c2VyIGV4dGVuZHMgQWJzdHJhY3RSZXBsYXlBbmFseXNlcl8xLkFic3RyYWN0UmVwbGF5QW5hbHlzZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVwbGF5KSB7XHJcbiAgICAgICAgc3VwZXIocmVwbGF5KTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gbmFtZSA9PiBzdXBlcltuYW1lXTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCBfc3VwZXIoXCJpbml0aWFsaXplXCIpLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzaWNSZXBsYXlBbmFseXNlciA9IG5ldyBCYXNpY1JlcGxheUFuYWx5c2VyXzEuQmFzaWNSZXBsYXlBbmFseXNlcih0aGlzLnJlcGxheSk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYmFzaWNSZXBsYXlBbmFseXNlci5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2NvcmVTY3JlZW5EYXRhKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJTY29yZXMgPSB5aWVsZCB0aGlzLnBsYXllclNjb3Jlc1NpbXBsZTtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVyU2NvcmVzUSA9IGxpbnEuZnJvbShwbGF5ZXJTY29yZXMpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZWFtMUtpbGxzID0gcGxheWVyU2NvcmVzUS53aGVyZShfID0+IF8udGVhbSA9PT0gMSkuc3VtKF8gPT4gXy5zdGF0cy5EZWF0aHMpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZWFtMktpbGxzID0gcGxheWVyU2NvcmVzUS53aGVyZShfID0+IF8udGVhbSA9PT0gMCkuc3VtKF8gPT4gXy5zdGF0cy5EZWF0aHMpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZWFtMUxldmVsID0gcGxheWVyU2NvcmVzUS5maXJzdChfID0+IF8udGVhbSA9PT0gMCkuc3RhdHMuVGVhbUxldmVsO1xyXG4gICAgICAgICAgICBjb25zdCB0ZWFtMkxldmVsID0gcGxheWVyU2NvcmVzUS5maXJzdChfID0+IF8udGVhbSA9PT0gMSkuc3RhdHMuVGVhbUxldmVsO1xyXG4gICAgICAgICAgICBjb25zdCB3aW5uaW5nVGVhbSA9IHBsYXllclNjb3Jlc1EuZmlyc3QoXyA9PiBfLnRlYW0gPT09IDApLndvbiA/IDAgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBzY29yZURhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICB3aW5uaW5nVGVhbSxcclxuICAgICAgICAgICAgICAgIHRlYW0xS2lsbHMsXHJcbiAgICAgICAgICAgICAgICB0ZWFtMktpbGxzLFxyXG4gICAgICAgICAgICAgICAgdGVhbTFMZXZlbCxcclxuICAgICAgICAgICAgICAgIHRlYW0yTGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBwbGF5ZXJTY29yZXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3JlRGF0YTtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxuICAgIGdldCBwbGF5ZXJTY29yZXNTaW1wbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZXJRdWVyaWFibGUgPSB5aWVsZCB0aGlzLnRyYWNrZXJFdmVudHNRdWVyaWFibGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYXllcnMgPSB5aWVsZCB0aGlzLmJhc2ljUmVwbGF5QW5hbHlzZXIucGxheWVyTGlzdDtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVyc1EgPSBsaW5xLmZyb20ocGxheWVycyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0cmFja2VyUXVlcmlhYmxlLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NTY29yZVJlc3VsdEV2ZW50KGUpKS5sYXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjb3JlU3RhdHMgPSBbXHJcbiAgICAgICAgICAgICAgICBcIlRha2Vkb3duc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJEZWF0aHNcIixcclxuICAgICAgICAgICAgICAgIFwiU29sb0tpbGxcIixcclxuICAgICAgICAgICAgICAgIFwiQXNzaXN0c1wiLFxyXG4gICAgICAgICAgICAgICAgXCJFeHBlcmllbmNlQ29udHJpYnV0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBcIkhlYWxpbmdcIixcclxuICAgICAgICAgICAgICAgIFwiU2llZ2VEYW1hZ2VcIixcclxuICAgICAgICAgICAgICAgIFwiSGVyb0RhbWFnZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJEYW1hZ2VUYWtlblwiLFxyXG4gICAgICAgICAgICAgICAgXCJUZWFtTGV2ZWxcIlxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGxpbnEuZnJvbShyZXN1bHRzLm1faW5zdGFuY2VMaXN0KVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gc2NvcmVTdGF0cy5pbmRleE9mKGUubV9uYW1lKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xyXG4gICAgICAgICAgICBjb25zdCBhd2FyZHMgPSBsaW5xLmZyb20ocmVzdWx0cy5tX2luc3RhbmNlTGlzdClcclxuICAgICAgICAgICAgICAgIC53aGVyZShlID0+IGUubV9uYW1lLnN0YXJ0c1dpdGgoJ0VuZE9mTWF0Y2hBd2FyZCcpKVxyXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVyU2NvcmVzID0gcGxheWVyc1Euc2VsZWN0KF8gPT4gKHtcclxuICAgICAgICAgICAgICAgIHNsb3Q6IF8uc2xvdCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IF8ubmFtZSxcclxuICAgICAgICAgICAgICAgIHRlYW06IF8udGVhbSxcclxuICAgICAgICAgICAgICAgIGhlcm86IF8uaGVybyxcclxuICAgICAgICAgICAgICAgIHdvbjogXy53b24sXHJcbiAgICAgICAgICAgICAgICBoYXNDaGF0U2lsZW5jZTogXy5oYXNDaGF0U2lsZW5jZSxcclxuICAgICAgICAgICAgICAgIGhhc1ZvaWNlU2lsZW5jZTogXy5oYXNWb2ljZVNpbGVuY2UsXHJcbiAgICAgICAgICAgICAgICBzdGF0czoge30sXHJcbiAgICAgICAgICAgICAgICBhd2FyZHM6IFtdXHJcbiAgICAgICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYXllclNjb3Jlc1EgPSBsaW5xLmZyb20ocGxheWVyU2NvcmVzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdCA9IHN0YXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdE5hbWUgPSBzdGF0Lm1fbmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRRID0gbGlucS5mcm9tKHN0YXQubV92YWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgoXywgaSkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90OiBpLCB2YWx1ZTogXy5sZW5ndGggPyBfWzBdLm1fdmFsdWUgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShfID0+IF8udmFsdWUgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKHBsYXllclNjb3Jlc1EsIChzKSA9PiBzLnNsb3QsIHAgPT4gcC5zbG90LCAocywgcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuc3RhdHNbc3RhdE5hbWVdID0gcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgICAgIH0pLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF3YXJkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXdhcmQgPSBhd2FyZHNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhd2FyZE5hbWUgPSBhd2FyZC5tX25hbWUuc3Vic3RyaW5nKDAsIGF3YXJkLm1fbmFtZS5sZW5ndGggLSA3KS5zdWJzdHJpbmcoMTUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdFEgPSBsaW5xLmZyb20oYXdhcmQubV92YWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgoXywgaSkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90OiBpLCB2YWx1ZTogXy5sZW5ndGggPyBfWzBdLm1fdmFsdWUgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShfID0+IF8udmFsdWUgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKHBsYXllclNjb3Jlc1EsIChzKSA9PiBzLnNsb3QsIHAgPT4gcC5zbG90LCAocywgcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnZhbHVlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuYXdhcmRzLnB1c2goYXdhcmROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICB9KS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdG1wID0geWllbGQgdGhpcy5wbGF5ZXJTY29yZXNGdWxsO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGxheWVyU2NvcmVzRnVsbCcsIHRtcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXJTY29yZXM7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGxheWVyU2NvcmVzRnVsbCgpIHtcclxuICAgICAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2tlclF1ZXJpYWJsZSA9IHlpZWxkIHRoaXMudHJhY2tlckV2ZW50c1F1ZXJpYWJsZTtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVycyA9IHlpZWxkIHRoaXMuYmFzaWNSZXBsYXlBbmFseXNlci5wbGF5ZXJMaXN0O1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHRyYWNrZXJRdWVyaWFibGUud2hlcmUoXyA9PiB0eXBlc18xLmlzU1Njb3JlUmVzdWx0RXZlbnQoXykpLmxhc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVyU3RhdHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSBwbGF5ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxheWVyU2NvcmUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGxheWVyLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVybzogcGxheWVyLmhlcm8sXHJcbiAgICAgICAgICAgICAgICAgICAgdGVhbTogcGxheWVyLnRlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgd29uOiBwbGF5ZXIud29uLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NoYXRTaWxlbmNlOiBwbGF5ZXIuaGFzQ2hhdFNpbGVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVm9pY2VTaWxlbmNlOiBwbGF5ZXIuaGFzVm9pY2VTaWxlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzOiB7fVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdHMubV9pbnN0YW5jZUxpc3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ID0gc3RhdHMubV9pbnN0YW5jZUxpc3Rbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0Lm1fbmFtZS5lbmRzV2l0aCgnQm9vbGVhbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFzdGF0Lm1fbmFtZS5lbmRzV2l0aCgnVGFsZW50JykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXN0YXQubV9uYW1lLnN0YXJ0c1dpdGgoJ1BsYXlzJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXN0YXQubV9uYW1lLnN0YXJ0c1dpdGgoJ1dpbnMnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhc3RhdC5tX25hbWUuc3RhcnRzV2l0aCgnVGVhbVdpbnMnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhc3RhdC5tX25hbWUuZW5kc1dpdGgoJ0xldmVsJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5tX25hbWUgIT09ICdSb2xlJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0Lm1fbmFtZSAhPT0gJ0dhbWVTY29yZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcFN0YXRzID0gc3RhdC5tX3ZhbHVlc1twbGF5ZXIuc2xvdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBTdGF0cykgJiYgcFN0YXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcFN0YXQgPSBwU3RhdHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJTY29yZS5zdGF0c1tzdGF0Lm1fbmFtZV0gPSBwU3RhdC5tX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGxheWVyU3RhdHMucHVzaChwbGF5ZXJTY29yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGxheWVyU3RhdHNRID0gbGlucS5mcm9tKHBsYXllclN0YXRzKTtcclxuICAgICAgICAgICAgY29uc3QgdGVhbVRha2Vkb3ducyA9IFtcclxuICAgICAgICAgICAgICAgIHBsYXllclN0YXRzUS53aGVyZShfID0+IF8udGVhbSA9PT0gMSkuc3VtKF8gPT4gXy5zdGF0cy5EZWF0aHMpLFxyXG4gICAgICAgICAgICAgICAgcGxheWVyU3RhdHNRLndoZXJlKF8gPT4gXy50ZWFtID09PSAwKS5zdW0oXyA9PiBfLnN0YXRzLkRlYXRocylcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgdGVhbURhbWFnZVRha2VuID0gW1xyXG4gICAgICAgICAgICAgICAgcGxheWVyU3RhdHNRLndoZXJlKF8gPT4gXy50ZWFtID09PSAwKS5zdW0oXyA9PiBfLnN0YXRzLkRhbWFnZVRha2VuKSxcclxuICAgICAgICAgICAgICAgIHBsYXllclN0YXRzUS53aGVyZShfID0+IF8udGVhbSA9PT0gMSkuc3VtKF8gPT4gXy5zdGF0cy5EYW1hZ2VUYWtlbiksXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRlYW1IZXJvRGFtYWdlQWdhaW5zdCA9IFtcclxuICAgICAgICAgICAgICAgIHBsYXllclN0YXRzUS53aGVyZShfID0+IF8udGVhbSA9PT0gMSkuc3VtKF8gPT4gXy5zdGF0cy5IZXJvRGFtYWdlKSxcclxuICAgICAgICAgICAgICAgIHBsYXllclN0YXRzUS53aGVyZShfID0+IF8udGVhbSA9PT0gMCkuc3VtKF8gPT4gXy5zdGF0cy5IZXJvRGFtYWdlKSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXJTdGF0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxheWVyID0gcGxheWVyU3RhdHNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwU3RhdHMgPSBwbGF5ZXIuc3RhdHM7XHJcbiAgICAgICAgICAgICAgICBwU3RhdHNbJ0tpbGxQYXJ0aWNpcGF0aW9uJ10gPSBwU3RhdHMuVGFrZWRvd25zIC8gdGVhbVRha2Vkb3duc1twbGF5ZXIudGVhbV07XHJcbiAgICAgICAgICAgICAgICBwU3RhdHNbJ0F2ZXJhZ2VEYW1hZ2VUYWtlblBlckxpZmUnXSA9IHBTdGF0cy5EYW1hZ2VUYWtlbiAvIChwU3RhdHMuRGVhdGhzICsgMSk7XHJcbiAgICAgICAgICAgICAgICBwU3RhdHNbJ0tEQVJhdGlvJ10gPSBwU3RhdHMuVGFrZWRvd25zIC8gKHBTdGF0cy5EZWF0aHMgKyAxKTtcclxuICAgICAgICAgICAgICAgIHBTdGF0c1snS0RSYXRpbyddID0gcFN0YXRzLlNvbG9LaWxsIC8gKHBTdGF0cy5EZWF0aHMgKyAxKTtcclxuICAgICAgICAgICAgICAgIHBTdGF0c1snQURSYXRpbyddID0gcFN0YXRzLkFzc2lzdHMgLyAocFN0YXRzLkRlYXRocyArIDEpO1xyXG4gICAgICAgICAgICAgICAgcFN0YXRzWydQZXJjZW50RGFtYWdlSGVhbGVkJ10gPSBwU3RhdHMuSGVhbGluZyAvICh0ZWFtRGFtYWdlVGFrZW5bcGxheWVyLnRlYW1dIHx8IDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1hdGNoZXMoJzw2MzUwNycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFN0YXRzWydQZXJjZW50RGFtYWdlSGVhbGVkJ10gPSBwU3RhdHMuSGVhbGluZyAvICh0ZWFtSGVyb0RhbWFnZUFnYWluc3RbcGxheWVyLnRlYW1dIHx8IDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXJTdGF0cztcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIGRlY29yYXRvcnNfMi5SZXF1aXJlZFJlcGxheVZlcnNpb24oNDAzMzYsICdTY29yZXNjcmVlbiBEYXRhIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHJlcGxheScpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFByb21pc2UpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG5dLCBTY29yZUFuYWx5c2VyLnByb3RvdHlwZSwgXCJzY29yZVNjcmVlbkRhdGFcIiwgbnVsbCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJ1bk9uV29ya2VyKCksXHJcbiAgICBkZWNvcmF0b3JzXzIuUmVxdWlyZWRSZXBsYXlWZXJzaW9uKDQwMzM2LCAnUGxheWVyIHNjb3JlIGRhdGEgbm90IHN1cHBvcnRlZCBieSB0aGlzIHZlcnNpb24gb2YgcmVwbGF5JyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIFNjb3JlQW5hbHlzZXIucHJvdG90eXBlLCBcInBsYXllclNjb3Jlc1NpbXBsZVwiLCBudWxsKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIGRlY29yYXRvcnNfMi5SZXF1aXJlZFJlcGxheVZlcnNpb24oNDAzMzYsICdQbGF5ZXIgc2NvcmUgZGF0YSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiByZXBsYXknKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgU2NvcmVBbmFseXNlci5wcm90b3R5cGUsIFwicGxheWVyU2NvcmVzRnVsbFwiLCBudWxsKTtcclxuU2NvcmVBbmFseXNlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJlcGxheUFuYWx5c2VyQ29udGV4dCgnMEI5RUJDMjUtQ0IxRi00N0NDLUIyODctRDgwNkQ1OEUyQzU1JyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlcGxheV8xLlJlcGxheV0pXHJcbl0sIFNjb3JlQW5hbHlzZXIpO1xyXG5leHBvcnRzLlNjb3JlQW5hbHlzZXIgPSBTY29yZUFuYWx5c2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVMk52Y21WQmJtRnNlWE5sY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJbE5qYjNKbFFXNWhiSGx6WlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenM3T3pzN096dEJRVU5CTEdsRVFVRnpSVHRCUVVOMFJTeDVRMEZCYzBNN1FVRkRkRU1zTUVOQlFUaEdPMEZCUXpsR0xEWkNRVUUyUWp0QlFVTTNRaXdyUkVGQk1rUTdRVUZETTBRc2MwVkJRVzFGTzBGQlEyNUZMRGhEUVVGelJEdEJRWGxHZEVRc1NVRkJZU3hoUVVGaExFZEJRVEZDTEcxQ1FVRXlRaXhUUVVGUkxDdERRVUZ6UWp0SlFVZHlSQ3haUVVGdFFpeE5RVUZqTzFGQlF6ZENMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU5zUWl4RFFVRkRPMGxCUlZrc1ZVRkJWVHM3TzFsQlEyNUNMRTFCUVUwc2IwSkJRV2RDTEZkQlFVVXNRMEZCUXp0WlFVTjZRaXhKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRWRCUVVjc1NVRkJTU3g1UTBGQmJVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03V1VGRGFFVXNUVUZCVFN4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNWVUZCVlN4RlFVRkZMRU5CUVVNN1VVRkRhRVFzUTBGQlF6dExRVUZCTzBsQlNVUXNTVUZCVnl4bFFVRmxPMUZCUTNSQ0xFOUJRVThzUTBGQlF5eEhRVUZ2UXl4RlFVRkZPMWxCUXpGRExFMUJRVTBzV1VGQldTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETzFsQlJXNUVMRTFCUVUwc1lVRkJZU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1dVRkRPVU1zVFVGQlRTeFZRVUZWTEVkQlFVY3NZVUZCWVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0WlFVTnVSaXhOUVVGTkxGVkJRVlVzUjBGQlJ5eGhRVUZoTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlEyNUdMRTFCUVUwc1ZVRkJWU3hIUVVGSExHRkJRV0VzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU03V1VGRE1VVXNUVUZCVFN4VlFVRlZMRWRCUVVjc1lVRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJRenRaUVVNeFJTeE5RVUZOTEZkQlFWY3NSMEZCUnl4aFFVRmhMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlJYWkZMRTFCUVUwc1UwRkJVeXhIUVVGeFFqdG5Ra0ZEYUVNc1YwRkJWenRuUWtGRFdDeFZRVUZWTzJkQ1FVTldMRlZCUVZVN1owSkJRMVlzVlVGQlZUdG5Ra0ZEVml4VlFVRlZPMmRDUVVOV0xGbEJRVms3WVVGRFppeERRVUZETzFsQlEwWXNUMEZCVHl4VFFVRlRMRU5CUVVNN1VVRkRja0lzUTBGQlF5eERRVUZCTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVsRUxFbEJRVmNzYTBKQlFXdENPMUZCUTNwQ0xFOUJRVThzUTBGQlF5eEhRVUYxUWl4RlFVRkZPMWxCUXpkQ0xFMUJRVTBzWjBKQlFXZENMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYzBKQlFYTkNMRU5CUVVNN1dVRkRNMFFzVFVGQlRTeFBRVUZQTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNWVUZCVlN4RFFVRkRPMWxCUXpGRUxFMUJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03V1VGRGNFTXNUVUZCVFN4UFFVRlBMRWRCUVRSQ0xHZENRVUZuUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETERKQ1FVRnRRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1dVRkRjRWNzVFVGQlRTeFZRVUZWTEVkQlFVYzdaMEpCUTJZc1YwRkJWenRuUWtGRFdDeFJRVUZSTzJkQ1FVTlNMRlZCUVZVN1owSkJRMVlzVTBGQlV6dG5Ra0ZEVkN4M1FrRkJkMEk3WjBKQlEzaENMRk5CUVZNN1owSkJRMVFzWVVGQllUdG5Ra0ZEWWl4WlFVRlpPMmRDUVVOYUxHRkJRV0U3WjBKQlEySXNWMEZCVnp0aFFVTmtMRU5CUVVNN1dVRkRSaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhqUVVGakxFTkJRVU03YVVKQlF6RkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEZWQlFWVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmxDUVVNdlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVVm1MRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMR05CUVdNc1EwRkJRenRwUWtGRE0wTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXp0cFFrRkRiRVFzVDBGQlR5eEZRVUZGTEVOQlFVTTdXVUZGWml4TlFVRk5MRmxCUVZrc1IwRkJSeXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRuUWtGRGRrTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSk8yZENRVU5hTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTVHRuUWtGRFdpeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrN1owSkJRMW9zU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpPMmRDUVVOYUxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnp0blFrRkRWaXhqUVVGakxFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFXTTdaMEpCUTJoRExHVkJRV1VzUlVGQlJTeERRVUZETEVOQlFVTXNaVUZCWlR0blFrRkRiRU1zUzBGQlN5eEZRVUZGTEVWQlFVVTdaMEpCUTFRc1RVRkJUU3hGUVVGRkxFVkJRVVU3WVVGRFlpeERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJRenRaUVVOa0xFMUJRVTBzWVVGQllTeEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU03V1VGRk9VTXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3WjBKQlEyNURMRTFCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRUlzVFVGQlRTeFJRVUZSTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRuUWtGRE4wSXNUVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRPM0ZDUVVOcVF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzI5Q1FVTm1MRWxCUVVrc1JVRkJSU3hEUVVGRExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk03YVVKQlEzUkVMRU5CUVVNc1EwRkJRenR4UWtGRFJpeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEZOQlFWTXNRMEZCUXp0eFFrRkRhRU1zU1VGQlNTeERRVUZETEdGQlFXRXNSVUZCUlN4RFFVRkRMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3YjBKQlEzUkVMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJRenR2UWtGRE5VSXNUMEZCVHl4RFFVRkRMRU5CUVVNN1owSkJRMklzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1lVRkRjRUk3V1VGRlJDeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRuUWtGRGNFTXNUVUZCVFN4TFFVRkxMRWRCUVVjc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjRRaXhOUVVGTkxGTkJRVk1zUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFVkJRVVVzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOdVJpeE5RVUZOTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTTdjVUpCUTJ4RExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03YjBKQlEyWXNTVUZCU1N4RlFVRkZMRU5CUVVNc1JVRkJSU3hMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVenRwUWtGRGRFUXNRMEZCUXl4RFFVRkRPM0ZDUVVOR0xFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzVTBGQlV5eERRVUZETzNGQ1FVTm9ReXhKUVVGSkxFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHR2UWtGRmRFUXNTVUZCU1N4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExFTkJRVU1zUlVGQlJUdDNRa0ZEWml4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXp0eFFrRkROVUk3YjBKQlEwUXNUMEZCVHl4RFFVRkRMRU5CUVVNN1owSkJRMklzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1lVRkRjRUk3V1VGSFJDeE5RVUZOTEVkQlFVY3NSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXp0WlFVTjRReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEd0Q1FVRnJRaXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETzFsQlEzSkRMRTlCUVU4c1dVRkJXU3hEUVVGRE8xRkJRM2hDTEVOQlFVTXNRMEZCUVN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVOVUxFTkJRVU03U1VGSlJDeEpRVUZYTEdkQ1FVRm5RanRSUVVOMlFpeFBRVUZQTEVOQlFVTXNSMEZCZFVJc1JVRkJSVHRaUVVNM1FpeE5RVUZOTEdkQ1FVRm5RaXhIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEhOQ1FVRnpRaXhEUVVGRE8xbEJRek5FTEUxQlFVMHNUMEZCVHl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRlZCUVZVc1EwRkJRenRaUVVVeFJDeE5RVUZOTEV0QlFVc3NSMEZCTkVJc1owSkJRV2RDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zTWtKQlFXMUNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXp0WlFVVnNSeXhOUVVGTkxGZEJRVmNzUjBGQmJVSXNSVUZCUlN4RFFVRkRPMWxCUTNaRExFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMmRDUVVOeVF5eE5RVUZOTEUxQlFVMHNSMEZCUnl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6RkNMRTFCUVUwc1YwRkJWeXhIUVVGcFFqdHZRa0ZET1VJc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEpRVUZKTzI5Q1FVTnFRaXhKUVVGSkxFVkJRVVVzVFVGQlRTeERRVUZETEVsQlFVazdiMEpCUTJwQ0xFbEJRVWtzUlVGQlJTeE5RVUZOTEVOQlFVTXNTVUZCU1R0dlFrRkRha0lzUjBGQlJ5eEZRVUZGTEUxQlFVMHNRMEZCUXl4SFFVRkhPMjlDUVVObUxHTkJRV01zUlVGQlJTeE5RVUZOTEVOQlFVTXNZMEZCWXp0dlFrRkRja01zWlVGQlpTeEZRVUZGTEUxQlFVMHNRMEZCUXl4bFFVRmxPMjlDUVVOMlF5eExRVUZMTEVWQlFYRkNMRVZCUVVVN2FVSkJReTlDTEVOQlFVTTdaMEpCUlVZc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRXRCUVVzc1EwRkJReXhqUVVGakxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMjlDUVVOc1JDeE5RVUZOTEVsQlFVa3NSMEZCUnl4TFFVRkxMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTnlReXhKUVVOSkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhEUVVGRE8zZENRVU5vUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXp0M1FrRkRMMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhQUVVGUExFTkJRVU03ZDBKQlEyaERMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRPM2RDUVVNdlFpeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExGVkJRVlVzUTBGQlF6dDNRa0ZEYmtNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNN2QwSkJRemxDTEVsQlFVa3NRMEZCUXl4TlFVRk5MRXRCUVVzc1RVRkJUVHQzUWtGRGRFSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1MwRkJTeXhYUVVGWExFVkJRemRDTzNkQ1FVTkZMRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8zZENRVU14UXl4SlFVRkpMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSVHMwUWtGRGVFTXNUVUZCVFN4TFFVRkxMRWRCUVVjc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZET3pSQ1FVTjRRaXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETzNsQ1FVTnNSRHR4UWtGRFNqdHBRa0ZEU2p0blFrRkRSQ3hYUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMkZCUTJwRE8xbEJRMFFzVFVGQlRTeFpRVUZaTEVkQlFVY3NTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dFpRVVUxUXl4TlFVRk5MR0ZCUVdFc1IwRkJSenRuUWtGRGJFSXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTTdaMEpCUXpsRUxGbEJRVmtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRE8yRkJRMnBGTEVOQlFVTTdXVUZGUml4TlFVRk5MR1ZCUVdVc1IwRkJSenRuUWtGRGNFSXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTTdaMEpCUTI1RkxGbEJRVmtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJWeXhEUVVGRE8yRkJRM1JGTEVOQlFVTTdXVUZGUml4TlFVRk5MSEZDUVVGeFFpeEhRVUZITzJkQ1FVTXhRaXhaUVVGWkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRlZCUVZVc1EwRkJRenRuUWtGRGJFVXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTTdZVUZEY2tVc1EwRkJRenRaUVVWR0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhYUVVGWExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMmRDUVVONlF5eE5RVUZOTEUxQlFVMHNSMEZCUnl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6bENMRTFCUVUwc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdaMEpCUXpWQ0xFMUJRVTBzUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF5eFRRVUZUTEVkQlFVY3NZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZETlVVc1RVRkJUU3hEUVVGRExESkNRVUV5UWl4RFFVRkRMRWRCUVVjc1RVRkJUU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF5OUZMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNVMEZCVXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkROVVFzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4SFFVRkhMRTFCUVUwc1EwRkJReXhSUVVGUkxFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU14UkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEU5QlFVOHNSMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwRUxFMUJRVTBzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF5eFBRVUZQTEVkQlFVY3NRMEZCUXl4bFFVRmxMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVWeVJpeEpRVUZITEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1VVRkJVU3hEUVVGRExFVkJRVU03YjBKQlF6ZENMRTFCUVUwc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4SFFVRkhMRTFCUVUwc1EwRkJReXhQUVVGUExFZEJRVWNzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN2FVSkJRemxHTzJGQlJVbzdXVUZEUkN4UFFVRlBMRmRCUVZjc1EwRkJRenRSUVVOMlFpeERRVUZETEVOQlFVRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRWQ3hEUVVGRE8wTkJRMG9zUTBGQlFUdEJRWEJNUnp0SlFVWkRMSGRDUVVGWExFVkJRVVU3U1VGRFlpeHJRMEZCY1VJc1EwRkJReXhMUVVGTExFVkJRVVVzTUVSQlFUQkVMRU5CUVVNN096dHZSRUZ6UW5oR08wRkJTVVE3U1VGR1F5eDNRa0ZCVnl4RlFVRkZPMGxCUTJJc2EwTkJRWEZDTEVOQlFVTXNTMEZCU3l4RlFVRkZMREpFUVVFeVJDeERRVUZET3pzN2RVUkJORVY2Ump0QlFVbEVPMGxCUmtNc2QwSkJRVmNzUlVGQlJUdEpRVU5pTEd0RFFVRnhRaXhEUVVGRExFdEJRVXNzUlVGQlJTd3lSRUZCTWtRc1EwRkJRenM3TzNGRVFUUkZla1k3UVVGc1RWRXNZVUZCWVR0SlFVUjZRaXhyUTBGQmNVSXNRMEZCUXl4elEwRkJjME1zUTBGQlF6dHhRMEZKTDBJc1pVRkJUVHRIUVVoNFFpeGhRVUZoTEVOQmJVMTZRanRCUVc1TldTeHpRMEZCWVNKOSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi4vLi4vZGVjb3JhdG9yc1wiKTtcclxuY29uc3QgUmVwbGF5XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVwbGF5XCIpO1xyXG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xyXG5jb25zdCBsaW5xID0gcmVxdWlyZShcImxpbnFcIik7XHJcbmNvbnN0IEJhc2ljUmVwbGF5QW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2ljUmVwbGF5QW5hbHlzZXJcIik7XHJcbmNvbnN0IEFic3RyYWN0UmVwbGF5QW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdFJlcGxheUFuYWx5c2VyXCIpO1xyXG5jb25zdCBkZWNvcmF0b3JzXzIgPSByZXF1aXJlKFwiLi4vZGVjb3JhdG9yc1wiKTtcclxubGV0IFRhbGVudEFuYWx5c2VyID0gY2xhc3MgVGFsZW50QW5hbHlzZXIgZXh0ZW5kcyBBYnN0cmFjdFJlcGxheUFuYWx5c2VyXzEuQWJzdHJhY3RSZXBsYXlBbmFseXNlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXBsYXkpIHtcclxuICAgICAgICBzdXBlcihyZXBsYXkpO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBuYW1lID0+IHN1cGVyW25hbWVdO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIF9zdXBlcihcImluaXRpYWxpemVcIikuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5iYXNpY1JlcGxheUFuYWx5c2VyID0gbmV3IEJhc2ljUmVwbGF5QW5hbHlzZXJfMS5CYXNpY1JlcGxheUFuYWx5c2VyKHRoaXMucmVwbGF5KTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5iYXNpY1JlcGxheUFuYWx5c2VyLmluaXRpYWxpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCB0YWxlbnRzKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUXVlcmlhYmxlID0geWllbGQgdGhpcy50cmFja2VyRXZlbnRzUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJMaXN0ID0geWllbGQgdGhpcy5iYXNpY1JlcGxheUFuYWx5c2VyLnBsYXllckxpc3Q7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYXllcnMgPSBsaW5xLmZyb20ocGxheWVyTGlzdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlcm9EYXRhID0gbGlucS5mcm9tKHlpZWxkIHRoaXMucmVwbGF5Lmhlcm9EYXRhKTtcclxuICAgICAgICAgICAgY29uc3QgdGlja1JhdGUgPSB5aWVsZCB0aGlzLnRpY2tSYXRlO1xyXG4gICAgICAgICAgICBjb25zdCB0YWxlbnRRdWVyeSA9IHRyYWNrZXJRdWVyaWFibGVcclxuICAgICAgICAgICAgICAgIC53aGVyZShfID0+IHR5cGVzXzEuaXNTU3RhdEdhbWVFdmVudChfKSAmJiBfLm1fZXZlbnROYW1lID09PSAnVGFsZW50Q2hvc2VuJylcclxuICAgICAgICAgICAgICAgIC5ncm91cEJ5KChfKSA9PiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ludERhdGEsICdQbGF5ZXJJRCcpIC0gMSwgXyA9PiBfLCAoa2V5LCBldmVudCkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiBrZXksXHJcbiAgICAgICAgICAgICAgICB0YWxlbnRzOiBldmVudC5zZWxlY3QoKF8pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSBwbGF5ZXJMaXN0W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFsZW50TmFtZSA9IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1fc3RyaW5nRGF0YSwgJ1B1cmNoYXNlTmFtZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlcm8gPSBoZXJvRGF0YS5maXJzdChfID0+IF8ubmFtZSA9PT0gcGxheWVyLmhlcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGVybyB8fCAhaGVyby50YWxlbnRzIHx8ICFoZXJvLnRhbGVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0YWxlbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogXy5fZ2FtZWxvb3AgLyB0aWNrUmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWxlbnRRID0gbGlucS5mcm9tKGhlcm8udGFsZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhbGVudFEuZmlyc3QoXyA9PiBfLm5hbWUgPT09IHRhbGVudE5hbWUpLCB7IHRpbWU6IF8uX2dhbWVsb29wIC8gdGlja1JhdGUgfSk7XHJcbiAgICAgICAgICAgICAgICB9KS50b0FycmF5KClcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGxheWVycy5qb2luKHRhbGVudFF1ZXJ5LCBwID0+IHAuaW5kZXgsIGUgPT4gZS5pbmRleCwgKHAsIHQpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXJOYW1lOiBwLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0ZWFtOiBwLnRlYW0sXHJcbiAgICAgICAgICAgICAgICBoZXJvOiBwLmhlcm8sXHJcbiAgICAgICAgICAgICAgICB0YWxlbnRzOiB0LnRhbGVudHNcclxuICAgICAgICAgICAgfSkpLnRvQXJyYXkoKTtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIGRlY29yYXRvcnNfMi5SZXF1aXJlZFJlcGxheVZlcnNpb24oNDAzMzYsICdQbGF5ZXIgdGFsZW50IGRhdGEgbm90IHN1cHBvcnRlZCBieSB0aGlzIHZlcnNpb24gb2YgcmVwbGF5JyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUHJvbWlzZSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbl0sIFRhbGVudEFuYWx5c2VyLnByb3RvdHlwZSwgXCJ0YWxlbnRzXCIsIG51bGwpO1xyXG5UYWxlbnRBbmFseXNlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJlcGxheUFuYWx5c2VyQ29udGV4dCgnOTU5RkNGNTQtMDI4NC00NTJCLTg1RjktODE0MzlGQjdGNDk4JyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlcGxheV8xLlJlcGxheV0pXHJcbl0sIFRhbGVudEFuYWx5c2VyKTtcclxuZXhwb3J0cy5UYWxlbnRBbmFseXNlciA9IFRhbGVudEFuYWx5c2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lWR0ZzWlc1MFFXNWhiSGx6WlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpVWVd4bGJuUkJibUZzZVhObGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUTBFc2FVUkJRWE5GTzBGQlEzUkZMSGxEUVVGelF6dEJRVU4wUXl3d1EwRkJiMGc3UVVGRGNFZ3NOa0pCUVRaQ08wRkJRemRDTEN0RVFVRXlSRHRCUVVVelJDeHpSVUZCYlVVN1FVRkRia1VzT0VOQlFYTkVPMEZCWlhSRUxFbEJRV0VzWTBGQll5eEhRVUV6UWl4dlFrRkJORUlzVTBGQlVTd3JRMEZCYzBJN1NVRkhkRVFzV1VGQmJVSXNUVUZCWXp0UlFVTTNRaXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVWWkxGVkJRVlU3T3p0WlFVTnVRaXhOUVVGTkxHOUNRVUZuUWl4WFFVRkZMRU5CUVVNN1dVRkRla0lzU1VGQlNTeERRVUZETEcxQ1FVRnRRaXhIUVVGSExFbEJRVWtzZVVOQlFXMUNMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlEyaEZMRTFCUVUwc1NVRkJTU3hEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRMmhFTEVOQlFVTTdTMEZCUVR0SlFVbEVMRWxCUVZjc1QwRkJUenRSUVVOa0xFOUJRVThzUTBGQlF5eEhRVUV3UXl4RlFVRkZPMWxCUTJoRUxFMUJRVTBzWjBKQlFXZENMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYzBKQlFYTkNMRU5CUVVNN1dVRkRNMFFzVFVGQlRTeFZRVUZWTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNWVUZCVlN4RFFVRkRPMWxCUXpkRUxFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03V1VGRGRFTXNUVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03V1VGRGRrUXNUVUZCVFN4UlFVRlJMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETzFsQlEzSkRMRTFCUVUwc1YwRkJWeXhIUVVGSExHZENRVUZuUWp0cFFrRkRMMElzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc2QwSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExGZEJRVmNzUzBGQlN5eGpRVUZqTEVOQlFVTTdhVUpCUTI1RkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFXdENMRVZCUVVVc1JVRkJSU3hEUVVGRExIRkNRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNc1JVRkJSU3hWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU5zUnl4TFFVRkxMRVZCUVVVc1IwRkJSenRuUWtGRFZpeFBRVUZQTEVWQlFVVXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRV3RDTEVWQlFXVXNSVUZCUlR0dlFrRkRkRVFzVFVGQlRTeE5RVUZOTEVkQlFVY3NWVUZCVlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8yOUNRVU12UWl4TlFVRk5MRlZCUVZVc1IwRkJSeXh4UWtGQllTeERRVUZETEVOQlFVTXNRMEZCUXl4WlFVRlpMRVZCUVVVc1kwRkJZeXhEUVVGRExFTkJRVU03YjBKQlEycEZMRTFCUVUwc1NVRkJTU3hIUVVGSExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenR2UWtGRGVrUXNTVUZCUnl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlF6dDNRa0ZET1VNc1QwRkJXVHMwUWtGRFVpeEpRVUZKTEVWQlFVVXNWVUZCVlRzMFFrRkRhRUlzU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4VFFVRlRMRWRCUVVjc1VVRkJVVHQ1UWtGREwwSXNRMEZCUVR0eFFrRkRTanR2UWtGRFJDeE5RVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0dlFrRkRlRU1zVDBGQlR5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRVZCUVVVc1JVRkJSU3hQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUzBGQlN5eFZRVUZWTEVOQlFVTXNSVUZCUlN4RlFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eEhRVUZITEZGQlFWRXNSVUZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM2hITEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSVHRoUVVObUxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlJWSXNUMEZCVHl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVObUxGZEJRVmNzUlVGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFVkJRMW9zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVOYUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCZDBJc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlF6ZENMRlZCUVZVc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNUdG5Ra0ZEYkVJc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTzJkQ1FVTmFMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNUdG5Ra0ZEV2l4UFFVRlBMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVTg3WVVGRGNrSXNRMEZCUXl4RFFVTk1MRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRGFFSXNRMEZCUXl4RFFVRkJMRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMVFzUTBGQlF6dERRVU5LTEVOQlFVRTdRVUYyUTBjN1NVRkdReXgzUWtGQlZ5eEZRVUZGTzBsQlEySXNhME5CUVhGQ0xFTkJRVU1zUzBGQlN5eEZRVUZGTERSRVFVRTBSQ3hEUVVGRE96czdOa05CZFVNeFJqdEJRWEpFVVN4alFVRmpPMGxCUkRGQ0xHdERRVUZ4UWl4RFFVRkRMSE5EUVVGelF5eERRVUZETzNGRFFVa3ZRaXhsUVVGTk8wZEJTSGhDTEdOQlFXTXNRMEZ6UkRGQ08wRkJkRVJaTEhkRFFVRmpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9kZWNvcmF0b3JzXCIpO1xyXG5jb25zdCBSZXBsYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXBsYXlcIik7XHJcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XHJcbmNvbnN0IGxpbnEgPSByZXF1aXJlKFwibGlucVwiKTtcclxuY29uc3QgUGxheWVyQW5hbHlzZXJfMSA9IHJlcXVpcmUoXCIuL1BsYXllckFuYWx5c2VyXCIpO1xyXG5jb25zdCBBYnN0cmFjdFJlcGxheUFuYWx5c2VyXzEgPSByZXF1aXJlKFwiLi4vQWJzdHJhY3RSZXBsYXlBbmFseXNlclwiKTtcclxuY29uc3QgZGVjb3JhdG9yc18yID0gcmVxdWlyZShcIi4uL2RlY29yYXRvcnNcIik7XHJcbmxldCBYUEFuYWx5c2VyID0gY2xhc3MgWFBBbmFseXNlciBleHRlbmRzIEFic3RyYWN0UmVwbGF5QW5hbHlzZXJfMS5BYnN0cmFjdFJlcGxheUFuYWx5c2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcGxheSkge1xyXG4gICAgICAgIHN1cGVyKHJlcGxheSk7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IG5hbWUgPT4gc3VwZXJbbmFtZV07XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgX3N1cGVyKFwiaW5pdGlhbGl6ZVwiKS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXllckFuYWx5c2VyID0gbmV3IFBsYXllckFuYWx5c2VyXzEuUGxheWVyQW5hbHlzZXIodGhpcy5yZXBsYXkpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXllckFuYWx5c2VyLmluaXRpYWxpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFN0YXQoZnJvbSwga2V5KSB7XHJcbiAgICAgICAgaWYgKGZyb20pIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBsaW5xLmZyb20oZnJvbSkuc2luZ2xlT3JEZWZhdWx0KF8gPT4gXy5tX2tleSA9PT0ga2V5KTtcclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByLm1fdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGdldCBwZXJpb2RpY1hQKCkge1xyXG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2FibGVRID0geWllbGQgdGhpcy50cmFja2VyRXZlbnRzUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJzID0geWllbGQgdGhpcy5wbGF5ZXJBbmFseXNlci5wbGF5ZXJTbG90RGF0YTtcclxuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLnJlcGxheS5wcm90b2NvbDtcclxuICAgICAgICAgICAgY29uc3QgdGlja1JhdGUgPSB5aWVsZCB0aGlzLnRpY2tSYXRlO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0cmFja2FibGVRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoXyA9PiB0eXBlc18xLmlzUGVyaW9kaWNYUEJyZWFrZG93blNTdGF0R2FtZUV2ZW50KF8pKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgoXykgPT4gKHtcclxuICAgICAgICAgICAgICAgIHRlYW06IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1faW50RGF0YSwgJ1RlYW0nKSAtIDEsXHJcbiAgICAgICAgICAgICAgICB0ZWFtTGV2ZWw6IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1faW50RGF0YSwgJ1RlYW1MZXZlbCcpLFxyXG4gICAgICAgICAgICAgICAgdGltZTogdHlwZXNfMS5nZXRTU3RhdFZhbHVlKF8ubV9maXhlZERhdGEsICdHYW1lVGltZScsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNUaW1lOiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ1ByZXZpb3VzR2FtZVRpbWUnLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIG1pbmlvblhQOiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ01pbmlvblhQJywgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBjcmVlcFhQOiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ0NyZWVwWFAnLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIHN0cnVjdHVyZVhQOiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ1N0cnVjdHVyZVhQJywgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBoZXJvWFA6IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1fZml4ZWREYXRhLCAnSGVyb1hQJywgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICB0cmlja2xlWFA6IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1fZml4ZWREYXRhLCAnVHJpY2tsZVhQJywgdHJ1ZSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xyXG4gICAgICAgICAgICBjb25zdCBsdmxSZXN1bHQgPSB0cmFja2FibGVRLndoZXJlKGUgPT4gdHlwZXNfMS5pc1NTY29yZVJlc3VsdEV2ZW50KGUpKS5sYXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxldmVscyA9IGxpbnEuZnJvbShsdmxSZXN1bHQubV9pbnN0YW5jZUxpc3QpXHJcbiAgICAgICAgICAgICAgICAud2hlcmUobCA9PiBsLm1fbmFtZSA9PT0gJ0xldmVsJylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RNYW55KF8gPT4gXy5tX3ZhbHVlcylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKGwsIGkpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBpOiBpLFxyXG4gICAgICAgICAgICAgICAgbDogbFswXSA/IGxbMF0ubV92YWx1ZSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgIC53aGVyZShyID0+IHIuaSA9PT0gMCB8fCByLmkgPT09IDUpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0KF8gPT4gXy5sKVxyXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgY29uc3QgY29yZURlYXRoID0gdHJhY2thYmxlUS53aGVyZShfID0+IHR5cGVzXzEuaXNTVW5pdEJvcm5FdmVudChfKSAmJiBfLm1fdW5pdFR5cGVOYW1lID09PSAnS2luZ3NDb3JlJylcclxuICAgICAgICAgICAgICAgIC5qb2luKHRyYWNrYWJsZVEud2hlcmUoXyA9PiB0eXBlc18xLmlzU1VuaXREaWVkRXZlbnQoXykpLCAoYikgPT4gcHJvdG9jb2wudW5pdFRhZyhiLm1fdW5pdFRhZ0luZGV4LCBiLm1fdW5pdFRhZ1JlY3ljbGUpLCAoZCkgPT4gcHJvdG9jb2wudW5pdFRhZyhkLm1fdW5pdFRhZ0luZGV4LCBkLm1fdW5pdFRhZ1JlY3ljbGUpLCAoYiwgZCkgPT4gZC5fZ2FtZWxvb3ApLmZpcnN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mR2FtZVJlc3VsdHMgPSB0cmFja2FibGVRXHJcbiAgICAgICAgICAgICAgICAud2hlcmUoXyA9PiB0eXBlc18xLmlzRW5kT2ZHYW1lWFBCcmVha2Rvd25TU3RhdEdhbWVFdmVudChfKSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoKF8pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllckluZGV4ID0gdHlwZXNfMS5nZXRTU3RhdFZhbHVlKF8ubV9pbnREYXRhLCAnUGxheWVySUQnKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSBwbGF5ZXJzW3BsYXllckluZGV4XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVhbTogcGxheWVyLnRlYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGVhbUxldmVsOiBwbGF5ZXIudGVhbSA9PSAwID8gbGV2ZWxzWzBdIDogbGV2ZWxzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGNvcmVEZWF0aCAvIHRpY2tSYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVGltZTogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50aW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZDogdHlwZXNfMS5nZXRTU3RhdFZhbHVlKF8ubV9pbnREYXRhLCAnUGxheWVySUQnKSxcclxuICAgICAgICAgICAgICAgICAgICBtaW5pb25YUDogdHlwZXNfMS5nZXRTU3RhdFZhbHVlKF8ubV9maXhlZERhdGEsICdNaW5pb25YUCcsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWVwWFA6IHR5cGVzXzEuZ2V0U1N0YXRWYWx1ZShfLm1fZml4ZWREYXRhLCAnQ3JlZXBYUCcsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdHVyZVhQOiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ1N0cnVjdHVyZVhQJywgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgaGVyb1hQOiB0eXBlc18xLmdldFNTdGF0VmFsdWUoXy5tX2ZpeGVkRGF0YSwgJ0hlcm9YUCcsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyaWNrbGVYUDogdHlwZXNfMS5nZXRTU3RhdFZhbHVlKF8ubV9maXhlZERhdGEsICdUcmlja2xlWFAnLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbmRPZkdhbWVSZXN1bHRzLmZpcnN0KF8gPT4gXy50ZWFtID09PSAwKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuZE9mR2FtZVJlc3VsdHMuZmlyc3QoXyA9PiBfLnRlYW0gPT09IDEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KSkoKTtcclxuICAgIH1cclxufTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBkZWNvcmF0b3JzXzEuUnVuT25Xb3JrZXIoKSxcclxuICAgIGRlY29yYXRvcnNfMi5SZXF1aXJlZFJlcGxheVZlcnNpb24oNDAzMzYsICdQbGF5ZXIgeHAgZGF0YSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiByZXBsYXknKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQcm9taXNlKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuXSwgWFBBbmFseXNlci5wcm90b3R5cGUsIFwicGVyaW9kaWNYUFwiLCBudWxsKTtcclxuWFBBbmFseXNlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgZGVjb3JhdG9yc18xLlJlcGxheUFuYWx5c2VyQ29udGV4dCgnQ0RERDI4RkYtREFCMi00NzEwLUEyOEYtOEQ0OERENkRFODRGJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlcGxheV8xLlJlcGxheV0pXHJcbl0sIFhQQW5hbHlzZXIpO1xyXG5leHBvcnRzLlhQQW5hbHlzZXIgPSBYUEFuYWx5c2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lXRkJCYm1Gc2VYTmxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklsaFFRVzVoYkhselpYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenRCUVVOQkxHbEVRVUZ6UlR0QlFVTjBSU3g1UTBGQmMwTTdRVUZEZEVNc01FTkJUM2RDTzBGQlEzaENMRFpDUVVFMlFqdEJRVU0zUWl4eFJFRkJLMFE3UVVGRkwwUXNjMFZCUVcxRk8wRkJRMjVGTERoRFFVRnpSRHRCUVdsQ2RFUXNTVUZCWVN4VlFVRlZMRWRCUVhaQ0xHZENRVUYzUWl4VFFVRlJMQ3REUVVGelFqdEpRVVZzUkN4WlFVRnRRaXhOUVVGak8xRkJRemRDTEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlExa3NWVUZCVlRzN08xbEJRMjVDTEUxQlFVMHNiMEpCUVdkQ0xGZEJRVVVzUTBGQlF6dFpRVU42UWl4SlFVRkpMRU5CUVVNc1kwRkJZeXhIUVVGSExFbEJRVWtzSzBKQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03V1VGRGRFUXNUVUZCVFN4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETzFGQlF6TkRMRU5CUVVNN1MwRkJRVHRKUVVWUExFOUJRVThzUTBGQlNTeEpRVUU0UWl4RlFVRkZMRWRCUVZjN1VVRkRNVVFzU1VGQlNTeEpRVUZKTEVWQlFVVTdXVUZEVGl4SlFVRkpMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE9VUXNTVUZCU1N4RFFVRkRMRVZCUVVVN1owSkJRMGdzVDBGQlR5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRPMkZCUTNCQ08xTkJRMG83VVVGRFJDeFBRVUZQTEZOQlFWTXNRMEZCUXp0SlFVTnlRaXhEUVVGRE8wbEJTVVFzU1VGQlZ5eFZRVUZWTzFGQlEycENMRTlCUVU4c1EwRkJReXhIUVVGcFF5eEZRVUZGTzFsQlEzWkRMRTFCUVUwc1ZVRkJWU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEhOQ1FVRnpRaXhEUVVGRE8xbEJRM0pFTEUxQlFVMHNUMEZCVHl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eGpRVUZqTEVOQlFVTTdXVUZEZWtRc1RVRkJUU3hSUVVGUkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRaUVVNMVF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU03V1VGRGNrTXNUVUZCVFN4TlFVRk5MRWRCUVVjc1ZVRkJWVHRwUWtGRGNFSXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zTWtOQlFXMURMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YVVKQlEyeEVMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRV3RDTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRemRDTEVsQlFVa3NSVUZCUlN4eFFrRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJRenRuUWtGRE5VTXNVMEZCVXl4RlFVRkZMSEZDUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNSVUZCUlN4WFFVRlhMRU5CUVVNN1owSkJRMnhFTEVsQlFVa3NSVUZCUlN4eFFrRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNWVUZCVlN4RlFVRkZMRWxCUVVrc1EwRkJRenRuUWtGRGNFUXNXVUZCV1N4RlFVRkZMSEZDUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeEpRVUZKTEVOQlFVTTdaMEpCUTNCRkxGRkJRVkVzUlVGQlJTeHhRa0ZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFVkJRVVVzVlVGQlZTeEZRVUZGTEVsQlFVa3NRMEZCUXp0blFrRkRlRVFzVDBGQlR5eEZRVUZGTEhGQ1FVRmhMRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUlVGQlJTeFRRVUZUTEVWQlFVVXNTVUZCU1N4RFFVRkRPMmRDUVVOMFJDeFhRVUZYTEVWQlFVVXNjVUpCUVdFc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEdGQlFXRXNSVUZCUlN4SlFVRkpMRU5CUVVNN1owSkJRemxFTEUxQlFVMHNSVUZCUlN4eFFrRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNVVUZCVVN4RlFVRkZMRWxCUVVrc1EwRkJRenRuUWtGRGNFUXNVMEZCVXl4RlFVRkZMSEZDUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NSVUZCUlN4WFFVRlhMRVZCUVVVc1NVRkJTU3hEUVVGRE8yRkJRemRFTEVOQlFVTXNRMEZCUXp0cFFrRkRSaXhQUVVGUExFVkJRVVVzUTBGQlF6dFpRVVZtTEUxQlFVMHNVMEZCVXl4SFFVRTBRaXhWUVVGVkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc01rSkJRVzFDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dFpRVU5vUnl4TlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4alFVRmpMRU5CUVVNN2FVSkJRemRETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEV0QlFVc3NUMEZCVHl4RFFVRkRPMmxDUVVOb1F5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETzJsQ1FVTXpRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU5tTEVOQlFVTXNSVUZCUlN4RFFVRkRPMmRDUVVOS0xFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk03WVVGRGNrTXNRMEZCUXl4RFFVRkRPMmxDUVVOR0xFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8ybENRVU5zUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmxDUVVOb1FpeFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVVm1MRTFCUVUwc1UwRkJVeXhIUVVGSExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXgzUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zWTBGQll5eExRVUZMTEZkQlFWY3NRMEZCUXp0cFFrRkRNMFlzU1VGQlNTeERRVU5FTEZWQlFWVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eDNRa0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVU14UXl4RFFVRkRMRU5CUVd0Q0xFVkJRVVVzUlVGQlJTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExHTkJRV01zUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUlVGRE9VVXNRMEZCUXl4RFFVRnJRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhqUVVGakxFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFVkJRemxGTEVOQlFVTXNRMEZCYTBJc1JVRkJSU3hEUVVGclFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVNeFJDeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMWxCUldRc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4VlFVRlZPMmxDUVVNNVFpeExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXcwUTBGQmIwTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRwUWtGRGJrUXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJhMElzUlVGQlJTeEZRVUZGTzJkQ1FVTXpRaXhOUVVGTkxGZEJRVmNzUjBGQlJ5eHhRa0ZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhUUVVGVExFVkJRVVVzVlVGQlZTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMmRDUVVNdlJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4UFFVRlBMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03WjBKQlEzQkRMRTlCUVU4N2IwSkJRMGdzU1VGQlNTeEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpPMjlDUVVOcVFpeFRRVUZUTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRia1FzU1VGQlNTeEZRVUZGTEZOQlFWTXNSMEZCUnl4UlFVRlJPMjlDUVVNeFFpeFpRVUZaTEVWQlFVVXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1R0dlFrRkROVU1zVFVGQlRTeEZRVUZGTEhGQ1FVRmhMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUlVGQlJTeFZRVUZWTEVOQlFVTTdiMEpCUXpsRExGRkJRVkVzUlVGQlJTeHhRa0ZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFVkJRVVVzVlVGQlZTeEZRVUZGTEVsQlFVa3NRMEZCUXp0dlFrRkRlRVFzVDBGQlR5eEZRVUZGTEhGQ1FVRmhMRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUlVGQlJTeFRRVUZUTEVWQlFVVXNTVUZCU1N4RFFVRkRPMjlDUVVOMFJDeFhRVUZYTEVWQlFVVXNjVUpCUVdFc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEdGQlFXRXNSVUZCUlN4SlFVRkpMRU5CUVVNN2IwSkJRemxFTEUxQlFVMHNSVUZCUlN4eFFrRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNVVUZCVVN4RlFVRkZMRWxCUVVrc1EwRkJRenR2UWtGRGNFUXNVMEZCVXl4RlFVRkZMSEZDUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NSVUZCUlN4WFFVRlhMRVZCUVVVc1NVRkJTU3hEUVVGRE8ybENRVU0zUkN4RFFVRkJPMWxCUTB3c1EwRkJReXhEUVVGRExFTkJRVU03V1VGRlVDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMR2RDUVVGblFpeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMR2RDUVVGblFpeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlJDeFBRVUZQTEUxQlFVMHNRMEZCUXp0UlFVTnNRaXhEUVVGRExFTkJRVUVzUTBGQlF5eEZRVUZGTEVOQlFVTTdTVUZEVkN4RFFVRkRPME5CUjBvc1EwRkJRVHRCUVc1RlJ6dEpRVVpETEhkQ1FVRlhMRVZCUVVVN1NVRkRZaXhyUTBGQmNVSXNRMEZCUXl4TFFVRkxMRVZCUVVVc2QwUkJRWGRFTEVOQlFVTTdPenMwUTBGcFJYUkdPMEZCZGtaUkxGVkJRVlU3U1VGRWRFSXNhME5CUVhGQ0xFTkJRVU1zYzBOQlFYTkRMRU5CUVVNN2NVTkJSeTlDTEdWQlFVMDdSMEZHZUVJc1ZVRkJWU3hEUVRCR2RFSTdRVUV4Umxrc1owTkJRVlVpZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9CYXNpY1JlcGxheUFuYWx5c2VyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vUGxheWVyQW5hbHlzZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9SZXBsYXlNYXBBbmFseXNlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1Njb3JlQW5hbHlzZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9EcmFmdEFuYWx5c2VyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vQ2hhdEFuYWx5c2VyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vWFBBbmFseXNlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1RhbGVudEFuYWx5c2VyXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKcGJtUmxlQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096dEJRVUZCTERKRFFVRnpRenRCUVVOMFF5eHpRMEZCYVVNN1FVRkRha01zZVVOQlFXOURPMEZCUTNCRExIRkRRVUZuUXp0QlFVTm9ReXh4UTBGQlowTTdRVUZEYUVNc2IwTkJRU3RDTzBGQlF5OUNMR3REUVVFMlFqdEJRVU0zUWl4elEwRkJhVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9kZWNvcmF0b3JzXCIpO1xyXG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XHJcbmZ1bmN0aW9uIFJlcXVpcmVkUmVwbGF5VmVyc2lvbih2ZXJzaW9uLCBjdXN0b21NZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpID0+IHtcclxuICAgICAgICBpZiAoIWRlY29yYXRvcnNfMS5pc1J1bm5pbmdJbldvcmtlcigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxVmVyID0gdHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInID8gJz49JyArIHZlcnNpb24gOiB2ZXJzaW9uO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9GbiA9IGRlc2NyaXB0b3IudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrRm4gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZlcnNpb25NYXRjaGVzKHJlcVZlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUmVwbGF5VmVyc2lvbk91dE9mUmFuZ2VFcnJvcihjdXN0b21NZXNzYWdlIHx8ICdNZXRob2Qgbm90IHN1cHBvcnRlZCBieSB0aGlzIHZlcnNpb24gb2YgcmVwbGF5Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb0ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoZWNrRm5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvci5nZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb0ZuID0gZGVzY3JpcHRvci5nZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVyc2lvbk1hdGNoZXMocmVxVmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SZXBsYXlWZXJzaW9uT3V0T2ZSYW5nZUVycm9yKGN1c3RvbU1lc3NhZ2UgfHwgJ1Byb3BlcnR5IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHJlcGxheScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9Gbi5hcHBseSh0aGlzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGdldDogY2hlY2tGblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5SZXF1aXJlZFJlcGxheVZlcnNpb24gPSBSZXF1aXJlZFJlcGxheVZlcnNpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpHVmpiM0poZEc5eWN5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSW1SbFkyOXlZWFJ2Y25NdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN3NFEwRkJhMFE3UVVGRmJFUXNjME5CUVhsRU8wRkJSWHBFTEN0Q1FVRnpReXhQUVVGM1FpeEZRVUZGTEdGQlFYTkNPMGxCUTJ4R0xFOUJRVThzUTBGQlNTeE5RVUZqTEVWQlFVVXNWMEZCTkVJc1JVRkJSU3hWUVVGelF5eEZRVUZ4UXl4RlFVRkZPMUZCUTJ4SkxFbEJRVWtzUTBGQlF5dzRRa0ZCYVVJc1JVRkJSU3hGUVVGRk8xbEJRM1JDTEU5QlFVODdVMEZEVmp0UlFVTkVMRTFCUVUwc1RVRkJUU3hIUVVGWExFOUJRVThzVDBGQlR5eExRVUZMTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hIUVVGSExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRPMUZCUXpsRkxFbEJRVWtzVlVGQlZTeERRVUZETEV0QlFVc3NSVUZCUlR0WlFVTnNRaXhOUVVGTkxFZEJRVWNzUjBGQmFVSXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJRenRaUVVNelF5eE5RVUZOTEU5QlFVOHNSMEZCUnl4VlFVRnBReXhIUVVGSExFbEJRVmM3WjBKQlF6TkVMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zWTBGQll5eERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZPMjlDUVVNNVFpeE5RVUZOTEVsQlFVa3NjVU5CUVRSQ0xFTkJRVU1zWVVGQllTeEpRVUZKTEdkRVFVRm5SQ3hEUVVGRExFTkJRVU03YVVKQlF6ZEhPMmRDUVVORUxFOUJRVThzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRGFrTXNRMEZCUXl4RFFVRkRPMWxCUTBZc1QwRkJUenRuUWtGRFNDeExRVUZMTEVWQlFVOHNUMEZCVHp0aFFVTjBRaXhEUVVGQk8xTkJRMG83WVVGQlN5eEpRVUZITEZWQlFWVXNRMEZCUXl4SFFVRkhMRVZCUVVNN1dVRkRjRUlzVFVGQlRTeEhRVUZITEVkQlFXbENMRlZCUVZVc1EwRkJReXhIUVVGSExFTkJRVU03V1VGRGVrTXNUVUZCVFN4UFFVRlBMRWRCUVVjN1owSkJRMW9zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1RVRkJUU3hEUVVGRExFVkJRVVU3YjBKQlF6bENMRTFCUVUwc1NVRkJTU3h4UTBGQk5FSXNRMEZCUXl4aFFVRmhMRWxCUVVrc2EwUkJRV3RFTEVOQlFVTXNRMEZCUXp0cFFrRkRMMGM3WjBKQlEwUXNUMEZCVHl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJRenRaUVVOR0xFOUJRVTg3WjBKQlEwZ3NSMEZCUnl4RlFVRkZMRTlCUVU4N1lVRkRaaXhEUVVGQk8xTkJRMG83U1VGRFRDeERRVUZETEVOQlFVRTdRVUZEVEN4RFFVRkRPMEZCT1VKRUxITkVRVGhDUXlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi90eXBlc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0Fic3RyYWN0UmVwbGF5QW5hbHlzZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9idWlsdGluXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SnBibVJsZUM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenRCUVVGQkxEWkNRVUYzUWp0QlFVVjRRaXc0UTBGQmVVTTdRVUZEZWtNc0swSkJRVEJDTzBGQlF6RkNMR3REUVVFMlFpSjkiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgR2FtZVR5cGU7XHJcbihmdW5jdGlvbiAoR2FtZVR5cGUpIHtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIkZMQUdfU09MT19RVUVVRVwiXSA9IDFdID0gXCJGTEFHX1NPTE9fUVVFVUVcIjtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiRkxBR19DT09QXCJdID0gMl0gPSBcIkZMQUdfQ09PUFwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJGTEFHX1BWUFwiXSA9IDRdID0gXCJGTEFHX1BWUFwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJGTEFHX0RSQUZUXCJdID0gOF0gPSBcIkZMQUdfRFJBRlRcIjtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiRkxBR19SQU5LRURcIl0gPSAxNl0gPSBcIkZMQUdfUkFOS0VEXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIk1PREVfUFJBQ1RJQ0VcIl0gPSAzMl0gPSBcIk1PREVfUFJBQ1RJQ0VcIjtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiTU9ERV9BSVwiXSA9IDY0XSA9IFwiTU9ERV9BSVwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJNT0RFX0JSQVdMXCJdID0gMTI4XSA9IFwiTU9ERV9CUkFXTFwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJNT0RFX1FNXCJdID0gMjU2XSA9IFwiTU9ERV9RTVwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJNT0RFX1VSXCJdID0gNTEyXSA9IFwiTU9ERV9VUlwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJNT0RFX0hMXCJdID0gMTAyNF0gPSBcIk1PREVfSExcIjtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiTU9ERV9UTFwiXSA9IDIwNDhdID0gXCJNT0RFX1RMXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIk1PREVfQ1VTVE9NXCJdID0gNDA5Nl0gPSBcIk1PREVfQ1VTVE9NXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIlBSQUNUSUNFXCJdID0gMzNdID0gXCJQUkFDVElDRVwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJTT0xPX0FJXCJdID0gNjVdID0gXCJTT0xPX0FJXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIkNPT1BfQUlcIl0gPSA2Nl0gPSBcIkNPT1BfQUlcIjtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiQ1VTVE9NXCJdID0gNDEwMF0gPSBcIkNVU1RPTVwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJDVVNUT01fRFJBRlRcIl0gPSA0MTA4XSA9IFwiQ1VTVE9NX0RSQUZUXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIkJSQVdMXCJdID0gMTMyXSA9IFwiQlJBV0xcIjtcclxuICAgIEdhbWVUeXBlW0dhbWVUeXBlW1wiUVVJQ0tfTUFUQ0hcIl0gPSAyNjBdID0gXCJRVUlDS19NQVRDSFwiO1xyXG4gICAgR2FtZVR5cGVbR2FtZVR5cGVbXCJVTlJBTktFRF9EUkFGVFwiXSA9IDUyNF0gPSBcIlVOUkFOS0VEX0RSQUZUXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIkhFUk9fTEVBR1VFXCJdID0gMTA1M10gPSBcIkhFUk9fTEVBR1VFXCI7XHJcbiAgICBHYW1lVHlwZVtHYW1lVHlwZVtcIlRFQU1fTEVBR1VFXCJdID0gMjA3Nl0gPSBcIlRFQU1fTEVBR1VFXCI7XHJcbn0pKEdhbWVUeXBlID0gZXhwb3J0cy5HYW1lVHlwZSB8fCAoZXhwb3J0cy5HYW1lVHlwZSA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVIyRnRaVlI1Y0dVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpIWVcxbFZIbHdaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMRWxCUVZrc1VVRXdRbGc3UVVFeFFrUXNWMEZCV1N4UlFVRlJPMGxCUTJoQ0xEWkRRVUZYTEVOQlFVRTdTVUZEV0N3MlJFRkJiVUlzUTBGQlFUdEpRVU51UWl4cFJFRkJhMElzUTBGQlFUdEpRVU5zUWl3clEwRkJhVUlzUTBGQlFUdEpRVU5xUWl4dFJFRkJiVUlzUTBGQlFUdEpRVU51UWl4elJFRkJiMElzUTBGQlFUdEpRVU53UWl3d1JFRkJjMElzUTBGQlFUdEpRVU4wUWl3NFEwRkJaMElzUTBGQlFUdEpRVU5vUWl4eFJFRkJiVUlzUTBGQlFUdEpRVU51UWl3clEwRkJaMElzUTBGQlFUdEpRVU5vUWl3clEwRkJaMElzUTBGQlFUdEpRVU5vUWl4blJFRkJhVUlzUTBGQlFUdEpRVU5xUWl4blJFRkJhVUlzUTBGQlFUdEpRVU5xUWl4M1JFRkJjVUlzUTBGQlFUdEpRVVZ5UWl4blJFRkJNRU1zUTBGQlFUdEpRVU14UXl3NFEwRkJiVU1zUTBGQlFUdEpRVU51UXl3NFEwRkJOa0lzUTBGQlFUdEpRVU0zUWl3NFEwRkJLMElzUTBGQlFUdEpRVU12UWl3d1JFRkJhMFFzUTBGQlFUdEpRVU5zUkN3eVEwRkJOa0lzUTBGQlFUdEpRVU0zUWl4MVJFRkJaME1zUTBGQlFUdEpRVU5vUXl3MlJFRkJaMFFzUTBGQlFUdEpRVU5vUkN4M1JFRkJOa1VzUTBGQlFUdEpRVU0zUlN4M1JFRkJNa1FzUTBGQlFUdEJRVU12UkN4RFFVRkRMRVZCTVVKWExGRkJRVkVzUjBGQlVpeG5Ra0ZCVVN4TFFVRlNMR2RDUVVGUkxGRkJNRUp1UWlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9HYW1lVHlwZVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SnBibVJsZUM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenRCUVVGQkxHZERRVUV5UWlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnJlcXVpcmUoXCJyZWZsZWN0LW1ldGFkYXRhXCIpO1xyXG5jb25zdCBXb3JrZXJDb250ZXh0UmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3Byb3h5L2NvbnRleHQvV29ya2VyQ29udGV4dFJlZ2lzdHJ5XCIpO1xyXG5jb25zdCBSZXBsYXlDb250ZXh0Q2FsbGVyXzEgPSByZXF1aXJlKFwiLi9wcm94eS9SZXBsYXlDb250ZXh0Q2FsbGVyXCIpO1xyXG5jb25zdCBSZXBsYXlBbmFseXNlckNvbnRleHRDYWxsZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3h5L1JlcGxheUFuYWx5c2VyQ29udGV4dENhbGxlclwiKTtcclxuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XHJcbmZ1bmN0aW9uIGlzUnVubmluZ0luV29ya2VyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nICYmIG5hdmlnYXRvci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnV29ya2VyTmF2aWdhdG9yJztcclxufVxyXG5leHBvcnRzLmlzUnVubmluZ0luV29ya2VyID0gaXNSdW5uaW5nSW5Xb3JrZXI7XHJcbmZ1bmN0aW9uIGdldFByb3BlcnR5TmFtZXModHlwZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSBuZXcgU2V0KCk7XHJcbiAgICBsZXQgcHJvdG8gPSB0eXBlLnByb3RvdHlwZTtcclxuICAgIHdoaWxlIChwcm90byAmJiBwcm90by5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgIHByb3BzLmFkZChuKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRQcm94eU9iamVjdChjYWxsZXJUeXBlLCBwcm94aWVkVHlwZSwgY3RvckFyZ3MpIHtcclxuICAgIGNvbnN0IGNhbGxlckluc3QgPSBuZXcgY2FsbGVyVHlwZSguLi5jdG9yQXJncyk7XHJcbiAgICBjb25zdCBjYWxsZXJQcm9wcyA9IGdldFByb3BlcnR5TmFtZXMoY2FsbGVyVHlwZSk7XHJcbiAgICBsZXQgcHJvdG8gPSBwcm94aWVkVHlwZS5wcm90b3R5cGU7XHJcbiAgICB3aGlsZSAocHJvdG8gJiYgcHJvdG8uY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWNhbGxlclByb3BzLmhhcyhwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxlckluc3QsIHByb3AsIGRlc2MpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVyUHJvcHMuYWRkKHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWxsZXJJbnN0O1xyXG59XHJcbmZ1bmN0aW9uIFdvcmtlckNvbnRleHRDYWxsZXIoZ3VpZCwgcHJveHlUeXBlKSB7XHJcbiAgICByZXR1cm4gKHRhcmdldCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1J1bm5pbmdJbldvcmtlcigpKSB7XHJcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3dvcmtlckNvbnRleHQ6dHlwZUlkJywgZ3VpZCwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgV29ya2VyQ29udGV4dFJlZ2lzdHJ5XzEuV29ya2VyQ29udGV4dFJlZ2lzdHJ5LnJlZ2lzdGVyQ29udGV4dENhbGxlcih0YXJnZXQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGFyZ2V0O1xyXG4gICAgICAgIGNvbnN0IGYgPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmID0gYnVpbGRQcm94eU9iamVjdChwcm94eVR5cGUsIG9yaWdpbmFsLCBhcmdzKTtcclxuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgnd29ya2VyQ29udGV4dDp0eXBlSWQnLCBndWlkLCBzZWxmLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgV29ya2VyQ29udGV4dFJlZ2lzdHJ5XzEuV29ya2VyQ29udGV4dFJlZ2lzdHJ5LnJlZ2lzdGVyQ29udGV4dENhbGxlcihzZWxmLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmLnByb3RvdHlwZSA9IG9yaWdpbmFsLnByb3RvdHlwZTtcclxuICAgICAgICByZXR1cm4gZjtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5Xb3JrZXJDb250ZXh0Q2FsbGVyID0gV29ya2VyQ29udGV4dENhbGxlcjtcclxuZnVuY3Rpb24gUmVwbGF5V29ya2VyQ29udGV4dChndWlkKSB7XHJcbiAgICByZXR1cm4gV29ya2VyQ29udGV4dENhbGxlcihndWlkLCBSZXBsYXlDb250ZXh0Q2FsbGVyXzEuUmVwbGF5Q29udGV4dENhbGxlcik7XHJcbn1cclxuZXhwb3J0cy5SZXBsYXlXb3JrZXJDb250ZXh0ID0gUmVwbGF5V29ya2VyQ29udGV4dDtcclxuZnVuY3Rpb24gUmVwbGF5QW5hbHlzZXJDb250ZXh0KGd1aWQpIHtcclxuICAgIHJldHVybiBXb3JrZXJDb250ZXh0Q2FsbGVyKGd1aWQsIFJlcGxheUFuYWx5c2VyQ29udGV4dENhbGxlcl8xLlJlcGxheUFuYWx5c2VyQ29udGV4dENhbGxlcik7XHJcbn1cclxuZXhwb3J0cy5SZXBsYXlBbmFseXNlckNvbnRleHQgPSBSZXBsYXlBbmFseXNlckNvbnRleHQ7XHJcbmZ1bmN0aW9uIHdyYXBQcm94aWVkTWV0aG9kKG1ldGhvZElkLCBjYWNoZVJlc3VsdCkge1xyXG4gICAgY29uc3QgZm4gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlckNvbnRleHQuY2FsbE1ldGhvZCh0aGlzLCBtZXRob2RJZCwgYXJncywgY2FjaGVSZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmbjtcclxufVxyXG5mdW5jdGlvbiB3cmFwUHJveGllZEdldHRlcihwcm9wZXJ0eUlkLCBjYWNoZVJlc3VsdCkge1xyXG4gICAgY29uc3QgcElkID0gcHJvcGVydHlJZDtcclxuICAgIGNvbnN0IGZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlckNvbnRleHQuZ2V0UHJvcGVydHkodGhpcywgcElkLCBjYWNoZVJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZuO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkV29ya2VyUG94eU1ldGhvZCh0YXJnZXQsIG1ldGhvZE51bSwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246cmV0dXJuVHlwZScsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgd3JpdGFibGU6IGRlc2NyaXB0b3Iud3JpdGFibGUsXHJcbiAgICAgICAgdmFsdWU6IHdyYXBQcm94aWVkTWV0aG9kKG1ldGhvZE51bSwgdHJ1ZSlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRXb3JrZXJQb3h5R2V0dGVyUHJvcGVydHkodGFyZ2V0LCBtZXRob2ROdW0sIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHdyYXAgc2V0dGVyIFwiJHtwcm9wZXJ0eUtleX1cIi4gT25seSByZWFkb25seSBwcm9wZXJ0aWVzIGFyZSBzdXBwb3J0ZWQuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0eXBlID0gUmVmbGVjdC5nZXRNZXRhZGF0YSgnZGVzaWduOnR5cGUnLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIGNvbnN0IGRlc2MgPSB7XHJcbiAgICAgICAgZ2V0OiB3cmFwUHJveGllZEdldHRlcihtZXRob2ROdW0sIHRydWUpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRlc2M7XHJcbn1cclxubGV0IGNhbGxBZGRyZXNzID0gLTE7XHJcbmZ1bmN0aW9uIFJ1bk9uV29ya2VyKCkge1xyXG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSA9PiB7XHJcbiAgICAgICAgbGV0IHByb3h5TWFwID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnd29rZXI6cHJveHlNZXRob2RzJywgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBpZiAoIXByb3h5TWFwKSB7XHJcbiAgICAgICAgICAgIHByb3h5TWFwID0ge307XHJcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3dva2VyOnByb3h5TWV0aG9kcycsIHByb3h5TWFwLCB0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtQ291bnQgPSArK2NhbGxBZGRyZXNzO1xyXG4gICAgICAgIHByb3h5TWFwW21Db3VudF0gPSBwcm9wZXJ0eUtleTtcclxuICAgICAgICBpZiAoaXNSdW5uaW5nSW5Xb3JrZXIoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgKGRlc2NyaXB0b3IudmFsdWUpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFdvcmtlclBveHlNZXRob2QodGFyZ2V0LCBtQ291bnQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFdvcmtlclBveHlHZXR0ZXJQcm9wZXJ0eSh0YXJnZXQsIG1Db3VudCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5SdW5PbldvcmtlciA9IFJ1bk9uV29ya2VyO1xyXG5mdW5jdGlvbiBXb3JrZXJPbmx5KCkge1xyXG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzUnVubmluZ0luV29ya2VyKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZXNjID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICgoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkRXhlY3V0aW9uQ29udGV4dEVycm9yKGBUaGUgTWV0aG9kIFwiJHtwcm9wZXJ0eUtleX1cIiBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgd29ya2VyIGNvbnRleHQuYCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvci5nZXQgfHwgZGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCB0aHJvd0ZuID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEV4ZWN1dGlvbkNvbnRleHRFcnJvcihgVGhlIFByb3BlcnR5IFwiJHtwcm9wZXJ0eUtleX1cIiBjYW4gb25seSBiZSBhY2Nlc3NlZCBmcm9tIHRoZSB3b3JrZXIgY29udGV4dC5gKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xyXG4gICAgICAgICAgICAgICAgZGVzYy5nZXQgPSB0aHJvd0ZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgICAgICAgICAgZGVzYy5zZXQgPSB0aHJvd0ZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5Xb3JrZXJPbmx5ID0gV29ya2VyT25seTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWkdWamIzSmhkRzl5Y3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJbVJsWTI5eVlYUnZjbk11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkRRU3cwUWtGQk1FSTdRVUZETVVJc2FVWkJRVGhGTzBGQlJUbEZMSEZGUVVGclJUdEJRVU5zUlN4eFJrRkJhMFk3UVVGRmJFWXNjVU5CUVhWRU8wRkJSWFpFTzBsQlEwa3NUMEZCVHl4UFFVRlBMR0ZCUVdFc1MwRkJTeXhWUVVGVkxFbEJRVWtzVTBGQlV5eERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRXRCUVVzc2FVSkJRV2xDTEVOQlFVTTdRVUZEYmtjc1EwRkJRenRCUVVaRUxEaERRVVZETzBGQlEwUXNNRUpCUVRCQ0xFbEJRV1U3U1VGRGNrTXNUVUZCVFN4TFFVRkxMRWRCUVdkQ0xFbEJRVWtzUjBGQlJ5eEZRVUZGTEVOQlFVTTdTVUZEY2tNc1NVRkJTU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTXpRaXhQUVVGUExFdEJRVXNzU1VGQlNTeExRVUZMTEVOQlFVTXNWMEZCVnl4TFFVRkxMRTFCUVUwc1JVRkJSVHRSUVVNeFF5eE5RVUZOTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRk8xbEJRekZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRTQ3hMUVVGTExFZEJRVWNzVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRMUVVONFF6dEpRVU5FTEU5QlFVOHNTMEZCU3l4RFFVRkRPMEZCUTJwQ0xFTkJRVU03UVVGRlJDd3dRa0ZCTUVJc1ZVRkJiME1zUlVGQlJTeFhRVUZ6UWl4RlFVRkZMRkZCUVdVN1NVRkRia2NzVFVGQlRTeFZRVUZWTEVkQlFVY3NTVUZCU1N4VlFVRlZMRU5CUVVNc1IwRkJSeXhSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU12UXl4TlFVRk5MRmRCUVZjc1IwRkJSeXhuUWtGQlowSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJRenRKUVVWcVJDeEpRVUZKTEV0QlFVc3NSMEZCUnl4WFFVRlhMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRMnhETEU5QlFVOHNTMEZCU3l4SlFVRkpMRXRCUVVzc1EwRkJReXhYUVVGWExFdEJRVXNzVFVGQlRTeEZRVUZGTzFGQlF6RkRMRTFCUVUwc1MwRkJTeXhIUVVGSExFMUJRVTBzUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU5vUkN4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVU51UXl4TlFVRk5MRWxCUVVrc1IwRkJSeXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVJc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1owSkJRM2hDTEUxQlFVMHNTVUZCU1N4SFFVRkhMRTFCUVUwc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03WjBKQlF6RkVMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU1zVlVGQlZTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRE9VTXNWMEZCVnl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dGhRVU42UWp0VFFVTktPMUZCUTBRc1MwRkJTeXhIUVVGSExFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1MwRkRlRU03U1VGRFJDeFBRVUZQTEZWQlFWVXNRMEZCUXp0QlFVTjBRaXhEUVVGRE8wRkJSVVFzTmtKQlFXOURMRWxCUVZrc1JVRkJSU3hUUVVGdFF6dEpRVU5xUml4UFFVRlBMRU5CUVRaQ0xFMUJRV2xDTEVWQlFXOUNMRVZCUVVVN1VVRkRka1VzU1VGQlNTeHBRa0ZCYVVJc1JVRkJSU3hGUVVGRk8xbEJRM0pDTEU5QlFVOHNRMEZCUXl4alFVRmpMRU5CUVVNc2MwSkJRWE5DTEVWQlFVVXNTVUZCU1N4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJRemRFTERaRFFVRnhRaXhEUVVGRExIRkNRVUZ4UWl4RFFVRk5MRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJRM3BFTEU5QlFVODdVMEZEVmp0UlFVTkVMRTFCUVUwc1VVRkJVU3hIUVVGUkxFMUJRVTBzUTBGQlF6dFJRVU0zUWl4TlFVRk5MRU5CUVVNc1IwRkJVU3hWUVVGVkxFZEJRVWNzU1VGQlNUdFpRVVUxUWl4TlFVRk5MRWxCUVVrc1IwRkJSeXhuUWtGQlowSXNRMEZCUXl4VFFVRlRMRVZCUVVVc1VVRkJVU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFsQmFVSjZSQ3hQUVVGUExFTkJRVU1zWTBGQll5eERRVUZETEhOQ1FVRnpRaXhGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1dVRkRka1VzTmtOQlFYRkNMRU5CUVVNc2NVSkJRWEZDTEVOQlFWa3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xbEJRM3BGTEU5QlFVOHNTVUZCU1N4RFFVRkRPMUZCUTJoQ0xFTkJRVU1zUTBGQlF6dFJRVU5HTEVOQlFVTXNRMEZCUXl4VFFVRlRMRWRCUVVjc1VVRkJVU3hEUVVGRExGTkJRVk1zUTBGQlF6dFJRVU5xUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOaUxFTkJRVU1zUTBGQlF6dEJRVU5PTEVOQlFVTTdRVUZzUTBRc2EwUkJhME5ETzBGQlJVUXNOa0pCUVc5RExFbEJRVms3U1VGRE5VTXNUMEZCVHl4dFFrRkJiVUlzUTBGQlF5eEpRVUZKTEVWQlFVVXNlVU5CUVcxQ0xFTkJRVU1zUTBGQlF6dEJRVU14UkN4RFFVRkRPMEZCUmtRc2EwUkJSVU03UVVGRlJDd3JRa0ZCYzBNc1NVRkJXVHRKUVVNNVF5eFBRVUZQTEcxQ1FVRnRRaXhEUVVGRExFbEJRVWtzUlVGQlJTeDVSRUZCTWtJc1EwRkJReXhEUVVGRE8wRkJRMnhGTEVOQlFVTTdRVUZHUkN4elJFRkZRenRCUVVWRUxESkNRVUU0UWl4UlFVRm5RaXhGUVVGRkxGZEJRVzlDTzBsQlEyaEZMRTFCUVUwc1JVRkJSU3hIUVVGSExGVkJRVzlETEVkQlFVY3NTVUZCVnp0UlFVTjZSQ3hQUVVGUExFbEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFVkJRVVVzU1VGQlNTeEZRVUZGTEZkQlFWY3NRMEZCUXl4RFFVRkRPMGxCUXpWRkxFTkJRVU1zUTBGQlF6dEpRVU5HTEU5QlFVOHNSVUZCUlN4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVVWRUxESkNRVUV5UWl4VlFVRnJRaXhGUVVGRkxGZEJRVzlDTzBsQlF5OUVMRTFCUVUwc1IwRkJSeXhIUVVGSExGVkJRVlVzUTBGQlF6dEpRVU4yUWl4TlFVRk5MRVZCUVVVc1IwRkJSenRSUVVOUUxFOUJRVThzU1VGQlNTeERRVUZETEdGQlFXRXNRMEZCUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFZEJRVWNzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXp0SlFVTnNSU3hEUVVGRExFTkJRVU03U1VGRFJpeFBRVUZQTEVWQlFVVXNRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRkZSQ3dyUWtGRFNTeE5RVUZqTEVWQlEyUXNVMEZCYVVJc1JVRkRha0lzVjBGQk5FSXNSVUZETlVJc1ZVRkJjME03U1VGRmRFTXNUVUZCVFN4SlFVRkpMRWRCUVVjc1QwRkJUeXhEUVVGRExGZEJRVmNzUTBGQlF5eHRRa0ZCYlVJc1JVRkJSU3hOUVVGTkxFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdTVUZMTTBVc1QwRkJiVU03VVVGREwwSXNWVUZCVlN4RlFVRkZMRlZCUVZVc1EwRkJReXhWUVVGVk8xRkJRMnBETEZGQlFWRXNSVUZCUlN4VlFVRlZMRU5CUVVNc1VVRkJVVHRSUVVNM1FpeExRVUZMTEVWQlFVOHNhVUpCUVdsQ0xFTkJRVU1zVTBGQlV5eEZRVUZGTEVsQlFVa3NRMEZCUXp0TFFVTnFSQ3hEUVVGRE8wRkJRMDRzUTBGQlF6dEJRVVZFTEhWRFFVTkpMRTFCUVdNc1JVRkRaQ3hUUVVGcFFpeEZRVU5xUWl4WFFVRTBRaXhGUVVNMVFpeFZRVUZ6UXp0SlFVVjBReXhKUVVGSkxGVkJRVlVzUTBGQlF5eEhRVUZITEVWQlFVVTdVVUZEYUVJc1RVRkJUU3hMUVVGTExFTkJRVU1zZFVKQlFYVkNMRmRCUVZjc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0TFFVTXZSanRKUVVWRUxFMUJRVTBzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4WFFVRlhMRU5CUVVNc1lVRkJZU3hGUVVGRkxFMUJRVTBzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXp0SlFVbHlSU3hOUVVGTkxFbEJRVWtzUjBGQkswSTdVVUZEY2tNc1IwRkJSeXhGUVVGUExHbENRVUZwUWl4RFFVRkRMRk5CUVZNc1JVRkJSU3hKUVVGSkxFTkJRVU03UzBGREwwTXNRMEZCUXp0SlFVTkdMRTlCUVU4c1NVRkJTU3hEUVVGRE8wRkJRMmhDTEVOQlFVTTdRVUZGUkN4SlFVRkpMRmRCUVZjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVVZ5UWp0SlFVTkpMRTlCUVU4c1EwRkJTU3hOUVVGakxFVkJRVVVzVjBGQk5FSXNSVUZCUlN4VlFVRnpReXhGUVVGeFF5eEZRVUZGTzFGQlEyeEpMRWxCUVVrc1VVRkJVU3hIUVVGSExFOUJRVThzUTBGQlF5eGpRVUZqTEVOQlFVTXNiMEpCUVc5Q0xFVkJRVVVzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUTJoR0xFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVTdXVUZEV0N4UlFVRlJMRWRCUVVjc1JVRkJSU3hEUVVGRE8xbEJRMlFzVDBGQlR5eERRVUZETEdOQlFXTXNRMEZCUXl4dlFrRkJiMElzUlVGQlJTeFJRVUZSTEVWQlFVVXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xTkJRemxGTzFGQlEwUXNUVUZCVFN4TlFVRk5MRWRCUVVjc1JVRkJSU3hYUVVGWExFTkJRVU03VVVGRE4wSXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExGZEJRVmNzUTBGQlF6dFJRVU12UWl4SlFVRkpMR2xDUVVGcFFpeEZRVUZGTEVWQlFVVTdXVUZEY2tJc1QwRkJUenRUUVVOV08xRkJSVVFzU1VGQlNTeFBRVUZQTEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExGVkJRVlVzUlVGQlJUdFpRVU14UXl4UFFVRlBMSEZDUVVGeFFpeERRVUZETEUxQlFVMHNSVUZCUlN4TlFVRk5MRVZCUVVVc1YwRkJWeXhGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzFOQlEzcEZPMkZCUVUwN1dVRkRTQ3hQUVVGUExEWkNRVUUyUWl4RFFVRkRMRTFCUVUwc1JVRkJSU3hOUVVGTkxFVkJRVVVzVjBGQlZ5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRPMU5CUTJwR08wbEJRMHdzUTBGQlF5eERRVUZETzBGQlEwNHNRMEZCUXp0QlFXNUNSQ3hyUTBGdFFrTTdRVUZGUkR0SlFVTkpMRTlCUVU4c1EwRkJTU3hOUVVGakxFVkJRVVVzVjBGQk5FSXNSVUZCUlN4VlFVRnpReXhGUVVGeFF5eEZRVUZGTzFGQlEyeEpMRWxCUVVrc2FVSkJRV2xDTEVWQlFVVXNSVUZCUlR0WlFVTnlRaXhQUVVGUE8xTkJRMVk3VVVGRFJDeEpRVUZKTEZWQlFWVXNRMEZCUXl4TFFVRkxMRVZCUVVVN1dVRkRiRUlzVFVGQlRTeEpRVUZKTEVkQlFTdENPMmRDUVVOeVF5eExRVUZMTEVWQlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hGUVVGUExFVkJRVVU3YjBKQlF6RkNMRTFCUVUwc1NVRkJTU3h4UTBGQk5FSXNRMEZCUXl4bFFVRmxMRmRCUVZjc0swTkJRU3RETEVOQlFVTXNRMEZCUXp0blFrRkRkRWdzUTBGQlF5eERRVUZETzJGQlEwd3NRMEZCUVR0WlFVTkVMRTlCUVU4c1NVRkJTU3hEUVVGRE8xTkJRMlk3WVVGQlN5eEpRVUZKTEZWQlFWVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1ZVRkJWU3hEUVVGRExFZEJRVWNzUlVGQlJUdFpRVU40UXl4TlFVRk5MRWxCUVVrc1IwRkJLMElzUlVGQlJTeERRVUZETzFsQlF6VkRMRTFCUVUwc1QwRkJUeXhIUVVGUkxFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCVHl4RlFVRkZPMmRDUVVOdVF5eE5RVUZOTEVsQlFVa3NjVU5CUVRSQ0xFTkJRVU1zYVVKQlFXbENMRmRCUVZjc2FVUkJRV2xFTEVOQlFVTXNRMEZCUXp0WlFVTXhTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5JTEVsQlFVY3NWVUZCVlN4RFFVRkRMRWRCUVVjc1JVRkJRenRuUWtGRFpDeEpRVUZKTEVOQlFVTXNSMEZCUnl4SFFVRkhMRTlCUVU4c1EwRkJRenRoUVVOMFFqdFpRVU5FTEVsQlFVY3NWVUZCVlN4RFFVRkRMRWRCUVVjc1JVRkJRenRuUWtGRFpDeEpRVUZKTEVOQlFVTXNSMEZCUnl4SFFVRkhMRTlCUVU4c1EwRkJRenRoUVVOMFFqdFpRVU5FTEU5QlFVOHNTVUZCU1N4RFFVRkRPMU5CUTJZN1NVRkRUQ3hEUVVGRExFTkJRVUU3UVVGRFRDeERRVUZETzBGQk1VSkVMR2REUVRCQ1F5SjkiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBQcm94aWFibGVFcnJvcl8xID0gcmVxdWlyZShcIi4uL3Byb3h5L2Vycm9yL1Byb3hpYWJsZUVycm9yXCIpO1xyXG5jbGFzcyBGYWlsZWRUb0xvYWRQcm90b2NvbEVycm9yIGV4dGVuZHMgUHJveGlhYmxlRXJyb3JfMS5Qcm94aWFibGVFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZFRvTG9hZFByb3RvY29sRXJyb3InLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRmFpbGVkVG9Mb2FkUHJvdG9jb2xFcnJvciA9IEZhaWxlZFRvTG9hZFByb3RvY29sRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVJtRnBiR1ZrVkc5TWIyRmtVSEp2ZEc5amIyeEZjbkp2Y2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJa1poYVd4bFpGUnZURzloWkZCeWIzUnZZMjlzUlhKeWIzSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTeHJSVUZCSzBRN1FVRkZMMFFzSzBKQlFYVkRMRk5CUVZFc0swSkJRV003U1VGRmVrUXNXVUZCYlVJc1QwRkJaU3hGUVVGRkxFOUJRV1U3VVVGREwwTXNTMEZCU3l4RFFVRkRMREpDUVVFeVFpeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUkRkQ0xGbEJRVThzUjBGQlVDeFBRVUZQTEVOQlFWRTdTVUZGYkVNc1EwRkJRenREUVVOS08wRkJURVFzT0VSQlMwTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUHJveGlhYmxlRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9wcm94eS9lcnJvci9Qcm94aWFibGVFcnJvclwiKTtcclxuY2xhc3MgR2FtZVR5cGVOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFByb3hpYWJsZUVycm9yXzEuUHJveGlhYmxlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKCdHYW1lVHlwZU5vdFN1cHBvcnRlZEVycm9yJywgbWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5HYW1lVHlwZU5vdFN1cHBvcnRlZEVycm9yID0gR2FtZVR5cGVOb3RTdXBwb3J0ZWRFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pUjJGdFpWUjVjR1ZPYjNSVGRYQndiM0owWldSRmNuSnZjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklrZGhiV1ZVZVhCbFRtOTBVM1Z3Y0c5eWRHVmtSWEp5YjNJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4clJVRkJLMFE3UVVGRkwwUXNLMEpCUVhWRExGTkJRVkVzSzBKQlFXTTdTVUZEZWtRc1dVRkJXU3hQUVVGbE8xRkJRM1pDTEV0QlFVc3NRMEZCUXl3eVFrRkJNa0lzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wTkJRMG83UVVGS1JDdzRSRUZKUXlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFByb3hpYWJsZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vcHJveHkvZXJyb3IvUHJveGlhYmxlRXJyb3JcIik7XHJcbmNsYXNzIEludmFsaWRFeGVjdXRpb25Db250ZXh0RXJyb3IgZXh0ZW5kcyBQcm94aWFibGVFcnJvcl8xLlByb3hpYWJsZUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcignSW52YWxpZEV4ZWN1dGlvbkNvbnRleHRFcnJvcicsIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuSW52YWxpZEV4ZWN1dGlvbkNvbnRleHRFcnJvciA9IEludmFsaWRFeGVjdXRpb25Db250ZXh0RXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVNXNTJZV3hwWkVWNFpXTjFkR2x2YmtOdmJuUmxlSFJGY25KdmNpNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWtsdWRtRnNhV1JGZUdWamRYUnBiMjVEYjI1MFpYaDBSWEp5YjNJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4clJVRkJLMFE3UVVGRkwwUXNhME5CUVRCRExGTkJRVkVzSzBKQlFXTTdTVUZETlVRc1dVRkJXU3hQUVVGbE8xRkJRM1pDTEV0QlFVc3NRMEZCUXl3NFFrRkJPRUlzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTnVSQ3hEUVVGRE8wTkJRMG83UVVGS1JDeHZSVUZKUXlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFByb3hpYWJsZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vcHJveHkvZXJyb3IvUHJveGlhYmxlRXJyb3JcIik7XHJcbmNsYXNzIE1hcE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgUHJveGlhYmxlRXJyb3JfMS5Qcm94aWFibGVFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIoJ01hcE5vdFN1cHBvcnRlZEVycm9yJywgbWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NYXBOb3RTdXBwb3J0ZWRFcnJvciA9IE1hcE5vdFN1cHBvcnRlZEVycm9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lUV0Z3VG05MFUzVndjRzl5ZEdWa1JYSnliM0l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5Sk5ZWEJPYjNSVGRYQndiM0owWldSRmNuSnZjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMR3RGUVVFclJEdEJRVVV2UkN3d1FrRkJhME1zVTBGQlVTd3JRa0ZCWXp0SlFVTndSQ3haUVVGWkxFOUJRV1U3VVVGRGRrSXNTMEZCU3l4RFFVRkRMSE5DUVVGelFpeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXpORExFTkJRVU03UTBGRFNqdEJRVXBFTEc5RVFVbERJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUHJveGlhYmxlRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9wcm94eS9lcnJvci9Qcm94aWFibGVFcnJvclwiKTtcclxuY2xhc3MgUmVwbGF5VmVyc2lvbk91dE9mUmFuZ2VFcnJvciBleHRlbmRzIFByb3hpYWJsZUVycm9yXzEuUHJveGlhYmxlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKCdSZXBsYXlWZXJzaW9uT3V0T2ZSYW5nZUVycm9yJywgbWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZXBsYXlWZXJzaW9uT3V0T2ZSYW5nZUVycm9yID0gUmVwbGF5VmVyc2lvbk91dE9mUmFuZ2VFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVW1Wd2JHRjVWbVZ5YzJsdmJrOTFkRTltVW1GdVoyVkZjbkp2Y2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJbEpsY0d4aGVWWmxjbk5wYjI1UGRYUlBabEpoYm1kbFJYSnliM0l1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3hyUlVGQkswUTdRVUZGTDBRc2EwTkJRVEJETEZOQlFWRXNLMEpCUVdNN1NVRkROVVFzV1VGQldTeFBRVUZsTzFGQlEzWkNMRXRCUVVzc1EwRkJReXc0UWtGQk9FSXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOdVJDeERRVUZETzBOQlEwbzdRVUZLUkN4dlJVRkpReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1JlcGxheVZlcnNpb25PdXRPZlJhbmdlRXJyb3JcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9JbnZhbGlkRXhlY3V0aW9uQ29udGV4dEVycm9yXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vRmFpbGVkVG9Mb2FkUHJvdG9jb2xFcnJvclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0dhbWVUeXBlTm90U3VwcG9ydGVkRXJyb3JcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9NYXBOb3RTdXBwb3J0ZWRFcnJvclwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SnBibVJsZUM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenRCUVVGQkxHOUVRVUVyUXp0QlFVTXZReXh2UkVGQkswTTdRVUZETDBNc2FVUkJRVFJETzBGQlF6VkRMR2xFUVVFMFF6dEJRVU0xUXl3MFEwRkJkVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9hbmFseXplcnNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9SZXBsYXlcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcHJveHlcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9lcnJvcnNcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3p0QlFVRkJMR2xEUVVFMFFqdEJRVU0xUWl3NFFrRkJlVUk3UVVGRGVrSXNhME5CUVRaQ08wRkJRemRDTERaQ1FVRjNRanRCUVVONFFpdzRRa0ZCZDBJaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBSZXBsYXlBbmFseXNlckNvbnRleHRDYWxsZXIge1xyXG4gICAgZ2V0IHdvcmtlckNvbnRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxheSA/IHRoaXMuX3JlcGxheS53b3JrZXJDb250ZXh0IDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IocmVwbGF5KSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbGF5ID0gcmVwbGF5O1xyXG4gICAgICAgIHRoaXMud29ya2VyQ29udGV4dC5hZGRDYWxsQ29udGV4dCh0aGlzKTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0aWFsaXplIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiB0aGUgd2ViIHdvcmtlciBjb250ZXh0Jyk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXBsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0LnJlbW92ZUNhbGxDb250ZXh0KHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVwbGF5QW5hbHlzZXJDb250ZXh0Q2FsbGVyID0gUmVwbGF5QW5hbHlzZXJDb250ZXh0Q2FsbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVbVZ3YkdGNVFXNWhiSGx6WlhKRGIyNTBaWGgwUTJGc2JHVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVVtVndiR0Y1UVc1aGJIbHpaWEpEYjI1MFpYaDBRMkZzYkdWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCU1VFN1NVRkhTU3hKUVVGWExHRkJRV0U3VVVGRGNFSXNUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETzBsQlEycEZMRU5CUVVNN1NVRkZSQ3haUVVGdFFpeE5RVUV5UWp0UlFVTXhReXhKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEUxQlFVMHNRMEZCUXp0UlFVTjBRaXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNMVF5eERRVUZETzBsQlJVMHNWVUZCVlR0UlFVTmlMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZVVSQlFYbEVMRU5CUVVNc1EwRkJRenRKUVVNdlJTeERRVUZETzBsQlJVMHNUMEZCVHp0UlFVTldMRWxCUVVrc1NVRkJTU3hEUVVGRExFOUJRVThzUlVGQlJUdFpRVU5rTEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRNME1zU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4VFFVRlRMRU5CUVVNN1UwRkROVUk3U1VGRFRDeERRVUZETzBOQlJVbzdRVUYyUWtRc2EwVkJkVUpESW4wPSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFdvcmtlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2NvbnRleHQvV29ya2VyQ29udGV4dFwiKTtcclxuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xyXG5jb25zdCBoZXJvcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZXJvcHJvdG9jb2xcIik7XHJcbmNvbnN0IFN1YmplY3RfMSA9IHJlcXVpcmUoXCJyeGpzL1N1YmplY3RcIik7XHJcbmNvbnN0IG9wZXJhdG9yc18xID0gcmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpO1xyXG5jbGFzcyBSZXBsYXlDb250ZXh0Q2FsbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1wcURhdGEpIHtcclxuICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XHJcbiAgICAgICAgY29uc3QgaW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYXlJbml0UHJvbWlzZSA9IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlcyxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZXBsYXlJbml0UHJvbWlzZS5wcm9taXNlID0gaW5pdFByb21pc2U7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyQ29udGV4dCA9IG5ldyBXb3JrZXJDb250ZXh0XzEuV29ya2VyQ29udGV4dChgLi9hc3NldHMvd2Vid29ya2VyL3JlcGxheS13b3JrZXIke2hlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5lbnYgPT09ICdwcm9kdWN0aW9uJyA/ICcubWluJyA6ICcnfS5qc2AsIG1wcURhdGEsIFttcHFEYXRhXSk7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyQ29udGV4dC5hZGRDYWxsQ29udGV4dCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0U3Vic2NyaXB0aW9uID0gdGhpcy5fd29ya2VyQ29udGV4dC5jaGFubmVsTWVzc2FnZXMucGlwZShvcGVyYXRvcnNfMS5maWx0ZXIobXNnID0+IG1lc3NhZ2VzXzEuaXNSZXBsYXlTdGF0dXNNZXNzYWdlKG1zZykpKS5zdWJzY3JpYmUoKChzdGF0dXNNZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXNNZXNzYWdlLnN0YXR1cyA9PT0gJ1JFUExBWV9SRUFEWScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5SW5pdFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c1N1YmplY3QubmV4dChzdGF0dXNNZXNzYWdlKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2xMb2FkZXJTdWJzY3JpcHRpb24gPSB0aGlzLl93b3JrZXJDb250ZXh0LmNoYW5uZWxNZXNzYWdlcy5waXBlKG9wZXJhdG9yc18xLmZpbHRlcihtc2cgPT4gbWVzc2FnZXNfMS5pc0xvYWRIZXJvRGF0YU1lc3NhZ2UobXNnKSkpLnN1YnNjcmliZSgoKGhlcm9EYXRhTG9hZE1lc3NhZ2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGhlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5sb2FkSGVyb0RhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0LnNlbmQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQtaGVyby1kYXRhLXJlc3VsdCcsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2xMb2FkZXJTdWJzY3JpcHRpb24gPSB0aGlzLl93b3JrZXJDb250ZXh0LmNoYW5uZWxNZXNzYWdlcy5waXBlKG9wZXJhdG9yc18xLmZpbHRlcihtc2cgPT4gbWVzc2FnZXNfMS5pc0xvYWRQcm90b2NvbE1lc3NhZ2UobXNnKSkpLnN1YnNjcmliZSgoKHByb3RvY29sTWVzc2FnZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHlpZWxkIGhlcm9wcm90b2NvbF8xLkhlcm9Qcm90b2NvbC5sb2FkUHJvdG9jb2wocHJvdG9jb2xNZXNzYWdlLnZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0LnNlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkLXByb3RvY29sLXJlc3VsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcHJvdG9jb2xNZXNzYWdlLnZlcnNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5SW5pdFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpKTtcclxuICAgIH1cclxuICAgIGdldCB3b3JrZXJDb250ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JrZXJDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICAgIH1cclxuICAgIGdldCBwcm90b2NvbCgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3RvY29sIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGluIHRoZSB3ZWIgd29ya2VyIGNvbnRleHQnKTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGF5SW5pdFByb21pc2UucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtlckNvbnRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzU3ViamVjdFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0U3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JrZXJDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlcGxheUNvbnRleHRDYWxsZXIgPSBSZXBsYXlDb250ZXh0Q2FsbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lVbVZ3YkdGNVEyOXVkR1Y0ZEVOaGJHeGxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklsSmxjR3hoZVVOdmJuUmxlSFJEWVd4c1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenRCUVVkQkxESkVRVUYzUkR0QlFVTjRSQ3g1UTBGSmIwSTdRVUZEY0VJc2NVUkJRV3RFTzBGQlEyeEVMREJEUVVGMVF6dEJRVWQyUXl3NFEwRkJkME03UVVGRmVFTTdTVUZ4UWtrc1dVRkJiVUlzVDBGQmNVSTdVVUZxUW1oRExHMUNRVUZqTEVkQlFXdERMRWxCUVVrc2FVSkJRVThzUlVGQlJTeERRVUZETzFGQmEwSnNSU3hOUVVGTkxGZEJRVmNzUjBGQlJ5eEpRVUZKTEU5QlFVOHNRMEZCVHl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVU1zUlVGQlJUdFpRVU01UXl4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVkQlFVYzdaMEpCUTNKQ0xFOUJRVThzUlVGQlJTeEhRVUZITzJkQ1FVTmFMRTFCUVUwc1JVRkJSU3hIUVVGSE8yRkJRMlFzUTBGQlF6dFJRVU5PTEVOQlFVTXNRMEZCUXl4RFFVRkJPMUZCUTBZc1NVRkJTU3hEUVVGRExHbENRVUZwUWl4RFFVRkRMRTlCUVU4c1IwRkJSeXhYUVVGWExFTkJRVU03VVVGRE4wTXNTVUZCU1N4RFFVRkRMR05CUVdNc1IwRkJSeXhKUVVGSkxEWkNRVUZoTEVOQlFVTXNiVU5CUVcxRExESkNRVUZaTEVOQlFVTXNSMEZCUnl4TFFVRkxMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVVVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKS0xFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM3BETEVsQlFVa3NRMEZCUXl3d1FrRkJNRUlzUjBGQlJ5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhKUVVGSkxFTkJRM1JGTEd0Q1FVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eG5RMEZCY1VJc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhoUVVGdFF5eEZRVUZGTEVWQlFVVTdXVUZETVVZc1NVRkJSeXhoUVVGaExFTkJRVU1zVFVGQlRTeExRVUZMTEdOQlFXTXNSVUZCUXp0blFrRkRka01zU1VGQlNTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzJGQlEzQkRPMWxCUTBRc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkROVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTlNMRWxCUVVrc1EwRkJReXd5UWtGQk1rSXNSMEZCUnl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExHVkJRV1VzUTBGQlF5eEpRVUZKTEVOQlEzWkZMR3RDUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4blEwRkJjVUlzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlR5eHRRa0ZCZVVNc1JVRkJSU3hGUVVGRk8xbEJRM1JITEUxQlFVMHNTVUZCU1N4SFFVRkhMRTFCUVUwc01rSkJRVmtzUTBGQlF5eFpRVUZaTEVWQlFVVXNRMEZCUXp0WlFVTXZReXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCTmtJN1owSkJRMmhFTEVsQlFVa3NSVUZCUlN4MVFrRkJkVUk3WjBKQlF6ZENMRWxCUVVrc1JVRkJSU3hKUVVGSk8yRkJRMklzUTBGQlF5eERRVUZETzFGQlExQXNRMEZCUXl4RFFVRkJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMUlzU1VGQlNTeERRVUZETERKQ1FVRXlRaXhIUVVGSExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1EwRkRka1VzYTBKQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExHZERRVUZ4UWl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRlBMR1ZCUVhGRExFVkJRVVVzUlVGQlJUdFpRVU5zUnl4SlFVRkhPMmRDUVVORExFMUJRVTBzU1VGQlNTeEhRVUZITEUxQlFVMHNNa0pCUVZrc1EwRkJReXhaUVVGWkxFTkJRVU1zWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMmRDUVVOMFJTeEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRWxCUVVrc1EwRkJOa0k3YjBKQlEyaEVMRWxCUVVrc1JVRkJSU3h6UWtGQmMwSTdiMEpCUXpWQ0xFOUJRVThzUlVGQlJTeGxRVUZsTEVOQlFVTXNUMEZCVHp0dlFrRkRhRU1zU1VGQlNTeEZRVUZGTEVsQlFVazdhVUpCUTJJc1EwRkJReXhEUVVGRE8yRkJRMDQ3V1VGQlFTeFBRVUZOTEVOQlFVTXNSVUZCUXp0blFrRkRUQ3hKUVVGSkxFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJGQlEzQkRPMUZCUTB3c1EwRkJReXhEUVVGQkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlExb3NRMEZCUXp0SlFXeEVSQ3hKUVVGWExHRkJRV0U3VVVGRGNFSXNUMEZCVHl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRE8wbEJReTlDTEVOQlFVTTdTVUZGUkN4SlFVRlhMRTFCUVUwN1VVRkRZaXhQUVVGUExFbEJRVWtzUTBGQlF5eGpRVUZqTEVOQlFVTXNXVUZCV1N4RlFVRkZMRU5CUVVNN1NVRkRPVU1zUTBGQlF6dEpRVVZFTEVsQlFWY3NVVUZCVVR0UlFVTm1MRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZVVSQlFYbEVMRU5CUVVNc1EwRkJRenRKUVVNdlJTeERRVUZETzBsQk1FTk5MRlZCUVZVN1VVRkRZaXhQUVVGUExFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRE1VTXNRMEZCUXp0SlFVVk5MRTlCUVU4N1VVRkRWaXhKUVVGSkxFbEJRVWtzUTBGQlF5eGpRVUZqTEVWQlFVVTdXVUZEY2tJc1NVRkJTU3hEUVVGRExEQkNRVUV3UWl4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRE8xbEJRemxETEVsQlFVa3NRMEZCUXl3d1FrRkJNRUlzUjBGQlJ5eFRRVUZUTEVOQlFVTTdXVUZETlVNc1NVRkJTU3hEUVVGRExHTkJRV01zUjBGQlJ5eFRRVUZUTEVOQlFVTTdXVUZEYUVNc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0WlFVTTNRaXhKUVVGSkxFTkJRVU1zWTBGQll5eEhRVUZITEZOQlFWTXNRMEZCUXp0VFFVTnVRenRKUVVOTUxFTkJRVU03UTBGRFNqdEJRVEZGUkN4clJFRXdSVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlc1wiKTtcclxuY29uc3QgV29ya2VyQ29udGV4dFJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9jb250ZXh0L1dvcmtlckNvbnRleHRSZWdpc3RyeVwiKTtcclxucmVxdWlyZShcInJlZmxlY3QtbWV0YWRhdGFcIik7XHJcbnJlcXVpcmUoXCJyeGpzL29wZXJhdG9ycy9kZWJvdW5jZVwiKTtcclxuY29uc3QgUmVwbGF5XzEgPSByZXF1aXJlKFwiLi4vUmVwbGF5XCIpO1xyXG5jbGFzcyBSZXBsYXlXb3JrZXIge1xyXG4gICAgY29uc3RydWN0b3IoaW5pdENtZCkge1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sUHJvbWlzaWVzID0ge307XHJcbiAgICAgICAgdGhpcy5fbG9hZGVkQ29udGV4dHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZVBvcnQgPSBpbml0Q21kLnBvcnQ7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZVBvcnQub25tZXNzYWdlID0gKGV2ZW50KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLmlzV29ya2VyQ2FsbE1lc3NhZ2UoZXZlbnQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHlpZWxkIHRoaXMuaGFuZGxlV29ya2VyQ2FsbE1lc3NhZ2UoZXZlbnQuZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXItY2FsbC1yZXN1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsSWQ6IGV2ZW50LmRhdGEuY2FsbElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogZS5zdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoZXJyTXNnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLmlzTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZShldmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm90b2NvbFJlc3VsdChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLmlzTG9hZEhlcm9EYXRhUmVzdWx0TWVzc2FnZShldmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGVyb0RhdGFQcm9taXNlLnJlc29sdmUoZXZlbnQuZGF0YS5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3JlcGxheSA9IG5ldyBSZXBsYXlfMS5SZXBsYXkoaW5pdENtZC5kYXRhKTtcclxuICAgICAgICBjb25zdCByZXBsYXlDb250ZXh0SWQgPSBXb3JrZXJDb250ZXh0UmVnaXN0cnlfMS5Xb3JrZXJDb250ZXh0UmVnaXN0cnkuZ2V0Q29udGV4dENhbGxlcklkKHRoaXMuX3JlcGxheSk7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVkQ29udGV4dHMuc2V0KHJlcGxheUNvbnRleHRJZCwgdGhpcy5fcmVwbGF5KTtcclxuICAgICAgICB0aGlzLl9yZXBsYXkuc3RhdHVzLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcmVwbGF5LmxvYWRQcm90b2NvbCA9ICh2ZXJzaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm90b2NvbFByb21pc2llc1t2ZXJzaW9uXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sUHJvbWlzaWVzW3ZlcnNpb25dLnByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sUHJvbWlzaWVzW3ZlcnNpb25dID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sUHJvbWlzaWVzW3ZlcnNpb25dLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQtcHJvdG9jb2wnLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9yZXBsYXkubG9hZEhlcm9EYXRhID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGVyb0RhdGFQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVyb0RhdGFQcm9taXNlLnByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hlcm9EYXRhUHJvbWlzZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCxcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9oZXJvRGF0YVByb21pc2UucHJvbWlzZSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZC1oZXJvLWRhdGEnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3JlcGxheS5pbml0aWFsaXplKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kKGRhdGEsIHRyYW5zZmVyID0gW10pIHtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlUG9ydC5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlcik7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVQcm90b2NvbFJlc3VsdChkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX3Byb3RvY29sUHJvbWlzaWVzW2RhdGEudmVyc2lvbl07XHJcbiAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGRhdGEuY29kZSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVXb3JrZXJDYWxsTWVzc2FnZShtc2cpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5pc1dvcmtlclByb3BlcnR5Q2FsbChtc2cuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmhhbmRsZVdvcmtlclByb3BlcnR5Q2FsbChtc2cuY2FsbElkLCBtc2cuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5pc1dvcmtlck1ldGhvZENhbGwobXNnLmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5oYW5kbGVXb3JrZXJNZXRob2RDYWxsKG1zZy5jYWxsSWQsIG1zZy5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIFdvcmtlciBDYWxsIE1lc3NhZ2UgXCIke21zZy50eXBlfVwiYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGhhbmRsZVdvcmtlclByb3BlcnR5Q2FsbChjYWxsSWQsIGNhbGwpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0geWllbGQgdGhpcy5nZXRDb250ZXh0SW5zdGFuY2UoY2FsbC5jb250ZXh0KTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB5aWVsZCBjb250ZXh0W3RoaXMuZ2V0UHJvcGVydHlOYW1lKGNvbnRleHQsIGNhbGwucHJvcGVydHlJZCldO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyLWNhbGwtcmVzdWx0JyxcclxuICAgICAgICAgICAgICAgIGNhbGxJZCxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogdmFsdWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGhhbmRsZVdvcmtlck1ldGhvZENhbGwoY2FsbElkLCBjYWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHlpZWxkIHRoaXMuZ2V0Q29udGV4dEluc3RhbmNlKGNhbGwuY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZuID0gY29udGV4dFt0aGlzLmdldFByb3BlcnR5TmFtZShjb250ZXh0LCBjYWxsLm1ldGhvZElkKV07XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0geWllbGQgZm4uYXBwbHkoY29udGV4dCwgY2FsbC5hcmdzIHx8IFtdKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlci1jYWxsLXJlc3VsdCcsXHJcbiAgICAgICAgICAgICAgICBjYWxsSWQsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHZhbHVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb250ZXh0SW5zdGFuY2UoY29udGV4dElkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWRlZENvbnRleHRzLmhhcyhjb250ZXh0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkQ29udGV4dHMuZ2V0KGNvbnRleHRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29udGV4dFR5cGUgPSBXb3JrZXJDb250ZXh0UmVnaXN0cnlfMS5Xb3JrZXJDb250ZXh0UmVnaXN0cnkuZ2V0Q29udGV4dENhbGxlckJ5SWQoY29udGV4dElkKTtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dEluc3QgPSBuZXcgY29udGV4dFR5cGUodGhpcy5fcmVwbGF5KTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVkQ29udGV4dHMuc2V0KGNvbnRleHRJZCwgY29udGV4dEluc3QpO1xyXG4gICAgICAgICAgICB5aWVsZCBjb250ZXh0SW5zdC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0SW5zdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFByb3BlcnR5TmFtZShjb250ZXh0LCBpZCkge1xyXG4gICAgICAgIGNvbnN0IHByb3h5TWFwID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnd29rZXI6cHJveHlNZXRob2RzJywgY29udGV4dC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIHByb3h5TWFwW2lkXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlcGxheVdvcmtlciA9IFJlcGxheVdvcmtlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVW1Wd2JHRjVWMjl5YTJWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpVW1Wd2JHRjVWMjl5YTJWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096czdRVUZCUVN4NVEwRmpiMEk3UVVGRGNFSXNNa1ZCUVhkRk8wRkJRM2hGTERSQ1FVRXdRanRCUVVjeFFpeHRRMEZCYVVNN1FVRkZha01zYzBOQlFXMURPMEZCUTI1RE8wbEJVVWtzV1VGQldTeFBRVUV5UWp0UlFVd3ZRaXgxUWtGQmEwSXNSMEZCTmtZc1JVRkJSU3hEUVVGRE8xRkJSMnhJTEc5Q1FVRmxMRWRCUVhGQ0xFbEJRVWtzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZIYkVRc1NVRkJTU3hEUVVGRExGbEJRVmtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJwRExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNVMEZCVXl4SFFVRkhMRU5CUVU4c1MwRkJTeXhGUVVGRkxFVkJRVVU3V1VGRE1VTXNTVUZCU1N3NFFrRkJiVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1owSkJRMnBETEVsQlFVazdiMEpCUTBFc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4MVFrRkJkVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRwUWtGRE4wUTdaMEpCUVVNc1QwRkJUeXhEUVVGRExFVkJRVVU3YjBKQlExSXNUVUZCVFN4TlFVRk5MRWRCUVRaQ08zZENRVU55UXl4SlFVRkpMRVZCUVVVc2IwSkJRVzlDTzNkQ1FVTXhRaXhOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5PM2RDUVVONlFpeExRVUZMTEVWQlFVVXNTVUZCU1R0M1FrRkRXQ3hOUVVGTkxFVkJRVVU3TkVKQlEwb3NTVUZCU1N4RlFVRlZMRU5CUVVVc1EwRkJReXhKUVVGSk96UkNRVU55UWl4UFFVRlBMRVZCUVZVc1EwRkJSU3hEUVVGRExFOUJRVTg3TkVKQlF6TkNMRXRCUVVzc1JVRkJWU3hEUVVGRkxFTkJRVU1zUzBGQlN6dDVRa0ZETVVJN2NVSkJRMG9zUTBGQlF6dHZRa0ZEUml4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzJsQ1FVTnlRanRoUVVOS08ybENRVUZOTEVsQlFVa3NjME5CUVRKQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZPMmRDUVVOb1JDeEpRVUZKTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMkZCUTNwRE8ybENRVUZMTEVsQlFVa3NjME5CUVRKQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZPMmRDUVVNdlF5eEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WVVGRGJFUTdVVUZEVEN4RFFVRkRMRU5CUVVFc1EwRkJRenRSUVVOR0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NTVUZCU1N4bFFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzaERMRTFCUVUwc1pVRkJaU3hIUVVGSExEWkRRVUZ4UWl4RFFVRkRMR3RDUVVGclFpeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVNdlJTeEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWRCUVVjc1EwRkJReXhsUVVGbExFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUlhoRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFMUJRVTBzUlVGQlJTeEZRVUZGTzFsQlEzSkRMRWxCUVVrc1RVRkJUU3hGUVVGRk8yZENRVU5TTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WVVGRGNrSTdVVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVWSUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4SFFVRkhMRU5CUVVNc1QwRkJaU3hGUVVGdFFpeEZRVUZGTzFsQlF6ZEVMRWxCUVVrc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRk8yZENRVU5zUXl4UFFVRlBMRWxCUVVrc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU03WVVGRGJrUTdXVUZGUkN4TlFVRk5MRTlCUVU4c1IwRkJSeXhKUVVGSkxFOUJRVThzUTBGQlV5eERRVUZETEU5QlFVOHNSVUZCUlN4TlFVRk5MRVZCUVVVc1JVRkJSVHRuUWtGRGNFUXNTVUZCU1N4RFFVRkRMR3RDUVVGclFpeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhPMjlDUVVNdlFpeFBRVUZQTzI5Q1FVTlFMRTFCUVUwN2IwSkJRMDRzVDBGQlR5eEZRVUZGTEZOQlFWTTdhVUpCUTNKQ0xFTkJRVU03V1VGRFRpeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTklMRWxCUVVrc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETzFsQlEyNUVMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRWFZDTzJkQ1FVTTFRaXhKUVVGSkxFVkJRVVVzWlVGQlpUdG5Ra0ZEY2tJc1QwRkJUeXhGUVVGRkxFOUJRVTg3WVVGRGJrSXNRMEZCUXl4RFFVRkRPMWxCUTBnc1QwRkJUeXhQUVVGUExFTkJRVU03VVVGRGJrSXNRMEZCUXl4RFFVRkRPMUZCUTBZc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFpRVUZaTEVkQlFVY3NSMEZCYVVJc1JVRkJSVHRaUVVNelF5eEpRVUZKTEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUlVGQlJUdG5Ra0ZEZGtJc1QwRkJUeXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1QwRkJUeXhEUVVGRE8yRkJRM2hETzFsQlEwUXNUVUZCVFN4UFFVRlBMRWRCUVVjc1NVRkJTU3hQUVVGUExFTkJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVN1owSkJRMnBFTEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUjBGQlJ6dHZRa0ZEY0VJc1QwRkJUenR2UWtGRFVDeE5RVUZOTzI5Q1FVTk9MRTlCUVU4c1JVRkJSU3hUUVVGVE8ybENRVU55UWl4RFFVRkRPMWxCUTA0c1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFNDeEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXp0WlFVTjRReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUYxUWp0blFrRkROVUlzU1VGQlNTeEZRVUZGTEdkQ1FVRm5RanRoUVVONlFpeERRVUZETEVOQlFVTTdXVUZEU0N4UFFVRlBMRTlCUVU4c1EwRkJRenRSUVVOdVFpeERRVUZETEVOQlFVTTdVVUZEUml4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETzBsQlF6bENMRU5CUVVNN1NVRkhUeXhKUVVGSkxFTkJRVU1zU1VGQlV5eEZRVUZGTEZkQlFXdENMRVZCUVVVN1VVRkRlRU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzBsQlEyeEVMRU5CUVVNN1NVRkZUeXh2UWtGQmIwSXNRMEZCUXl4SlFVRm5RenRSUVVONlJDeE5RVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRM1JFTEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlF5OUNMRU5CUVVNN1NVRkhZU3gxUWtGQmRVSXNRMEZCUXl4SFFVRjFRanM3V1VGRGVrUXNTVUZCU1N3clFrRkJiMElzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1owSkJRMmhETEU5QlFVOHNUVUZCVFN4SlFVRkpMRU5CUVVNc2QwSkJRWGRDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdZVUZEY0VVN2FVSkJRVTBzU1VGQlNTdzJRa0ZCYTBJc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVTdaMEpCUTNKRExFOUJRVThzVFVGQlRTeEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNSVUZCUlN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WVVGRGJFVTdhVUpCUVUwN1owSkJRMGdzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4clEwRkJhME1zUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRU5CUVVNN1lVRkRiRVU3VVVGRFRDeERRVUZETzB0QlFVRTdTVUZGWVN4M1FrRkJkMElzUTBGQlF5eE5RVUZqTEVWQlFVVXNTVUZCZVVJN08xbEJRelZGTEUxQlFVMHNUMEZCVHl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU0xUkN4TlFVRk5MRXRCUVVzc1IwRkJSeXhOUVVGTkxFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTFSU3hOUVVGTkxFMUJRVTBzUjBGQk5rSTdaMEpCUTNKRExFbEJRVWtzUlVGQlJTeHZRa0ZCYjBJN1owSkJRekZDTEUxQlFVMDdaMEpCUTA0c1RVRkJUU3hGUVVGRkxFdEJRVXM3WVVGRGFFSXNRMEZCUXp0WlFVTkdMRTlCUVU4c1RVRkJUU3hEUVVGRE8xRkJRMnhDTEVOQlFVTTdTMEZCUVR0SlFVVmhMSE5DUVVGelFpeERRVUZETEUxQlFXTXNSVUZCUlN4SlFVRjFRanM3V1VGRGVFVXNUVUZCVFN4UFFVRlBMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFsQlF6VkVMRTFCUVUwc1JVRkJSU3hIUVVGaExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXpSU3hOUVVGTkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVWQlFVVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRka1FzVFVGQlRTeE5RVUZOTEVkQlFUWkNPMmRDUVVOeVF5eEpRVUZKTEVWQlFVVXNiMEpCUVc5Q08yZENRVU14UWl4TlFVRk5PMmRDUVVOT0xFMUJRVTBzUlVGQlJTeExRVUZMTzJGQlEyaENMRU5CUVVNN1dVRkRSaXhQUVVGUExFMUJRVTBzUTBGQlF6dFJRVU5zUWl4RFFVRkRPMHRCUVVFN1NVRnRRbUVzYTBKQlFXdENMRU5CUVVNc1UwRkJhVUk3TzFsQlF6bERMRWxCUVVrc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eEhRVUZITEVOQlFVTXNVMEZCVXl4RFFVRkRMRVZCUVVVN1owSkJRM0pETEU5QlFVOHNTVUZCU1N4RFFVRkRMR1ZCUVdVc1EwRkJReXhIUVVGSExFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdZVUZET1VNN1dVRkRSQ3hOUVVGTkxGZEJRVmNzUjBGQlJ5dzJRMEZCY1VJc1EwRkJReXh2UWtGQmIwSXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRaUVVNeFJTeE5RVUZOTEZkQlFWY3NSMEZCUnl4SlFVRkpMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEYkVRc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eEhRVUZITEVOQlFVTXNVMEZCVXl4RlFVRkZMRmRCUVZjc1EwRkJReXhEUVVGRE8xbEJRMnBFTEUxQlFVMHNWMEZCVnl4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xbEJReTlDTEU5QlFVOHNWMEZCVnl4RFFVRkRPMUZCUTNaQ0xFTkJRVU03UzBGQlFUdEpRVVZQTEdWQlFXVXNRMEZCUXl4UFFVRmxMRVZCUVVVc1JVRkJWVHRSUVVNdlF5eE5RVUZOTEZGQlFWRXNSMEZCUnl4UFFVRlBMRU5CUVVNc1kwRkJZeXhEUVVGRExHOUNRVUZ2UWl4RlFVRkZMRTlCUVU4c1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dFJRVU51Uml4UFFVRlBMRkZCUVZFc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU40UWl4RFFVRkRPME5CUlVvN1FVRXZTa1FzYjBOQkswcERJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcclxuY29uc3QgV29ya2VyQ29udGV4dFJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9Xb3JrZXJDb250ZXh0UmVnaXN0cnlcIik7XHJcbmNvbnN0IFN1YmplY3RfMSA9IHJlcXVpcmUoXCJyeGpzL1N1YmplY3RcIik7XHJcbmNvbnN0IHNoYTEgPSByZXF1aXJlKFwic2hhMVwiKTtcclxuY2xhc3MgV29ya2VyQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXJQYXRoLCBpbml0RGF0YSwgaW5pdFRyYW5zZmVyID0gW10pIHtcclxuICAgICAgICB0aGlzLndvcmtlclBhdGggPSB3b3JrZXJQYXRoO1xyXG4gICAgICAgIHRoaXMuX2luaXRNZXNzYWdlUXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLl93b3JrZXJNZXNzYWdlcyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xyXG4gICAgICAgIHRoaXMuX2NoYW5uZWxNZXNzYWdlcyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xyXG4gICAgICAgIHRoaXMuX2NhbGxJZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0Q2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fY2FsbFByb21pc2VzID0ge307XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhY2hlUHJvbWlzZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0Q2FsbGVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclBhdGgpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShpbml0RGF0YSwgaW5pdFRyYW5zZmVyKTtcclxuICAgIH1cclxuICAgIGdldCB3b3JrZXJNZXNzYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyTWVzc2FnZXMuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgY2hhbm5lbE1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsTWVzc2FnZXMuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGluaXREYXRhLCBpbml0VHJhbnNmZXIpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhID09PSAnV09SS0VSX0lOSVRJQUxJWkVEJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbml0TWVzc2FnZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnID0gdGhpcy5faW5pdE1lc3NhZ2VRdWV1ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoYXJnWzBdLCBhcmdbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyTWVzc2FnZXMubmV4dChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcclxuICAgICAgICB0aGlzLl9wb3J0ID0gbWVzc2FnZUNoYW5uZWwucG9ydDE7XHJcbiAgICAgICAgdGhpcy5fcG9ydC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhbmRsZUNoYW5uZWxNZXNzYWdlKGV2ZW50LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsTWVzc2FnZXMubmV4dChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgaW5pdENvbW1hbmQgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdpbml0aWFsaXplJyxcclxuICAgICAgICAgICAgcG9ydDogbWVzc2FnZUNoYW5uZWwucG9ydDIsXHJcbiAgICAgICAgICAgIGRhdGE6IGluaXREYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoaW5pdENvbW1hbmQsIFttZXNzYWdlQ2hhbm5lbC5wb3J0MiwgLi4uaW5pdFRyYW5zZmVyXSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDaGFubmVsTWVzc2FnZShtc2cpIHtcclxuICAgICAgICBpZiAobWVzc2FnZXNfMS5pc1dvcmtlckNhbGxSZXN1bHRNZXNzYWdlKG1zZykpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVXb3JrZXJDYWxsUmVzdWx0KG1zZyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQ2FjaGVLZXkoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShhcmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNoYTEoZGF0YVN0cik7XHJcbiAgICB9XHJcbiAgICBoYXNDYWNoZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0Q2FjaGUuaGFzKGtleSk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWNoZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0Q2FjaGUuZ2V0KGtleSk7XHJcbiAgICB9XHJcbiAgICBzZXRDYWNoZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0Q2FjaGUuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlV29ya2VyQ2FsbFJlc3VsdChkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2NhbGxQcm9taXNlc1tkYXRhLmNhbGxJZF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxQcm9taXNlc1tkYXRhLmNhbGxJZF07XHJcbiAgICAgICAgaWYgKHByb21pc2UuY2FjaGVLZXkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdDYWNoZVByb21pc2VzW3Byb21pc2UuY2FjaGVLZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YS5lcnJvcikge1xyXG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChkYXRhLnJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocHJvbWlzZS5jYWNoZUtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDYWNoZShwcm9taXNlLmNhY2hlS2V5LCBkYXRhLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGRhdGEucmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kKGRhdGEsIHRyYW5zZmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0TWVzc2FnZVF1ZXVlLnB1c2goW2RhdGEsIHRyYW5zZmVyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3J0LnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWxsKGRhdGEsIGNhY2hlUmVzdWx0ID0gdHJ1ZSwgdHJhbnNmZXIpIHtcclxuICAgICAgICBjb25zdCBjYWxsSWQgPSB0aGlzLl9jYWxsSWQrKztcclxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlUmVzdWx0ID8gdGhpcy5jb21wdXRlQ2FjaGVLZXkoZGF0YSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGNhY2hlUmVzdWx0ICYmIHRoaXMuaGFzQ2FjaGUoY2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXModGhpcy5nZXRDYWNoZShjYWNoZUtleSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhY2hlUmVzdWx0ICYmIHRoaXMuX3BlbmRpbmdDYWNoZVByb21pc2VzW2NhY2hlS2V5XSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NhY2hlUHJvbWlzZXNbY2FjaGVLZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsUHJvbWlzZXNbY2FsbElkXSA9IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICByZWplY3QsXHJcbiAgICAgICAgICAgICAgICBjYWNoZUtleVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNlbmQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlci1jYWxsJyxcclxuICAgICAgICAgICAgICAgIGNhbGxJZCxcclxuICAgICAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNhY2hlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWNoZVByb21pc2VzW2NhY2hlS2V5XSA9IHByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJvcGVydHkoY29udGV4dCwgcHJvcGVydHlJZCwgY2FjaGVSZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBjYWxsID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnZ2V0LXByb3BlcnR5JyxcclxuICAgICAgICAgICAgY29udGV4dDogV29ya2VyQ29udGV4dFJlZ2lzdHJ5XzEuV29ya2VyQ29udGV4dFJlZ2lzdHJ5LmdldENvbnRleHRDYWxsZXJJZChjb250ZXh0KSxcclxuICAgICAgICAgICAgcHJvcGVydHlJZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsLCBjYWNoZVJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBjYWxsTWV0aG9kKGNvbnRleHQsIG1ldGhvZElkLCBhcmdzLCBjYWNoZVJlc3VsdCwgdHJhbnNmZXIpIHtcclxuICAgICAgICBjb25zdCBjYWxsID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnY2FsbC1tZXRob2QnLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBXb3JrZXJDb250ZXh0UmVnaXN0cnlfMS5Xb3JrZXJDb250ZXh0UmVnaXN0cnkuZ2V0Q29udGV4dENhbGxlcklkKGNvbnRleHQpLFxyXG4gICAgICAgICAgICBtZXRob2RJZCxcclxuICAgICAgICAgICAgYXJnc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsLCBjYWNoZVJlc3VsdCwgdHJhbnNmZXIpO1xyXG4gICAgfVxyXG4gICAgYWRkQ2FsbENvbnRleHQoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRDYWxsZXJzLmFkZChjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNhbGxDb250ZXh0KGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0Q2FsbGVycy5kZWxldGUoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICB0cnlEaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0Q2FsbGVycy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0TWVzc2FnZVF1ZXVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsUHJvbWlzZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWNoZVByb21pc2VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLldvcmtlckNvbnRleHQgPSBXb3JrZXJDb250ZXh0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lWMjl5YTJWeVEyOXVkR1Y0ZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJbGR2Y210bGNrTnZiblJsZUhRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZIUVN3d1EwRkpjVUk3UVVGRGNrSXNiVVZCUVdkRk8wRkJSV2hGTERCRFFVRjFRenRCUVVkMlF5dzJRa0ZCTmtJN1FVRkZOMEk3U1VFeVFra3NXVUZCTWtJc1ZVRkJhMElzUlVGQlJTeFJRVUZqTEVWQlFVVXNaVUZCYzBJc1JVRkJSVHRSUVVFMVJDeGxRVUZWTEVkQlFWWXNWVUZCVlN4RFFVRlJPMUZCY0VKeVF5eHpRa0ZCYVVJc1IwRkJjMElzUlVGQlJTeERRVUZETzFGQlF6RkRMRzlDUVVGbExFZEJRV2xDTEVsQlFVa3NhVUpCUVU4c1JVRkJSU3hEUVVGRE8xRkJRemxETEhGQ1FVRm5RaXhIUVVGcFFpeEpRVUZKTEdsQ1FVRlBMRVZCUVVVc1EwRkJRenRSUVVVdlF5eFpRVUZQTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTFvc2FVSkJRVmtzUjBGQmNVSXNTVUZCU1N4SFFVRkhMRVZCUVdVc1EwRkJRenRSUVVONFJDeHJRa0ZCWVN4SFFVRXJSU3hGUVVGRkxFTkJRVU03VVVGREwwWXNNRUpCUVhGQ0xFZEJRVzlETEVWQlFVVXNRMEZCUXp0UlFVYzFSQ3h2UWtGQlpTeEhRVUUwUWl4SlFVRkpMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJWM3BFTEVsQlFVa3NRMEZCUXl4UFFVRlBMRWRCUVVjc1NVRkJTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdVVUZEZEVNc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eFJRVUZSTEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNN1NVRkROVU1zUTBGQlF6dEpRVmhFTEVsQlFWY3NZMEZCWXp0UlFVTnlRaXhQUVVGUExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNXVUZCV1N4RlFVRkZMRU5CUVVNN1NVRkRMME1zUTBGQlF6dEpRVVZFTEVsQlFWY3NaVUZCWlR0UlFVTjBRaXhQUVVGUExFbEJRVWtzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhaUVVGWkxFVkJRVVVzUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCVDA4c1ZVRkJWU3hEUVVGRExGRkJRV0VzUlVGQlJTeFpRVUZ0UWp0UlFVTnFSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNSMEZCUnl4RFFVRkRMRXRCUVVzc1JVRkJSU3hGUVVGRk8xbEJReTlDTEVsQlFVa3NTMEZCU3l4RFFVRkRMRWxCUVVrc1MwRkJTeXh2UWtGQmIwSXNSVUZCUlR0blFrRkRja01zU1VGQlNTeERRVUZETEZsQlFWa3NSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRM3BDTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMjlDUVVOd1JDeE5RVUZOTEVkQlFVY3NSMEZCUnl4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRM1JETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8ybENRVU0zUWp0aFFVTktPMmxDUVVGTk8yZENRVU5JTEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0aFFVTjZRenRSUVVOTUxFTkJRVU1zUTBGQlF6dFJRVVZHTEUxQlFVMHNZMEZCWXl4SFFVRkhMRWxCUVVrc1kwRkJZeXhGUVVGRkxFTkJRVU03VVVGRE5VTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhqUVVGakxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlJXeERMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVVN1dVRkROMElzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1owSkJRM2hETEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yRkJRekZETzFGQlEwd3NRMEZCUXl4RFFVRkRPMUZCUlVZc1RVRkJUU3hYUVVGWExFZEJRWFZDTzFsQlEzQkRMRWxCUVVrc1JVRkJSU3haUVVGWk8xbEJRMnhDTEVsQlFVa3NSVUZCUlN4alFVRmpMRU5CUVVNc1MwRkJTenRaUVVNeFFpeEpRVUZKTEVWQlFVVXNVVUZCVVR0VFFVTnFRaXhEUVVGRE8xRkJSVVlzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4WFFVRlhMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU1zWTBGQll5eERRVUZETEV0QlFVc3NSVUZCUlN4SFFVRkhMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGJrWXNRMEZCUXp0SlFVVlBMRzlDUVVGdlFpeERRVUZETEVkQlFWRTdVVUZEYWtNc1NVRkJTU3h2UTBGQmVVSXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVOb1F5eEpRVUZKTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZEYWtNc1QwRkJUeXhKUVVGSkxFTkJRVU03VTBGRFpqdFJRVU5FTEU5QlFVOHNTMEZCU3l4RFFVRkRPMGxCUTJwQ0xFTkJRVU03U1VGRlR5eGxRVUZsTEVOQlFVTXNSMEZCUnl4SlFVRkpPMUZCUXpOQ0xFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RlFVRkZPMWxCUTJoRUxFOUJRVThzUzBGQlN5eERRVUZETzFGQlEycENMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMGdzVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRla0lzUTBGQlF6dEpRVVZQTEZGQlFWRXNRMEZCUXl4SFFVRlhPMUZCUTNoQ0xFOUJRVThzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRGRFTXNRMEZCUXp0SlFVVlBMRkZCUVZFc1EwRkJReXhIUVVGWE8xRkJRM2hDTEU5QlFVOHNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZEZEVNc1EwRkJRenRKUVVWUExGRkJRVkVzUTBGQlF5eEhRVUZYTEVWQlFVVXNTMEZCVlR0UlFVTndReXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRGRFTXNRMEZCUXp0SlFVVlBMSE5DUVVGelFpeERRVUZETEVsQlFUaENPMUZCUTNwRUxFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEyaEVMRTlCUVU4c1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkZka01zU1VGQlNTeFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZPMWxCUTJ4Q0xFOUJRVThzU1VGQlNTeERRVUZETEhGQ1FVRnhRaXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0VFFVTjJSRHRSUVVWRUxFbEJRVWtzU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlR0WlFVTmFMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMU5CUXk5Q08yRkJRVTA3V1VGRFNDeEpRVUZKTEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVN1owSkJRMnhDTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUlVGQlJTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1lVRkRhRVE3V1VGRFJDeFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFRRVU5vUXp0SlFVTk1MRU5CUVVNN1NVRkZUU3hKUVVGSkxFTkJRVU1zU1VGQlV5eEZRVUZGTEZGQlFXZENPMUZCUTI1RExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNXVUZCV1N4RlFVRkZPMWxCUTNCQ0xFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOcVJEdGhRVUZOTzFsQlEwZ3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU1zU1VGQlNTeEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMU5CUXpGRE8wbEJRMHdzUTBGQlF6dEpRVVZOTEVsQlFVa3NRMEZCVlN4SlFVRlRMRVZCUVVVc1YwRkJWeXhIUVVGSExFbEJRVWtzUlVGQlJTeFJRVUZuUWp0UlFVTm9SU3hOUVVGTkxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkRPVUlzVFVGQlRTeFJRVUZSTEVkQlFVY3NWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhUUVVGVExFTkJRVU03VVVGRmRFVXNTVUZCU1N4WFFVRlhMRWxCUVVrc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlR0WlFVTjRReXhQUVVGUExFbEJRVWtzVDBGQlR5eERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRVZCUVVVN1owSkJRM1pDTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtNc1EwRkJReXhEUVVGRExFTkJRVU03VTBGRFRqdFJRVVZFTEVsQlFVa3NWMEZCVnl4SlFVRkpMRWxCUVVrc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSVHRaUVVOeVJDeFBRVUZQTEVsQlFVa3NRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0VFFVTXZRenRSUVVWRUxFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NUMEZCVHl4RFFVRlZMRU5CUVVNc1QwRkJUeXhGUVVGRkxFMUJRVTBzUlVGQlJTeEZRVUZGTzFsQlEzSkVMRWxCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVYzdaMEpCUTNwQ0xFOUJRVTg3WjBKQlExQXNUVUZCVFR0blFrRkRUaXhSUVVGUk8yRkJRMWdzUTBGQlF6dFpRVU5HTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVhGQ08yZENRVU14UWl4SlFVRkpMRVZCUVVVc1lVRkJZVHRuUWtGRGJrSXNUVUZCVFR0blFrRkRUaXhKUVVGSk8yRkJRMUFzUTBGQlF5eERRVUZETzFGQlExQXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRTQ3hKUVVGSkxGZEJRVmNzUlVGQlJUdFpRVU5pTEVsQlFVa3NRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4UFFVRlBMRU5CUVVNN1UwRkRiRVE3VVVGRFJDeFBRVUZQTEU5QlFVOHNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVTBzVjBGQlZ5eERRVUZWTEU5QlFUSkNMRVZCUVVVc1ZVRkJhMElzUlVGQlJTeFhRVUZ4UWp0UlFVTTVSaXhOUVVGTkxFbEJRVWtzUjBGQmQwSTdXVUZET1VJc1NVRkJTU3hGUVVGRkxHTkJRV003V1VGRGNFSXNUMEZCVHl4RlFVRkZMRFpEUVVGeFFpeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFOUJRVThzUTBGQlF6dFpRVU14UkN4VlFVRlZPMU5CUTJJc1EwRkJRenRSUVVOR0xFOUJRVThzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRVZCUVVVc1YwRkJWeXhEUVVGRExFTkJRVU03U1VGRGVFTXNRMEZCUXp0SlFVTk5MRlZCUVZVc1EwRkRZaXhQUVVFeVFpeEZRVUZGTEZGQlFXZENMRVZCUVVVc1NVRkJXU3hGUVVGRkxGZEJRWEZDTEVWQlFVVXNVVUZCWjBJN1VVRkZjRWNzVFVGQlRTeEpRVUZKTEVkQlFYTkNPMWxCUXpWQ0xFbEJRVWtzUlVGQlJTeGhRVUZoTzFsQlEyNUNMRTlCUVU4c1JVRkJSU3cyUTBGQmNVSXNRMEZCUXl4clFrRkJhMElzUTBGQlF5eFBRVUZQTEVOQlFVTTdXVUZETVVRc1VVRkJVVHRaUVVOU0xFbEJRVWs3VTBGRFVDeERRVUZETzFGQlEwWXNUMEZCVHl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUlVGQlJTeFhRVUZYTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNN1NVRkRiRVFzUTBGQlF6dEpRVVZOTEdOQlFXTXNRMEZCUXl4UFFVRXlRanRSUVVNM1F5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUTAwc2FVSkJRV2xDTEVOQlFVTXNUMEZCTWtJN1VVRkRhRVFzU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGVrTXNRMEZCUXp0SlFVVk5MRlZCUVZVN1VVRkRZaXhKUVVGSkxFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNTVUZCU1N4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVNdlFpeFBRVUZQTEV0QlFVc3NRMEZCUXp0VFFVTm9RanRSUVVORUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0UlFVTm1MRTlCUVU4c1NVRkJTU3hEUVVGRE8wbEJRMmhDTEVOQlFVTTdTVUZGVFN4UFFVRlBPMUZCUTFZc1NVRkJTU3hKUVVGSkxFTkJRVU1zVDBGQlR5eEZRVUZGTzFsQlEyUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFpRVU42UWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExGTkJRVk1zUTBGQlF6dFpRVU42UWl4SlFVRkpMRU5CUVVNc1dVRkJXU3hIUVVGSExFdEJRVXNzUTBGQlF6dFpRVU14UWl4SlFVRkpMRU5CUVVNc1MwRkJTeXhIUVVGSExGTkJRVk1zUTBGQlF6dFpRVU4yUWl4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVkQlFVY3NVMEZCVXl4RFFVRkRPMWxCUTI1RExFbEJRVWtzUTBGQlF5eGhRVUZoTEVkQlFVY3NVMEZCVXl4RFFVRkRPMWxCUXk5Q0xFbEJRVWtzUTBGQlF5eHhRa0ZCY1VJc1IwRkJSeXhUUVVGVExFTkJRVU03VTBGRE1VTTdTVUZEVEN4RFFVRkRPME5CUTBvN1FVRnNUVVFzYzBOQmEwMURJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcclxucmVxdWlyZShcInJlZmxlY3QtbWV0YWRhdGFcIik7XHJcbmNsYXNzIFdvcmtlckNvbnRleHRSZWdpc3RyeSB7XHJcbiAgICBzdGF0aWMgcmVnaXN0ZXJDb250ZXh0Q2FsbGVyKHR5cGUpIHtcclxuICAgICAgICBjb25zdCBpZCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ3dvcmtlckNvbnRleHQ6dHlwZUlkJywgdHlwZSk7XHJcbiAgICAgICAgaWYgKFdvcmtlckNvbnRleHRSZWdpc3RyeS5fY29udGV4dENhbGxlcnMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWdUeXBlID0gV29ya2VyQ29udGV4dFJlZ2lzdHJ5Ll9jb250ZXh0Q2FsbGVycy5nZXQoaWQpO1xyXG4gICAgICAgICAgICBpZiAocmVnVHlwZSAhPT0gdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgVHlwZUlkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFdvcmtlckNvbnRleHRSZWdpc3RyeS5fY29udGV4dENhbGxlcnMuc2V0KGlkLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0Q29udGV4dENhbGxlcklkKHR5cGUpIHtcclxuICAgICAgICBpZiAoIXR5cGVzXzEuaXNUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ3dvcmtlckNvbnRleHQ6dHlwZUlkJywgdHlwZSk7XHJcbiAgICAgICAgaWYgKFdvcmtlckNvbnRleHRSZWdpc3RyeS5fY29udGV4dENhbGxlcnMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldENvbnRleHRDYWxsZXJCeUlkKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIFdvcmtlckNvbnRleHRSZWdpc3RyeS5fY29udGV4dENhbGxlcnMuZ2V0KGlkKTtcclxuICAgIH1cclxufVxyXG5Xb3JrZXJDb250ZXh0UmVnaXN0cnkuX2NvbnRleHRDYWxsZXJzID0gbmV3IE1hcCgpO1xyXG5leHBvcnRzLldvcmtlckNvbnRleHRSZWdpc3RyeSA9IFdvcmtlckNvbnRleHRSZWdpc3RyeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVjI5eWEyVnlRMjl1ZEdWNGRGSmxaMmx6ZEhKNUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpVjI5eWEyVnlRMjl1ZEdWNGRGSmxaMmx6ZEhKNUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFc01FTkJRVGhETzBGQlJ6bERMRFJDUVVFd1FqdEJRVVV4UWp0SlFVbFhMRTFCUVUwc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4SlFVRTRRanRSUVVNNVJDeE5RVUZOTEVWQlFVVXNSMEZCVnl4UFFVRlBMRU5CUVVNc1kwRkJZeXhEUVVGRExITkNRVUZ6UWl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM2hGTEVsQlFVa3NjVUpCUVhGQ0xFTkJRVU1zWlVGQlpTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSVHRaUVVNdlF5eE5RVUZOTEU5QlFVOHNSMEZCUnl4eFFrRkJjVUlzUTBGQlF5eGxRVUZsTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRemxFTEVsQlFVa3NUMEZCVHl4TFFVRkxMRWxCUVVrc1JVRkJSVHRuUWtGRGJFSXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4RFFVRkRPMkZCUTNaRE8xTkJRMG83WVVGQlRUdFpRVU5JTEhGQ1FVRnhRaXhEUVVGRExHVkJRV1VzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xTkJRM1pFTzBsQlEwd3NRMEZCUXp0SlFVVk5MRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4SlFVRnRSRHRSUVVOb1JpeEpRVUZKTEVOQlFVTXNZMEZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRk8xbEJRMllzU1VGQlNTeEhRVUZSTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNN1UwRkRhRU03VVVGRFJDeE5RVUZOTEVWQlFVVXNSMEZCVnl4UFFVRlBMRU5CUVVNc1kwRkJZeXhEUVVGRExITkNRVUZ6UWl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM2hGTEVsQlFVa3NjVUpCUVhGQ0xFTkJRVU1zWlVGQlpTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSVHRaUVVNdlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0VFFVTmlPMGxCUTB3c1EwRkJRenRKUVVWTkxFMUJRVTBzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhGUVVGVk8xRkJRM3BETEU5QlFVOHNjVUpCUVhGQ0xFTkJRVU1zWlVGQlpTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVONlJDeERRVUZET3p0QlFUTkNZeXh4UTBGQlpTeEhRVUV3UXl4SlFVRkpMRWRCUVVjc1JVRkJSU3hEUVVGRE8wRkJSSFJHTEhORVFUaENReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgUHJveGlhYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlByb3hpYWJsZUVycm9yID0gUHJveGlhYmxlRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVVISnZlR2xoWW14bFJYSnliM0l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SlFjbTk0YVdGaWJHVkZjbkp2Y2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEc5Q1FVRTBRaXhUUVVGUkxFdEJRVXM3U1VGRGNrTXNXVUZCV1N4SlFVRlhMRVZCUVVVc1QwRkJaVHRSUVVOd1F5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRaaXhKUVVGSkxFTkJRVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTnlRaXhEUVVGRE8wTkJRMG83UVVGTVJDeDNRMEZMUXlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZXNzYWdlc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1JlcGxheUNvbnRleHRDYWxsZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9SZXBsYXlXb3JrZXJcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3p0QlFVRkJMR2REUVVFeVFqdEJRVU16UWl3eVEwRkJjME03UVVGRGRFTXNiME5CUVN0Q0luMD0iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBpc1dvcmtlckNhbGxNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuICEhb2JqICYmIG9iai50eXBlID09PSAnd29ya2VyLWNhbGwnICYmIHR5cGVvZiBvYmouY2FsbElkID09PSAnbnVtYmVyJyAmJiAnZGF0YScgaW4gb2JqO1xyXG59XHJcbmV4cG9ydHMuaXNXb3JrZXJDYWxsTWVzc2FnZSA9IGlzV29ya2VyQ2FsbE1lc3NhZ2U7XHJcbmZ1bmN0aW9uIGlzV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2Uob2JqKSB7XHJcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLnR5cGUgPT09ICd3b3JrZXItY2FsbC1yZXN1bHQnICYmIHR5cGVvZiBvYmouY2FsbElkID09PSAnbnVtYmVyJztcclxufVxyXG5leHBvcnRzLmlzV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2UgPSBpc1dvcmtlckNhbGxSZXN1bHRNZXNzYWdlO1xyXG5mdW5jdGlvbiBpc1dvcmtlclByb3BlcnR5Q2FsbChvYmopIHtcclxuICAgIHJldHVybiAhIW9iaiAmJiBvYmoudHlwZSA9PT0gJ2dldC1wcm9wZXJ0eScgJiYgdHlwZW9mIG9iai5jb250ZXh0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb2JqLnByb3BlcnR5SWQgPT09ICdudW1iZXInO1xyXG59XHJcbmV4cG9ydHMuaXNXb3JrZXJQcm9wZXJ0eUNhbGwgPSBpc1dvcmtlclByb3BlcnR5Q2FsbDtcclxuZnVuY3Rpb24gaXNXb3JrZXJNZXRob2RDYWxsKG9iaikge1xyXG4gICAgcmV0dXJuICEhb2JqICYmIG9iai50eXBlID09PSAnY2FsbC1tZXRob2QnICYmIHR5cGVvZiBvYmouY29udGV4dCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iai5tZXRob2RJZCA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc1dvcmtlck1ldGhvZENhbGwgPSBpc1dvcmtlck1ldGhvZENhbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyRnNiQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYkltTmhiR3d1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRk5RU3cyUWtGQmIwTXNSMEZCVVR0SlFVTjRReXhQUVVGUExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSMEZCUnl4RFFVRkRMRWxCUVVrc1MwRkJTeXhoUVVGaExFbEJRVWtzVDBGQlR5eEhRVUZITEVOQlFVTXNUVUZCVFN4TFFVRkxMRkZCUVZFc1NVRkJTU3hOUVVGTkxFbEJRVWtzUjBGQlJ5eERRVUZETzBGQlEyeEhMRU5CUVVNN1FVRkdSQ3hyUkVGRlF6dEJRVlZFTEcxRFFVRXdReXhIUVVGUk8wbEJRemxETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hIUVVGSExFTkJRVU1zU1VGQlNTeExRVUZMTEc5Q1FVRnZRaXhKUVVGSkxFOUJRVThzUjBGQlJ5eERRVUZETEUxQlFVMHNTMEZCU3l4UlFVRlJMRU5CUVVNN1FVRkRlRVlzUTBGQlF6dEJRVVpFTERoRVFVVkRPMEZCVTBRc09FSkJRWEZETEVkQlFWRTdTVUZEZWtNc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVkQlFVY3NRMEZCUXl4SlFVRkpMRXRCUVVzc1kwRkJZeXhKUVVGSkxFOUJRVThzUjBGQlJ5eERRVUZETEU5QlFVOHNTMEZCU3l4UlFVRlJMRWxCUVVrc1QwRkJUeXhIUVVGSExFTkJRVU1zVlVGQlZTeExRVUZMTEZGQlFWRXNRMEZCUXp0QlFVTjZTQ3hEUVVGRE8wRkJSa1FzYjBSQlJVTTdRVUZUUkN3MFFrRkJiVU1zUjBGQlVUdEpRVU4yUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUjBGQlJ5eERRVUZETEVsQlFVa3NTMEZCU3l4aFFVRmhMRWxCUVVrc1QwRkJUeXhIUVVGSExFTkJRVU1zVDBGQlR5eExRVUZMTEZGQlFWRXNTVUZCU1N4UFFVRlBMRWRCUVVjc1EwRkJReXhSUVVGUkxFdEJRVXNzVVVGQlVTeERRVUZETzBGQlEzUklMRU5CUVVNN1FVRkdSQ3huUkVGRlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBpc1dvcmtlckNvbW1hbmQob2JqKSB7XHJcbiAgICByZXR1cm4gJ3R5cGUnIGluIG9iaiAmJiAnbWVzc2FnZUlkJyBpbiBvYmpcclxuICAgICAgICAmJiB0eXBlb2Ygb2JqLm1lc3NhZ2VJZCA9PT0gJ251bWJlcidcclxuICAgICAgICAmJiB0eXBlb2Ygb2JqLmNvbnRleHQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvYmouaWQgPT09ICdudW1iZXInO1xyXG59XHJcbmV4cG9ydHMuaXNXb3JrZXJDb21tYW5kID0gaXNXb3JrZXJDb21tYW5kO1xyXG5mdW5jdGlvbiBpc1dvcmtlckdldFByb3BlcnR5Q29tbWFuZChvYmopIHtcclxuICAgIHJldHVybiBpc1dvcmtlckNvbW1hbmQob2JqKSAmJiBvYmoudHlwZSA9PT0gJ3Byb3BlcnR5JztcclxufVxyXG5leHBvcnRzLmlzV29ya2VyR2V0UHJvcGVydHlDb21tYW5kID0gaXNXb3JrZXJHZXRQcm9wZXJ0eUNvbW1hbmQ7XHJcbmZ1bmN0aW9uIGlzV29ya2VyQ2FsbE1ldGhvZENvbW1hbmQob2JqKSB7XHJcbiAgICByZXR1cm4gaXNXb3JrZXJDb21tYW5kKG9iaikgJiYgb2JqLnR5cGUgPT09ICdtZXRob2QnO1xyXG59XHJcbmV4cG9ydHMuaXNXb3JrZXJDYWxsTWV0aG9kQ29tbWFuZCA9IGlzV29ya2VyQ2FsbE1ldGhvZENvbW1hbmQ7XHJcbmZ1bmN0aW9uIGlzV29ya2VyQ29tbWFuZFJlc3VsdChvYmopIHtcclxuICAgIHJldHVybiBvYmoudHlwZSA9PT0gJ2NvbW1hbmQtcmVzdWx0JyAmJiB0eXBlb2Ygb2JqLm1lc3NhZ2VJZCA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc1dvcmtlckNvbW1hbmRSZXN1bHQgPSBpc1dvcmtlckNvbW1hbmRSZXN1bHQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyMWtjeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYkltTnRaSE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRlBRU3g1UWtGQlowTXNSMEZCVVR0SlFVTndReXhQUVVGUExFMUJRVTBzU1VGQlNTeEhRVUZITEVsQlFVa3NWMEZCVnl4SlFVRkpMRWRCUVVjN1YwRkRia01zVDBGQlR5eEhRVUZITEVOQlFVTXNVMEZCVXl4TFFVRkxMRkZCUVZFN1YwRkRha01zVDBGQlR5eEhRVUZITEVOQlFVTXNUMEZCVHl4TFFVRkxMRkZCUVZFc1NVRkJTU3hQUVVGUExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NVVUZCVVN4RFFVRkRPMEZCUTNwRkxFTkJRVU03UVVGS1JDd3dRMEZKUXp0QlFVOUVMRzlEUVVFeVF5eEhRVUZSTzBsQlF5OURMRTlCUVU4c1pVRkJaU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVkQlFVY3NRMEZCUXl4SlFVRkpMRXRCUVVzc1ZVRkJWU3hEUVVGRE8wRkJRek5FTEVOQlFVTTdRVUZHUkN4blJVRkZRenRCUVZGRUxHMURRVUV3UXl4SFFVRlJPMGxCUXpsRExFOUJRVThzWlVGQlpTeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRWRCUVVjc1EwRkJReXhKUVVGSkxFdEJRVXNzVVVGQlVTeERRVUZETzBGQlEzcEVMRU5CUVVNN1FVRkdSQ3c0UkVGRlF6dEJRVlZFTEN0Q1FVRnpReXhIUVVGUk8wbEJRekZETEU5QlFVOHNSMEZCUnl4RFFVRkRMRWxCUVVrc1MwRkJTeXhuUWtGQlowSXNTVUZCU1N4UFFVRlBMRWRCUVVjc1EwRkJReXhUUVVGVExFdEJRVXNzVVVGQlVTeERRVUZETzBGQlF6bEZMRU5CUVVNN1FVRkdSQ3h6UkVGRlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vaW5pdFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Byb3RvY29sXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vY21kc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXR1c1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NhbGxcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3p0QlFVRkJMRFJDUVVGMVFqdEJRVU4yUWl4blEwRkJNa0k3UVVGRE0wSXNORUpCUVhWQ08wRkJRM1pDTERoQ1FVRjVRanRCUVVONlFpdzBRa0ZCZFVJaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBpc0luaXRpYWxpemVDb21tYW5kKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnaW5pdGlhbGl6ZScgJiYgb2JqLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJiBvYmoucG9ydCBpbnN0YW5jZW9mIE1lc3NhZ2VQb3J0O1xyXG59XHJcbmV4cG9ydHMuaXNJbml0aWFsaXplQ29tbWFuZCA9IGlzSW5pdGlhbGl6ZUNvbW1hbmQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNXBkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYkltbHVhWFF1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRk5RU3cyUWtGQmIwTXNSMEZCVVR0SlFVTjRReXhQUVVGUExFZEJRVWNzUTBGQlF5eEpRVUZKTEV0QlFVc3NXVUZCV1N4SlFVRkpMRWRCUVVjc1EwRkJReXhKUVVGSkxGbEJRVmtzVjBGQlZ5eEpRVUZKTEVkQlFVY3NRMEZCUXl4SlFVRkpMRmxCUVZrc1YwRkJWeXhEUVVGRE8wRkJRek5ITEVOQlFVTTdRVUZHUkN4clJFRkZReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gaXNMb2FkUHJvdG9jb2xNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnbG9hZC1wcm90b2NvbCc7XHJcbn1cclxuZXhwb3J0cy5pc0xvYWRQcm90b2NvbE1lc3NhZ2UgPSBpc0xvYWRQcm90b2NvbE1lc3NhZ2U7XHJcbmZ1bmN0aW9uIGlzTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZShvYmopIHtcclxuICAgIHJldHVybiBvYmoudHlwZSA9PT0gJ2xvYWQtcHJvdG9jb2wtcmVzdWx0JztcclxufVxyXG5leHBvcnRzLmlzTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZSA9IGlzTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZTtcclxuZnVuY3Rpb24gaXNMb2FkSGVyb0RhdGFNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnbG9hZC1oZXJvLWRhdGEnO1xyXG59XHJcbmV4cG9ydHMuaXNMb2FkSGVyb0RhdGFNZXNzYWdlID0gaXNMb2FkSGVyb0RhdGFNZXNzYWdlO1xyXG5mdW5jdGlvbiBpc0xvYWRIZXJvRGF0YVJlc3VsdE1lc3NhZ2Uob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLnR5cGUgPT09ICdsb2FkLWhlcm8tZGF0YS1yZXN1bHQnO1xyXG59XHJcbmV4cG9ydHMuaXNMb2FkSGVyb0RhdGFSZXN1bHRNZXNzYWdlID0gaXNMb2FkSGVyb0RhdGFSZXN1bHRNZXNzYWdlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljSEp2ZEc5amIyd3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKd2NtOTBiMk52YkM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVkZCTEN0Q1FVRnpReXhIUVVGUk8wbEJRekZETEU5QlFVOHNSMEZCUnl4RFFVRkRMRWxCUVVrc1MwRkJTeXhsUVVGbExFTkJRVU03UVVGRGVFTXNRMEZCUXp0QlFVWkVMSE5FUVVWRE8wRkJVMFFzY1VOQlFUUkRMRWRCUVZFN1NVRkRhRVFzVDBGQlR5eEhRVUZITEVOQlFVTXNTVUZCU1N4TFFVRkxMSE5DUVVGelFpeERRVUZETzBGQlF5OURMRU5CUVVNN1FVRkdSQ3hyUlVGRlF6dEJRVTlFTEN0Q1FVRnpReXhIUVVGUk8wbEJRekZETEU5QlFVOHNSMEZCUnl4RFFVRkRMRWxCUVVrc1MwRkJTeXhuUWtGQlowSXNRMEZCUXp0QlFVTjZReXhEUVVGRE8wRkJSa1FzYzBSQlJVTTdRVUZSUkN4eFEwRkJORU1zUjBGQlVUdEpRVU5vUkN4UFFVRlBMRWRCUVVjc1EwRkJReXhKUVVGSkxFdEJRVXNzZFVKQlFYVkNMRU5CUVVNN1FVRkRhRVFzUTBGQlF6dEJRVVpFTEd0RlFVVkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gaXNSZXBsYXlTdGF0dXNNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAncmVwbGF5LXN0YXR1cycgJiYgdHlwZW9mIG9iai5zdGF0dXMgPT09ICdzdHJpbmcnO1xyXG59XHJcbmV4cG9ydHMuaXNSZXBsYXlTdGF0dXNNZXNzYWdlID0gaXNSZXBsYXlTdGF0dXNNZXNzYWdlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1JoZEhWekxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpYzNSaGRIVnpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlQwRXNLMEpCUVhORExFZEJRVkU3U1VGRE1VTXNUMEZCVHl4SFFVRkhMRU5CUVVNc1NVRkJTU3hMUVVGTExHVkJRV1VzU1VGQlNTeFBRVUZQTEVkQlFVY3NRMEZCUXl4TlFVRk5MRXRCUVVzc1VVRkJVU3hEUVVGRE8wRkJRekZGTEVOQlFVTTdRVUZHUkN4elJFRkZReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgUmVwbGF5QXR0cmlidXRlSGVscGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcGxheUF0dHJpYnV0ZUV2ZW50cykge1xyXG4gICAgICAgIHRoaXMucmVwbGF5QXR0cmlidXRlRXZlbnRzID0gcmVwbGF5QXR0cmlidXRlRXZlbnRzO1xyXG4gICAgfVxyXG4gICAgZ2V0KHNjb3BlLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYXlBdHRyaWJ1dGVFdmVudHMuc2NvcGVzW3Njb3BlXVtrZXldWzBdLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBpY2tPcmRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoMTYsIDQwMTgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdhbWVTcGVlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoMTYsIDMwMDApO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdhbWVQcml2YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgxNiwgMzAwOSkgPT09ICdQcml2JztcclxuICAgIH1cclxuICAgIGdldCBkcmFmdE1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDE2LCA0MDEwKTtcclxuICAgIH1cclxuICAgIGdldCBiYW5UeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgxNiwgNDAyMSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYmFubmVyQ2hvb3NlTWV0aG9kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgxNiwgNDAyMik7XHJcbiAgICB9XHJcbiAgICBnZXRCYW5QbGF5ZXJTbG90KHRlYW0pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KDE2LCB0ZWFtID09PSAwID8gNDAyMiA6IDQwMjcpLnRyaW0oKTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICdIbW1yJyA/IC0xIDogcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICAgIH1cclxuICAgIGdldEJhbldhc0xvY2tlZCh0ZWFtLCBiYW4pIHtcclxuICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgIGlmICh0ZWFtID09PSAwKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGJhbiA/IDQwMjQgOiA0MDI2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAga2V5ID0gYmFuID8gNDAyOSA6IDQwMzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgxNiwga2V5KSA9PT0gJ3llcyc7XHJcbiAgICB9XHJcbiAgICBnZXRCYW4odGVhbSwgYmFuKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBpZiAodGVhbSA9PT0gMCkge1xyXG4gICAgICAgICAgICBrZXkgPSBiYW4gPyA0MDIzIDogNDAyNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGtleSA9IGJhbiA/IDQwMjggOiA0MDMwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoMTYsIGtleSk7XHJcbiAgICB9XHJcbiAgICBnZXRXYXNCYW5uZWQodGVhbSwgYmFuKSB7XHJcbiAgICAgICAgY29uc3QgYmFubmVkID0gdGhpcy5nZXRCYW4odGVhbSwgYmFuKTtcclxuICAgICAgICBpZiAoIWJhbm5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhIShiYW5uZWQudHJpbSgpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlcGxheUF0dHJpYnV0ZUhlbHBlciA9IFJlcGxheUF0dHJpYnV0ZUhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVW1Wd2JHRjVRWFIwY21saWRYUmxTR1ZzY0dWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpVW1Wd2JHRjVRWFIwY21saWRYUmxTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFN1NVRkZTU3haUVVFeVFpeHhRa0ZCTUVJN1VVRkJNVUlzTUVKQlFYRkNMRWRCUVhKQ0xIRkNRVUZ4UWl4RFFVRkxPMGxCUVVrc1EwRkJRenRKUVVWdVJDeEhRVUZITEVOQlFVTXNTMEZCWVN4RlFVRkZMRWRCUVZjN1VVRkRha01zVDBGQlR5eEpRVUZKTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXp0SlFVTnNSU3hEUVVGRE8wbEJSVVFzU1VGQlZ5eFRRVUZUTzFGQlEyaENMRTlCUVU4c1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRPVUlzUTBGQlF6dEpRVWRFTEVsQlFWY3NVMEZCVXp0UlFVTm9RaXhQUVVGUExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZGUkN4SlFVRlhMRmRCUVZjN1VVRkRiRUlzVDBGQlR5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1JVRkJSU3hKUVVGSkxFTkJRVU1zUzBGQlN5eE5RVUZOTEVOQlFVTTdTVUZEZWtNc1EwRkJRenRKUVVWRUxFbEJRVmNzVTBGQlV6dFJRVU5vUWl4UFFVRlBMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRlJDeEpRVUZYTEU5QlFVODdVVUZEWkN4UFFVRlBMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRlJDeEpRVUZYTEd0Q1FVRnJRanRSUVVONlFpeFBRVUZQTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzBsQlF6bENMRU5CUVVNN1NVRkZUU3huUWtGQlowSXNRMEZCUXl4SlFVRlpPMUZCUTJoRExFMUJRVTBzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1VVRkROVVFzVDBGQlR5eExRVUZMTEV0QlFVc3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU4yUkN4RFFVRkRPMGxCUlUwc1pVRkJaU3hEUVVGRExFbEJRVmtzUlVGQlJTeEhRVUZYTzFGQlF6VkRMRWxCUVVrc1IwRkJWeXhEUVVGRE8xRkJRMmhDTEVsQlFVa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1JVRkJSVHRaUVVOYUxFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETzFOQlF6TkNPMkZCUVUwN1dVRkRTQ3hIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF6dFRRVU16UWp0UlFVTkVMRTlCUVU4c1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVWQlFVVXNSMEZCUnl4RFFVRkRMRXRCUVVzc1MwRkJTeXhEUVVGRE8wbEJRM1pETEVOQlFVTTdTVUZGVFN4TlFVRk5MRU5CUVVNc1NVRkJXU3hGUVVGRkxFZEJRVmM3VVVGRGJrTXNTVUZCU1N4SFFVRlhMRU5CUVVNN1VVRkRhRUlzU1VGQlNTeEpRVUZKTEV0QlFVc3NRMEZCUXl4RlFVRkZPMWxCUTFvc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU03VTBGRE0wSTdZVUZCVFR0WlFVTklMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRE8xTkJRek5DTzFGQlEwUXNUMEZCVHl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTTNRaXhEUVVGRE8wbEJSVTBzV1VGQldTeERRVUZETEVsQlFWa3NSVUZCUlN4SFFVRlhPMUZCUTNwRExFMUJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETzFGQlEzUkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFVkJRVVU3V1VGRFZDeFBRVUZQTEV0QlFVc3NRMEZCUXp0VFFVTm9RanRSUVVORUxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRE4wSXNRMEZCUXp0RFFVbEtPMEZCY0VWRUxITkVRVzlGUXlKOSIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRmlsdGVyZWRFdmVudHMgPSBbXHJcbiAgICAnTk5ldC5HYW1lLlNMb2FkaW5nUHJvZ3Jlc3NNZXNzYWdlJyxcclxuICAgICdOTmV0LlJlcGxheS5UcmFja2VyLlNVbml0UG9zaXRpb25zRXZlbnQnLFxyXG4gICAgJ05OZXQuR2FtZS5TVXNlckZpbmlzaGVkTG9hZGluZ1N5bmNFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyU291bmRMZW5ndGhTeW5jRXZlbnQnLFxyXG4gICAgJ05OZXQuR2FtZS5TVHJpZ2dlck1vdXNlTW92ZWRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNDYW1lcmFVcGRhdGVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyU291bmRPZmZzZXRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNTZWxlY3Rpb25EZWx0YUV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NvbnRyb2xHcm91cFVwZGF0ZUV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NvbW1hbmRNYW5hZ2VyU3RhdGVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNDbWRVcGRhdGVUYXJnZXRQb2ludEV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NtZFVwZGF0ZVRhcmdldFVuaXRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyU291bmR0cmFja0RvbmVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyRGlhbG9nQ29udHJvbEV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU1RyaWdnZXJUcmFuc21pc3Npb25Db21wbGV0ZUV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU1RyaWdnZXJUcmFuc21pc3Npb25PZmZzZXRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyQ3V0c2NlbmVFbmRTY2VuZUZpcmVkRXZlbnQnLFxyXG4gICAgJ05OZXQuR2FtZS5TVHJpZ2dlclRhcmdldE1vZGVVcGRhdGVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNDb21tYW5kTWFuYWdlclJlc2V0RXZlbnQnLFxyXG4gICAgJ05OZXQuR2FtZS5TVHJpZ2dlcktleVByZXNzZWRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNVbml0Q2xpY2tFdmVudCcsXHJcbl07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVJtbHNkR1Z5WldSRmRtVnVkSE11YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SkdhV3gwWlhKbFpFVjJaVzUwY3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZoTEZGQlFVRXNZMEZCWXl4SFFVRmhPMGxCUTNCRExHMURRVUZ0UXp0SlFVVnVReXg1UTBGQmVVTTdTVUZGZWtNc2VVTkJRWGxETzBsQlEzcERMSGREUVVGM1F6dEpRVU40UXl4dFEwRkJiVU03U1VGRGJrTXNPRUpCUVRoQ08wbEJRemxDTEc5RFFVRnZRenRKUVVOd1F5eG5RMEZCWjBNN1NVRkRhRU1zYjBOQlFXOURPMGxCUTNCRExIRkRRVUZ4UXp0SlFVTnlReXh6UTBGQmMwTTdTVUZGZEVNc2NVTkJRWEZETzBsQlEzSkRMSFZEUVVGMVF6dEpRVU4yUXl4elEwRkJjME03U1VGRGRFTXNOa05CUVRaRE8wbEJRemRETERKRFFVRXlRenRKUVVNelF5dzRRMEZCT0VNN1NVRkRPVU1zZVVOQlFYbERPMGxCUTNwRExIRkRRVUZ4UXp0SlFVVjBReXh0UTBGQmJVTTdTVUZEYmtNc01rSkJRVEpDTzBOQlpUZENMRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBJUmVwbGF5RXZlbnRfMSA9IHJlcXVpcmUoXCIuL0lSZXBsYXlFdmVudFwiKTtcclxuZXhwb3J0cy5NZXNzYWdlRXZlbnRUeXBlcyA9IFtcclxuICAgICdOTmV0LkdhbWUuU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2UnLFxyXG4gICAgJ05OZXQuR2FtZS5TUGluZ01lc3NhZ2UnLFxyXG4gICAgJ05OZXQuR2FtZS5TQ2hhdE1lc3NhZ2UnLFxyXG4gICAgJ05OZXQuR2FtZS5TUGxheWVyQW5ub3VuY2VNZXNzYWdlJyxcclxuICAgICdOTmV0LkdhbWUuU1JlY29ubmVjdE5vdGlmeU1lc3NhZ2UnXHJcbl07XHJcbmZ1bmN0aW9uIGlzSVJlcGxheU1lc3NhZ2VFdmVudChvYmopIHtcclxuICAgIHJldHVybiBJUmVwbGF5RXZlbnRfMS5pc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iaikgJiYgZXhwb3J0cy5NZXNzYWdlRXZlbnRUeXBlcy5pbmRleE9mKG9iai5fZXZlbnQpICE9PSAtMTtcclxufVxyXG5leHBvcnRzLmlzSVJlcGxheU1lc3NhZ2VFdmVudCA9IGlzSVJlcGxheU1lc3NhZ2VFdmVudDtcclxuZnVuY3Rpb24gaXNJU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2Uob2JqKSB7XHJcbiAgICByZXR1cm4gSVJlcGxheUV2ZW50XzEuaXNJUmVwbGF5R2FtZUV2ZW50QmFzZShvYmopICYmIG9iai5fZXZlbnQgPT09ICdOTmV0LkdhbWUuU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2UnO1xyXG59XHJcbmV4cG9ydHMuaXNJU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2UgPSBpc0lTTG9hZGluZ1Byb2dyZXNzTWVzc2FnZTtcclxuZnVuY3Rpb24gaXNJU1BpbmdNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuIElSZXBsYXlFdmVudF8xLmlzSVJlcGxheUdhbWVFdmVudEJhc2Uob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5HYW1lLlNQaW5nTWVzc2FnZSc7XHJcbn1cclxuZXhwb3J0cy5pc0lTUGluZ01lc3NhZ2UgPSBpc0lTUGluZ01lc3NhZ2U7XHJcbmZ1bmN0aW9uIGlzSVNDaGF0TWVzc2FnZShvYmopIHtcclxuICAgIHJldHVybiBJUmVwbGF5RXZlbnRfMS5pc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iaikgJiYgb2JqLl9ldmVudCA9PT0gJ05OZXQuR2FtZS5TQ2hhdE1lc3NhZ2UnO1xyXG59XHJcbmV4cG9ydHMuaXNJU0NoYXRNZXNzYWdlID0gaXNJU0NoYXRNZXNzYWdlO1xyXG5mdW5jdGlvbiBpc0lTUGxheWVyQW5ub3VuY2VNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuIElSZXBsYXlFdmVudF8xLmlzSVJlcGxheUdhbWVFdmVudEJhc2Uob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5HYW1lLlNQbGF5ZXJBbm5vdW5jZU1lc3NhZ2UnO1xyXG59XHJcbmV4cG9ydHMuaXNJU1BsYXllckFubm91bmNlTWVzc2FnZSA9IGlzSVNQbGF5ZXJBbm5vdW5jZU1lc3NhZ2U7XHJcbmZ1bmN0aW9uIGlzSVNSZWNvbm5lY3ROb3RpZnlNZXNzYWdlKG9iaikge1xyXG4gICAgcmV0dXJuIElSZXBsYXlFdmVudF8xLmlzSVJlcGxheUdhbWVFdmVudEJhc2Uob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5HYW1lLlNSZWNvbm5lY3ROb3RpZnlNZXNzYWdlJztcclxufVxyXG5leHBvcnRzLmlzSVNSZWNvbm5lY3ROb3RpZnlNZXNzYWdlID0gaXNJU1JlY29ubmVjdE5vdGlmeU1lc3NhZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVNVMWxjM05oWjJWRmRtVnVkSE11YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SkpUV1Z6YzJGblpVVjJaVzUwY3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEdsRVFVRTRSVHRCUVVkcVJTeFJRVUZCTEdsQ1FVRnBRaXhIUVVGaE8wbEJRM1pETEcxRFFVRnRRenRKUVVOdVF5eDNRa0ZCZDBJN1NVRkRlRUlzZDBKQlFYZENPMGxCUTNoQ0xHdERRVUZyUXp0SlFVTnNReXh0UTBGQmJVTTdRMEZEZEVNc1EwRkJRenRCUVUxR0xDdENRVUZ6UXl4SFFVRlJPMGxCUXpGRExFOUJRVThzY1VOQlFYTkNMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzZVVKQlFXbENMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOMlJpeERRVUZETzBGQlJrUXNjMFJCUlVNN1FVRlBSQ3h2UTBGQk1rTXNSMEZCVVR0SlFVTXZReXhQUVVGUExIRkRRVUZ6UWl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFZEJRVWNzUTBGQlF5eE5RVUZOTEV0QlFVc3NiVU5CUVcxRExFTkJRVU03UVVGRE4wWXNRMEZCUXp0QlFVWkVMR2RGUVVWRE8wRkJVVVFzZVVKQlFXZERMRWRCUVZFN1NVRkRjRU1zVDBGQlR5eHhRMEZCYzBJc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeEhRVUZITEVOQlFVTXNUVUZCVFN4TFFVRkxMSGRDUVVGM1FpeERRVUZETzBGQlEyeEdMRU5CUVVNN1FVRkdSQ3d3UTBGRlF6dEJRVkZFTEhsQ1FVRm5ReXhIUVVGUk8wbEJRM0JETEU5QlFVOHNjVU5CUVhOQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRTFCUVUwc1MwRkJTeXgzUWtGQmQwSXNRMEZCUXp0QlFVTnNSaXhEUVVGRE8wRkJSa1FzTUVOQlJVTTdRVUZWUkN4dFEwRkJNRU1zUjBGQlVUdEpRVU01UXl4UFFVRlBMSEZEUVVGelFpeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRWRCUVVjc1EwRkJReXhOUVVGTkxFdEJRVXNzYTBOQlFXdERMRU5CUVVNN1FVRkROVVlzUTBGQlF6dEJRVVpFTERoRVFVVkRPMEZCVVVRc2IwTkJRVEpETEVkQlFWRTdTVUZETDBNc1QwRkJUeXh4UTBGQmMwSXNRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hIUVVGSExFTkJRVU1zVFVGQlRTeExRVUZMTEcxRFFVRnRReXhEUVVGRE8wRkJRemRHTEVOQlFVTTdRVUZHUkN4blJVRkZReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gaXNJUmVwbGF5RXZlbnQob2JqKSB7XHJcbiAgICByZXR1cm4gJ19ldmVudCcgaW4gb2JqICYmIG9iai5fZXZlbnQuaW5kZXhPZignTk5ldC4nKSA9PT0gMDtcclxufVxyXG5leHBvcnRzLmlzSVJlcGxheUV2ZW50ID0gaXNJUmVwbGF5RXZlbnQ7XHJcbmZ1bmN0aW9uIGlzSVJlcGxheVVzZXJFdmVudChvYmopIHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlFdmVudChvYmopICYmICdfdXNlcmlkJyBpbiBvYmo7XHJcbn1cclxuZXhwb3J0cy5pc0lSZXBsYXlVc2VyRXZlbnQgPSBpc0lSZXBsYXlVc2VyRXZlbnQ7XHJcbmZ1bmN0aW9uIGlzSVJlcGxheUdhbWVFdmVudEJhc2Uob2JqKSB7XHJcbiAgICByZXR1cm4gaXNJUmVwbGF5RXZlbnQob2JqKSAmJiBvYmouX2V2ZW50LmluZGV4T2YoJ05OZXQuR2FtZS4nKSA9PT0gMDtcclxufVxyXG5leHBvcnRzLmlzSVJlcGxheUdhbWVFdmVudEJhc2UgPSBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlO1xyXG5mdW5jdGlvbiBpc0lSZXBsYXlUcmFja2VyRXZlbnQob2JqKSB7XHJcbiAgICByZXR1cm4gaXNJUmVwbGF5RXZlbnQob2JqKSAmJiBvYmouX2V2ZW50LmluZGV4T2YoJ05OZXQuUmVwbGF5LlRyYWNrZXIuJykgPT09IDA7XHJcbn1cclxuZXhwb3J0cy5pc0lSZXBsYXlUcmFja2VyRXZlbnQgPSBpc0lSZXBsYXlUcmFja2VyRXZlbnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVNWSmxjR3hoZVVWMlpXNTBMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVNWSmxjR3hoZVVWMlpXNTBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlVVRXNkMEpCUVN0Q0xFZEJRVkU3U1VGRGJrTXNUMEZCVHl4UlFVRlJMRWxCUVVrc1IwRkJSeXhKUVVGSkxFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEJRVU5vUlN4RFFVRkRPMEZCUmtRc2QwTkJSVU03UVVGUFJDdzBRa0ZCYlVNc1IwRkJVVHRKUVVOMlF5eFBRVUZQTEdOQlFXTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hUUVVGVExFbEJRVWtzUjBGQlJ5eERRVUZETzBGQlEyNUVMRU5CUVVNN1FVRkdSQ3huUkVGRlF6dEJRVXRFTEdkRFFVRjFReXhIUVVGUk8wbEJRek5ETEU5QlFVOHNZMEZCWXl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRmxCUVZrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEJRVU42UlN4RFFVRkRPMEZCUmtRc2QwUkJSVU03UVVGSlJDd3JRa0ZCYzBNc1IwRkJVVHRKUVVNeFF5eFBRVUZQTEdOQlFXTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hIUVVGSExFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4elFrRkJjMElzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0QlFVTnVSaXhEUVVGRE8wRkJSa1FzYzBSQlJVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgSVJlcGxheUV2ZW50XzEgPSByZXF1aXJlKFwiLi9JUmVwbGF5RXZlbnRcIik7XHJcbmNvbnN0IGxpbnEgPSByZXF1aXJlKFwibGlucVwiKTtcclxuZnVuY3Rpb24gaXNTVW5pdEJvcm5FdmVudChvYmopIHtcclxuICAgIHJldHVybiBJUmVwbGF5RXZlbnRfMS5pc0lSZXBsYXlUcmFja2VyRXZlbnQob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5SZXBsYXkuVHJhY2tlci5TVW5pdEJvcm5FdmVudCc7XHJcbn1cclxuZXhwb3J0cy5pc1NVbml0Qm9ybkV2ZW50ID0gaXNTVW5pdEJvcm5FdmVudDtcclxuZnVuY3Rpb24gaXNTVW5pdERpZWRFdmVudChvYmopIHtcclxuICAgIHJldHVybiBJUmVwbGF5RXZlbnRfMS5pc0lSZXBsYXlUcmFja2VyRXZlbnQob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5SZXBsYXkuVHJhY2tlci5TVW5pdERpZWRFdmVudCc7XHJcbn1cclxuZXhwb3J0cy5pc1NVbml0RGllZEV2ZW50ID0gaXNTVW5pdERpZWRFdmVudDtcclxuZnVuY3Rpb24gaXNTU2NvcmVSZXN1bHRFdmVudChvYmopIHtcclxuICAgIHJldHVybiBJUmVwbGF5RXZlbnRfMS5pc0lSZXBsYXlUcmFja2VyRXZlbnQob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5SZXBsYXkuVHJhY2tlci5TU2NvcmVSZXN1bHRFdmVudCc7XHJcbn1cclxuZXhwb3J0cy5pc1NTY29yZVJlc3VsdEV2ZW50ID0gaXNTU2NvcmVSZXN1bHRFdmVudDtcclxuZnVuY3Rpb24gaXNTSGVyb0Jhbm5lZEV2ZW50KG9iaikge1xyXG4gICAgcmV0dXJuIElSZXBsYXlFdmVudF8xLmlzSVJlcGxheVRyYWNrZXJFdmVudChvYmopICYmIG9iai5fZXZlbnQgPT09ICdOTmV0LlJlcGxheS5UcmFja2VyLlNIZXJvQmFubmVkRXZlbnQnO1xyXG59XHJcbmV4cG9ydHMuaXNTSGVyb0Jhbm5lZEV2ZW50ID0gaXNTSGVyb0Jhbm5lZEV2ZW50O1xyXG5mdW5jdGlvbiBpc1NIZXJvUGlja2VkRXZlbnQob2JqKSB7XHJcbiAgICByZXR1cm4gSVJlcGxheUV2ZW50XzEuaXNJUmVwbGF5VHJhY2tlckV2ZW50KG9iaikgJiYgb2JqLl9ldmVudCA9PT0gJ05OZXQuUmVwbGF5LlRyYWNrZXIuU0hlcm9QaWNrZWRFdmVudCc7XHJcbn1cclxuZXhwb3J0cy5pc1NIZXJvUGlja2VkRXZlbnQgPSBpc1NIZXJvUGlja2VkRXZlbnQ7XHJcbmZ1bmN0aW9uIGlzU1N0YXRHYW1lRXZlbnQob2JqKSB7XHJcbiAgICByZXR1cm4gSVJlcGxheUV2ZW50XzEuaXNJUmVwbGF5VHJhY2tlckV2ZW50KG9iaikgJiYgb2JqLl9ldmVudCA9PT0gJ05OZXQuUmVwbGF5LlRyYWNrZXIuU1N0YXRHYW1lRXZlbnQnO1xyXG59XHJcbmV4cG9ydHMuaXNTU3RhdEdhbWVFdmVudCA9IGlzU1N0YXRHYW1lRXZlbnQ7XHJcbmZ1bmN0aW9uIGlzUGVyaW9kaWNYUEJyZWFrZG93blNTdGF0R2FtZUV2ZW50KG9iaikge1xyXG4gICAgcmV0dXJuIGlzU1N0YXRHYW1lRXZlbnQob2JqKSAmJiBvYmoubV9ldmVudE5hbWUgPT09ICdQZXJpb2RpY1hQQnJlYWtkb3duJztcclxufVxyXG5leHBvcnRzLmlzUGVyaW9kaWNYUEJyZWFrZG93blNTdGF0R2FtZUV2ZW50ID0gaXNQZXJpb2RpY1hQQnJlYWtkb3duU1N0YXRHYW1lRXZlbnQ7XHJcbmZ1bmN0aW9uIGlzRW5kT2ZHYW1lWFBCcmVha2Rvd25TU3RhdEdhbWVFdmVudChvYmopIHtcclxuICAgIHJldHVybiBpc1NTdGF0R2FtZUV2ZW50KG9iaikgJiYgb2JqLm1fZXZlbnROYW1lID09PSAnRW5kT2ZHYW1lWFBCcmVha2Rvd24nO1xyXG59XHJcbmV4cG9ydHMuaXNFbmRPZkdhbWVYUEJyZWFrZG93blNTdGF0R2FtZUV2ZW50ID0gaXNFbmRPZkdhbWVYUEJyZWFrZG93blNTdGF0R2FtZUV2ZW50O1xyXG5mdW5jdGlvbiBpc0dhbWVTdGFydFNTdGF0R2FtZUV2ZW50KG9iaikge1xyXG4gICAgcmV0dXJuIGlzU1N0YXRHYW1lRXZlbnQob2JqKSAmJiBvYmoubV9ldmVudE5hbWUgPT09ICdHYW1lU3RhcnQnO1xyXG59XHJcbmV4cG9ydHMuaXNHYW1lU3RhcnRTU3RhdEdhbWVFdmVudCA9IGlzR2FtZVN0YXJ0U1N0YXRHYW1lRXZlbnQ7XHJcbmZ1bmN0aW9uIGdldFNTdGF0VmFsdWUoZnJvbSwga2V5LCBhc0Zsb2F0ID0gZmFsc2UpIHtcclxuICAgIGlmIChmcm9tKSB7XHJcbiAgICAgICAgdmFyIHIgPSBsaW5xLmZyb20oZnJvbSkuc2luZ2xlT3JEZWZhdWx0KF8gPT4gXy5tX2tleSA9PT0ga2V5KTtcclxuICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICBpZiAoYXNGbG9hdCAmJiB0eXBlb2Ygci5tX3ZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChyLm1fdmFsdWUgLyA0MDk2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gci5tX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0cy5nZXRTU3RhdFZhbHVlID0gZ2V0U1N0YXRWYWx1ZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pU1ZSeVlXTnJaWEpGZG1WdWRITXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKSlZISmhZMnRsY2tWMlpXNTBjeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMR2xFUVVFMFJUdEJRVU0xUlN3MlFrRkJOa0k3UVVGaE4wSXNNRUpCUVdsRExFZEJRVkU3U1VGRGNrTXNUMEZCVHl4dlEwRkJjVUlzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4SFFVRkhMRU5CUVVNc1RVRkJUU3hMUVVGTExHOURRVUZ2UXl4RFFVRkRPMEZCUXpkR0xFTkJRVU03UVVGR1JDdzBRMEZGUXp0QlFXRkVMREJDUVVGcFF5eEhRVUZSTzBsQlEzSkRMRTlCUVU4c2IwTkJRWEZDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1IwRkJSeXhEUVVGRExFMUJRVTBzUzBGQlN5eHZRMEZCYjBNc1EwRkJRenRCUVVNM1JpeERRVUZETzBGQlJrUXNORU5CUlVNN1FVRm5Ra1FzTmtKQlFXOURMRWRCUVZFN1NVRkRlRU1zVDBGQlR5eHZRMEZCY1VJc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeEhRVUZITEVOQlFVTXNUVUZCVFN4TFFVRkxMSFZEUVVGMVF5eERRVUZETzBGQlEyaEhMRU5CUVVNN1FVRkdSQ3hyUkVGRlF6dEJRVk5FTERSQ1FVRnRReXhIUVVGUk8wbEJRM1pETEU5QlFVOHNiME5CUVhGQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRTFCUVUwc1MwRkJTeXh6UTBGQmMwTXNRMEZCUXp0QlFVTXZSaXhEUVVGRE8wRkJSa1FzWjBSQlJVTTdRVUZWUkN3MFFrRkJiVU1zUjBGQlVUdEpRVU4yUXl4UFFVRlBMRzlEUVVGeFFpeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRWRCUVVjc1EwRkJReXhOUVVGTkxFdEJRVXNzYzBOQlFYTkRMRU5CUVVNN1FVRkRMMFlzUTBGQlF6dEJRVVpFTEdkRVFVVkRPMEZCYVVKRUxEQkNRVUZwUXl4SFFVRlJPMGxCUTNKRExFOUJRVThzYjBOQlFYRkNMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUjBGQlJ5eERRVUZETEUxQlFVMHNTMEZCU3l4dlEwRkJiME1zUTBGQlF6dEJRVU0zUml4RFFVRkRPMEZCUmtRc05FTkJSVU03UVVGRlJDdzJRMEZCYjBRc1IwRkJVVHRKUVVONFJDeFBRVUZQTEdkQ1FVRm5RaXhEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVkQlFVY3NRMEZCUXl4WFFVRlhMRXRCUVVzc2NVSkJRWEZDTEVOQlFVTTdRVUZET1VVc1EwRkJRenRCUVVaRUxHdEdRVVZETzBGQlJVUXNPRU5CUVhGRUxFZEJRVkU3U1VGRGVrUXNUMEZCVHl4blFrRkJaMElzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4SFFVRkhMRU5CUVVNc1YwRkJWeXhMUVVGTExITkNRVUZ6UWl4RFFVRkRPMEZCUXk5RkxFTkJRVU03UVVGR1JDeHZSa0ZGUXp0QlFVVkVMRzFEUVVFd1F5eEhRVUZSTzBsQlF6bERMRTlCUVU4c1owSkJRV2RDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1IwRkJSeXhEUVVGRExGZEJRVmNzUzBGQlN5eFhRVUZYTEVOQlFVTTdRVUZEY0VVc1EwRkJRenRCUVVaRUxEaEVRVVZETzBGQlJVUXNkVUpCUVdsRExFbEJRVGhDTEVWQlFVVXNSMEZCVnl4RlFVRkZMRlZCUVcxQ0xFdEJRVXM3U1VGRGJFY3NTVUZCU1N4SlFVRkpMRVZCUVVVN1VVRkRUaXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZET1VRc1NVRkJTU3hEUVVGRExFVkJRVVU3V1VGRFNDeEpRVUZITEU5QlFVOHNTVUZCU1N4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzVVVGQlVTeEZRVUZETzJkQ1FVTjRReXhQUVVGbExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1EwRkJRenRoUVVOeVF6dFpRVU5FTEU5QlFVOHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJRenRUUVVOd1FqdExRVU5LTzBsQlEwUXNUMEZCVHl4VFFVRlRMRU5CUVVNN1FVRkRja0lzUTBGQlF6dEJRVmhFTEhORFFWZERJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0lSZXBsYXlFdmVudFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0lNZXNzYWdlRXZlbnRzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vRmlsdGVyZWRFdmVudHNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9JVHJhY2tlckV2ZW50c1wiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SnBibVJsZUM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenRCUVVGQkxHOURRVUVyUWp0QlFVTXZRaXh6UTBGQmFVTTdRVUZEYWtNc2MwTkJRV2xETzBGQlEycERMSE5EUVVGcFF5SjkiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vZXZlbnRzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdHlwZVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SnBibVJsZUM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenRCUVV0QkxEaENRVUY1UWp0QlFVTjZRaXcwUWtGQmRVSWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5UeXBlID0gRnVuY3Rpb247XHJcbmZ1bmN0aW9uIGlzVHlwZSh2KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRIbHdaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYkluUjVjR1V1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJZU3hSUVVGQkxFbEJRVWtzUjBGQlJ5eFJRVUZSTEVOQlFVTTdRVUZGTjBJc1owSkJRWFZDTEVOQlFVMDdTVUZETTBJc1QwRkJUeXhQUVVGUExFTkJRVU1zUzBGQlN5eFZRVUZWTEVOQlFVTTdRVUZEYWtNc1EwRkJRenRCUVVaRUxIZENRVVZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4uL2xpYlwiKTtcclxubGV0IHJlcGxheVdvcmtlcjtcclxuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFyZXBsYXlXb3JrZXIgJiYgbGliXzEuaXNJbml0aWFsaXplQ29tbWFuZChldnQuZGF0YSkpIHtcclxuICAgICAgICAgICAgcmVwbGF5V29ya2VyID0gbmV3IGxpYl8xLlJlcGxheVdvcmtlcihldnQuZGF0YSk7XHJcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKCdXT1JLRVJfSU5JVElBTElaRUQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICB9XHJcbn0pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZDI5eWEyVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaWQyOXlhMlZ5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3pzN1FVRkJRU3huUTBGQk1rUTdRVUZGTTBRc1NVRkJTU3haUVVFd1FpeERRVUZETzBGQlF5OUNMR2RDUVVGblFpeERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRlBMRWRCUVVjc1JVRkJSU3hGUVVGRk8wbEJRM1JETEVsQlFVazdVVUZEUVN4SlFVRkpMRU5CUVVNc1dVRkJXU3hKUVVGSkxIbENRVUZ0UWl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU5vUkN4WlFVRlpMRWRCUVVjc1NVRkJTU3hyUWtGQldTeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVNeFF5eFhRVUZYTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zUTBGQlF6dFRRVU55UXp0TFFVTktPMGxCUVVNc1QwRkJUeXhEUVVGRExFVkJRVVU3VVVGRFVpeFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wdEJRM0JDTzBGQlEwd3NRMEZCUXl4RFFVRkJMRU5CUVVNc1EwRkJReUo5Il0sInNvdXJjZVJvb3QiOiIifQ==
webpackJsonp(["main"],{

/***/ "../heroprotocol/dist/lib/decoder/AbstractDecoder.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BitPackedBuffer_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/BitPackedBuffer.js");
const errors_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/errors/index.js");
class AbstractDecoder {
    constructor(data, typeIfo) {
        this._buffer = new BitPackedBuffer_1.BitPackedBuffer(data);
        this._typeinfos = typeIfo;
    }
    toString() {
        return this._buffer.toString();
    }
    instance(typeid) {
        if (typeid >= this._typeinfos.length) {
            throw new errors_1.CorruptedError(this.toString());
        }
        const typeinfo = this._typeinfos[typeid];
        return this[typeinfo[0]].apply(this, typeinfo[1]);
    }
    byteAlign() {
        this._buffer.byteAlign();
    }
    get isDone() {
        return this._buffer.isDone;
    }
    get usedBits() {
        return this._buffer.usedBits;
    }
    get size() {
        return this._buffer.size;
    }
}
exports.AbstractDecoder = AbstractDecoder;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvQWJzdHJhY3REZWNvZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsdURBQW9EO0FBQ3BELHFDQUEwQztBQUUxQztJQUlJLFlBQW1CLElBQVksRUFBRSxPQUFPO1FBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDO0lBQzlCLENBQUM7SUFFTSxRQUFRO1FBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFTSxRQUFRLENBQUMsTUFBTTtRQUNsQixJQUFJLE1BQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTtZQUFFLE1BQU0sSUFBSSx1QkFBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQUU7UUFFcEYsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFTSxTQUFTO1FBQ1osSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsSUFBVyxNQUFNO1FBQ2IsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsSUFBVyxJQUFJO1FBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUM3QixDQUFDO0NBQ0o7QUFsQ0QsMENBa0NDIiwiZmlsZSI6ImRlY29kZXIvQWJzdHJhY3REZWNvZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcclxuaW1wb3J0IHsgQml0UGFja2VkQnVmZmVyIH0gZnJvbSAnLi9CaXRQYWNrZWRCdWZmZXInO1xyXG5pbXBvcnQgeyBDb3JydXB0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdERlY29kZXIge1xyXG5cclxuICAgIHByb3RlY3RlZCBfYnVmZmVyOiBCaXRQYWNrZWRCdWZmZXI7XHJcbiAgICBwcm90ZWN0ZWQgX3R5cGVpbmZvczogYW55O1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlciwgdHlwZUlmbykge1xyXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBCaXRQYWNrZWRCdWZmZXIoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fdHlwZWluZm9zID0gdHlwZUlmbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluc3RhbmNlKHR5cGVpZCkge1xyXG4gICAgICAgIGlmICh0eXBlaWQgPj0gdGhpcy5fdHlwZWluZm9zLmxlbmd0aCkgeyB0aHJvdyBuZXcgQ29ycnVwdGVkRXJyb3IodGhpcy50b1N0cmluZygpKTsgfVxyXG5cclxuICAgICAgICBjb25zdCB0eXBlaW5mbyA9IHRoaXMuX3R5cGVpbmZvc1t0eXBlaWRdO1xyXG4gICAgICAgIHJldHVybiB0aGlzW3R5cGVpbmZvWzBdXS5hcHBseSh0aGlzLCB0eXBlaW5mb1sxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJ5dGVBbGlnbigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9idWZmZXIuYnl0ZUFsaWduKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0RvbmUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5pc0RvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB1c2VkQml0cygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIudXNlZEJpdHM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnNpemU7XHJcbiAgICB9XHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/BitPackedBuffer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-bitwise
const buffer_1 = __webpack_require__("./node_modules/buffer/index.js");
const errors_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/errors/index.js");
class BitPackedBuffer {
    constructor(data, endian = 'big') {
        this._used = 0;
        this._next = null;
        this._nextBits = 0;
        this._data = data || new buffer_1.Buffer(0);
        this._bigEndian = endian === 'big';
    }
    toString() {
        return 'buffer(' +
            (this._nextBits && this._next || 0).toString(16) + '/' + this._nextBits +
            ',[' + this._used + ']=' + ((this._used < this._data.length) ? this._data.readUInt8(this._used).toString(16) : '--') +
            ')';
    }
    get isDone() {
        return this._nextBits === 0 && this._used >= this._data.length;
    }
    get size() {
        return this._data.length * 8;
    }
    get usedBits() {
        return this._used * 8 - this._nextBits;
    }
    byteAlign() {
        this._nextBits = 0;
    }
    readAlignedBytes(bytes) {
        this.byteAlign();
        const data = this._data.slice(this._used, this._used + bytes);
        this._used += bytes;
        if (data.length !== bytes) {
            throw new errors_1.TruncateError(this.toString());
        }
        return data;
    }
    readBits(bits) {
        let result = 0;
        let resultbits = 0;
        while (resultbits !== bits) {
            if (this._nextBits === 0) {
                if (this.isDone) {
                    throw new errors_1.TruncateError(this.toString());
                }
                this._next = this._data.readUInt8(this._used);
                this._used += 1;
                this._nextBits = 8;
            }
            const copybits = Math.min(bits - resultbits, this._nextBits);
            const copy = this._next & ((1 << copybits) - 1);
            if (this._bigEndian) {
                result |= copy << (bits - resultbits - copybits);
            }
            else {
                result |= copy << resultbits;
            }
            this._next >>= copybits;
            this._nextBits -= copybits;
            resultbits += copybits;
        }
        return result;
    }
    readUnalignedBytes(bytes) {
        const buff = new buffer_1.Buffer(bytes);
        for (let i = 0; i < bytes; i += 1) {
            buff.writeUInt8(this.readBits(8), i);
        }
        return buff;
    }
}
exports.BitPackedBuffer = BitPackedBuffer;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvQml0UGFja2VkQnVmZmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsNEJBQTRCO0FBQzVCLG1DQUFnQztBQUNoQyxxQ0FBeUM7QUFDekM7SUFRSSxZQUFtQixJQUFZLEVBQUUsU0FBMEIsS0FBSztRQUx4RCxVQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsVUFBSyxHQUFHLElBQUksQ0FBQztRQUNiLGNBQVMsR0FBRyxDQUFDLENBQUM7UUFJbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLElBQUksSUFBSSxlQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLEtBQUssS0FBSyxDQUFDO0lBQ3ZDLENBQUM7SUFHTSxRQUFRO1FBQ1gsT0FBTyxTQUFTO1lBQ1osQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUztZQUN2RSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3BILEdBQUcsQ0FBQztJQUNaLENBQUM7SUFFRCxJQUFXLE1BQU07UUFDYixPQUFPLElBQUksQ0FBQyxTQUFTLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDbkUsQ0FBQztJQUVELElBQVcsSUFBSTtRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxJQUFXLFFBQVE7UUFDZixPQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDM0MsQ0FBQztJQUVNLFNBQVM7UUFDWixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRU0sZ0JBQWdCLENBQUMsS0FBYTtRQUNqQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDakIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzlELElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDO1FBQ3BCLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxLQUFLLEVBQUU7WUFDdkIsTUFBTSxJQUFJLHNCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDNUM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU0sUUFBUSxDQUFDLElBQVk7UUFDeEIsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBRW5CLE9BQU8sVUFBVSxLQUFLLElBQUksRUFBRTtZQUN4QixJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssQ0FBQyxFQUFFO2dCQUN0QixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQUUsTUFBTSxJQUFJLHNCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7aUJBQUU7Z0JBQzlELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM5QyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7YUFDdEI7WUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzdELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUVoRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEdBQUcsVUFBVSxHQUFHLFFBQVEsQ0FBQyxDQUFDO2FBQ3BEO2lCQUFNO2dCQUNILE1BQU0sSUFBSSxJQUFJLElBQUksVUFBVSxDQUFDO2FBQ2hDO1lBQ0QsSUFBSSxDQUFDLEtBQUssS0FBSyxRQUFRLENBQUM7WUFDeEIsSUFBSSxDQUFDLFNBQVMsSUFBSSxRQUFRLENBQUM7WUFDM0IsVUFBVSxJQUFJLFFBQVEsQ0FBQztTQUMxQjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFTSxrQkFBa0IsQ0FBQyxLQUFhO1FBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDeEM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0NBQ0o7QUFsRkQsMENBa0ZDIiwiZmlsZSI6ImRlY29kZXIvQml0UGFja2VkQnVmZmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxyXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xyXG5pbXBvcnQgeyBUcnVuY2F0ZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xyXG5leHBvcnQgY2xhc3MgQml0UGFja2VkQnVmZmVyIHtcclxuXHJcbiAgICBwcml2YXRlIF9kYXRhOiBCdWZmZXI7XHJcbiAgICBwcml2YXRlIF91c2VkID0gMDtcclxuICAgIHByaXZhdGUgX25leHQgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbmV4dEJpdHMgPSAwO1xyXG4gICAgcHJpdmF0ZSBfYmlnRW5kaWFuOiBib29sZWFuO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIsIGVuZGlhbjogJ2JpZycgfCAnc21hbGwnID0gJ2JpZycpIHtcclxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YSB8fCBuZXcgQnVmZmVyKDApO1xyXG4gICAgICAgIHRoaXMuX2JpZ0VuZGlhbiA9IGVuZGlhbiA9PT0gJ2JpZyc7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ2J1ZmZlcignICtcclxuICAgICAgICAgICAgKHRoaXMuX25leHRCaXRzICYmIHRoaXMuX25leHQgfHwgMCkudG9TdHJpbmcoMTYpICsgJy8nICsgdGhpcy5fbmV4dEJpdHMgK1xyXG4gICAgICAgICAgICAnLFsnICsgdGhpcy5fdXNlZCArICddPScgKyAoKHRoaXMuX3VzZWQgPCB0aGlzLl9kYXRhLmxlbmd0aCkgPyB0aGlzLl9kYXRhLnJlYWRVSW50OCh0aGlzLl91c2VkKS50b1N0cmluZygxNikgOiAnLS0nKSArXHJcbiAgICAgICAgICAgICcpJztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzRG9uZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEJpdHMgPT09IDAgJiYgdGhpcy5fdXNlZCA+PSB0aGlzLl9kYXRhLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sZW5ndGggKiA4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdXNlZEJpdHMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXNlZCAqIDggLSB0aGlzLl9uZXh0Qml0cztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYnl0ZUFsaWduKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX25leHRCaXRzID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVhZEFsaWduZWRCeXRlcyhieXRlczogbnVtYmVyKTogQnVmZmVyIHtcclxuICAgICAgICB0aGlzLmJ5dGVBbGlnbigpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX3VzZWQsIHRoaXMuX3VzZWQgKyBieXRlcyk7XHJcbiAgICAgICAgdGhpcy5fdXNlZCArPSBieXRlcztcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IGJ5dGVzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUcnVuY2F0ZUVycm9yKHRoaXMudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWFkQml0cyhiaXRzOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgICAgIGxldCByZXN1bHRiaXRzID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKHJlc3VsdGJpdHMgIT09IGJpdHMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX25leHRCaXRzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RvbmUpIHsgdGhyb3cgbmV3IFRydW5jYXRlRXJyb3IodGhpcy50b1N0cmluZygpKTsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dCA9IHRoaXMuX2RhdGEucmVhZFVJbnQ4KHRoaXMuX3VzZWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dEJpdHMgPSA4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb3B5Yml0cyA9IE1hdGgubWluKGJpdHMgLSByZXN1bHRiaXRzLCB0aGlzLl9uZXh0Qml0cyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSB0aGlzLl9uZXh0ICYgKCgxIDw8IGNvcHliaXRzKSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JpZ0VuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IGNvcHkgPDwgKGJpdHMgLSByZXN1bHRiaXRzIC0gY29weWJpdHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IGNvcHkgPDwgcmVzdWx0Yml0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9uZXh0ID4+PSBjb3B5Yml0cztcclxuICAgICAgICAgICAgdGhpcy5fbmV4dEJpdHMgLT0gY29weWJpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdGJpdHMgKz0gY29weWJpdHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWFkVW5hbGlnbmVkQnl0ZXMoYnl0ZXM6IG51bWJlcik6IEJ1ZmZlciB7XHJcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBCdWZmZXIoYnl0ZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXM7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgodGhpcy5yZWFkQml0cyg4KSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBidWZmO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/BitPackedDecoder.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/errors/index.js");
const AbstractDecoder_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/AbstractDecoder.js");
class BitPackedDecoder extends AbstractDecoder_1.AbstractDecoder {
    constructor(data, typeIfo) {
        super(data, typeIfo);
    }
    _array(bounds, typeid) {
        const length = this._int(bounds);
        const ar = [];
        for (let i = 0; i < length; i += 1) {
            ar[i] = this.instance(typeid);
        }
        return ar;
    }
    _bitarray(bounds) {
        const length = this._int(bounds);
        return [length, this._buffer.readBits(length)];
    }
    _blob(bounds) {
        const length = this._int(bounds);
        return this._buffer.readAlignedBytes(length);
    }
    _bool() {
        return this._int([0, 1]) !== 0;
    }
    _choice(bounds, fields) {
        const tag = this._int(bounds);
        const field = fields[tag];
        if (!field) {
            throw new errors_1.CorruptedError(this.toString());
        }
        const ret = {};
        ret[field[0]] = this.instance(field[1]);
        return ret;
    }
    _fourcc() {
        return this._buffer.readUnalignedBytes(4);
    }
    _int(bounds) {
        const value = bounds[0] + this._buffer.readBits(bounds[1]);
        return value;
    }
    _null() {
        return null;
    }
    _optional(typeid) {
        const exists = this._bool();
        return exists ? this.instance(typeid) : null;
    }
    _real32() {
        return this._buffer.readUnalignedBytes(4).readFloatBE(0);
    }
    _real64() {
        return this._buffer.readUnalignedBytes(8).readDoubleBE(0);
    }
    _struct(fields) {
        let result = {};
        fields.forEach(field => {
            if (field[0] === '__parent') {
                const parent = this.instance(field[1]);
                if (parent && typeof parent === 'object' && !Array.isArray(parent)) {
                    result = Object.assign(result, parent);
                }
                else if (fields.length === 0) {
                    result = parent;
                }
                else {
                    result[field[0]] = parent;
                }
            }
            else {
                result[field[0]] = this.instance(field[1]);
            }
        });
        return result;
    }
}
exports.BitPackedDecoder = BitPackedDecoder;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvQml0UGFja2VkRGVjb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBLHFDQUEwQztBQUMxQyx1REFBb0Q7QUFHcEQsc0JBQThCLFNBQVEsaUNBQWU7SUFFakQsWUFBbUIsSUFBWSxFQUFFLE9BQU87UUFDcEMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRU0sTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNO1FBQ3hCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2pDO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRU0sU0FBUyxDQUFDLE1BQU07UUFDbkIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVNLEtBQUssQ0FBQyxNQUFNO1FBQ2YsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVNLEtBQUs7UUFDUixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVNLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTTtRQUN6QixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlCLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQUUsTUFBTSxJQUFJLHVCQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FBRTtRQUMxRCxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDZixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QyxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFTSxPQUFPO1FBQ1YsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFTSxJQUFJLENBQUMsTUFBTTtRQUNkLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRU0sS0FBSztRQUNSLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxTQUFTLENBQUMsTUFBTTtRQUNuQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDNUIsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNqRCxDQUFDO0lBRU0sT0FBTztRQUNWLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVNLE9BQU87UUFDVixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFTSxPQUFPLENBQUMsTUFBTTtRQUNqQixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDaEIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNuQixJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxVQUFVLEVBQUU7Z0JBQ3pCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZDLElBQUksTUFBTSxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQ2hFLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztpQkFDMUM7cUJBQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDNUIsTUFBTSxHQUFHLE1BQU0sQ0FBQztpQkFDbkI7cUJBQU07b0JBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztpQkFDN0I7YUFDSjtpQkFBTTtnQkFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM5QztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztDQUdKO0FBcEZELDRDQW9GQyIsImZpbGUiOiJkZWNvZGVyL0JpdFBhY2tlZERlY29kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xyXG5pbXBvcnQgeyBCaXRQYWNrZWRCdWZmZXIgfSBmcm9tICcuL0JpdFBhY2tlZEJ1ZmZlcic7XHJcbmltcG9ydCB7IENvcnJ1cHRlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBBYnN0cmFjdERlY29kZXIgfSBmcm9tICcuL0Fic3RyYWN0RGVjb2Rlcic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEJpdFBhY2tlZERlY29kZXIgZXh0ZW5kcyBBYnN0cmFjdERlY29kZXIge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIsIHR5cGVJZm8pIHtcclxuICAgICAgICBzdXBlcihkYXRhLCB0eXBlSWZvKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2FycmF5KGJvdW5kcywgdHlwZWlkKTogYW55W10ge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX2ludChib3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IGFyID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBhcltpXSA9IHRoaXMuaW5zdGFuY2UodHlwZWlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfYml0YXJyYXkoYm91bmRzKTogbnVtYmVyW10ge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX2ludChib3VuZHMpO1xyXG4gICAgICAgIHJldHVybiBbbGVuZ3RoLCB0aGlzLl9idWZmZXIucmVhZEJpdHMobGVuZ3RoKV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ibG9iKGJvdW5kcyk6IEJ1ZmZlciB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5faW50KGJvdW5kcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ib29sKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnQoWzAsIDFdKSAhPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2Nob2ljZShib3VuZHMsIGZpZWxkcykge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMuX2ludChib3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFmaWVsZCkgeyB0aHJvdyBuZXcgQ29ycnVwdGVkRXJyb3IodGhpcy50b1N0cmluZygpKTsgfVxyXG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgICAgIHJldFtmaWVsZFswXV0gPSB0aGlzLmluc3RhbmNlKGZpZWxkWzFdKTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfZm91cmNjKCk6IEJ1ZmZlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkVW5hbGlnbmVkQnl0ZXMoNCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9pbnQoYm91bmRzKTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGJvdW5kc1swXSArIHRoaXMuX2J1ZmZlci5yZWFkQml0cyhib3VuZHNbMV0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX251bGwoKTogbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9vcHRpb25hbCh0eXBlaWQpOiBhbnkgfCBudWxsIHtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSB0aGlzLl9ib29sKCk7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0cyA/IHRoaXMuaW5zdGFuY2UodHlwZWlkKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9yZWFsMzIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnJlYWRVbmFsaWduZWRCeXRlcyg0KS5yZWFkRmxvYXRCRSgwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX3JlYWw2NCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZFVuYWxpZ25lZEJ5dGVzKDgpLnJlYWREb3VibGVCRSgwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX3N0cnVjdChmaWVsZHMpOiBhbnkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZFswXSA9PT0gJ19fcGFyZW50Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5pbnN0YW5jZShmaWVsZFsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBwYXJlbnQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBPYmplY3QuYXNzaWduKHJlc3VsdCwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkWzBdXSA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZFswXV0gPSB0aGlzLmluc3RhbmNlKGZpZWxkWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/VersionDecoder.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/errors/index.js");
const AbstractDecoder_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/AbstractDecoder.js");
const Long = __webpack_require__("../heroprotocol/node_modules/long/src/long.js");
class VersionDecoder extends AbstractDecoder_1.AbstractDecoder {
    constructor(data, typeIfo) {
        super(data, typeIfo);
    }
    _expectSkip(expected) {
        const r = this._buffer.readBits(8);
        if (r !== expected) {
            throw new errors_1.CorruptedError(this.toString());
        }
        ;
    }
    _vint() {
        let b = this._buffer.readBits(8);
        const negative = b & 1;
        let result = (b >> 1) & 0x3f;
        let bits = 6;
        while ((b & 0x80) !== 0) {
            b = this._buffer.readBits(8);
            // result |= (b & 0x7f) << bits; // Bitwise operators do not work above 32 bits
            let myLong = new Long;
            myLong = Long.fromString(result.toString(), false);
            result = myLong.or((b & 0x7f) * Math.pow(2, bits)).toString();
            bits += 7;
        }
        result = parseInt(result.toString(), 10);
        return negative ? -result : result;
    }
    ;
    _array(bounds, typeid) {
        this._expectSkip(0);
        const length = this._vint();
        const ar = [];
        for (let i = 0; i < length; i++) {
            ar[i] = this.instance(typeid);
        }
        return ar;
    }
    _bitarray(bounds) {
        this._expectSkip(1);
        const length = this._vint();
        return [length, this._buffer.readAlignedBytes((length + 7) / 8)];
    }
    _blob(bounds) {
        this._expectSkip(2);
        const length = this._vint();
        return this._buffer.readAlignedBytes(length);
    }
    _bool() {
        this._expectSkip(6);
        return this._buffer.readBits(8) !== 0;
    }
    _choice(bounds, fields) {
        this._expectSkip(3);
        const tag = this._vint();
        const field = fields[tag];
        if (!field) {
            this._skipInstance();
            return {};
        }
        const ret = {};
        ret[field[0]] = this.instance(field[1]);
        return ret;
    }
    _fourcc() {
        this._expectSkip(7);
        return this._buffer.readAlignedBytes(4);
    }
    _int() {
        this._expectSkip(9);
        return this._vint();
    }
    _null() {
        return null;
    }
    _optional(typeid) {
        this._expectSkip(4);
        const exists = this._buffer.readBits(8) !== 0;
        return exists ? this.instance(typeid) : null;
    }
    _real32() {
        this._expectSkip(7);
        return this._buffer.readAlignedBytes(4).readFloatBE(0);
    }
    _real64() {
        this._expectSkip(8);
        return this._buffer.readAlignedBytes(8).readDoubleBE(0);
    }
    _struct(fields) {
        function matchTag(tag) {
            return function (field) {
                return tag === field[2];
            };
        }
        this._expectSkip(5);
        let result = {};
        const length = this._vint();
        for (let i = 0; i < length; i += 1) {
            const tag = this._vint();
            const field = fields.find(matchTag(tag));
            if (field) {
                if (field[0] === '__parent') {
                    const parent = this.instance(field[1]);
                    if (parent && typeof parent === 'object' && !Array.isArray(parent)) {
                        result = Object.assign(result, parent);
                    }
                    else if (fields.length === 0) {
                        result = parent;
                    }
                    else {
                        result[field[0]] = parent;
                    }
                }
                else {
                    result[field[0]] = this.instance(field[1]);
                }
            }
            else {
                this._skipInstance();
            }
        }
        return result;
    }
    _skipInstance() {
        const skip = this._buffer.readBits(8);
        let length;
        let exists;
        let tag;
        if (skip === 0) { // array
            length = this._vint();
            for (let i = 0; i < length; i++) {
                this._skipInstance();
            }
        }
        else if (skip === 1) { // bitblob
            length = this._vint();
            this._buffer.readAlignedBytes((length + 7) / 8);
        }
        else if (skip === 2) { // blob
            length = this._vint();
            this._buffer.readAlignedBytes(length);
        }
        else if (skip === 3) { // choice
            tag = this._vint();
            this._skipInstance();
        }
        else if (skip === 4) { // optional
            exists = this._buffer.readBits(8) !== 0;
            if (exists) {
                this._skipInstance();
            }
        }
        else if (skip === 5) { // struct
            length = this._vint();
            for (let i = 0; i < length; i += 1) {
                tag = this._vint();
                this._skipInstance();
            }
        }
        else if (skip === 6) { // u8
            this._buffer.readAlignedBytes(1);
        }
        else if (skip === 7) { // u32
            this._buffer.readAlignedBytes(4);
        }
        else if (skip === 8) { // u64
            this._buffer.readAlignedBytes(8);
        }
        else if (skip === 9) { // vint
            this._vint();
        }
    }
}
exports.VersionDecoder = VersionDecoder;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvVmVyc2lvbkRlY29kZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFHQSxxQ0FBMEM7QUFDMUMsdURBQW9EO0FBQ3BELDZCQUE2QjtBQUU3QixvQkFBNEIsU0FBUSxpQ0FBZTtJQUcvQyxZQUFtQixJQUFZLEVBQUUsT0FBTztRQUNwQyxLQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFHTSxXQUFXLENBQUMsUUFBUTtRQUN2QixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFBRSxNQUFNLElBQUksdUJBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtTQUFFO1FBQUEsQ0FBQztJQUN0RSxDQUFDO0lBRU0sS0FBSztRQUNSLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkIsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQzdCLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztRQUViLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QiwrRUFBK0U7WUFDL0UsSUFBSSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUM7WUFDdEIsTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ25ELE1BQU0sR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLENB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QUFDLEtBQUssRUFBRSxDQUFDO2dCQUNuQixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7YUFDeEI7U0FDSjthQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxFQUFFLEtBQUs7WUFDMUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQzthQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU07WUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQzthQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU07WUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQzthQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxFQUFFLE9BQU87WUFDNUIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2hCO0lBQ0wsQ0FBQztDQUNKO0FBL0tELHdDQStLQyIsImZpbGUiOiJkZWNvZGVyL1ZlcnNpb25EZWNvZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxyXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xyXG5pbXBvcnQgeyBCaXRQYWNrZWRCdWZmZXIgfSBmcm9tICcuL0JpdFBhY2tlZEJ1ZmZlcic7XHJcbmltcG9ydCB7IENvcnJ1cHRlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBBYnN0cmFjdERlY29kZXIgfSBmcm9tICcuL0Fic3RyYWN0RGVjb2Rlcic7XHJcbmltcG9ydCAqIGFzIExvbmcgZnJvbSAnbG9uZyc7XHJcblxyXG5leHBvcnQgY2xhc3MgVmVyc2lvbkRlY29kZXIgZXh0ZW5kcyBBYnN0cmFjdERlY29kZXIge1xyXG5cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoZGF0YTogQnVmZmVyLCB0eXBlSWZvKSB7XHJcbiAgICAgICAgc3VwZXIoZGF0YSwgdHlwZUlmbyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBfZXhwZWN0U2tpcChleHBlY3RlZCkge1xyXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLl9idWZmZXIucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgaWYgKHIgIT09IGV4cGVjdGVkKSB7IHRocm93IG5ldyBDb3JydXB0ZWRFcnJvcih0aGlzLnRvU3RyaW5nKCkpIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF92aW50KCkge1xyXG4gICAgICAgIGxldCBiID0gdGhpcy5fYnVmZmVyLnJlYWRCaXRzKDgpO1xyXG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlID0gYiAmIDE7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IChiID4+IDEpICYgMHgzZjtcclxuICAgICAgICBsZXQgYml0cyA9IDY7XHJcblxyXG4gICAgICAgIHdoaWxlICgoYiAmIDB4ODApICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLl9idWZmZXIucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgICAgIC8vIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IGJpdHM7IC8vIEJpdHdpc2Ugb3BlcmF0b3JzIGRvIG5vdCB3b3JrIGFib3ZlIDMyIGJpdHNcclxuICAgICAgICAgICAgbGV0IG15TG9uZyA9IG5ldyBMb25nO1xyXG4gICAgICAgICAgICBteUxvbmcgPSBMb25nLmZyb21TdHJpbmcocmVzdWx0LnRvU3RyaW5nKCksIGZhbHNlKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbXlMb25nLm9yKChiICYgMHg3ZikgKiBNYXRoLnBvdygyLCBiaXRzKSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgYml0cyArPSA3O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBwYXJzZUludChyZXN1bHQudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgICAgIHJldHVybiBuZWdhdGl2ZSA/IC1yZXN1bHQgOiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBfYXJyYXkoYm91bmRzLCB0eXBlaWQpOiBhbnlbXSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCgwKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgY29uc3QgYXIgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyW2ldID0gdGhpcy5pbnN0YW5jZSh0eXBlaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9iaXRhcnJheShib3VuZHMpOiB7IDA6IG51bWJlciwgMTogQnVmZmVyIH0ge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoMSk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5fdmludCgpO1xyXG4gICAgICAgIHJldHVybiBbbGVuZ3RoLCB0aGlzLl9idWZmZXIucmVhZEFsaWduZWRCeXRlcygobGVuZ3RoICsgNykgLyA4KV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ibG9iKGJvdW5kcyk6IEJ1ZmZlciB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCgyKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9ib29sKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoNik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkQml0cyg4KSAhPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2Nob2ljZShib3VuZHMsIGZpZWxkcykge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoMyk7XHJcbiAgICAgICAgY29uc3QgdGFnID0gdGhpcy5fdmludCgpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFmaWVsZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9za2lwSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXQgPSB7fTtcclxuICAgICAgICByZXRbZmllbGRbMF1dID0gdGhpcy5pbnN0YW5jZShmaWVsZFsxXSk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2ZvdXJjYygpOiBCdWZmZXIge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoNyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKDQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfaW50KCk6IG51bWJlciB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCg5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmludCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfbnVsbCgpOiBudWxsIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX29wdGlvbmFsKHR5cGVpZCk6IGFueSB7XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCg0KTtcclxuICAgICAgICBjb25zdCBleGlzdHMgPSB0aGlzLl9idWZmZXIucmVhZEJpdHMoOCkgIT09IDA7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0cyA/IHRoaXMuaW5zdGFuY2UodHlwZWlkKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9yZWFsMzIoKTogbnVtYmVyIHtcclxuICAgICAgICB0aGlzLl9leHBlY3RTa2lwKDcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZEFsaWduZWRCeXRlcyg0KS5yZWFkRmxvYXRCRSgwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX3JlYWw2NCgpOiBudW1iZXIge1xyXG4gICAgICAgIHRoaXMuX2V4cGVjdFNraXAoOCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKDgpLnJlYWREb3VibGVCRSgwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX3N0cnVjdChmaWVsZHMpOiBhbnkge1xyXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoVGFnKHRhZykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnID09PSBmaWVsZFsyXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZXhwZWN0U2tpcCg1KTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX3ZpbnQoKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzLmZpbmQobWF0Y2hUYWcodGFnKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZFswXSA9PT0gJ19fcGFyZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuaW5zdGFuY2UoZmllbGRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgdHlwZW9mIHBhcmVudCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBPYmplY3QuYXNzaWduKHJlc3VsdCwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZFswXV0gPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRbMF1dID0gdGhpcy5pbnN0YW5jZShmaWVsZFsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9za2lwSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfc2tpcEluc3RhbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHNraXAgPSB0aGlzLl9idWZmZXIucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgbGV0IGxlbmd0aDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBleGlzdHM6IGJvb2xlYW47XHJcbiAgICAgICAgbGV0IHRhZztcclxuXHJcbiAgICAgICAgaWYgKHNraXAgPT09IDApIHsgICAgICAgIC8vIGFycmF5XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2tpcEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHNraXAgPT09IDEpIHsgLy8gYml0YmxvYlxyXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKChsZW5ndGggKyA3KSAvIDgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2tpcCA9PT0gMikgeyAvLyBibG9iXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMobGVuZ3RoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNraXAgPT09IDMpIHsgLy8gY2hvaWNlXHJcbiAgICAgICAgICAgIHRhZyA9IHRoaXMuX3ZpbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2tpcEluc3RhbmNlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChza2lwID09PSA0KSB7IC8vIG9wdGlvbmFsXHJcbiAgICAgICAgICAgIGV4aXN0cyA9IHRoaXMuX2J1ZmZlci5yZWFkQml0cyg4KSAhPT0gMDtcclxuICAgICAgICAgICAgaWYgKGV4aXN0cykgeyB0aGlzLl9za2lwSW5zdGFuY2UoKTsgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc2tpcCA9PT0gNSkgeyAvLyBzdHJ1Y3RcclxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmludCgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0YWcgPSB0aGlzLl92aW50KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9za2lwSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc2tpcCA9PT0gNikgeyAvLyB1OFxyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIucmVhZEFsaWduZWRCeXRlcygxKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNraXAgPT09IDcpIHsgLy8gdTMyXHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKDQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2tpcCA9PT0gOCkgeyAvLyB1NjRcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnJlYWRBbGlnbmVkQnl0ZXMoOCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChza2lwID09PSA5KSB7IC8vIHZpbnRcclxuICAgICAgICAgICAgdGhpcy5fdmludCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/errors/CorruptedError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CorruptedError extends Error {
    constructor(message = 'Corrupted Error') {
        super(message);
    }
}
exports.CorruptedError = CorruptedError;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvZXJyb3JzL0NvcnJ1cHRlZEVycm9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsb0JBQTRCLFNBQVEsS0FBSztJQUNyQyxZQUFtQixPQUFPLEdBQUcsaUJBQWlCO1FBQzFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQixDQUFDO0NBQ0o7QUFKRCx3Q0FJQyIsImZpbGUiOiJkZWNvZGVyL2Vycm9ycy9Db3JydXB0ZWRFcnJvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBDb3JydXB0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ0NvcnJ1cHRlZCBFcnJvcicpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/errors/TruncateError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TruncateError extends Error {
    constructor(message = 'Truncate Error') {
        super(message);
    }
}
exports.TruncateError = TruncateError;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvZXJyb3JzL1RydW5jYXRlRXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQkFBMkIsU0FBUSxLQUFLO0lBQ3BDLFlBQW1CLE9BQU8sR0FBRyxnQkFBZ0I7UUFDekMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CLENBQUM7Q0FDSjtBQUpELHNDQUlDIiwiZmlsZSI6ImRlY29kZXIvZXJyb3JzL1RydW5jYXRlRXJyb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgVHJ1bmNhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ1RydW5jYXRlIEVycm9yJykge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/errors/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/decoder/errors/CorruptedError.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/decoder/errors/TruncateError.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvZXJyb3JzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsc0NBQWlDO0FBQ2pDLHFDQUFnQyIsImZpbGUiOiJkZWNvZGVyL2Vycm9ycy9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vQ29ycnVwdGVkRXJyb3InO1xyXG5leHBvcnQgKiBmcm9tICcuL1RydW5jYXRlRXJyb3InO1xyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/decoder/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/decoder/errors/index.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/decoder/BitPackedBuffer.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/decoder/BitPackedDecoder.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/decoder/VersionDecoder.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY29kZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw4QkFBeUI7QUFDekIsdUNBQWtDO0FBQ2xDLHdDQUFtQztBQUNuQyxzQ0FBaUMiLCJmaWxlIjoiZGVjb2Rlci9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcclxuZXhwb3J0ICogZnJvbSAnLi9CaXRQYWNrZWRCdWZmZXInO1xyXG5leHBvcnQgKiBmcm9tICcuL0JpdFBhY2tlZERlY29kZXInO1xyXG5leHBvcnQgKiBmcm9tICcuL1ZlcnNpb25EZWNvZGVyJztcclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/heroprotocol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const PythonProtocolConverter_1 = __webpack_require__("../heroprotocol/dist/lib/protocols/PythonProtocolConverter.js");
class HeroProtocol {
    static loadProtocol(protocolVersion) {
        const path = `https://raw.githubusercontent.com/Blizzard/heroprotocol/master/protocol${protocolVersion}.py`;
        return new Promise((resolve, reject) => {
            if (HeroProtocol._protocolCode.has(protocolVersion)) {
                resolve(HeroProtocol._protocolCode.get(protocolVersion));
            }
            else {
                const request = new XMLHttpRequest();
                request.open('GET', path, true);
                request.onload = () => {
                    const p = HeroProtocol.convertProtocolFromPython(protocolVersion, request.responseText);
                    HeroProtocol._protocolCode.set(protocolVersion, p);
                    resolve(p);
                };
                request.onabort = (event) => {
                    reject(event);
                };
                request.onerror = (event) => {
                    reject(event);
                };
                request.send();
            }
        });
    }
    static getProtocol(protocolVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (HeroProtocol.hasProtocol(protocolVersion)) {
                return HeroProtocol._protocols.get(protocolVersion);
            }
            const code = yield HeroProtocol.loadProtocol(protocolVersion);
            return HeroProtocol.compile(protocolVersion, code);
        });
    }
    static compile(protocolVersion, code) {
        const protocol = PythonProtocolConverter_1.PythonProtocolConverter.compile(code);
        HeroProtocol._protocols.set(protocolVersion, protocol);
        return protocol;
    }
    static hasProtocol(protocolVersion) {
        return HeroProtocol._protocols.has(protocolVersion);
    }
    static convertProtocolFromPython(version, pyCode) {
        const converter = new PythonProtocolConverter_1.PythonProtocolConverter(version, pyCode);
        return converter.getCode();
    }
}
HeroProtocol.env = 'development';
HeroProtocol._protocols = new Map();
HeroProtocol._protocolCode = new Map();
exports.HeroProtocol = HeroProtocol;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUhlcm9Qcm90b2NvbCB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBQeXRob25Qcm90b2NvbENvbnZlcnRlciB9IGZyb20gJy4vcHJvdG9jb2xzL1B5dGhvblByb3RvY29sQ29udmVydGVyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBIZXJvUHJvdG9jb2wge1xyXG4gICAgcHVibGljIHN0YXRpYyBlbnYgPSAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3Byb3RvY29sczogTWFwPG51bWJlciwgSUhlcm9Qcm90b2NvbD4gPSBuZXcgTWFwPG51bWJlciwgSUhlcm9Qcm90b2NvbD4oKTtcclxuICAgIHByaXZhdGUgc3RhdGljIF9wcm90b2NvbENvZGU6IE1hcDxudW1iZXIsIHN0cmluZz4gPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPigpO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGxvYWRQcm90b2NvbChwcm90b2NvbFZlcnNpb246IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vQmxpenphcmQvaGVyb3Byb3RvY29sL21hc3Rlci9wcm90b2NvbCR7cHJvdG9jb2xWZXJzaW9ufS5weWA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKEhlcm9Qcm90b2NvbC5fcHJvdG9jb2xDb2RlLmhhcyhwcm90b2NvbFZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKEhlcm9Qcm90b2NvbC5fcHJvdG9jb2xDb2RlLmdldChwcm90b2NvbFZlcnNpb24pKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gSGVyb1Byb3RvY29sLmNvbnZlcnRQcm90b2NvbEZyb21QeXRob24ocHJvdG9jb2xWZXJzaW9uLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgSGVyb1Byb3RvY29sLl9wcm90b2NvbENvZGUuc2V0KHByb3RvY29sVmVyc2lvbiwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0UHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uOiBudW1iZXIpOiBQcm9taXNlPElIZXJvUHJvdG9jb2w+IHtcclxuICAgICAgICBpZiAoSGVyb1Byb3RvY29sLmhhc1Byb3RvY29sKHByb3RvY29sVmVyc2lvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhlcm9Qcm90b2NvbC5fcHJvdG9jb2xzLmdldChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgSGVyb1Byb3RvY29sLmxvYWRQcm90b2NvbChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgICAgIHJldHVybiBIZXJvUHJvdG9jb2wuY29tcGlsZShwcm90b2NvbFZlcnNpb24sIGNvZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY29tcGlsZShwcm90b2NvbFZlcnNpb246IG51bWJlciwgY29kZTogc3RyaW5nKTogSUhlcm9Qcm90b2NvbCB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBQeXRob25Qcm90b2NvbENvbnZlcnRlci5jb21waWxlKGNvZGUpO1xyXG4gICAgICAgIEhlcm9Qcm90b2NvbC5fcHJvdG9jb2xzLnNldChwcm90b2NvbFZlcnNpb24sIHByb3RvY29sKTtcclxuICAgICAgICByZXR1cm4gcHJvdG9jb2w7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBoYXNQcm90b2NvbChwcm90b2NvbFZlcnNpb246IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBIZXJvUHJvdG9jb2wuX3Byb3RvY29scy5oYXMocHJvdG9jb2xWZXJzaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjb252ZXJ0UHJvdG9jb2xGcm9tUHl0aG9uKHZlcnNpb246IG51bWJlciwgcHlDb2RlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBQeXRob25Qcm90b2NvbENvbnZlcnRlcih2ZXJzaW9uLCBweUNvZGUpO1xyXG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZ2V0Q29kZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/replay/index.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/types/index.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/heroprotocol.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsOEJBQXlCO0FBQ3pCLDZCQUF3QjtBQUN4QixvQ0FBK0IiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL3JlcGxheSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2hlcm9wcm90b2NvbCc7XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/protocols/PythonProtocolConverter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decoders = __webpack_require__("../heroprotocol/dist/lib/protocols/decoders.js");
const _template = `
    "use strict";

    const progress = {
        current: -1,
        total: -1
    }
    exports.progress = progress;

    exports.version = \${version};
    \${patch}

    const BitPackedDecoder = decoders.BitPackedDecoder;
    const VersionDecoder = decoders.VersionDecoder;


    // Decoding instructions for each protocol type.
    const typeinfos = [
    \${typeinfos}
    ];

    // Map from protocol NNet.Game.*Event eventid to [typeid, name]
    const game_event_types = {
    \${gameeventsTypes}
    };

    // The typeid of the NNet.Game.EEventId enum.
    const game_eventid_typeid = \${gameeventsTypeid};

    // Map from protocol NNet.Game.*Message eventid to [typeid, name]
    const message_event_types = {
    \${messageeventsTypes}
    };

    // The typeid of the NNet.Game.EMessageId enum.
    const message_eventid_typeid = \${messageeventsTypeid};

    // Map from protocol NNet.Replay.Tracker.*Event eventid to [typeid, name]
    const tracker_event_types = {
    \${trackereventstypes}
    };

    // The typeid of the NNet.Replay.Tracker.EEventId enum.
    const tracker_eventid_typeid = \${trackereventsTypeid};

    // The typeid of NNet.SVarUint32 (the type used to encode gameloop deltas).
    const svaruint32_typeid = 7;

    // The typeid of NNet.Replay.SGameUserId (the type used to encode player ids).
    const replay_userid_typeid = 8;

    // The typeid of NNet.Replay.SHeader (the type used to store replay game version and length).
    const replay_header_typeid = \${headerTypeid};

    // The typeid of NNet.Game.SDetails (the type used to store overall replay details).
    const game_details_typeid = \${detailsTypeid};

    // The typeid of NNet.Replay.SInitData (the type used to store the inital lobby).
    const replay_initdata_typeid = \${initdataTypeid};

    // not sure if correct port
    function _varuint32Value(value) {
    // Returns the numeric value from a SVarUint32 instance.
    return value[Object.keys(value)[0]];
    }

    function* _decode_event_stream(decoder, eventidTypeid, eventTypes, decodeUserId) {
    // Decodes events prefixed with a gameloop and possibly userid
    var gameloop = 0;
    while (!decoder.isDone) {
        
        var startBits = decoder.usedBits;

        // decode the gameloop delta before each event
        var delta = _varuint32Value(decoder.instance(svaruint32_typeid));
        gameloop += delta;

        // decode the userid before each event
        var userid = (decodeUserId === true) ? decoder.instance(replay_userid_typeid) : undefined;

        // decode the event id
        var eventid = decoder.instance(eventidTypeid);
        var eventType = eventTypes[eventid] || [null, null];
        var typeid = eventType[0];
        var typename = eventType[1];
        if (typeid === null) throw new decoders.CorruptedError('eventid(' + eventid + ') at ' + decoder.toString());

        // decode the event struct instance
        var event = decoder.instance(typeid);
        event._event = typename;
        event._eventid = eventid;

        // insert gameloop and userid
        event._gameloop = gameloop;
        if (decodeUserId) event._userid = userid;

        // the next event is byte aligned
        decoder.byteAlign();

        // insert bits used in stream
        event._bits = decoder.usedBits - startBits;
        progress.current = decoder.usedBits;
        yield event;
    }
    }

    exports.decodeReplayGameEvents = function* (contents) {
    // Decodes and yields each game event from the contents byte string.
    const decoder = new BitPackedDecoder(contents, typeinfos);
    progress.current = 0;
    progress.total = decoder.size;
    for (let event of _decode_event_stream(decoder, game_eventid_typeid, game_event_types, true))
        yield event;
    };

    exports.decodeReplayMessageEvents = function* (contents) {
        // Decodes and yields each message event from the contents byte string.
        const decoder = new BitPackedDecoder(contents, typeinfos);
        progress.current = 0;
        progress.total = decoder.size;
        for (let event of _decode_event_stream(decoder, message_eventid_typeid, message_event_types, true))
            yield event;
    };

    exports.decodeReplayTrackerEvents = function* (contents) {
    // Decodes and yields each tracker event from the contents byte string.
    const decoder = new VersionDecoder(contents, typeinfos);
    progress.current = 0;
    progress.total = decoder.size;
    for (let event of _decode_event_stream(decoder, tracker_eventid_typeid, tracker_event_types, false))
        yield event;
    };

    exports.decodeReplayHeader = function(contents) {
    // Decodes and return the replay header from the contents byte string.
    const decoder = new VersionDecoder(contents, typeinfos);
    return decoder.instance(replay_header_typeid);
    };

    exports.decodeReplayDetails = function(contents) {
    // Decodes and returns the game details from the contents byte string.
    const decoder = new VersionDecoder(contents, typeinfos);
    return decoder.instance(game_details_typeid);
    };

    exports.decodeReplayInitdata = function(contents) {
    // Decodes and return the replay init data from the contents byte string.
    const decoder = new BitPackedDecoder(contents, typeinfos);
    return decoder.instance(replay_initdata_typeid);
    };

    exports.decodeReplayAttributesEvents = function (contents) {
    // Decodes and yields each attribute from the contents byte string.
    const buffer = new decoders.BitPackedBuffer(contents, 'little');
    progress.current = 0;
    progress.total = buffer.size;
    const attributes = {};

    if (!buffer.isDone) {
        attributes.source = buffer.readBits(8);
        attributes.mapNameSpace = buffer.readBits(32);
        var count = buffer.readBits(32);
        attributes.scopes = {};

        while (!buffer.isDone) {
        var value = {};
        value.namespace = buffer.readBits(32);
        var attrid = value.attrid = buffer.readBits(32);
        var scope = buffer.readBits(8);
        value.value = buffer.readAlignedBytes(4).reverse();
        while (value.value[0] === 0) value.value = value.value.slice(1);
        while (value.value[value.value.length - 1] === 0) value.value = value.value.slice(0, -1);
        if (!attributes.scopes[scope])
            attributes.scopes[scope] = {};
        if (!attributes.scopes[scope][attrid])
            attributes.scopes[scope][attrid] = [];
        attributes.scopes[scope][attrid].push(value);
        progress.current = buffer.usedBits;
        }
    }

    return attributes;
    };

    exports.unitTag = function(unitTagIndex, unitTagRecycle) {
    return (unitTagIndex << 18) + unitTagRecycle;
    };

    exports.unitTagIndex = function(unitTag) {
    return (unitTag >> 18) & 0x00003FFF;
    };

    exports.unitTagRecycle = function(unitTag) {
    return unitTag & 0x0003FFFF;
    };
`;
const types = {
    tuple: function (str) {
        return str.match(/(-?\w+)/g);
    },
    tuples: function (str) {
        return str.match(/(\(.*?\))/g);
    },
    _int: {
        decode: function (str) {
            const ret = {};
            const res = types.tuple(str);
            ret['bounds'] = [res[0], res[1]];
            return ret;
        },
        encode: function (infos) {
            return `[${infos.bounds[0]}, ${infos.bounds[1]}]`;
        }
    },
    _choice: {
        decode: function (str) {
            const ret = { bounds: [], choices: [] };
            const res = types.tuples(str);
            Object.assign(ret, types._int.decode(res[0]));
            for (let i = 1; i < res.length; i += 1) {
                const tuple = types.tuple(res[i]);
                ret.choices.push({
                    label: tuple[0],
                    typeIndex: tuple[1]
                });
            }
            return ret;
        },
        encode: function (infos) {
            return `[${infos.bounds[0]}, ${infos.bounds[1]}], { ${infos.choices.map((choice, index, ar) => {
                return `${index}: ['${choice.label}', ${choice.typeIndex}]${(index === ar.length - 1) ? '' : ', '}`;
            }).join('')}}`;
        }
    },
    _struct: {
        decode: function (str) {
            const ret = { items: [] };
            const tuples = types.tuples(str);
            if (tuples) {
                tuples.forEach(tuple => {
                    tuple = types.tuple(tuple);
                    ret.items.push({
                        label: tuple[0],
                        typeIndex: tuple[1],
                        tag: tuple[2]
                    });
                });
            }
            return ret;
        },
        encode: function (infos) {
            return `[${infos.items.map((item, index, ar) => {
                return `['${item.label}', ${item.typeIndex}, ${item.tag}]${(index === ar.length - 1) ? '' : ', '}`;
            }).join('')}]`;
        }
    },
    _blob: {
        decode: function (str) {
            return types._int.decode(str);
        },
        encode: function (infos) {
            return types._int.encode(infos);
        }
    },
    _bool: {
        decode: function (str) {
            return {};
        },
        encode: function (infos) {
            return '';
        }
    },
    _array: {
        decode: function (str) {
            return Object.assign({ typeIndex: str.match(/\d+$/)[0] }, types._int.decode(str));
        },
        encode: function (infos) {
            return `[${infos.bounds[0]}, ${infos.bounds[1]}], ${infos.typeIndex}`;
        }
    },
    _optional: {
        decode: function (str) {
            return { typeIndex: Number(str) };
        },
        encode: function (infos) {
            return `${infos.typeIndex}`;
        }
    },
    _fourcc: {
        decode: function (str) {
            return {};
        },
        encode: function (infos) {
            return '';
        }
    },
    _bitarray: {
        decode: function (str) {
            return types._int.decode(str);
        },
        encode: function (infos) {
            return types._int.encode(infos);
        }
    },
    _null: {
        decode: function (str) {
            return {};
        },
        encode: function (infos) {
            return '';
        }
    }
};
const tokens = {
    newline: '\n',
    indent: '  ',
    typeinfosStart: 'typeinfos = [',
    typeinfosEnd: ']',
    gameeventsStart: 'game_event_types = {',
    gameeventsEnd: '}',
    messageeventsStart: 'message_event_types = {',
    messageeventsEnd: '}',
    trackereventsStart: 'tracker_event_types = {',
    trackereventsEnd: '}',
    gameeventsTypeid: 'game_eventid_typeid =',
    messageeventsTypeid: 'message_eventid_typeid =',
    trackereventsTypeid: 'tracker_eventid_typeid =',
    headerTypeid: 'replay_header_typeid =',
    detailsTypeid: 'game_details_typeid =',
    initdataTypeid: 'replay_initdata_typeid ='
};
const _data = {
    realms: [undefined, 'live'],
    regions: [
        undefined,
        undefined,
        'Europe'
    ],
    heroes: [],
    mounts: [],
    maps: [],
    builds: []
};
class PythonProtocolConverter {
    constructor(version, pyCode) {
        this.version = version;
        this.pyCode = pyCode;
    }
    static compile(protocolCode) {
        const start = new Date().getTime();
        const protocol = {};
        const fn = Function('exports', 'decoders', protocolCode);
        fn(protocol, decoders);
        console.log('Protocol Compile Time: ', new Date().getTime() - start);
        return protocol;
    }
    convert() {
        return PythonProtocolConverter.compile(this.getCode());
    }
    getCode() {
        this.parse(this.pyCode);
        return this.write();
    }
    parse(raw) {
        const start = new Date().getTime();
        const lines = raw.split(tokens.newline);
        let line = 0, str;
        this.typeinfos = [];
        this.gameeventsTypes = [];
        this.messageeventsTypes = [];
        this.trackereventstypes = [];
        while (line < lines.length) {
            str = lines[line].trim();
            if (str === tokens.typeinfosStart) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.typeinfos.push(this.parseTypeinfos(str));
                    line += 1;
                    str = lines[line].trim();
                } while (str !== tokens.typeinfosEnd);
            }
            else if (tokens.gameeventsStart === str) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.gameeventsTypes.push(this.parseEvent(str));
                    line += 1;
                    str = lines[line].trim();
                } while (tokens.gameeventsEnd !== str);
            }
            else if (tokens.messageeventsStart === str) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.messageeventsTypes.push(this.parseEvent(str));
                    line += 1;
                    str = lines[line].trim();
                } while (tokens.messageeventsEnd !== str);
            }
            else if (tokens.trackereventsStart === str) {
                line += 1;
                str = lines[line].trim();
                do {
                    this.trackereventstypes.push(this.parseEvent(str));
                    line += 1;
                    str = lines[line].trim();
                } while (tokens.trackereventsEnd !== str);
            }
            else if (str.startsWith(tokens.gameeventsTypeid)) {
                this.gameeventsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.messageeventsTypeid)) {
                this.messageeventsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.trackereventsTypeid)) {
                this.trackereventsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.headerTypeid)) {
                this.headerTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.detailsTypeid)) {
                this.detailsTypeid = str.match(/\d+/)[0];
            }
            else if (str.startsWith(tokens.initdataTypeid)) {
                this.initdataTypeid = str.match(/\d+/)[0];
            }
            line += 1;
        }
        console.log('Protocol Parse Time: ', new Date().getTime() - start);
    }
    parseEvent(str) {
        const res = str.match(/^(\d+):\s\((\d+),\s\'(.*)\'/);
        return {
            key: res[1],
            typeIndex: res[2],
            name: res[3]
        };
    }
    parseTypeinfos(str) {
        const typeRegex = /^\('(.*?)',\[(.*)\]\),\s*#(\d+)$/;
        const infos = { str: str };
        const res = typeRegex.exec(str);
        infos.type = res[1];
        Object.assign(infos, types[infos.type].decode(res[2]));
        infos.index = res[3];
        return infos;
    }
    write() {
        const start = new Date().getTime();
        const buildInfos = _data.builds[this.version];
        let out = _template;
        // unnessiary
        out = out.replace('${date}', new Date().toUTCString());
        // unnessiary
        out = out.replace('${version}', this.version);
        if (buildInfos) {
            const patch = buildInfos.live ? buildInfos.live.patch : buildInfos.ptr.patch;
            out = out.replace('${patch}', `exports.patch = \'${patch}\';${tokens.newline}`);
        }
        else {
            out = out.replace('${patch}', '');
        }
        out = out.replace('${typeinfos}', this.typeinfos.map((infos, index, ar) => {
            let str = tokens.indent;
            str += `['${infos.type}', [`;
            str += types[infos.type].encode(infos);
            str += `]]${index === (ar.length - 1) ? '' : ','}`;
            str += `  //${infos.index}`;
            return str;
        }).join(tokens.newline));
        out = out.replace('${gameeventsTypes}', this.gameeventsTypes.map((event, index, ar) => {
            let str = tokens.indent;
            str += `${event.key}: [${event.typeIndex}, \'${event.name}\']`;
            str += index === ar.length - 1 ? '' : ',';
            return str;
        }).join(tokens.newline));
        out = out.replace('${messageeventsTypes}', this.messageeventsTypes.map((event, index, ar) => {
            let str = tokens.indent;
            str += `${event.key}: [${event.typeIndex}, \'${event.name}\']`;
            str += index === ar.length - 1 ? '' : ',';
            return str;
        }).join(tokens.newline));
        out = out.replace('${trackereventstypes}', this.trackereventstypes.map((event, index, ar) => {
            let str = tokens.indent + tokens.indent;
            str += `${event.key}: [${event.typeIndex}, \'${event.name}\']`;
            str += index === ar.length - 1 ? '' : ',';
            return str;
        }).join(tokens.newline));
        out = out.replace('${gameeventsTypeid}', this.gameeventsTypeid);
        out = out.replace('${messageeventsTypeid}', this.messageeventsTypeid);
        out = out.replace('${trackereventsTypeid}', this.trackereventsTypeid);
        out = out.replace('${headerTypeid}', this.headerTypeid);
        out = out.replace('${detailsTypeid}', this.detailsTypeid);
        out = out.replace('${initdataTypeid}', this.initdataTypeid);
        console.log('Protocol Write Time: ', new Date().getTime() - start);
        return out;
    }
}
exports.PythonProtocolConverter = PythonProtocolConverter;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByb3RvY29scy9QeXRob25Qcm90b2NvbENvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHVDQUF1QztBQUV2QyxNQUFNLFNBQVMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbU1qQixDQUFDO0FBR0YsTUFBTSxLQUFLLEdBQUc7SUFDVixLQUFLLEVBQUUsVUFBVSxHQUFHO1FBQ2hCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsTUFBTSxFQUFFLFVBQVUsR0FBRztRQUNqQixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELElBQUksRUFBRTtRQUNGLE1BQU0sRUFBRSxVQUFVLEdBQUc7WUFDakIsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO1lBQ2YsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QixHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakMsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDO1FBQ0QsTUFBTSxFQUFFLFVBQVUsS0FBSztZQUNuQixPQUFPLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDdEQsQ0FBQztLQUNKO0lBQ0QsT0FB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LEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDbkUsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0NBRUo7QUF4TEQsMERBd0xDIiwiZmlsZSI6InByb3RvY29scy9QeXRob25Qcm90b2NvbENvbnZlcnRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgKiBhcyBkZWNvZGVycyBmcm9tICcuL2RlY29kZXJzJztcclxuaW1wb3J0IHsgSUhlcm9Qcm90b2NvbCB9IGZyb20gJy4uL3R5cGVzJztcclxuY29uc3QgX3RlbXBsYXRlID0gYFxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgY3VycmVudDogLTEsXHJcbiAgICAgICAgdG90YWw6IC0xXHJcbiAgICB9XHJcbiAgICBleHBvcnRzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XHJcblxyXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gXFwke3ZlcnNpb259O1xyXG4gICAgXFwke3BhdGNofVxyXG5cclxuICAgIGNvbnN0IEJpdFBhY2tlZERlY29kZXIgPSBkZWNvZGVycy5CaXRQYWNrZWREZWNvZGVyO1xyXG4gICAgY29uc3QgVmVyc2lvbkRlY29kZXIgPSBkZWNvZGVycy5WZXJzaW9uRGVjb2RlcjtcclxuXHJcblxyXG4gICAgLy8gRGVjb2RpbmcgaW5zdHJ1Y3Rpb25zIGZvciBlYWNoIHByb3RvY29sIHR5cGUuXHJcbiAgICBjb25zdCB0eXBlaW5mb3MgPSBbXHJcbiAgICBcXCR7dHlwZWluZm9zfVxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBNYXAgZnJvbSBwcm90b2NvbCBOTmV0LkdhbWUuKkV2ZW50IGV2ZW50aWQgdG8gW3R5cGVpZCwgbmFtZV1cclxuICAgIGNvbnN0IGdhbWVfZXZlbnRfdHlwZXMgPSB7XHJcbiAgICBcXCR7Z2FtZWV2ZW50c1R5cGVzfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIHRoZSBOTmV0LkdhbWUuRUV2ZW50SWQgZW51bS5cclxuICAgIGNvbnN0IGdhbWVfZXZlbnRpZF90eXBlaWQgPSBcXCR7Z2FtZWV2ZW50c1R5cGVpZH07XHJcblxyXG4gICAgLy8gTWFwIGZyb20gcHJvdG9jb2wgTk5ldC5HYW1lLipNZXNzYWdlIGV2ZW50aWQgdG8gW3R5cGVpZCwgbmFtZV1cclxuICAgIGNvbnN0IG1lc3NhZ2VfZXZlbnRfdHlwZXMgPSB7XHJcbiAgICBcXCR7bWVzc2FnZWV2ZW50c1R5cGVzfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIHRoZSBOTmV0LkdhbWUuRU1lc3NhZ2VJZCBlbnVtLlxyXG4gICAgY29uc3QgbWVzc2FnZV9ldmVudGlkX3R5cGVpZCA9IFxcJHttZXNzYWdlZXZlbnRzVHlwZWlkfTtcclxuXHJcbiAgICAvLyBNYXAgZnJvbSBwcm90b2NvbCBOTmV0LlJlcGxheS5UcmFja2VyLipFdmVudCBldmVudGlkIHRvIFt0eXBlaWQsIG5hbWVdXHJcbiAgICBjb25zdCB0cmFja2VyX2V2ZW50X3R5cGVzID0ge1xyXG4gICAgXFwke3RyYWNrZXJldmVudHN0eXBlc31cclxuICAgIH07XHJcblxyXG4gICAgLy8gVGhlIHR5cGVpZCBvZiB0aGUgTk5ldC5SZXBsYXkuVHJhY2tlci5FRXZlbnRJZCBlbnVtLlxyXG4gICAgY29uc3QgdHJhY2tlcl9ldmVudGlkX3R5cGVpZCA9IFxcJHt0cmFja2VyZXZlbnRzVHlwZWlkfTtcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIE5OZXQuU1ZhclVpbnQzMiAodGhlIHR5cGUgdXNlZCB0byBlbmNvZGUgZ2FtZWxvb3AgZGVsdGFzKS5cclxuICAgIGNvbnN0IHN2YXJ1aW50MzJfdHlwZWlkID0gNztcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIE5OZXQuUmVwbGF5LlNHYW1lVXNlcklkICh0aGUgdHlwZSB1c2VkIHRvIGVuY29kZSBwbGF5ZXIgaWRzKS5cclxuICAgIGNvbnN0IHJlcGxheV91c2VyaWRfdHlwZWlkID0gODtcclxuXHJcbiAgICAvLyBUaGUgdHlwZWlkIG9mIE5OZXQuUmVwbGF5LlNIZWFkZXIgKHRoZSB0eXBlIHVzZWQgdG8gc3RvcmUgcmVwbGF5IGdhbWUgdmVyc2lvbiBhbmQgbGVuZ3RoKS5cclxuICAgIGNvbnN0IHJlcGxheV9oZWFkZXJfdHlwZWlkID0gXFwke2hlYWRlclR5cGVpZH07XHJcblxyXG4gICAgLy8gVGhlIHR5cGVpZCBvZiBOTmV0LkdhbWUuU0RldGFpbHMgKHRoZSB0eXBlIHVzZWQgdG8gc3RvcmUgb3ZlcmFsbCByZXBsYXkgZGV0YWlscykuXHJcbiAgICBjb25zdCBnYW1lX2RldGFpbHNfdHlwZWlkID0gXFwke2RldGFpbHNUeXBlaWR9O1xyXG5cclxuICAgIC8vIFRoZSB0eXBlaWQgb2YgTk5ldC5SZXBsYXkuU0luaXREYXRhICh0aGUgdHlwZSB1c2VkIHRvIHN0b3JlIHRoZSBpbml0YWwgbG9iYnkpLlxyXG4gICAgY29uc3QgcmVwbGF5X2luaXRkYXRhX3R5cGVpZCA9IFxcJHtpbml0ZGF0YVR5cGVpZH07XHJcblxyXG4gICAgLy8gbm90IHN1cmUgaWYgY29ycmVjdCBwb3J0XHJcbiAgICBmdW5jdGlvbiBfdmFydWludDMyVmFsdWUodmFsdWUpIHtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bWVyaWMgdmFsdWUgZnJvbSBhIFNWYXJVaW50MzIgaW5zdGFuY2UuXHJcbiAgICByZXR1cm4gdmFsdWVbT2JqZWN0LmtleXModmFsdWUpWzBdXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiogX2RlY29kZV9ldmVudF9zdHJlYW0oZGVjb2RlciwgZXZlbnRpZFR5cGVpZCwgZXZlbnRUeXBlcywgZGVjb2RlVXNlcklkKSB7XHJcbiAgICAvLyBEZWNvZGVzIGV2ZW50cyBwcmVmaXhlZCB3aXRoIGEgZ2FtZWxvb3AgYW5kIHBvc3NpYmx5IHVzZXJpZFxyXG4gICAgdmFyIGdhbWVsb29wID0gMDtcclxuICAgIHdoaWxlICghZGVjb2Rlci5pc0RvbmUpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RhcnRCaXRzID0gZGVjb2Rlci51c2VkQml0cztcclxuXHJcbiAgICAgICAgLy8gZGVjb2RlIHRoZSBnYW1lbG9vcCBkZWx0YSBiZWZvcmUgZWFjaCBldmVudFxyXG4gICAgICAgIHZhciBkZWx0YSA9IF92YXJ1aW50MzJWYWx1ZShkZWNvZGVyLmluc3RhbmNlKHN2YXJ1aW50MzJfdHlwZWlkKSk7XHJcbiAgICAgICAgZ2FtZWxvb3AgKz0gZGVsdGE7XHJcblxyXG4gICAgICAgIC8vIGRlY29kZSB0aGUgdXNlcmlkIGJlZm9yZSBlYWNoIGV2ZW50XHJcbiAgICAgICAgdmFyIHVzZXJpZCA9IChkZWNvZGVVc2VySWQgPT09IHRydWUpID8gZGVjb2Rlci5pbnN0YW5jZShyZXBsYXlfdXNlcmlkX3R5cGVpZCkgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIGRlY29kZSB0aGUgZXZlbnQgaWRcclxuICAgICAgICB2YXIgZXZlbnRpZCA9IGRlY29kZXIuaW5zdGFuY2UoZXZlbnRpZFR5cGVpZCk7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXNbZXZlbnRpZF0gfHwgW251bGwsIG51bGxdO1xyXG4gICAgICAgIHZhciB0eXBlaWQgPSBldmVudFR5cGVbMF07XHJcbiAgICAgICAgdmFyIHR5cGVuYW1lID0gZXZlbnRUeXBlWzFdO1xyXG4gICAgICAgIGlmICh0eXBlaWQgPT09IG51bGwpIHRocm93IG5ldyBkZWNvZGVycy5Db3JydXB0ZWRFcnJvcignZXZlbnRpZCgnICsgZXZlbnRpZCArICcpIGF0ICcgKyBkZWNvZGVyLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAvLyBkZWNvZGUgdGhlIGV2ZW50IHN0cnVjdCBpbnN0YW5jZVxyXG4gICAgICAgIHZhciBldmVudCA9IGRlY29kZXIuaW5zdGFuY2UodHlwZWlkKTtcclxuICAgICAgICBldmVudC5fZXZlbnQgPSB0eXBlbmFtZTtcclxuICAgICAgICBldmVudC5fZXZlbnRpZCA9IGV2ZW50aWQ7XHJcblxyXG4gICAgICAgIC8vIGluc2VydCBnYW1lbG9vcCBhbmQgdXNlcmlkXHJcbiAgICAgICAgZXZlbnQuX2dhbWVsb29wID0gZ2FtZWxvb3A7XHJcbiAgICAgICAgaWYgKGRlY29kZVVzZXJJZCkgZXZlbnQuX3VzZXJpZCA9IHVzZXJpZDtcclxuXHJcbiAgICAgICAgLy8gdGhlIG5leHQgZXZlbnQgaXMgYnl0ZSBhbGlnbmVkXHJcbiAgICAgICAgZGVjb2Rlci5ieXRlQWxpZ24oKTtcclxuXHJcbiAgICAgICAgLy8gaW5zZXJ0IGJpdHMgdXNlZCBpbiBzdHJlYW1cclxuICAgICAgICBldmVudC5fYml0cyA9IGRlY29kZXIudXNlZEJpdHMgLSBzdGFydEJpdHM7XHJcbiAgICAgICAgcHJvZ3Jlc3MuY3VycmVudCA9IGRlY29kZXIudXNlZEJpdHM7XHJcbiAgICAgICAgeWllbGQgZXZlbnQ7XHJcbiAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0cy5kZWNvZGVSZXBsYXlHYW1lRXZlbnRzID0gZnVuY3Rpb24qIChjb250ZW50cykge1xyXG4gICAgLy8gRGVjb2RlcyBhbmQgeWllbGRzIGVhY2ggZ2FtZSBldmVudCBmcm9tIHRoZSBjb250ZW50cyBieXRlIHN0cmluZy5cclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgQml0UGFja2VkRGVjb2Rlcihjb250ZW50cywgdHlwZWluZm9zKTtcclxuICAgIHByb2dyZXNzLmN1cnJlbnQgPSAwO1xyXG4gICAgcHJvZ3Jlc3MudG90YWwgPSBkZWNvZGVyLnNpemU7XHJcbiAgICBmb3IgKGxldCBldmVudCBvZiBfZGVjb2RlX2V2ZW50X3N0cmVhbShkZWNvZGVyLCBnYW1lX2V2ZW50aWRfdHlwZWlkLCBnYW1lX2V2ZW50X3R5cGVzLCB0cnVlKSlcclxuICAgICAgICB5aWVsZCBldmVudDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5kZWNvZGVSZXBsYXlNZXNzYWdlRXZlbnRzID0gZnVuY3Rpb24qIChjb250ZW50cykge1xyXG4gICAgICAgIC8vIERlY29kZXMgYW5kIHlpZWxkcyBlYWNoIG1lc3NhZ2UgZXZlbnQgZnJvbSB0aGUgY29udGVudHMgYnl0ZSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBCaXRQYWNrZWREZWNvZGVyKGNvbnRlbnRzLCB0eXBlaW5mb3MpO1xyXG4gICAgICAgIHByb2dyZXNzLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIHByb2dyZXNzLnRvdGFsID0gZGVjb2Rlci5zaXplO1xyXG4gICAgICAgIGZvciAobGV0IGV2ZW50IG9mIF9kZWNvZGVfZXZlbnRfc3RyZWFtKGRlY29kZXIsIG1lc3NhZ2VfZXZlbnRpZF90eXBlaWQsIG1lc3NhZ2VfZXZlbnRfdHlwZXMsIHRydWUpKVxyXG4gICAgICAgICAgICB5aWVsZCBldmVudDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5kZWNvZGVSZXBsYXlUcmFja2VyRXZlbnRzID0gZnVuY3Rpb24qIChjb250ZW50cykge1xyXG4gICAgLy8gRGVjb2RlcyBhbmQgeWllbGRzIGVhY2ggdHJhY2tlciBldmVudCBmcm9tIHRoZSBjb250ZW50cyBieXRlIHN0cmluZy5cclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVmVyc2lvbkRlY29kZXIoY29udGVudHMsIHR5cGVpbmZvcyk7XHJcbiAgICBwcm9ncmVzcy5jdXJyZW50ID0gMDtcclxuICAgIHByb2dyZXNzLnRvdGFsID0gZGVjb2Rlci5zaXplO1xyXG4gICAgZm9yIChsZXQgZXZlbnQgb2YgX2RlY29kZV9ldmVudF9zdHJlYW0oZGVjb2RlciwgdHJhY2tlcl9ldmVudGlkX3R5cGVpZCwgdHJhY2tlcl9ldmVudF90eXBlcywgZmFsc2UpKVxyXG4gICAgICAgIHlpZWxkIGV2ZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheUhlYWRlciA9IGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAvLyBEZWNvZGVzIGFuZCByZXR1cm4gdGhlIHJlcGxheSBoZWFkZXIgZnJvbSB0aGUgY29udGVudHMgYnl0ZSBzdHJpbmcuXHJcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFZlcnNpb25EZWNvZGVyKGNvbnRlbnRzLCB0eXBlaW5mb3MpO1xyXG4gICAgcmV0dXJuIGRlY29kZXIuaW5zdGFuY2UocmVwbGF5X2hlYWRlcl90eXBlaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheURldGFpbHMgPSBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgLy8gRGVjb2RlcyBhbmQgcmV0dXJucyB0aGUgZ2FtZSBkZXRhaWxzIGZyb20gdGhlIGNvbnRlbnRzIGJ5dGUgc3RyaW5nLlxyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBWZXJzaW9uRGVjb2Rlcihjb250ZW50cywgdHlwZWluZm9zKTtcclxuICAgIHJldHVybiBkZWNvZGVyLmluc3RhbmNlKGdhbWVfZGV0YWlsc190eXBlaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheUluaXRkYXRhID0gZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgIC8vIERlY29kZXMgYW5kIHJldHVybiB0aGUgcmVwbGF5IGluaXQgZGF0YSBmcm9tIHRoZSBjb250ZW50cyBieXRlIHN0cmluZy5cclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgQml0UGFja2VkRGVjb2Rlcihjb250ZW50cywgdHlwZWluZm9zKTtcclxuICAgIHJldHVybiBkZWNvZGVyLmluc3RhbmNlKHJlcGxheV9pbml0ZGF0YV90eXBlaWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmRlY29kZVJlcGxheUF0dHJpYnV0ZXNFdmVudHMgPSBmdW5jdGlvbiAoY29udGVudHMpIHtcclxuICAgIC8vIERlY29kZXMgYW5kIHlpZWxkcyBlYWNoIGF0dHJpYnV0ZSBmcm9tIHRoZSBjb250ZW50cyBieXRlIHN0cmluZy5cclxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBkZWNvZGVycy5CaXRQYWNrZWRCdWZmZXIoY29udGVudHMsICdsaXR0bGUnKTtcclxuICAgIHByb2dyZXNzLmN1cnJlbnQgPSAwO1xyXG4gICAgcHJvZ3Jlc3MudG90YWwgPSBidWZmZXIuc2l6ZTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcbiAgICBpZiAoIWJ1ZmZlci5pc0RvbmUpIHtcclxuICAgICAgICBhdHRyaWJ1dGVzLnNvdXJjZSA9IGJ1ZmZlci5yZWFkQml0cyg4KTtcclxuICAgICAgICBhdHRyaWJ1dGVzLm1hcE5hbWVTcGFjZSA9IGJ1ZmZlci5yZWFkQml0cygzMik7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gYnVmZmVyLnJlYWRCaXRzKDMyKTtcclxuICAgICAgICBhdHRyaWJ1dGVzLnNjb3BlcyA9IHt9O1xyXG5cclxuICAgICAgICB3aGlsZSAoIWJ1ZmZlci5pc0RvbmUpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB7fTtcclxuICAgICAgICB2YWx1ZS5uYW1lc3BhY2UgPSBidWZmZXIucmVhZEJpdHMoMzIpO1xyXG4gICAgICAgIHZhciBhdHRyaWQgPSB2YWx1ZS5hdHRyaWQgPSBidWZmZXIucmVhZEJpdHMoMzIpO1xyXG4gICAgICAgIHZhciBzY29wZSA9IGJ1ZmZlci5yZWFkQml0cyg4KTtcclxuICAgICAgICB2YWx1ZS52YWx1ZSA9IGJ1ZmZlci5yZWFkQWxpZ25lZEJ5dGVzKDQpLnJldmVyc2UoKTtcclxuICAgICAgICB3aGlsZSAodmFsdWUudmFsdWVbMF0gPT09IDApIHZhbHVlLnZhbHVlID0gdmFsdWUudmFsdWUuc2xpY2UoMSk7XHJcbiAgICAgICAgd2hpbGUgKHZhbHVlLnZhbHVlW3ZhbHVlLnZhbHVlLmxlbmd0aCAtIDFdID09PSAwKSB2YWx1ZS52YWx1ZSA9IHZhbHVlLnZhbHVlLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuc2NvcGVzW3Njb3BlXSlcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5zY29wZXNbc2NvcGVdID0ge307XHJcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnNjb3Blc1tzY29wZV1bYXR0cmlkXSlcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5zY29wZXNbc2NvcGVdW2F0dHJpZF0gPSBbXTtcclxuICAgICAgICBhdHRyaWJ1dGVzLnNjb3Blc1tzY29wZV1bYXR0cmlkXS5wdXNoKHZhbHVlKTtcclxuICAgICAgICBwcm9ncmVzcy5jdXJyZW50ID0gYnVmZmVyLnVzZWRCaXRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy51bml0VGFnID0gZnVuY3Rpb24odW5pdFRhZ0luZGV4LCB1bml0VGFnUmVjeWNsZSkge1xyXG4gICAgcmV0dXJuICh1bml0VGFnSW5kZXggPDwgMTgpICsgdW5pdFRhZ1JlY3ljbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMudW5pdFRhZ0luZGV4ID0gZnVuY3Rpb24odW5pdFRhZykge1xyXG4gICAgcmV0dXJuICh1bml0VGFnID4+IDE4KSAmIDB4MDAwMDNGRkY7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMudW5pdFRhZ1JlY3ljbGUgPSBmdW5jdGlvbih1bml0VGFnKSB7XHJcbiAgICByZXR1cm4gdW5pdFRhZyAmIDB4MDAwM0ZGRkY7XHJcbiAgICB9O1xyXG5gO1xyXG5cclxuXHJcbmNvbnN0IHR5cGVzID0ge1xyXG4gICAgdHVwbGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLm1hdGNoKC8oLT9cXHcrKS9nKTtcclxuICAgIH0sXHJcbiAgICB0dXBsZXM6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLm1hdGNoKC8oXFwoLio/XFwpKS9nKTtcclxuICAgIH0sXHJcbiAgICBfaW50OiB7XHJcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0eXBlcy50dXBsZShzdHIpO1xyXG4gICAgICAgICAgICByZXRbJ2JvdW5kcyddID0gW3Jlc1swXSwgcmVzWzFdXTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgWyR7aW5mb3MuYm91bmRzWzBdfSwgJHtpbmZvcy5ib3VuZHNbMV19XWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jaG9pY2U6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0ID0geyBib3VuZHM6IFtdLCBjaG9pY2VzOiBbXSB9O1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0eXBlcy50dXBsZXMoc3RyKTtcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmV0LCB0eXBlcy5faW50LmRlY29kZShyZXNbMF0pKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gdHlwZXMudHVwbGUocmVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJldC5jaG9pY2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0dXBsZVswXSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5kZXg6IHR1cGxlWzFdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBbJHtpbmZvcy5ib3VuZHNbMF19LCAke2luZm9zLmJvdW5kc1sxXX1dLCB7ICR7aW5mb3MuY2hvaWNlcy5tYXAoKGNob2ljZSwgaW5kZXgsIGFyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7aW5kZXh9OiBbJyR7Y2hvaWNlLmxhYmVsfScsICR7Y2hvaWNlLnR5cGVJbmRleH1dJHsoaW5kZXggPT09IGFyLmxlbmd0aCAtIDEpID8gJycgOiAnLCAnfWA7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJycpfX1gO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfc3RydWN0OiB7XHJcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHsgaXRlbXM6IFtdIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlcyA9IHR5cGVzLnR1cGxlcyhzdHIpO1xyXG4gICAgICAgICAgICBpZiAodHVwbGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0dXBsZXMuZm9yRWFjaCh0dXBsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHVwbGUgPSB0eXBlcy50dXBsZSh0dXBsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0Lml0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdHVwbGVbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmRleDogdHVwbGVbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogdHVwbGVbMl1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFske2luZm9zLml0ZW1zLm1hcCgoaXRlbSwgaW5kZXgsIGFyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYFsnJHtpdGVtLmxhYmVsfScsICR7aXRlbS50eXBlSW5kZXh9LCAke2l0ZW0udGFnfV0keyhpbmRleCA9PT0gYXIubGVuZ3RoIC0gMSkgPyAnJyA6ICcsICd9YDtcclxuICAgICAgICAgICAgfSkuam9pbignJyl9XWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9ibG9iOiB7XHJcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlcy5faW50LmRlY29kZShzdHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzLl9pbnQuZW5jb2RlKGluZm9zKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2Jvb2w6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfYXJyYXk6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXHJcbiAgICAgICAgICAgICAgICB7IHR5cGVJbmRleDogc3RyLm1hdGNoKC9cXGQrJC8pWzBdIH0sXHJcbiAgICAgICAgICAgICAgICB0eXBlcy5faW50LmRlY29kZShzdHIpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFske2luZm9zLmJvdW5kc1swXX0sICR7aW5mb3MuYm91bmRzWzFdfV0sICR7aW5mb3MudHlwZUluZGV4fWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9vcHRpb25hbDoge1xyXG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlSW5kZXg6IE51bWJlcihzdHIpIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7aW5mb3MudHlwZUluZGV4fWA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9mb3VyY2M6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfYml0YXJyYXk6IHtcclxuICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzLl9pbnQuZGVjb2RlKHN0cik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZXMuX2ludC5lbmNvZGUoaW5mb3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfbnVsbDoge1xyXG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgdG9rZW5zID0ge1xyXG4gICAgbmV3bGluZTogJ1xcbicsXHJcbiAgICBpbmRlbnQ6ICcgICcsXHJcbiAgICB0eXBlaW5mb3NTdGFydDogJ3R5cGVpbmZvcyA9IFsnLFxyXG4gICAgdHlwZWluZm9zRW5kOiAnXScsXHJcbiAgICBnYW1lZXZlbnRzU3RhcnQ6ICdnYW1lX2V2ZW50X3R5cGVzID0geycsXHJcbiAgICBnYW1lZXZlbnRzRW5kOiAnfScsXHJcbiAgICBtZXNzYWdlZXZlbnRzU3RhcnQ6ICdtZXNzYWdlX2V2ZW50X3R5cGVzID0geycsXHJcbiAgICBtZXNzYWdlZXZlbnRzRW5kOiAnfScsXHJcbiAgICB0cmFja2VyZXZlbnRzU3RhcnQ6ICd0cmFja2VyX2V2ZW50X3R5cGVzID0geycsXHJcbiAgICB0cmFja2VyZXZlbnRzRW5kOiAnfScsXHJcbiAgICBnYW1lZXZlbnRzVHlwZWlkOiAnZ2FtZV9ldmVudGlkX3R5cGVpZCA9JyxcclxuICAgIG1lc3NhZ2VldmVudHNUeXBlaWQ6ICdtZXNzYWdlX2V2ZW50aWRfdHlwZWlkID0nLFxyXG4gICAgdHJhY2tlcmV2ZW50c1R5cGVpZDogJ3RyYWNrZXJfZXZlbnRpZF90eXBlaWQgPScsXHJcbiAgICBoZWFkZXJUeXBlaWQ6ICdyZXBsYXlfaGVhZGVyX3R5cGVpZCA9JyxcclxuICAgIGRldGFpbHNUeXBlaWQ6ICdnYW1lX2RldGFpbHNfdHlwZWlkID0nLFxyXG4gICAgaW5pdGRhdGFUeXBlaWQ6ICdyZXBsYXlfaW5pdGRhdGFfdHlwZWlkID0nXHJcbn07XHJcblxyXG5jb25zdCBfZGF0YSA9IHtcclxuICAgIHJlYWxtczogW3VuZGVmaW5lZCwgJ2xpdmUnXSxcclxuICAgIHJlZ2lvbnM6IFtcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICdFdXJvcGUnXHJcbiAgICBdLFxyXG4gICAgaGVyb2VzOiBbXSxcclxuICAgIG1vdW50czogW10sXHJcbiAgICBtYXBzOiBbXSxcclxuICAgIGJ1aWxkczogW11cclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBQeXRob25Qcm90b2NvbENvbnZlcnRlciB7XHJcbiAgICBwcml2YXRlIHB5Q29kZTogc3RyaW5nO1xyXG5cclxuICAgIHByaXZhdGUgdHlwZWluZm9zOiBhbnlbXTtcclxuICAgIHByaXZhdGUgZ2FtZWV2ZW50c1R5cGVzOiBhbnlbXTtcclxuICAgIHByaXZhdGUgbWVzc2FnZWV2ZW50c1R5cGVzOiBhbnlbXTtcclxuICAgIHByaXZhdGUgdHJhY2tlcmV2ZW50c3R5cGVzOiBhbnlbXTtcclxuXHJcbiAgICBwcml2YXRlIGdhbWVldmVudHNUeXBlaWQ7XHJcbiAgICBwcml2YXRlIG1lc3NhZ2VldmVudHNUeXBlaWQ7XHJcbiAgICBwcml2YXRlIHRyYWNrZXJldmVudHNUeXBlaWQ7XHJcbiAgICBwcml2YXRlIGhlYWRlclR5cGVpZDtcclxuICAgIHByaXZhdGUgZGV0YWlsc1R5cGVpZDtcclxuICAgIHByaXZhdGUgaW5pdGRhdGFUeXBlaWQ7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjb21waWxlKHByb3RvY29sQ29kZTogc3RyaW5nKTogSUhlcm9Qcm90b2NvbCB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICBjb25zdCBwcm90b2NvbDogSUhlcm9Qcm90b2NvbCA9IDxJSGVyb1Byb3RvY29sPnt9O1xyXG4gICAgICAgIGNvbnN0IGZuID0gRnVuY3Rpb24oJ2V4cG9ydHMnLCAnZGVjb2RlcnMnLCBwcm90b2NvbENvZGUpO1xyXG4gICAgICAgIGZuKHByb3RvY29sLCBkZWNvZGVycyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Byb3RvY29sIENvbXBpbGUgVGltZTogJywgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHByb3RvY29sO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHZlcnNpb246IG51bWJlciwgcHlDb2RlOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnB5Q29kZSA9IHB5Q29kZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29udmVydCgpOiBJSGVyb1Byb3RvY29sIHtcclxuICAgICAgICByZXR1cm4gUHl0aG9uUHJvdG9jb2xDb252ZXJ0ZXIuY29tcGlsZSh0aGlzLmdldENvZGUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENvZGUoKTogc3RyaW5nIHtcclxuICAgICAgICB0aGlzLnBhcnNlKHRoaXMucHlDb2RlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBwYXJzZShyYXc6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSByYXcuc3BsaXQodG9rZW5zLm5ld2xpbmUpO1xyXG4gICAgICAgIGxldCBsaW5lID0gMCwgc3RyO1xyXG4gICAgICAgIHRoaXMudHlwZWluZm9zID0gW107XHJcbiAgICAgICAgdGhpcy5nYW1lZXZlbnRzVHlwZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VldmVudHNUeXBlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudHJhY2tlcmV2ZW50c3R5cGVzID0gW107XHJcbiAgICAgICAgd2hpbGUgKGxpbmUgPCBsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc3RyID0gbGluZXNbbGluZV0udHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RyID09PSB0b2tlbnMudHlwZWluZm9zU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVpbmZvcy5wdXNoKHRoaXMucGFyc2VUeXBlaW5mb3Moc3RyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHN0ciAhPT0gdG9rZW5zLnR5cGVpbmZvc0VuZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5zLmdhbWVldmVudHNTdGFydCA9PT0gc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBsaW5lc1tsaW5lXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lZXZlbnRzVHlwZXMucHVzaCh0aGlzLnBhcnNlRXZlbnQoc3RyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2Vucy5nYW1lZXZlbnRzRW5kICE9PSBzdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2Vucy5tZXNzYWdlZXZlbnRzU3RhcnQgPT09IHN0cikge1xyXG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gbGluZXNbbGluZV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZWV2ZW50c1R5cGVzLnB1c2godGhpcy5wYXJzZUV2ZW50KHN0cikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBsaW5lc1tsaW5lXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0b2tlbnMubWVzc2FnZWV2ZW50c0VuZCAhPT0gc3RyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbnMudHJhY2tlcmV2ZW50c1N0YXJ0ID09PSBzdHIpIHtcclxuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGxpbmVzW2xpbmVdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrZXJldmVudHN0eXBlcy5wdXNoKHRoaXMucGFyc2VFdmVudChzdHIpKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gbGluZXNbbGluZV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW5zLnRyYWNrZXJldmVudHNFbmQgIT09IHN0cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyLnN0YXJ0c1dpdGgodG9rZW5zLmdhbWVldmVudHNUeXBlaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVldmVudHNUeXBlaWQgPSBzdHIubWF0Y2goL1xcZCsvKVswXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHIuc3RhcnRzV2l0aCh0b2tlbnMubWVzc2FnZWV2ZW50c1R5cGVpZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZWV2ZW50c1R5cGVpZCA9IHN0ci5tYXRjaCgvXFxkKy8pWzBdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ci5zdGFydHNXaXRoKHRva2Vucy50cmFja2VyZXZlbnRzVHlwZWlkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFja2VyZXZlbnRzVHlwZWlkID0gc3RyLm1hdGNoKC9cXGQrLylbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyLnN0YXJ0c1dpdGgodG9rZW5zLmhlYWRlclR5cGVpZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyVHlwZWlkID0gc3RyLm1hdGNoKC9cXGQrLylbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyLnN0YXJ0c1dpdGgodG9rZW5zLmRldGFpbHNUeXBlaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFpbHNUeXBlaWQgPSBzdHIubWF0Y2goL1xcZCsvKVswXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHIuc3RhcnRzV2l0aCh0b2tlbnMuaW5pdGRhdGFUeXBlaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRkYXRhVHlwZWlkID0gc3RyLm1hdGNoKC9cXGQrLylbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Byb3RvY29sIFBhcnNlIFRpbWU6ICcsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcGFyc2VFdmVudChzdHI6IHN0cmluZyk6IHsga2V5OiBzdHJpbmcsIHR5cGVJbmRleDogc3RyaW5nLCBuYW1lOiBzdHJpbmcgfSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gc3RyLm1hdGNoKC9eKFxcZCspOlxcc1xcKChcXGQrKSxcXHNcXCcoLiopXFwnLyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5OiByZXNbMV0sXHJcbiAgICAgICAgICAgIHR5cGVJbmRleDogcmVzWzJdLFxyXG4gICAgICAgICAgICBuYW1lOiByZXNbM11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcGFyc2VUeXBlaW5mb3Moc3RyOiBzdHJpbmcpOiB7IHN0cjogc3RyaW5nLCB0eXBlPzogc3RyaW5nLCBpbmRleD86IHN0cmluZyB9IHtcclxuICAgICAgICBjb25zdCB0eXBlUmVnZXggPSAvXlxcKCcoLio/KScsXFxbKC4qKVxcXVxcKSxcXHMqIyhcXGQrKSQvO1xyXG4gICAgICAgIGNvbnN0IGluZm9zOiB7IHN0cjogc3RyaW5nLCB0eXBlPzogc3RyaW5nLCBpbmRleD86IHN0cmluZyB9ID0geyBzdHI6IHN0ciB9O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHR5cGVSZWdleC5leGVjKHN0cik7XHJcbiAgICAgICAgaW5mb3MudHlwZSA9IHJlc1sxXTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGluZm9zLCB0eXBlc1tpbmZvcy50eXBlXS5kZWNvZGUocmVzWzJdKSk7XHJcbiAgICAgICAgaW5mb3MuaW5kZXggPSByZXNbM107XHJcbiAgICAgICAgcmV0dXJuIGluZm9zO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgd3JpdGUoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNvbnN0IGJ1aWxkSW5mb3MgPSBfZGF0YS5idWlsZHNbdGhpcy52ZXJzaW9uXTtcclxuXHJcbiAgICAgICAgbGV0IG91dDogc3RyaW5nID0gX3RlbXBsYXRlO1xyXG4gICAgICAgIC8vIHVubmVzc2lhcnlcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHtkYXRlfScsIG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSk7XHJcbiAgICAgICAgLy8gdW5uZXNzaWFyeVxyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKDxhbnk+JyR7dmVyc2lvbn0nLCA8YW55PnRoaXMudmVyc2lvbik7XHJcblxyXG4gICAgICAgIGlmIChidWlsZEluZm9zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gYnVpbGRJbmZvcy5saXZlID8gYnVpbGRJbmZvcy5saXZlLnBhdGNoIDogYnVpbGRJbmZvcy5wdHIucGF0Y2g7XHJcbiAgICAgICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke3BhdGNofScsIGBleHBvcnRzLnBhdGNoID0gXFwnJHtwYXRjaH1cXCc7JHt0b2tlbnMubmV3bGluZX1gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHtwYXRjaH0nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHt0eXBlaW5mb3N9JywgdGhpcy50eXBlaW5mb3MubWFwKChpbmZvcywgaW5kZXgsIGFyKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSB0b2tlbnMuaW5kZW50O1xyXG5cclxuICAgICAgICAgICAgc3RyICs9IGBbJyR7aW5mb3MudHlwZX0nLCBbYDtcclxuICAgICAgICAgICAgc3RyICs9IHR5cGVzW2luZm9zLnR5cGVdLmVuY29kZShpbmZvcyk7XHJcbiAgICAgICAgICAgIHN0ciArPSBgXV0ke2luZGV4ID09PSAoYXIubGVuZ3RoIC0gMSkgPyAnJyA6ICcsJ31gO1xyXG4gICAgICAgICAgICBzdHIgKz0gYCAgLy8ke2luZm9zLmluZGV4fWA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pLmpvaW4odG9rZW5zLm5ld2xpbmUpKTtcclxuXHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7Z2FtZWV2ZW50c1R5cGVzfScsIHRoaXMuZ2FtZWV2ZW50c1R5cGVzLm1hcCgoZXZlbnQsIGluZGV4LCBhcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gdG9rZW5zLmluZGVudDtcclxuXHJcbiAgICAgICAgICAgIHN0ciArPSBgJHtldmVudC5rZXl9OiBbJHtldmVudC50eXBlSW5kZXh9LCBcXCcke2V2ZW50Lm5hbWV9XFwnXWA7XHJcbiAgICAgICAgICAgIHN0ciArPSBpbmRleCA9PT0gYXIubGVuZ3RoIC0gMSA/ICcnIDogJywnO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9KS5qb2luKHRva2Vucy5uZXdsaW5lKSk7XHJcblxyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke21lc3NhZ2VldmVudHNUeXBlc30nLCB0aGlzLm1lc3NhZ2VldmVudHNUeXBlcy5tYXAoKGV2ZW50LCBpbmRleCwgYXIpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0ciA9IHRva2Vucy5pbmRlbnQ7XHJcblxyXG4gICAgICAgICAgICBzdHIgKz0gYCR7ZXZlbnQua2V5fTogWyR7ZXZlbnQudHlwZUluZGV4fSwgXFwnJHtldmVudC5uYW1lfVxcJ11gO1xyXG4gICAgICAgICAgICBzdHIgKz0gaW5kZXggPT09IGFyLmxlbmd0aCAtIDEgPyAnJyA6ICcsJztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfSkuam9pbih0b2tlbnMubmV3bGluZSkpO1xyXG5cclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHt0cmFja2VyZXZlbnRzdHlwZXN9JywgdGhpcy50cmFja2VyZXZlbnRzdHlwZXMubWFwKChldmVudCwgaW5kZXgsIGFyKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSB0b2tlbnMuaW5kZW50ICsgdG9rZW5zLmluZGVudDtcclxuXHJcbiAgICAgICAgICAgIHN0ciArPSBgJHtldmVudC5rZXl9OiBbJHtldmVudC50eXBlSW5kZXh9LCBcXCcke2V2ZW50Lm5hbWV9XFwnXWA7XHJcbiAgICAgICAgICAgIHN0ciArPSBpbmRleCA9PT0gYXIubGVuZ3RoIC0gMSA/ICcnIDogJywnO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9KS5qb2luKHRva2Vucy5uZXdsaW5lKSk7XHJcblxyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke2dhbWVldmVudHNUeXBlaWR9JywgdGhpcy5nYW1lZXZlbnRzVHlwZWlkKTtcclxuICAgICAgICBvdXQgPSBvdXQucmVwbGFjZSgnJHttZXNzYWdlZXZlbnRzVHlwZWlkfScsIHRoaXMubWVzc2FnZWV2ZW50c1R5cGVpZCk7XHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7dHJhY2tlcmV2ZW50c1R5cGVpZH0nLCB0aGlzLnRyYWNrZXJldmVudHNUeXBlaWQpO1xyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke2hlYWRlclR5cGVpZH0nLCB0aGlzLmhlYWRlclR5cGVpZCk7XHJcbiAgICAgICAgb3V0ID0gb3V0LnJlcGxhY2UoJyR7ZGV0YWlsc1R5cGVpZH0nLCB0aGlzLmRldGFpbHNUeXBlaWQpO1xyXG4gICAgICAgIG91dCA9IG91dC5yZXBsYWNlKCcke2luaXRkYXRhVHlwZWlkfScsIHRoaXMuaW5pdGRhdGFUeXBlaWQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdQcm90b2NvbCBXcml0ZSBUaW1lOiAnLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/protocols/decoders.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const decoder_1 = __webpack_require__("../heroprotocol/dist/lib/decoder/index.js");
exports.BitPackedBuffer = decoder_1.BitPackedBuffer;
exports.VersionDecoder = decoder_1.VersionDecoder;
exports.BitPackedDecoder = decoder_1.BitPackedDecoder;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByb3RvY29scy9kZWNvZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdDQUE2RTtBQUV4RSwwQkFGRyx5QkFBZSxDQUVIO0FBQ2YseUJBSG9CLHdCQUFjLENBR3BCO0FBQ2QsMkJBSm9DLDBCQUFnQixDQUlwQyIsImZpbGUiOiJwcm90b2NvbHMvZGVjb2RlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0JpdFBhY2tlZEJ1ZmZlciwgVmVyc2lvbkRlY29kZXIsIEJpdFBhY2tlZERlY29kZXJ9IGZyb20gJy4uL2RlY29kZXInO1xyXG5leHBvcnQge1xyXG4gICAgIEJpdFBhY2tlZEJ1ZmZlcixcclxuICAgICBWZXJzaW9uRGVjb2RlcixcclxuICAgICBCaXRQYWNrZWREZWNvZGVyXHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/Replay.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = __webpack_require__("./node_modules/buffer/index.js");
const mpq_1 = __webpack_require__("../heroprotocol/node_modules/@heroesbrowser/mpq/dist/index.js");
const heroprotocol_1 = __webpack_require__("../heroprotocol/dist/lib/heroprotocol.js");
const types_1 = __webpack_require__("../heroprotocol/dist/lib/types/index.js");
const decorators_1 = __webpack_require__("../heroprotocol/dist/lib/replay/decorators.js");
const BehaviorSubject_1 = __webpack_require__("./node_modules/rxjs/BehaviorSubject.js");
function parseStrings(data) {
    if (!data) {
        return data;
    }
    else if (data instanceof buffer_1.Buffer) {
        return data.toString();
    }
    else if (Array.isArray(data)) {
        return data.map(item => parseStrings(item));
    }
    else if (typeof data === 'object') {
        // tslint:disable-next-line:forin
        for (const key in data) {
            data[key] = parseStrings(data[key]);
        }
    }
    return data;
}
;
var ReplayFiles;
(function (ReplayFiles) {
    ReplayFiles["DETAILS"] = "replay.details";
    ReplayFiles["INITDATA"] = "replay.initdata";
    ReplayFiles["GAME_EVENTS"] = "replay.game.events";
    ReplayFiles["MESSAGE_EVENTS"] = "replay.message.events";
    ReplayFiles["TRACKER_EVENTS"] = "replay.tracker.events";
    ReplayFiles["ATTRIBUTES_EVENTS"] = "replay.attributes.events";
})(ReplayFiles = exports.ReplayFiles || (exports.ReplayFiles = {}));
const decoderMap = {
    [ReplayFiles.DETAILS]: 'decodeReplayDetails',
    [ReplayFiles.INITDATA]: 'decodeReplayInitdata',
    [ReplayFiles.GAME_EVENTS]: 'decodeReplayGameEvents',
    [ReplayFiles.MESSAGE_EVENTS]: 'decodeReplayMessageEvents',
    [ReplayFiles.TRACKER_EVENTS]: 'decodeReplayTrackerEvents',
    [ReplayFiles.ATTRIBUTES_EVENTS]: 'decodeReplayAttributesEvents',
};
let Replay = class Replay {
    constructor(mpqData) {
        this._data = new Map();
        this._statusSubject = new BehaviorSubject_1.BehaviorSubject(undefined);
        this._stateSubject = new BehaviorSubject_1.BehaviorSubject(undefined);
        this._lastProgressTime = 0;
        this.loadProtocol = (protocolVersion) => __awaiter(this, void 0, void 0, function* () {
            return yield heroprotocol_1.HeroProtocol.loadProtocol(protocolVersion);
        });
        this._mpq = new mpq_1.MPQArchive(mpqData);
        this.manageStatus();
    }
    get status() {
        return this._statusSubject;
    }
    get protocol() {
        if (this._protocol) {
            return this.asPromise(this._protocol);
        }
        return this.parseHeader().then(() => {
            return this.asPromise(this._protocol);
        });
    }
    get header() {
        if (this._header) {
            this.asPromise(this._header);
        }
        return this.parseHeader();
    }
    get details() {
        return this.data(ReplayFiles.DETAILS);
    }
    get initData() {
        return this.data(ReplayFiles.INITDATA);
    }
    get gameEvents() {
        return this.events(ReplayFiles.GAME_EVENTS);
    }
    get messageEvents() {
        return this.events(ReplayFiles.MESSAGE_EVENTS);
    }
    get trackerEvents() {
        return this.events(ReplayFiles.TRACKER_EVENTS);
    }
    get attributeEvents() {
        return this.data(ReplayFiles.ATTRIBUTES_EVENTS);
    }
    manageStatus() {
        /* let progressSub = this._progressSubject.pipe(debounceTime(100)).subscribe((next) => {
             this._statusSubject.next(next);
         });*/
        const stateSub = this._stateSubject.subscribe((next) => {
            //progressSub.unsubscribe();
            // this._progressSubject = new BehaviorSubject<IReplayStatusMessage>(undefined);
            this._statusSubject.next(next);
            /* progressSub = this._progressSubject.pipe(debounceTime(100)).subscribe((nextProgress) => {
                 this._statusSubject.next(nextProgress);
             });*/
        });
    }
    updateStatus(status, current = 0, total = -1) {
        const msg = {
            type: 'replay-status',
            status,
            current,
            total
        };
        if (total === -1) {
            if (this._lastProgress) {
                this._stateSubject.next(this._lastProgress);
                this._lastProgress = undefined;
            }
            this._stateSubject.next(msg);
        }
        else {
            const now = new Date().getTime();
            const delta = now - this._lastProgressTime;
            if (delta > 10) {
                this._stateSubject.next(msg);
                this._lastProgressTime = now;
            }
            else {
                this._lastProgress = msg;
            }
            /*if (!this._progressSubject) {
                this._progressSubject = new BehaviorSubject(undefined);
                this._progressSub = this._progressSubject.pipe(debounceTime(10)).subscribe((nextProgress) => {
                    this._statusSubject.next(nextProgress);
                });
            }*/
            //this._progressSubject.next(msg);
        }
    }
    parseHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            this.updateStatus('parseHeader');
            const headProtocol = yield this.getProtocol(29406);
            const rawHeader = parseStrings(headProtocol.decodeReplayHeader(this._mpq.header.userDataHeader.content));
            this._protocolPromise = this.getProtocol(rawHeader.m_version.m_baseBuild);
            this._protocol = yield this._protocolPromise;
            this._header = parseStrings(this._protocol.decodeReplayHeader(this._mpq.header.userDataHeader.content));
            this.updateStatus('parseHeader', -1);
            return this._header;
        });
    }
    getProtocol(protocolVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            this.updateStatus('getProtocol');
            if (heroprotocol_1.HeroProtocol.hasProtocol(protocolVersion)) {
                return heroprotocol_1.HeroProtocol.getProtocol(protocolVersion);
            }
            const code = yield this.loadProtocol(protocolVersion);
            const protocol = heroprotocol_1.HeroProtocol.compile(protocolVersion, code);
            this.updateStatus('getProtocol', -1);
            return protocol;
        });
    }
    parse(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.protocol;
            const data = parseStrings(protocol[decoderMap[type]](this._mpq.readFile(type)));
            this._data.set(type, data);
            return data;
        });
    }
    parseEvents(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.protocol;
            const eventGen = protocol[decoderMap[type]](this._mpq.readFile(type));
            const events = [];
            this.updateStatus('parse-event-' + type, 0, protocol.progress.total);
            for (const event of eventGen) {
                if (types_1.FilteredEvents.indexOf(event._event) === -1) {
                    events.push(parseStrings(event));
                }
                this.updateStatus('parse-event-' + type, protocol.progress.current, protocol.progress.total);
            }
            this._data.set(type, events);
            this.updateStatus('parse-event-' + type, -1);
            return events;
        });
    }
    data(type) {
        if (this._data.has(type)) {
            return this.asPromise(this._data.get(type));
        }
        return this.parse(type);
    }
    events(type) {
        if (this._data.has(type)) {
            return this.asPromise(this._data.get(type));
        }
        return this.parseEvents(type);
    }
    asPromise(value) {
        return new Promise((res, rej) => {
            res(value);
        });
    }
    dispose() {
        this._mpq = undefined;
        this._data = undefined;
        this._header = undefined;
        this._protocol = undefined;
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "header", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "details", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "initData", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "gameEvents", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "messageEvents", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "trackerEvents", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], Replay.prototype, "attributeEvents", null);
Replay = __decorate([
    decorators_1.ReplayWorkerContext('008DCF70-B7E4-42DF-A3F9-4D2ADE13E718'),
    __metadata("design:paramtypes", [ArrayBuffer])
], Replay);
exports.Replay = Replay;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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O0lBREMsd0JBQVcsRUFBRTs7OzJDQUdiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7MkNBR2I7QUFHRDtJQURDLHdCQUFXLEVBQUU7Ozs2Q0FHYjtBQTNEUSxNQUFNO0lBRGxCLGdDQUFtQixDQUFDLHNDQUFzQyxDQUFDO3FDQThENUIsV0FBVztHQTdEOUIsTUFBTSxDQXFNbEI7QUFyTVksd0JBQU0iLCJmaWxlIjoicmVwbGF5L1JlcGxheS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XHJcbmltcG9ydCB7IE1QUUFyY2hpdmUgfSBmcm9tICdAaGVyb2VzYnJvd3Nlci9tcHEnO1xyXG5pbXBvcnQgeyBIZXJvUHJvdG9jb2wgfSBmcm9tICcuLi9oZXJvcHJvdG9jb2wnO1xyXG5pbXBvcnQge1xyXG4gICAgSUhlcm9Qcm90b2NvbCxcclxuICAgIElSZXBsYXlIZWFkZXIsIElSZXBsYXlEZXRhaWxzLFxyXG4gICAgSVJlcGxheUluaXREYXRhLFxyXG4gICAgRmlsdGVyZWRFdmVudHMsIElSZXBsYXlFdmVudCwgSVJlcGxheVRyYWNrZXJFdmVudFxyXG59IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgUnVuT25Xb3JrZXIsIFJlcGxheVdvcmtlckNvbnRleHQgfSBmcm9tICcuL2RlY29yYXRvcnMnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgSVJlcGxheVN0YXR1c01lc3NhZ2UgfSBmcm9tICcuL3Byb3h5L21lc3NhZ2VzJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMvZGVib3VuY2VUaW1lJztcclxuaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzL09ic2VydmFibGUvdGltZXInO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VTdHJpbmdzPFQ+KGRhdGEpIHtcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcclxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLm1hcChpdGVtID0+IHBhcnNlU3RyaW5ncyhpdGVtKSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gcGFyc2VTdHJpbmdzKGRhdGFba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGVudW0gUmVwbGF5RmlsZXMge1xyXG4gICAgREVUQUlMUyA9ICdyZXBsYXkuZGV0YWlscycsXHJcbiAgICBJTklUREFUQSA9ICdyZXBsYXkuaW5pdGRhdGEnLFxyXG4gICAgR0FNRV9FVkVOVFMgPSAncmVwbGF5LmdhbWUuZXZlbnRzJyxcclxuICAgIE1FU1NBR0VfRVZFTlRTID0gJ3JlcGxheS5tZXNzYWdlLmV2ZW50cycsXHJcbiAgICBUUkFDS0VSX0VWRU5UUyA9ICdyZXBsYXkudHJhY2tlci5ldmVudHMnLFxyXG4gICAgQVRUUklCVVRFU19FVkVOVFMgPSAncmVwbGF5LmF0dHJpYnV0ZXMuZXZlbnRzJyxcclxuXHJcbn1cclxuXHJcbmNvbnN0IGRlY29kZXJNYXAgPSB7XHJcbiAgICBbUmVwbGF5RmlsZXMuREVUQUlMU106ICdkZWNvZGVSZXBsYXlEZXRhaWxzJyxcclxuICAgIFtSZXBsYXlGaWxlcy5JTklUREFUQV06ICdkZWNvZGVSZXBsYXlJbml0ZGF0YScsXHJcbiAgICBbUmVwbGF5RmlsZXMuR0FNRV9FVkVOVFNdOiAnZGVjb2RlUmVwbGF5R2FtZUV2ZW50cycsXHJcbiAgICBbUmVwbGF5RmlsZXMuTUVTU0FHRV9FVkVOVFNdOiAnZGVjb2RlUmVwbGF5TWVzc2FnZUV2ZW50cycsXHJcbiAgICBbUmVwbGF5RmlsZXMuVFJBQ0tFUl9FVkVOVFNdOiAnZGVjb2RlUmVwbGF5VHJhY2tlckV2ZW50cycsXHJcbiAgICBbUmVwbGF5RmlsZXMuQVRUUklCVVRFU19FVkVOVFNdOiAnZGVjb2RlUmVwbGF5QXR0cmlidXRlc0V2ZW50cycsXHJcbn07XHJcblxyXG5AUmVwbGF5V29ya2VyQ29udGV4dCgnMDA4RENGNzAtQjdFNC00MkRGLUEzRjktNEQyQURFMTNFNzE4JylcclxuZXhwb3J0IGNsYXNzIFJlcGxheSB7XHJcbiAgICBwcml2YXRlIF9tcHE6IE1QUUFyY2hpdmU7XHJcbiAgICBwcml2YXRlIF9wcm90b2NvbFByb21pc2U6IFByb21pc2U8SUhlcm9Qcm90b2NvbD47XHJcbiAgICBwcml2YXRlIF9wcm90b2NvbDogSUhlcm9Qcm90b2NvbDtcclxuICAgIHByaXZhdGUgX2hlYWRlcjogSVJlcGxheUhlYWRlcjtcclxuICAgIHByaXZhdGUgX2RhdGE6IE1hcDxSZXBsYXlGaWxlcywgYW55PiA9IG5ldyBNYXA8UmVwbGF5RmlsZXMsIGFueT4oKTtcclxuICAgIHByaXZhdGUgX3N0YXR1c1N1YmplY3Q6IEJlaGF2aW9yU3ViamVjdDxJUmVwbGF5U3RhdHVzTWVzc2FnZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XHJcbiAgICBwcml2YXRlIF9zdGF0ZVN1YmplY3Q6IEJlaGF2aW9yU3ViamVjdDxJUmVwbGF5U3RhdHVzTWVzc2FnZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XHJcbiAgICBwcml2YXRlIF9wcm9ncmVzc1N1YmplY3Q6IEJlaGF2aW9yU3ViamVjdDxJUmVwbGF5U3RhdHVzTWVzc2FnZT47XHJcbiAgICBwcml2YXRlIF9wcm9ncmVzc1N1YjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIHB1YmxpYyBnZXQgc3RhdHVzKCk6IEJlaGF2aW9yU3ViamVjdDxJUmVwbGF5U3RhdHVzTWVzc2FnZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNTdWJqZWN0O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCBwcm90b2NvbCgpOiBQcm9taXNlPElIZXJvUHJvdG9jb2w+IHtcclxuICAgICAgICBpZiAodGhpcy5fcHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNQcm9taXNlKHRoaXMuX3Byb3RvY29sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIZWFkZXIoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNQcm9taXNlKHRoaXMuX3Byb3RvY29sKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBoZWFkZXIoKTogUHJvbWlzZTxJUmVwbGF5SGVhZGVyPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmFzUHJvbWlzZSh0aGlzLl9oZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUhlYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIEBSdW5PbldvcmtlcigpXHJcbiAgICBwdWJsaWMgZ2V0IGRldGFpbHMoKTogUHJvbWlzZTxJUmVwbGF5RGV0YWlscz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE8SVJlcGxheURldGFpbHM+KFJlcGxheUZpbGVzLkRFVEFJTFMpO1xyXG4gICAgfVxyXG5cclxuICAgIEBSdW5PbldvcmtlcigpXHJcbiAgICBwdWJsaWMgZ2V0IGluaXREYXRhKCk6IFByb21pc2U8SVJlcGxheUluaXREYXRhPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTxJUmVwbGF5SW5pdERhdGE+KFJlcGxheUZpbGVzLklOSVREQVRBKTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBnYW1lRXZlbnRzKCk6IFByb21pc2U8SVJlcGxheURldGFpbHNbXT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50czxJUmVwbGF5RGV0YWlscz4oUmVwbGF5RmlsZXMuR0FNRV9FVkVOVFMpO1xyXG4gICAgfVxyXG5cclxuICAgIEBSdW5PbldvcmtlcigpXHJcbiAgICBwdWJsaWMgZ2V0IG1lc3NhZ2VFdmVudHMoKTogUHJvbWlzZTxJUmVwbGF5RGV0YWlsc1tdPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzPElSZXBsYXlEZXRhaWxzPihSZXBsYXlGaWxlcy5NRVNTQUdFX0VWRU5UUyk7XHJcbiAgICB9XHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgdHJhY2tlckV2ZW50cygpOiBQcm9taXNlPElSZXBsYXlUcmFja2VyRXZlbnRbXT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50czxJUmVwbGF5VHJhY2tlckV2ZW50PihSZXBsYXlGaWxlcy5UUkFDS0VSX0VWRU5UUyk7XHJcbiAgICB9XHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgYXR0cmlidXRlRXZlbnRzKCk6IFByb21pc2U8SVJlcGxheURldGFpbHM+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhPElSZXBsYXlEZXRhaWxzPihSZXBsYXlGaWxlcy5BVFRSSUJVVEVTX0VWRU5UUyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKG1wcURhdGE6IEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5fbXBxID0gbmV3IE1QUUFyY2hpdmUobXBxRGF0YSk7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1hbmFnZVN0YXR1cygpIHtcclxuICAgICAgICAvKiBsZXQgcHJvZ3Jlc3NTdWIgPSB0aGlzLl9wcm9ncmVzc1N1YmplY3QucGlwZShkZWJvdW5jZVRpbWUoMTAwKSkuc3Vic2NyaWJlKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0Lm5leHQobmV4dCk7XHJcbiAgICAgICAgIH0pOyovXHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRlU3ViID0gdGhpcy5fc3RhdGVTdWJqZWN0LnN1YnNjcmliZSgobmV4dCkgPT4ge1xyXG4gICAgICAgICAgICAvL3Byb2dyZXNzU3ViLnVuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGlzLl9wcm9ncmVzc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PElSZXBsYXlTdGF0dXNNZXNzYWdlPih1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0Lm5leHQobmV4dCk7XHJcbiAgICAgICAgICAgIC8qIHByb2dyZXNzU3ViID0gdGhpcy5fcHJvZ3Jlc3NTdWJqZWN0LnBpcGUoZGVib3VuY2VUaW1lKDEwMCkpLnN1YnNjcmliZSgobmV4dFByb2dyZXNzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzU3ViamVjdC5uZXh0KG5leHRQcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICB9KTsqL1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xhc3RQcm9ncmVzc1RpbWUgPSAwO1xyXG4gICAgcHJpdmF0ZSBfbGFzdFByb2dyZXNzOiBJUmVwbGF5U3RhdHVzTWVzc2FnZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlU3RhdHVzKHN0YXR1czogc3RyaW5nLCBjdXJyZW50ID0gMCwgdG90YWwgPSAtMSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG1zZzogSVJlcGxheVN0YXR1c01lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdyZXBsYXktc3RhdHVzJyxcclxuICAgICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgICBjdXJyZW50LFxyXG4gICAgICAgICAgICB0b3RhbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0b3RhbCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RQcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVTdWJqZWN0Lm5leHQodGhpcy5fbGFzdFByb2dyZXNzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN1YmplY3QubmV4dChtc2cpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IG5vdyAtIHRoaXMuX2xhc3RQcm9ncmVzc1RpbWU7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVN1YmplY3QubmV4dChtc2cpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzVGltZSA9IG5vdztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG1zZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKmlmICghdGhpcy5fcHJvZ3Jlc3NTdWJqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc1N1YiA9IHRoaXMuX3Byb2dyZXNzU3ViamVjdC5waXBlKGRlYm91bmNlVGltZSgxMCkpLnN1YnNjcmliZSgobmV4dFByb2dyZXNzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzU3ViamVjdC5uZXh0KG5leHRQcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgIC8vdGhpcy5fcHJvZ3Jlc3NTdWJqZWN0Lm5leHQobXNnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgcGFyc2VIZWFkZXIoKTogUHJvbWlzZTxJUmVwbGF5SGVhZGVyPiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ3BhcnNlSGVhZGVyJyk7XHJcbiAgICAgICAgY29uc3QgaGVhZFByb3RvY29sID0gYXdhaXQgdGhpcy5nZXRQcm90b2NvbCgyOTQwNik7XHJcbiAgICAgICAgY29uc3QgcmF3SGVhZGVyID0gcGFyc2VTdHJpbmdzKGhlYWRQcm90b2NvbC5kZWNvZGVSZXBsYXlIZWFkZXIodGhpcy5fbXBxLmhlYWRlci51c2VyRGF0YUhlYWRlci5jb250ZW50KSk7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2xQcm9taXNlID0gdGhpcy5nZXRQcm90b2NvbChyYXdIZWFkZXIubV92ZXJzaW9uLm1fYmFzZUJ1aWxkKTtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IGF3YWl0IHRoaXMuX3Byb3RvY29sUHJvbWlzZTtcclxuICAgICAgICB0aGlzLl9oZWFkZXIgPSBwYXJzZVN0cmluZ3ModGhpcy5fcHJvdG9jb2wuZGVjb2RlUmVwbGF5SGVhZGVyKHRoaXMuX21wcS5oZWFkZXIudXNlckRhdGFIZWFkZXIuY29udGVudCkpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCdwYXJzZUhlYWRlcicsIC0xKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgbG9hZFByb3RvY29sID0gYXN5bmMgKHByb3RvY29sVmVyc2lvbjogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgSGVyb1Byb3RvY29sLmxvYWRQcm90b2NvbChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0UHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uOiBudW1iZXIpOiBQcm9taXNlPElIZXJvUHJvdG9jb2w+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygnZ2V0UHJvdG9jb2wnKTtcclxuICAgICAgICBpZiAoSGVyb1Byb3RvY29sLmhhc1Byb3RvY29sKHByb3RvY29sVmVyc2lvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhlcm9Qcm90b2NvbC5nZXRQcm90b2NvbChwcm90b2NvbFZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5sb2FkUHJvdG9jb2wocHJvdG9jb2xWZXJzaW9uKTtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IEhlcm9Qcm90b2NvbC5jb21waWxlKHByb3RvY29sVmVyc2lvbiwgY29kZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXMoJ2dldFByb3RvY29sJywgLTEpO1xyXG4gICAgICAgIHJldHVybiBwcm90b2NvbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHBhcnNlPFQ+KHR5cGU6IFJlcGxheUZpbGVzKTogUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBhd2FpdCB0aGlzLnByb3RvY29sO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZVN0cmluZ3MocHJvdG9jb2xbZGVjb2Rlck1hcFt0eXBlXV0odGhpcy5fbXBxLnJlYWRGaWxlKHR5cGUpKSk7XHJcbiAgICAgICAgdGhpcy5fZGF0YS5zZXQodHlwZSwgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBwYXJzZUV2ZW50czxUPih0eXBlOiBSZXBsYXlGaWxlcyk6IFByb21pc2U8VFtdPiB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBhd2FpdCB0aGlzLnByb3RvY29sO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50R2VuID0gcHJvdG9jb2xbZGVjb2Rlck1hcFt0eXBlXV0odGhpcy5fbXBxLnJlYWRGaWxlKHR5cGUpKTtcclxuICAgICAgICBjb25zdCBldmVudHM6IFRbXSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygncGFyc2UtZXZlbnQtJyArIHR5cGUsIDAsIHByb3RvY29sLnByb2dyZXNzLnRvdGFsKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50R2VuKSB7XHJcbiAgICAgICAgICAgIGlmIChGaWx0ZXJlZEV2ZW50cy5pbmRleE9mKGV2ZW50Ll9ldmVudCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaChwYXJzZVN0cmluZ3MoZXZlbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygncGFyc2UtZXZlbnQtJyArIHR5cGUsIHByb3RvY29sLnByb2dyZXNzLmN1cnJlbnQsIHByb3RvY29sLnByb2dyZXNzLnRvdGFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGF0YS5zZXQodHlwZSwgZXZlbnRzKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygncGFyc2UtZXZlbnQtJyArIHR5cGUsIC0xKTtcclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGF0YTxUPih0eXBlOiBSZXBsYXlGaWxlcyk6IFByb21pc2U8VD4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc1Byb21pc2U8VD4odGhpcy5fZGF0YS5nZXQodHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZTxUPih0eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGV2ZW50czxUPih0eXBlOiBSZXBsYXlGaWxlcyk6IFByb21pc2U8VFtdPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzUHJvbWlzZTxUW10+KHRoaXMuX2RhdGEuZ2V0KHR5cGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFdmVudHM8VD4odHlwZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgYXNQcm9taXNlPFQ+KHZhbHVlOiBUKTogUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xyXG4gICAgICAgICAgICByZXModmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21wcSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/analyzers/BasicReplayAnalyser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Replay_1 = __webpack_require__("../heroprotocol/dist/lib/replay/Replay.js");
//import { IReplayTrackerEvent, isSUnitBornEvent, ISUnitBornEvent } from '../types';
const linq = __webpack_require__("../heroprotocol/node_modules/linq/linq.js");
const sha1 = __webpack_require__("../heroprotocol/node_modules/sha1/sha1.js");
const decorators_1 = __webpack_require__("../heroprotocol/dist/lib/replay/decorators.js");
// tslint:disable:no-bitwise
var GameType;
(function (GameType) {
    GameType[GameType["UNKNOWN"] = 0] = "UNKNOWN";
    GameType[GameType["FLAG_SOLO_QUEUE"] = 1] = "FLAG_SOLO_QUEUE";
    GameType[GameType["FLAG_COOP"] = 2] = "FLAG_COOP";
    GameType[GameType["FLAG_PVP"] = 4] = "FLAG_PVP";
    GameType[GameType["FLAG_DRAFT"] = 8] = "FLAG_DRAFT";
    GameType[GameType["FLAG_RANKED"] = 16] = "FLAG_RANKED";
    GameType[GameType["MODE_PRACTICE"] = 32] = "MODE_PRACTICE";
    GameType[GameType["MODE_AI"] = 64] = "MODE_AI";
    GameType[GameType["MODE_BRAWL"] = 128] = "MODE_BRAWL";
    GameType[GameType["MODE_QM"] = 256] = "MODE_QM";
    GameType[GameType["MODE_UR"] = 512] = "MODE_UR";
    GameType[GameType["MODE_HL"] = 1024] = "MODE_HL";
    GameType[GameType["MODE_TL"] = 2048] = "MODE_TL";
    GameType[GameType["MODE_CUSTOM"] = 4096] = "MODE_CUSTOM";
    GameType[GameType["PRACTICE"] = 33] = "PRACTICE";
    GameType[GameType["SOLO_AI"] = 65] = "SOLO_AI";
    GameType[GameType["COOP_AI"] = 66] = "COOP_AI";
    GameType[GameType["CUSTOM"] = 4100] = "CUSTOM";
    GameType[GameType["CUSTOM_DRAFT"] = 4108] = "CUSTOM_DRAFT";
    GameType[GameType["BRAWL"] = 132] = "BRAWL";
    GameType[GameType["QUICK_MATCH"] = 260] = "QUICK_MATCH";
    GameType[GameType["UNRANKED_DRAFT"] = 524] = "UNRANKED_DRAFT";
    GameType[GameType["HERO_LEAGUE"] = 1053] = "HERO_LEAGUE";
    GameType[GameType["TEAM_LEAGUE"] = 2076] = "TEAM_LEAGUE";
})(GameType = exports.GameType || (exports.GameType = {}));
let BasicReplayAnalyser = class BasicReplayAnalyser {
    constructor(replay) {
        this.replay = replay;
    }
    get fingerPrint() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            let fp = '';
            const head = yield this.replay.header;
            const init = yield this.replay.initData;
            fp = head.m_elapsedGameLoops.toString(16);
            fp += '|' + init.m_syncLobbyState.m_gameDescription.m_randomValue;
            fp += '|' + init.m_syncLobbyState.m_gameDescription.m_gameOptions.m_ammId;
            fp += '|' + linq.from(init.m_syncLobbyState.m_lobbyState.m_slots)
                .toJoinedString('#', elm => elm.m_hero + '~' + elm.m_teamId + '~' + elm.m_toonHandle);
            return sha1(fp);
        }))();
    }
    get gameDurationTicks() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const head = yield this.replay.header;
            return head.m_elapsedGameLoops;
        }))();
    }
    get gameDuration() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return (yield this.gameDurationTicks) / 16;
        }))();
    }
    get version() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const head = yield this.replay.header;
            return {
                protocol: head.m_version.m_baseBuild,
                build: head.m_version.m_build,
                major: head.m_version.m_major,
                minor: head.m_version.m_minor,
                revision: head.m_version.m_revision
            };
        }))();
    }
    get gameType() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const init = yield this.replay.initData;
            const gameDesc = init.m_syncLobbyState.m_gameDescription;
            console.log(gameDesc.m_gameOptions);
            switch (gameDesc.m_gameOptions.m_ammId) {
                case 50021:
                case 50021:
                    return GameType.MODE_AI;
                case 50001:
                    return GameType.QUICK_MATCH;
                case 50031:
                    return GameType.BRAWL;
                case 50051:
                    return GameType.UNRANKED_DRAFT;
                case 50061:
                    return GameType.HERO_LEAGUE;
                case 50071:
                    return GameType.TEAM_LEAGUE;
                default:
                    if (!gameDesc.m_gameOptions.m_competitive && !gameDesc.m_gameOptions.m_cooperative) {
                        if (gameDesc.m_gameOptions.m_heroDuplicatesAllowed) {
                            return GameType.CUSTOM;
                        }
                        else {
                            return GameType.CUSTOM_DRAFT;
                        }
                    }
                    return GameType.UNKNOWN;
            }
        }))();
    }
    isGameType(type) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const gameType = yield this.gameType;
            return (gameType & type) === type;
        }))();
    }
    get mapName() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const head = yield this.replay.header;
            const init = yield this.replay.initData;
            const details = yield this.replay.details;
            console.log(head);
            console.log(init);
            console.log(details);
            return details.m_title;
        }))();
    }
    get winningTeam() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.replay.details;
            return details.m_playerList[0].m_teamId === 0 && details.m_playerList[0].m_result === 1 ? 0 : 1;
        }))();
    }
    get timeZone() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.replay.details;
            return details.m_timeLocalOffset / 10000000 / 60 / 60;
        }))();
    }
    get playedOn() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.replay.details;
            return new Date(details.m_timeUTC / 10000 - 11644473600000);
        }))();
    }
    get playerList() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const init = yield this.replay.initData;
            const details = yield this.replay.details;
            const slots = linq.from(init.m_syncLobbyState.m_userInitialData).select((slot, i) => ({ slot, i }));
            const us = slots.join(linq.from(init.m_syncLobbyState.m_lobbyState.m_slots), d => d.i, s => s.m_userId, (d, s) => {
                return Object.assign({}, s, { m_name: d.slot.m_name });
            });
            const pl = linq.from(details.m_playerList);
            const playerList = us.groupJoin(pl, s => s.m_workingSetSlotId, p => p.m_workingSetSlotId, (s, p) => ({
                slot: s,
                player: p.firstOrDefault()
            })).select(p => ({
                id: p.slot.m_toonHandle,
                name: p.slot.m_name,
                team: p.player ? p.player.m_teamId : null,
                hero: p.player ? p.player.m_hero : null,
                won: p.player ? p.player.m_result === 1 : null,
                observer: p.slot.m_observe === 1
            }));
            return playerList.toArray();
        }))();
    }
    get replayDescription() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return {
                fingerPrint: yield this.fingerPrint,
                gameType: yield this.gameType,
                version: yield this.version,
                gameDurationTicks: yield this.gameDurationTicks,
                gameDuration: yield this.gameDuration,
                mapName: yield this.mapName,
                timeZone: yield this.timeZone,
                playedOn: yield this.playedOn,
                winningTeam: yield this.winningTeam,
                players: yield this.playerList
            };
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "fingerPrint", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "gameDurationTicks", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "version", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "gameType", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "mapName", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "winningTeam", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "timeZone", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "playedOn", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "playerList", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], BasicReplayAnalyser.prototype, "replayDescription", null);
BasicReplayAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('1B90BC76-8CE8-495C-A978-ABFD78DBB72A'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], BasicReplayAnalyser);
exports.BasicReplayAnalyser = BasicReplayAnalyser;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9hbmFseXplcnMvQmFzaWNSZXBsYXlBbmFseXNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0NBQW1DO0FBQ25DLG9GQUFvRjtBQUNwRiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBRTdCLDhDQUFtRTtBQUNuRSw0QkFBNEI7QUFHNUIsSUFBWSxRQTBCWDtBQTFCRCxXQUFZLFFBQVE7SUFDaEIsNkNBQVcsQ0FBQTtJQUNYLDZEQUFtQixDQUFBO0lBQ25CLGlEQUFrQixDQUFBO0lBQ2xCLCtDQUFpQixDQUFBO0lBQ2pCLG1EQUFtQixDQUFBO0lBQ25CLHNEQUFvQixDQUFBO0lBQ3BCLDBEQUFzQixDQUFBO0lBQ3RCLDhDQUFnQixDQUFBO0lBQ2hCLHFEQUFtQixDQUFBO0lBQ25CLCtDQUFnQixDQUFBO0lBQ2hCLCtDQUFnQixDQUFBO0lBQ2hCLGdEQUFpQixDQUFBO0lBQ2pCLGdEQUFpQixDQUFBO0lBQ2pCLHdEQUFxQixDQUFBO0lBRXJCLGdEQUEwQyxDQUFBO0lBQzFDLDhDQUFtQyxDQUFBO0lBQ25DLDhDQUE2QixDQUFBO0lBQzdCLDhDQUErQixDQUFBO0lBQy9CLDBEQUFrRCxDQUFBO0lBQ2xELDJDQUE2QixDQUFBO0lBQzdCLHVEQUFnQyxDQUFBO0lBQ2hDLDZEQUFnRCxDQUFBO0lBQ2hELHdEQUE2RSxDQUFBO0lBQzdFLHdEQUEyRCxDQUFBO0FBQy9ELENBQUMsRUExQlcsUUFBUSxHQUFSLGdCQUFRLEtBQVIsZ0JBQVEsUUEwQm5CO0FBeUJELElBQWEsbUJBQW1CLEdBQWhDO0lBR0ksWUFBMkIsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7SUFBSSxDQUFDO0lBSTlDLElBQVcsV0FBVztRQUNsQixPQUFPLENBQUMsR0FBMEIsRUFBRTtZQUNoQyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUM7WUFDWixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxD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LENBQUMsRUFBRSxDQUFDO0lBQ1QsQ0FBQztDQThESixDQUFBO0FBdk9HO0lBREMsd0JBQVcsRUFBRTs7O3NEQWFiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7NERBTWI7QUFTRDtJQURDLHdCQUFXLEVBQUU7OztrREFZYjtBQUdEO0lBREMsd0JBQVcsRUFBRTs7O21EQWdDYjtBQVdEO0lBREMsd0JBQVcsRUFBRTs7O2tEQVdiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7c0RBTWI7QUFHRDtJQURDLHdCQUFXLEVBQUU7OzttREFNYjtBQUdEO0lBREMsd0JBQVcsRUFBRTs7O21EQU1iO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7cURBOEJiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7NERBZ0JiO0FBaExRLG1CQUFtQjtJQUQvQixrQ0FBcUIsQ0FBQyxzQ0FBc0MsQ0FBQztxQ0FJdkIsZUFBTTtHQUhoQyxtQkFBbUIsQ0E4Ty9CO0FBOU9ZLGtEQUFtQiIsImZpbGUiOiJyZXBsYXkvYW5hbHl6ZXJzL0Jhc2ljUmVwbGF5QW5hbHlzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXBsYXkgfSBmcm9tICcuLi9SZXBsYXknO1xyXG4vL2ltcG9ydCB7IElSZXBsYXlUcmFja2VyRXZlbnQsIGlzU1VuaXRCb3JuRXZlbnQsIElTVW5pdEJvcm5FdmVudCB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0ICogYXMgbGlucSBmcm9tICdsaW5xJztcclxuaW1wb3J0ICogYXMgc2hhMSBmcm9tICdzaGExJztcclxuaW1wb3J0IHsgSVJlcGxheURldGFpbHNQbGF5ZXIgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7IFJlcGxheUFuYWx5c2VyQ29udGV4dCwgUnVuT25Xb3JrZXIgfSBmcm9tICcuLi9kZWNvcmF0b3JzJztcclxuLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxyXG5cclxuXHJcbmV4cG9ydCBlbnVtIEdhbWVUeXBlIHtcclxuICAgIFVOS05PV04gPSAwLFxyXG4gICAgRkxBR19TT0xPX1FVRVVFID0gMSxcclxuICAgIEZMQUdfQ09PUCA9IDEgPDwgMSxcclxuICAgIEZMQUdfUFZQID0gMSA8PCAyLFxyXG4gICAgRkxBR19EUkFGVCA9IDEgPDwgMyxcclxuICAgIEZMQUdfUkFOS0VEID0gMSA8PCA0LFxyXG4gICAgTU9ERV9QUkFDVElDRSA9IDEgPDwgNSxcclxuICAgIE1PREVfQUkgPSAxIDw8IDYsXHJcbiAgICBNT0RFX0JSQVdMID0gMSA8PCA3LFxyXG4gICAgTU9ERV9RTSA9IDEgPDwgOCxcclxuICAgIE1PREVfVVIgPSAxIDw8IDksXHJcbiAgICBNT0RFX0hMID0gMSA8PCAxMCxcclxuICAgIE1PREVfVEwgPSAxIDw8IDExLFxyXG4gICAgTU9ERV9DVVNUT00gPSAxIDw8IDEyLFxyXG5cclxuICAgIFBSQUNUSUNFID0gTU9ERV9QUkFDVElDRSB8IEZMQUdfU09MT19RVUVVRSxcclxuICAgIFNPTE9fQUkgPSBNT0RFX0FJIHwgRkxBR19TT0xPX1FVRVVFLFxyXG4gICAgQ09PUF9BSSA9IE1PREVfQUkgfCBGTEFHX0NPT1AsXHJcbiAgICBDVVNUT00gPSBNT0RFX0NVU1RPTSB8IEZMQUdfUFZQLFxyXG4gICAgQ1VTVE9NX0RSQUZUID0gTU9ERV9DVVNUT00gfCBGTEFHX1BWUCB8IEZMQUdfRFJBRlQsXHJcbiAgICBCUkFXTCA9IE1PREVfQlJBV0wgfCBGTEFHX1BWUCxcclxuICAgIFFVSUNLX01BVENIID0gTU9ERV9RTSB8IEZMQUdfUFZQLFxyXG4gICAgVU5SQU5LRURfRFJBRlQgPSBNT0RFX1VSIHwgRkxBR19QVlAgfCBGTEFHX0RSQUZULFxyXG4gICAgSEVST19MRUFHVUUgPSBNT0RFX0hMIHwgRkxBR19QVlAgfCBGTEFHX0RSQUZUIHwgRkxBR19SQU5LRUQgfCBGTEFHX1NPTE9fUVVFVUUsXHJcbiAgICBURUFNX0xFQUdVRSA9IE1PREVfVEwgfCBGTEFHX1BWUCB8IEZMQUdfRFJBRlQgfCBGTEFHX1JBTktFRFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlcGxheURlc2NyaXB0aW9uIHtcclxuICAgIGZpbmdlclByaW50OiBzdHJpbmc7XHJcbiAgICBtYXBOYW1lOiBzdHJpbmc7XHJcbiAgICBnYW1lRHVyYXRpb25UaWNrczogbnVtYmVyO1xyXG4gICAgZ2FtZUR1cmF0aW9uOiBudW1iZXI7XHJcbiAgICB2ZXJzaW9uOiB7IG1ham9yOiBudW1iZXIsIG1pbm9yOiBudW1iZXIsIHJldmlzaW9uOiBudW1iZXIsIGJ1aWxkOiBudW1iZXIsIHByb3RvY29sOiBudW1iZXIgfTtcclxuICAgIGdhbWVUeXBlOiBHYW1lVHlwZTtcclxuICAgIHRpbWVab25lOiBudW1iZXI7XHJcbiAgICBwbGF5ZWRPbjogRGF0ZTtcclxuICAgIHdpbm5pbmdUZWFtOiBudW1iZXI7XHJcbiAgICBwbGF5ZXJzOiBCYXNpY1BsYXllckRhdGFbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXNpY1BsYXllckRhdGEge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGhlcm86IHN0cmluZztcclxuICAgIHRlYW06IG51bWJlcjtcclxuICAgIHdvbjogYm9vbGVhbjtcclxuICAgIG9ic2VydmVyOiBib29sZWFuO1xyXG59XHJcblxyXG5AUmVwbGF5QW5hbHlzZXJDb250ZXh0KCcxQjkwQkM3Ni04Q0U4LTQ5NUMtQTk3OC1BQkZENzhEQkI3MkEnKVxyXG5leHBvcnQgY2xhc3MgQmFzaWNSZXBsYXlBbmFseXNlciB7XHJcblxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlcGxheTogUmVwbGF5KSB7IH1cclxuXHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgZmluZ2VyUHJpbnQoKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gKGFzeW5jICgpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gICAgICAgICAgICBsZXQgZnAgPSAnJztcclxuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGF3YWl0IHRoaXMucmVwbGF5LmhlYWRlcjtcclxuICAgICAgICAgICAgY29uc3QgaW5pdCA9IGF3YWl0IHRoaXMucmVwbGF5LmluaXREYXRhO1xyXG4gICAgICAgICAgICBmcCA9IGhlYWQubV9lbGFwc2VkR2FtZUxvb3BzLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgZnAgKz0gJ3wnICsgaW5pdC5tX3N5bmNMb2JieVN0YXRlLm1fZ2FtZURlc2NyaXB0aW9uLm1fcmFuZG9tVmFsdWU7XHJcbiAgICAgICAgICAgIGZwICs9ICd8JyArIGluaXQubV9zeW5jTG9iYnlTdGF0ZS5tX2dhbWVEZXNjcmlwdGlvbi5tX2dhbWVPcHRpb25zLm1fYW1tSWQ7XHJcbiAgICAgICAgICAgIGZwICs9ICd8JyArIGxpbnEuZnJvbShpbml0Lm1fc3luY0xvYmJ5U3RhdGUubV9sb2JieVN0YXRlLm1fc2xvdHMpXHJcbiAgICAgICAgICAgICAgICAudG9Kb2luZWRTdHJpbmcoJyMnLCBlbG0gPT4gZWxtLm1faGVybyArICd+JyArIGVsbS5tX3RlYW1JZCArICd+JyArIGVsbS5tX3Rvb25IYW5kbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhMShmcCk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBnYW1lRHVyYXRpb25UaWNrcygpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIHJldHVybiAoYXN5bmMgKCk6IFByb21pc2U8bnVtYmVyPiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBhd2FpdCB0aGlzLnJlcGxheS5oZWFkZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkLm1fZWxhcHNlZEdhbWVMb29wcztcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZ2FtZUR1cmF0aW9uKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdhbWVEdXJhdGlvblRpY2tzKSAvIDE2O1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgdmVyc2lvbigpOiBQcm9taXNlPHsgbWFqb3I6IG51bWJlciwgbWlub3I6IG51bWJlciwgcmV2aXNpb246IG51bWJlciwgYnVpbGQ6IG51bWJlciwgcHJvdG9jb2w6IG51bWJlciB9PiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxhbnk+ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGF3YWl0IHRoaXMucmVwbGF5LmhlYWRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHByb3RvY29sOiBoZWFkLm1fdmVyc2lvbi5tX2Jhc2VCdWlsZCxcclxuICAgICAgICAgICAgICAgIGJ1aWxkOiBoZWFkLm1fdmVyc2lvbi5tX2J1aWxkLFxyXG4gICAgICAgICAgICAgICAgbWFqb3I6IGhlYWQubV92ZXJzaW9uLm1fbWFqb3IsXHJcbiAgICAgICAgICAgICAgICBtaW5vcjogaGVhZC5tX3ZlcnNpb24ubV9taW5vcixcclxuICAgICAgICAgICAgICAgIHJldmlzaW9uOiBoZWFkLm1fdmVyc2lvbi5tX3JldmlzaW9uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBnYW1lVHlwZSgpOiBQcm9taXNlPEdhbWVUeXBlPiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxHYW1lVHlwZT4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbml0ID0gYXdhaXQgdGhpcy5yZXBsYXkuaW5pdERhdGE7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBnYW1lRGVzYyA9IGluaXQubV9zeW5jTG9iYnlTdGF0ZS5tX2dhbWVEZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2FtZURlc2MubV9nYW1lT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZ2FtZURlc2MubV9nYW1lT3B0aW9ucy5tX2FtbUlkKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUwMDIxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1MDAyMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2FtZVR5cGUuTU9ERV9BSTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTAwMDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdhbWVUeXBlLlFVSUNLX01BVENIO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1MDAzMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2FtZVR5cGUuQlJBV0w7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUwMDUxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHYW1lVHlwZS5VTlJBTktFRF9EUkFGVDtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTAwNjE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdhbWVUeXBlLkhFUk9fTEVBR1VFO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1MDA3MTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2FtZVR5cGUuVEVBTV9MRUFHVUU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2FtZURlc2MubV9nYW1lT3B0aW9ucy5tX2NvbXBldGl0aXZlICYmICFnYW1lRGVzYy5tX2dhbWVPcHRpb25zLm1fY29vcGVyYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVEZXNjLm1fZ2FtZU9wdGlvbnMubV9oZXJvRHVwbGljYXRlc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBHYW1lVHlwZS5DVVNUT007XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2FtZVR5cGUuQ1VTVE9NX0RSQUZUO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHYW1lVHlwZS5VTktOT1dOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNHYW1lVHlwZSh0eXBlOiBHYW1lVHlwZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIHJldHVybiAoYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBnYW1lVHlwZSA9IGF3YWl0IHRoaXMuZ2FtZVR5cGU7XHJcbiAgICAgICAgICAgIHJldHVybiAoZ2FtZVR5cGUgJiB0eXBlKSA9PT0gdHlwZTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBtYXBOYW1lKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGF3YWl0IHRoaXMucmVwbGF5LmhlYWRlcjtcclxuICAgICAgICAgICAgY29uc3QgaW5pdCA9IGF3YWl0IHRoaXMucmVwbGF5LmluaXREYXRhO1xyXG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgdGhpcy5yZXBsYXkuZGV0YWlscztcclxuICAgICAgICAgICAgY29uc29sZS5sb2coaGVhZCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGluaXQpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkZXRhaWxzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHMubV90aXRsZTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuICAgIEBSdW5PbldvcmtlcigpXHJcbiAgICBwdWJsaWMgZ2V0IHdpbm5pbmdUZWFtKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IGF3YWl0IHRoaXMucmVwbGF5LmRldGFpbHM7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzLm1fcGxheWVyTGlzdFswXS5tX3RlYW1JZCA9PT0gMCAmJiBkZXRhaWxzLm1fcGxheWVyTGlzdFswXS5tX3Jlc3VsdCA9PT0gMSA/IDAgOiAxO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgdGltZVpvbmUoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gKGFzeW5jICgpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgdGhpcy5yZXBsYXkuZGV0YWlscztcclxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHMubV90aW1lTG9jYWxPZmZzZXQgLyAxMDAwMDAwMCAvIDYwIC8gNjA7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBwbGF5ZWRPbigpOiBQcm9taXNlPERhdGU+IHtcclxuICAgICAgICByZXR1cm4gKGFzeW5jICgpOiBQcm9taXNlPERhdGU+ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IGF3YWl0IHRoaXMucmVwbGF5LmRldGFpbHM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkZXRhaWxzLm1fdGltZVVUQyAvIDEwMDAwIC0gMTE2NDQ0NzM2MDAwMDApO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgcGxheWVyTGlzdCgpOiBQcm9taXNlPEJhc2ljUGxheWVyRGF0YVtdPiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxCYXNpY1BsYXllckRhdGFbXT4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbml0ID0gYXdhaXQgdGhpcy5yZXBsYXkuaW5pdERhdGE7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgdGhpcy5yZXBsYXkuZGV0YWlscztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gbGlucS5mcm9tKGluaXQubV9zeW5jTG9iYnlTdGF0ZS5tX3VzZXJJbml0aWFsRGF0YSkuc2VsZWN0KChzbG90LCBpKSA9PiAoeyBzbG90LCBpIH0pKTtcclxuICAgICAgICAgICAgY29uc3QgdXMgPSBzbG90cy5qb2luKGxpbnEuZnJvbShpbml0Lm1fc3luY0xvYmJ5U3RhdGUubV9sb2JieVN0YXRlLm1fc2xvdHMpLCBkID0+IGQuaSwgcyA9PiBzLm1fdXNlcklkLCAoZCwgcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHMsIHsgbV9uYW1lOiBkLnNsb3QubV9uYW1lIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBwbCA9IGxpbnEuZnJvbShkZXRhaWxzLm1fcGxheWVyTGlzdCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJMaXN0ID0gdXMuZ3JvdXBKb2luKFxyXG4gICAgICAgICAgICAgICAgcGwsIHMgPT4gcy5tX3dvcmtpbmdTZXRTbG90SWQsIHAgPT4gcC5tX3dvcmtpbmdTZXRTbG90SWQsIChzLCBwOiBhbnlcclxuICAgICAgICAgICAgICAgICkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBzbG90OiBzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllcjogPElSZXBsYXlEZXRhaWxzUGxheWVyPnAuZmlyc3RPckRlZmF1bHQoKVxyXG4gICAgICAgICAgICAgICAgfSkpLnNlbGVjdChwID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHAuc2xvdC5tX3Rvb25IYW5kbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcC5zbG90Lm1fbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZWFtOiBwLnBsYXllciA/IHAucGxheWVyLm1fdGVhbUlkIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBoZXJvOiBwLnBsYXllciA/IHAucGxheWVyLm1faGVybyA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgd29uOiBwLnBsYXllciA/IHAucGxheWVyLm1fcmVzdWx0ID09PSAxIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcjogcC5zbG90Lm1fb2JzZXJ2ZSA9PT0gMVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYXllckxpc3QudG9BcnJheSgpO1xyXG5cclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuICAgIEBSdW5PbldvcmtlcigpXHJcbiAgICBwdWJsaWMgZ2V0IHJlcGxheURlc2NyaXB0aW9uKCk6IFByb21pc2U8UmVwbGF5RGVzY3JpcHRpb24+IHtcclxuICAgICAgICByZXR1cm4gKGFzeW5jICgpOiBQcm9taXNlPFJlcGxheURlc2NyaXB0aW9uPiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmaW5nZXJQcmludDogYXdhaXQgdGhpcy5maW5nZXJQcmludCxcclxuICAgICAgICAgICAgICAgIGdhbWVUeXBlOiBhd2FpdCB0aGlzLmdhbWVUeXBlLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogYXdhaXQgdGhpcy52ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgZ2FtZUR1cmF0aW9uVGlja3M6IGF3YWl0IHRoaXMuZ2FtZUR1cmF0aW9uVGlja3MsXHJcbiAgICAgICAgICAgICAgICBnYW1lRHVyYXRpb246IGF3YWl0IHRoaXMuZ2FtZUR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgbWFwTmFtZTogYXdhaXQgdGhpcy5tYXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmU6IGF3YWl0IHRoaXMudGltZVpvbmUsXHJcbiAgICAgICAgICAgICAgICBwbGF5ZWRPbjogYXdhaXQgdGhpcy5wbGF5ZWRPbixcclxuICAgICAgICAgICAgICAgIHdpbm5pbmdUZWFtOiBhd2FpdCB0aGlzLndpbm5pbmdUZWFtLFxyXG4gICAgICAgICAgICAgICAgcGxheWVyczogYXdhaXQgdGhpcy5wbGF5ZXJMaXN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICAgIHByaXZhdGUgX3RyYWNrZXJRdWVyaWFibGU6IGxpbnEuSUVudW1lcmFibGU8SVJlcGxheVRyYWNrZXJFdmVudD47XHJcbiAgICAgICAgcHJpdmF0ZSBfdHJhY2tlclF1ZXJpYWJsZVByb21pc2U6IFByb21pc2U8bGlucS5JRW51bWVyYWJsZTxJUmVwbGF5VHJhY2tlckV2ZW50Pj47XHJcbiAgICBcclxuICAgICAgICBwcml2YXRlIF91bml0VHlwZUJ5VGFnOiB7IFt0YWc6IG51bWJlcl06IHN0cmluZyB9ID0ge307XHJcbiAgICBcclxuICAgICAgICBwdWJsaWMgZ2V0IHRyYWNrZXJRdWVyaWFibGUoKTogUHJvbWlzZTxsaW5xLklFbnVtZXJhYmxlPElSZXBsYXlUcmFja2VyRXZlbnQ+PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFja2VyUXVlcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hc1Byb21pc2U8bGlucS5JRW51bWVyYWJsZTxJUmVwbGF5VHJhY2tlckV2ZW50Pj4odGhpcy5fdHJhY2tlclF1ZXJpYWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhY2tlclF1ZXJpYWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICAgICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVwbGF5OiBSZXBsYXkpIHtcclxuICAgIFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICBwdWJsaWMgYXN5bmMgZ2V0VW5pdFR5cGVzKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IGF3YWl0IHRoaXMucmVwbGF5LnByb3RvY29sO1xyXG4gICAgICAgICAgICBsZXQgcSA9IDxsaW5xLklFbnVtZXJhYmxlPElTVW5pdEJvcm5FdmVudD4+KGF3YWl0IHRoaXMudHJhY2tlclF1ZXJpYWJsZSk7XHJcbiAgICAgICAgICAgIHEgPSBxLndoZXJlKGUgPT4gaXNTVW5pdEJvcm5FdmVudChlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHEudG9PYmplY3QoZSA9PiBwcm90b2NvbC51bml0VGFnKGUubV91bml0VGFnSW5kZXgsIGUubV91bml0VGFnUmVjeWNsZSksIGUgPT4gZS5tX3VuaXRUeXBlTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgcHVibGljIGFzeW5jIGdldE1pbmlvblNwYXducyh0ZWFtPzogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0gYXdhaXQgdGhpcy5yZXBsYXkucHJvdG9jb2w7XHJcbiAgICAgICAgICAgIGxldCBxID0gPGxpbnEuSUVudW1lcmFibGU8SVNVbml0Qm9ybkV2ZW50Pj4oYXdhaXQgdGhpcy50cmFja2VyUXVlcmlhYmxlKVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKFxyXG4gICAgICAgICAgICAgICAgZSA9PiBpc1NVbml0Qm9ybkV2ZW50KGUpICYmIChlLm1fY29udHJvbFBsYXllcklkID09PSAxMSB8fCBlLm1fY29udHJvbFBsYXllcklkID09PSAxMikgJiYgZS5tX3VuaXRUeXBlTmFtZS5lbmRzV2l0aCgnTWluaW9uJylcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICh0ZWFtID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBxID0gcS53aGVyZShlID0+IGUubV9jb250cm9sUGxheWVySWQgPT09IDExKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZWFtID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBxID0gcS53aGVyZShlID0+IGUubV9jb250cm9sUGxheWVySWQgPT09IDEyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBxLnNlbGVjdChlID0+ICh7XHJcbiAgICAgICAgICAgICAgICB0YWc6IHByb3RvY29sLnVuaXRUYWcoZS5tX3VuaXRUYWdJbmRleCwgZS5tX3VuaXRUYWdSZWN5Y2xlKSxcclxuICAgICAgICAgICAgICAgIHVuaXRUeXBlOiBlLm1fdW5pdFR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGltZTogZS5fZ2FtZWxvb3AgLyAxNixcclxuICAgICAgICAgICAgICAgIHg6IGUubV94LFxyXG4gICAgICAgICAgICAgICAgeTogZS5tX3lcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgXHJcbiAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b0FycmF5KCk7Ly8uZ3JvdXBCeShlID0+IGUudGFnLCBlID0+IGUpLnRvQXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgICAgIHByaXZhdGUgYXN5bmMgZ2V0VHJhY2tlclF1ZXJpYWJsZSgpOiBQcm9taXNlPGxpbnEuSUVudW1lcmFibGU8SVJlcGxheVRyYWNrZXJFdmVudD4+IHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5yZXBsYXkudHJhY2tlckV2ZW50cztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrZXJRdWVyaWFibGUgPSBsaW5xLmZyb20oZXZlbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJpdmF0ZSBhc1Byb21pc2U8VD4odmFsdWU6IFQpOiBQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzKHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/analyzers/ReplayMapAnalyser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Replay_1 = __webpack_require__("../heroprotocol/dist/lib/replay/Replay.js");
const types_1 = __webpack_require__("../heroprotocol/dist/lib/types/index.js");
const linq = __webpack_require__("../heroprotocol/node_modules/linq/linq.js");
const decorators_1 = __webpack_require__("../heroprotocol/dist/lib/replay/decorators.js");
let ReplayMapAnalyser = class ReplayMapAnalyser {
    constructor(replay) {
        this.replay = replay;
    }
    get trackerQueriable() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const events = yield this.replay.trackerEvents;
            console.log(events);
            return linq.from(events);
        }))();
    }
    get mapName() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const details = yield this.replay.details;
            return details.m_title;
        }))();
    }
    get mapSize() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const init = yield this.replay.initData;
            console.log('init', init);
            return {
                x: init.m_syncLobbyState.m_gameDescription.m_mapSizeX,
                y: init.m_syncLobbyState.m_gameDescription.m_mapSizeY
            };
        }))();
    }
    get mapDescriptor() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            return {
                name: yield this.mapName,
                size: yield this.mapSize
            };
        }))();
    }
    getMinionSpawns(team) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.replay.protocol;
            let q = (yield this.trackerQueriable)
                .where(e => types_1.isSUnitBornEvent(e) && (e.m_controlPlayerId === 11 || e.m_controlPlayerId === 12) && e.m_unitTypeName.endsWith('Minion'));
            if (team === 1) {
                q = q.where(e => e.m_controlPlayerId === 11);
            }
            else if (team === 2) {
                q = q.where(e => e.m_controlPlayerId === 12);
            }
            const result = q.select(e => ({
                tag: protocol.unitTag(e.m_unitTagIndex, e.m_unitTagRecycle),
                unitType: e.m_unitTypeName,
                time: e._gameloop / 16,
                team: e.m_controlPlayerId === 11 ? 1 : 2,
                x: e.m_x,
                y: e.m_y
            })).toArray();
            return result;
        });
    }
    getMercSpawns() {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.replay.protocol;
            let q = (yield this.trackerQueriable)
                .where(e => types_1.isSUnitBornEvent(e)
                && (e.m_unitTypeName.startsWith('King') || e.m_unitTypeName.startsWith('Town') || e.m_unitTypeName.startsWith('Underworld')));
            const result = q.select(e => ({
                tag: protocol.unitTag(e.m_unitTagIndex, e.m_unitTagRecycle),
                unitType: e.m_unitTypeName,
                time: e._gameloop / 16,
                x: e.m_x,
                y: e.m_y
            }));
            console.log('MIN X', result.min(e => e.x));
            console.log('MAX X', result.max(e => e.x));
            console.log('MIN Y', result.min(e => e.y));
            console.log('MAX Y', result.max(e => e.y));
            return result.toArray();
        });
    }
    getMinionSpawnHeatmap(team) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocol = yield this.replay.protocol;
            let q = (yield this.trackerQueriable)
                .where(e => types_1.isSUnitBornEvent(e) //&& (e.m_controlPlayerId === 11 || e.m_controlPlayerId === 12) // && e.m_unitTypeName.endsWith('Minion')
            );
            if (team === 1) {
                q = q.where(e => e.m_controlPlayerId === 11);
            }
            else if (team === 2) {
                q = q.where(e => e.m_controlPlayerId === 12);
            }
            const result = q.groupBy(i => `${i.m_x},${i.m_y}`)
                .select(g => ({
                value: g.count(),
                x: g.first().m_x,
                y: g.first().m_y
            }));
            return result.toArray();
        });
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ReplayMapAnalyser.prototype, "mapName", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ReplayMapAnalyser.prototype, "mapSize", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ReplayMapAnalyser.prototype, "mapDescriptor", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMinionSpawns", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMercSpawns", null);
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ReplayMapAnalyser.prototype, "getMinionSpawnHeatmap", null);
ReplayMapAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('D90DC9EF-B016-47F1-984B-B9BA099869E6'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], ReplayMapAnalyser);
exports.ReplayMapAnalyser = ReplayMapAnalyser;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9hbmFseXplcnMvUmVwbGF5TWFwQW5hbHlzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNDQUFtQztBQUNuQyx1Q0FBcUY7QUFDckYsNkJBQTZCO0FBRzdCLDhDQUFtRTtBQWNuRSxJQUFhLGlCQUFpQixHQUE5QjtJQUdJLFlBQTJCLE1BQWM7UUFBZCxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQUksQ0FBQztJQUc5QyxJQUFZLGdCQUFnQjtRQUN4QixPQUFPLENBQUMsR0FBeUQsRUFBRTtZQUMvRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDO1lBQy9DLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQSxDQUFDLEVBQUUsQ0FBQztJQUNULENBQUM7SUFHRCxJQUFXLE9BQU87UUFDZCxPQUFPLENBQUMsR0FBMEIsRUFBRTtZQUNoQyxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBQzFDLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMzQixDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUM7SUFDVCxDQUFDO0lBSUQsSUFBVyxPQUFPO1FBQ2QsT0FBTyxDQUFDLEdBQTBCLEVBQUU7WUFDaEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztZQUN4QyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMxQixPQUFPO2dCQUNILENBQUMsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsVUFBVTtnQkFDckQsQ0FBQyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFV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aEQ7aUJBQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO2dCQUNuQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsS0FBSyxFQUFFLENBQUMsQ0FBQzthQUNoRDtZQUVELE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2lCQUNqRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNWLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFO2dCQUNoQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUc7Z0JBQ2hCLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRzthQUNuQixDQUFDLENBQUMsQ0FBQztZQUVKLE9BQU8sTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzVCLENBQUM7S0FBQTtDQUNKLENBQUE7QUFuR0c7SUFEQyx3QkFBVyxFQUFFOzs7Z0RBTWI7QUFJRDtJQURDLHdCQUFXLEVBQUU7OztnREFVYjtBQUdEO0lBREMsd0JBQVcsRUFBRTs7O3NEQVFiO0FBR0Q7SUFEQyx3QkFBVyxFQUFFOzs7O3dEQXFCYjtBQUdEO0lBREMsd0JBQVcsRUFBRTs7OztzREFzQmI7QUFHRDtJQURDLHdCQUFXLEVBQUU7Ozs7OERBcUJiO0FBakhRLGlCQUFpQjtJQUQ3QixrQ0FBcUIsQ0FBQyxzQ0FBc0MsQ0FBQztxQ0FJdkIsZUFBTTtHQUhoQyxpQkFBaUIsQ0FrSDdCO0FBbEhZLDhDQUFpQiIsImZpbGUiOiJyZXBsYXkvYW5hbHl6ZXJzL1JlcGxheU1hcEFuYWx5c2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwbGF5IH0gZnJvbSAnLi4vUmVwbGF5JztcclxuaW1wb3J0IHsgSVJlcGxheVRyYWNrZXJFdmVudCwgaXNTVW5pdEJvcm5FdmVudCwgSVNVbml0Qm9ybkV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgKiBhcyBsaW5xIGZyb20gJ2xpbnEnO1xyXG5pbXBvcnQgKiBhcyBzaGExIGZyb20gJ3NoYTEnO1xyXG5pbXBvcnQgeyBJUmVwbGF5RGV0YWlsc1BsYXllciB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuaW1wb3J0IHsgUmVwbGF5QW5hbHlzZXJDb250ZXh0LCBSdW5PbldvcmtlciB9IGZyb20gJy4uL2RlY29yYXRvcnMnO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElNYXBEZXNjcmlwdG9yIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHNpemU6IElQb2ludDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUG9pbnQge1xyXG4gICAgeDogbnVtYmVyO1xyXG4gICAgeTogbnVtYmVyO1xyXG59XHJcblxyXG5AUmVwbGF5QW5hbHlzZXJDb250ZXh0KCdEOTBEQzlFRi1CMDE2LTQ3RjEtOTg0Qi1COUJBMDk5ODY5RTYnKVxyXG5leHBvcnQgY2xhc3MgUmVwbGF5TWFwQW5hbHlzZXIge1xyXG5cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZXBsYXk6IFJlcGxheSkgeyB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0IHRyYWNrZXJRdWVyaWFibGUoKTogUHJvbWlzZTxsaW5xLklFbnVtZXJhYmxlPElSZXBsYXlUcmFja2VyRXZlbnQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxsaW5xLklFbnVtZXJhYmxlPElSZXBsYXlUcmFja2VyRXZlbnQ+PiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucmVwbGF5LnRyYWNrZXJFdmVudHM7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5xLmZyb20oZXZlbnRzKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuICAgIEBSdW5PbldvcmtlcigpXHJcbiAgICBwdWJsaWMgZ2V0IG1hcE5hbWUoKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gKGFzeW5jICgpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgdGhpcy5yZXBsYXkuZGV0YWlscztcclxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHMubV90aXRsZTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBtYXBTaXplKCk6IFByb21pc2U8SVBvaW50PiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxJUG9pbnQ+ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5pdCA9IGF3YWl0IHRoaXMucmVwbGF5LmluaXREYXRhO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW5pdCcsIGluaXQpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogaW5pdC5tX3N5bmNMb2JieVN0YXRlLm1fZ2FtZURlc2NyaXB0aW9uLm1fbWFwU2l6ZVgsXHJcbiAgICAgICAgICAgICAgICB5OiBpbml0Lm1fc3luY0xvYmJ5U3RhdGUubV9nYW1lRGVzY3JpcHRpb24ubV9tYXBTaXplWVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQFJ1bk9uV29ya2VyKClcclxuICAgIHB1YmxpYyBnZXQgbWFwRGVzY3JpcHRvcigpOiBQcm9taXNlPElNYXBEZXNjcmlwdG9yPiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxJTWFwRGVzY3JpcHRvcj4gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogYXdhaXQgdGhpcy5tYXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogYXdhaXQgdGhpcy5tYXBTaXplXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGFzeW5jIGdldE1pbmlvblNwYXducyh0ZWFtPzogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBhd2FpdCB0aGlzLnJlcGxheS5wcm90b2NvbDtcclxuICAgICAgICBsZXQgcSA9IDxsaW5xLklFbnVtZXJhYmxlPElTVW5pdEJvcm5FdmVudD4+KGF3YWl0IHRoaXMudHJhY2tlclF1ZXJpYWJsZSlcclxuICAgICAgICAgICAgLndoZXJlKFxyXG4gICAgICAgICAgICBlID0+IGlzU1VuaXRCb3JuRXZlbnQoZSkgJiYgKGUubV9jb250cm9sUGxheWVySWQgPT09IDExIHx8IGUubV9jb250cm9sUGxheWVySWQgPT09IDEyKSAmJiBlLm1fdW5pdFR5cGVOYW1lLmVuZHNXaXRoKCdNaW5pb24nKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIGlmICh0ZWFtID09PSAxKSB7XHJcbiAgICAgICAgICAgIHEgPSBxLndoZXJlKGUgPT4gZS5tX2NvbnRyb2xQbGF5ZXJJZCA9PT0gMTEpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGVhbSA9PT0gMikge1xyXG4gICAgICAgICAgICBxID0gcS53aGVyZShlID0+IGUubV9jb250cm9sUGxheWVySWQgPT09IDEyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcS5zZWxlY3QoZSA9PiAoe1xyXG4gICAgICAgICAgICB0YWc6IHByb3RvY29sLnVuaXRUYWcoZS5tX3VuaXRUYWdJbmRleCwgZS5tX3VuaXRUYWdSZWN5Y2xlKSxcclxuICAgICAgICAgICAgdW5pdFR5cGU6IGUubV91bml0VHlwZU5hbWUsXHJcbiAgICAgICAgICAgIHRpbWU6IGUuX2dhbWVsb29wIC8gMTYsXHJcbiAgICAgICAgICAgIHRlYW06IGUubV9jb250cm9sUGxheWVySWQgPT09IDExID8gMSA6IDIsXHJcbiAgICAgICAgICAgIHg6IGUubV94LFxyXG4gICAgICAgICAgICB5OiBlLm1feVxyXG4gICAgICAgIH0pKS50b0FycmF5KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGFzeW5jIGdldE1lcmNTcGF3bnMoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBhd2FpdCB0aGlzLnJlcGxheS5wcm90b2NvbDtcclxuICAgICAgICBsZXQgcSA9IDxsaW5xLklFbnVtZXJhYmxlPElTVW5pdEJvcm5FdmVudD4+KGF3YWl0IHRoaXMudHJhY2tlclF1ZXJpYWJsZSlcclxuICAgICAgICAgICAgLndoZXJlKFxyXG4gICAgICAgICAgICBlID0+IGlzU1VuaXRCb3JuRXZlbnQoZSlcclxuICAgICAgICAgICAgICAgICAmJiAoZS5tX3VuaXRUeXBlTmFtZS5zdGFydHNXaXRoKCdLaW5nJykgfHwgZS5tX3VuaXRUeXBlTmFtZS5zdGFydHNXaXRoKCdUb3duJykgfHwgZS5tX3VuaXRUeXBlTmFtZS5zdGFydHNXaXRoKCdVbmRlcndvcmxkJykpXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHEuc2VsZWN0KGUgPT4gKHtcclxuICAgICAgICAgICAgdGFnOiBwcm90b2NvbC51bml0VGFnKGUubV91bml0VGFnSW5kZXgsIGUubV91bml0VGFnUmVjeWNsZSksXHJcbiAgICAgICAgICAgIHVuaXRUeXBlOiBlLm1fdW5pdFR5cGVOYW1lLFxyXG4gICAgICAgICAgICB0aW1lOiBlLl9nYW1lbG9vcCAvIDE2LFxyXG4gICAgICAgICAgICB4OiBlLm1feCxcclxuICAgICAgICAgICAgeTogZS5tX3lcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01JTiBYJywgcmVzdWx0Lm1pbihlID0+IGUueCkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNQVggWCcsIHJlc3VsdC5tYXgoZSA9PiBlLngpKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnTUlOIFknLCByZXN1bHQubWluKGUgPT4gZS55KSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01BWCBZJywgcmVzdWx0Lm1heChlID0+IGUueSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGFzeW5jIGdldE1pbmlvblNwYXduSGVhdG1hcCh0ZWFtPzogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBhd2FpdCB0aGlzLnJlcGxheS5wcm90b2NvbDtcclxuICAgICAgICBsZXQgcSA9IDxsaW5xLklFbnVtZXJhYmxlPElTVW5pdEJvcm5FdmVudD4+KGF3YWl0IHRoaXMudHJhY2tlclF1ZXJpYWJsZSlcclxuICAgICAgICAgICAgLndoZXJlKFxyXG4gICAgICAgICAgICBlID0+IGlzU1VuaXRCb3JuRXZlbnQoZSkgLy8mJiAoZS5tX2NvbnRyb2xQbGF5ZXJJZCA9PT0gMTEgfHwgZS5tX2NvbnRyb2xQbGF5ZXJJZCA9PT0gMTIpIC8vICYmIGUubV91bml0VHlwZU5hbWUuZW5kc1dpdGgoJ01pbmlvbicpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgaWYgKHRlYW0gPT09IDEpIHtcclxuICAgICAgICAgICAgcSA9IHEud2hlcmUoZSA9PiBlLm1fY29udHJvbFBsYXllcklkID09PSAxMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZWFtID09PSAyKSB7XHJcbiAgICAgICAgICAgIHEgPSBxLndoZXJlKGUgPT4gZS5tX2NvbnRyb2xQbGF5ZXJJZCA9PT0gMTIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcS5ncm91cEJ5KGkgPT4gYCR7aS5tX3h9LCR7aS5tX3l9YClcclxuICAgICAgICAuc2VsZWN0KGcgPT4gKHtcclxuICAgICAgICAgICAgdmFsdWU6IGcuY291bnQoKSxcclxuICAgICAgICAgICAgeDogZy5maXJzdCgpLm1feCxcclxuICAgICAgICAgICAgeTogZy5maXJzdCgpLm1feVxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b0FycmF5KCk7XHJcbiAgICB9XHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/analyzers/ScoreAnalyser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = __webpack_require__("../heroprotocol/dist/lib/replay/decorators.js");
const Replay_1 = __webpack_require__("../heroprotocol/dist/lib/replay/Replay.js");
const types_1 = __webpack_require__("../heroprotocol/dist/lib/types/index.js");
const linq = __webpack_require__("../heroprotocol/node_modules/linq/linq.js");
let ScoreAnalyser = class ScoreAnalyser {
    constructor(replay) {
        this.replay = replay;
    }
    get trackerQueriable() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const events = yield this.replay.trackerEvents;
            console.log(events);
            return linq.from(events);
        }))();
    }
    get scoreScreenData() {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const trackerQueriable = yield this.trackerQueriable;
            const results = trackerQueriable.where(e => types_1.isSScoreResultEvent(e)).last();
            console.log('!!!!>>>', results);
            const scoreStats = [
                "Takedowns",
                "Deaths",
                "SoloKill",
                "Assists",
                "ExperienceContribution",
                "Healing",
                "SiegeDamage",
                "HeroDamage",
                "DamageTaken"
            ];
            const stats = linq.from(results.m_instanceList)
                .where(e => scoreStats.indexOf(e.m_name) !== -1)
                .toArray();
            const awards = linq.from(results.m_instanceList)
                .where(e => e.m_name.startsWith('EndOfMatchAward'))
                .toArray();
            const playerStats = [{ Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }, { Awards: [] }];
            for (let i = 0; i < playerStats.length; i++) {
                const pstats = playerStats[i];
                for (let j = 0; j < stats.length; j++) {
                    const stat = stats[j];
                    pstats[stat.m_name] = stat.m_values[i][0].m_value;
                }
                for (let j = 0; j < awards.length; j++) {
                    const award = awards[j];
                    const awardName = award.m_name.substring(0, award.m_name.length - 7).substring(15);
                    const value = award.m_values[i][0].m_value === 1;
                    if (value) {
                        pstats.Awards.push(awardName);
                    }
                }
            }
            return playerStats;
        }))();
    }
};
__decorate([
    decorators_1.RunOnWorker(),
    __metadata("design:type", Promise),
    __metadata("design:paramtypes", [])
], ScoreAnalyser.prototype, "scoreScreenData", null);
ScoreAnalyser = __decorate([
    decorators_1.ReplayAnalyserContext('0B9EBC25-CB1F-47CC-B287-D806D58E2C55'),
    __metadata("design:paramtypes", [Replay_1.Replay])
], ScoreAnalyser);
exports.ScoreAnalyser = ScoreAnalyser;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9hbmFseXplcnMvU2NvcmVBbmFseXNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsOENBQW1FO0FBQ25FLHNDQUFtQztBQUNuQyx1Q0FBMkY7QUFDM0YsNkJBQTZCO0FBZ0I3QixJQUFhLGFBQWEsR0FBMUI7SUFDSSxZQUEyQixNQUFjO1FBQWQsV0FBTSxHQUFOLE1BQU0sQ0FBUTtJQUFJLENBQUM7SUFFOUMsSUFBWSxnQkFBZ0I7UUFDeEIsT0FBTyxDQUFDLEdBQXlELEVBQUU7WUFDL0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQztZQUMvQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QixDQUFDLENBQUEsQ0FBQyxFQUFFLENBQUM7SUFDVCxDQUFDO0lBSUQsSUFBVyxlQUFlO1FBQ3RCLE9BQU8sQ0FBQyxHQUF1QixFQUFFO1lBQzdCLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUM7WUFDckQsTUFBTSxPQUFPLEdBQTRCLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLDJCQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDcEcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUE7WUFDL0IsTUFBTSxVQUFVLEdBQUc7Z0JBQ2YsV0FBVztnQkFDWCxRQUFRO2dCQUNSLFVBQVU7Z0JBQ1YsU0FBUztnQkFDVCx3QkFBd0I7Z0JBQ3hCLFNBQVM7Z0JBQ1QsYUFBYTtnQkFDYixZQUFZO2dCQUNaLGFBQWE7YUFDaEIsQ0FBQztZQUNGLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQztpQkFDMUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7aUJBQy9DLE9BQU8sRUFBRSxDQUFDO1lBRWYsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO2lCQUMzQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2lCQUNsRCxPQUFPLEVBQUUsQ0FBQztZQUVmLE1BQU0sV0FBVyxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNyTCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDekMsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbkMsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN0QixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO2lCQUNyRDtnQkFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDcEMsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN4QixNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUNuRixNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLENBQUM7b0JBQ2pELElBQUksS0FBSyxFQUFFO3dCQUNQLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO3FCQUNqQztpQkFDSjthQUNKO1lBRUQsT0FBTyxXQUFXLENBQUM7UUFDdkIsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDO0lBQ1QsQ0FBQztDQUNKLENBQUE7QUE1Q0c7SUFEQyx3QkFBVyxFQUFFOzs7b0RBNENiO0FBeERRLGFBQWE7SUFEekIsa0NBQXFCLENBQUMsc0NBQXNDLENBQUM7cUNBRXZCLGVBQU07R0FEaEMsYUFBYSxDQXlEekI7QUF6RFksc0NBQWEiLCJmaWxlIjoicmVwbGF5L2FuYWx5emVycy9TY29yZUFuYWx5c2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbmltcG9ydCB7IFJlcGxheUFuYWx5c2VyQ29udGV4dCwgUnVuT25Xb3JrZXIgfSBmcm9tICcuLi9kZWNvcmF0b3JzJztcclxuaW1wb3J0IHsgUmVwbGF5IH0gZnJvbSAnLi4vUmVwbGF5JztcclxuaW1wb3J0IHsgSVJlcGxheVRyYWNrZXJFdmVudCwgaXNTU2NvcmVSZXN1bHRFdmVudCwgSVNTY29yZVJlc3VsdEV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgKiBhcyBsaW5xIGZyb20gJ2xpbnEnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUGxheWVyU2NvcmVzIHtcclxuICAgIFwiVGFrZWRvd25zXCI6IG51bWJlcjtcclxuICAgIFwiRGVhdGhzXCI6IG51bWJlcjtcclxuICAgIFwiU29sb0tpbGxcIjogbnVtYmVyO1xyXG4gICAgXCJBc3Npc3RzXCI6IG51bWJlcjtcclxuICAgIFwiRXhwZXJpZW5jZUNvbnRyaWJ1dGlvblwiOiBudW1iZXI7XHJcbiAgICBcIkhlYWxpbmdcIjogbnVtYmVyO1xyXG4gICAgXCJTaWVnZURhbWFnZVwiOiBudW1iZXI7XHJcbiAgICBcIkhlcm9EYW1hZ2VcIjogbnVtYmVyO1xyXG4gICAgXCJEYW1hZ2VUYWtlblwiOiBudW1iZXI7XHJcbiAgICBcIkF3YXJkc1wiOiBzdHJpbmdbXTtcclxufVxyXG5cclxuQFJlcGxheUFuYWx5c2VyQ29udGV4dCgnMEI5RUJDMjUtQ0IxRi00N0NDLUIyODctRDgwNkQ1OEUyQzU1JylcclxuZXhwb3J0IGNsYXNzIFNjb3JlQW5hbHlzZXIge1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVwbGF5OiBSZXBsYXkpIHsgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0IHRyYWNrZXJRdWVyaWFibGUoKTogUHJvbWlzZTxsaW5xLklFbnVtZXJhYmxlPElSZXBsYXlUcmFja2VyRXZlbnQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKTogUHJvbWlzZTxsaW5xLklFbnVtZXJhYmxlPElSZXBsYXlUcmFja2VyRXZlbnQ+PiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucmVwbGF5LnRyYWNrZXJFdmVudHM7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5xLmZyb20oZXZlbnRzKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBAUnVuT25Xb3JrZXIoKVxyXG4gICAgcHVibGljIGdldCBzY29yZVNjcmVlbkRhdGEoKTogUHJvbWlzZTxJUGxheWVyU2NvcmVzW10+IHtcclxuICAgICAgICByZXR1cm4gKGFzeW5jICgpOiBQcm9taXNlPGFueT4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFja2VyUXVlcmlhYmxlID0gYXdhaXQgdGhpcy50cmFja2VyUXVlcmlhYmxlO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gPElTU2NvcmVSZXN1bHRFdmVudD48YW55PnRyYWNrZXJRdWVyaWFibGUud2hlcmUoZSA9PiBpc1NTY29yZVJlc3VsdEV2ZW50KGUpKS5sYXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCchISEhPj4+JywgcmVzdWx0cylcclxuICAgICAgICAgICAgY29uc3Qgc2NvcmVTdGF0cyA9IFtcclxuICAgICAgICAgICAgICAgIFwiVGFrZWRvd25zXCIsXHJcbiAgICAgICAgICAgICAgICBcIkRlYXRoc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJTb2xvS2lsbFwiLFxyXG4gICAgICAgICAgICAgICAgXCJBc3Npc3RzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkV4cGVyaWVuY2VDb250cmlidXRpb25cIixcclxuICAgICAgICAgICAgICAgIFwiSGVhbGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgXCJTaWVnZURhbWFnZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJIZXJvRGFtYWdlXCIsXHJcbiAgICAgICAgICAgICAgICBcIkRhbWFnZVRha2VuXCJcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBsaW5xLmZyb20ocmVzdWx0cy5tX2luc3RhbmNlTGlzdClcclxuICAgICAgICAgICAgICAgIC53aGVyZShlID0+IHNjb3JlU3RhdHMuaW5kZXhPZihlLm1fbmFtZSkgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGF3YXJkcyA9IGxpbnEuZnJvbShyZXN1bHRzLm1faW5zdGFuY2VMaXN0KVxyXG4gICAgICAgICAgICAgICAgLndoZXJlKGUgPT4gZS5tX25hbWUuc3RhcnRzV2l0aCgnRW5kT2ZNYXRjaEF3YXJkJykpXHJcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGxheWVyU3RhdHMgPSBbeyBBd2FyZHM6IFtdIH0sIHsgQXdhcmRzOiBbXSB9LCB7IEF3YXJkczogW10gfSwgeyBBd2FyZHM6IFtdIH0sIHsgQXdhcmRzOiBbXSB9LCB7IEF3YXJkczogW10gfSwgeyBBd2FyZHM6IFtdIH0sIHsgQXdhcmRzOiBbXSB9LCB7IEF3YXJkczogW10gfSwgeyBBd2FyZHM6IFtdIH1dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYXllclN0YXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwc3RhdHMgPSBwbGF5ZXJTdGF0c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ID0gc3RhdHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgcHN0YXRzW3N0YXQubV9uYW1lXSA9IHN0YXQubV92YWx1ZXNbaV1bMF0ubV92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXdhcmRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXdhcmQgPSBhd2FyZHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXdhcmROYW1lID0gYXdhcmQubV9uYW1lLnN1YnN0cmluZygwLCBhd2FyZC5tX25hbWUubGVuZ3RoIC0gNykuc3Vic3RyaW5nKDE1KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YXJkLm1fdmFsdWVzW2ldWzBdLm1fdmFsdWUgPT09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzdGF0cy5Bd2FyZHMucHVzaChhd2FyZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYXllclN0YXRzO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/analyzers/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/replay/analyzers/BasicReplayAnalyser.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/analyzers/ReplayMapAnalyser.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/analyzers/ScoreAnalyser.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9hbmFseXplcnMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQ0FBc0M7QUFDdEMseUNBQW9DO0FBQ3BDLHFDQUFnQyIsImZpbGUiOiJyZXBsYXkvYW5hbHl6ZXJzL2luZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9CYXNpY1JlcGxheUFuYWx5c2VyJztcclxuZXhwb3J0ICogZnJvbSAnLi9SZXBsYXlNYXBBbmFseXNlcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vU2NvcmVBbmFseXNlcic7XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/decorators.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("../heroprotocol/node_modules/reflect-metadata/Reflect.js");
const WorkerContextRegistry_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/context/WorkerContextRegistry.js");
const ReplayContextCaller_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/ReplayContextCaller.js");
const ReplayAnalyserContextCaller_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/ReplayAnalyserContextCaller.js");
function isRunningInWorker() {
    return typeof importScripts === 'function' && navigator.constructor.name === 'WorkerNavigator';
}
function addProtoIfRequired(obj, protoToAdd) {
    let proto = obj['__proto__'];
    while (proto) {
        const nextProto = proto['__proto__'];
        if (nextProto) {
            if (nextProto === protoToAdd) {
                return;
            }
            if (nextProto.constructor === Object) {
                proto['__proto__'] = protoToAdd;
                return;
            }
        }
        proto = nextProto;
    }
}
function WorkerContextCaller(guid, proxyType) {
    return (target) => {
        if (isRunningInWorker()) {
            Reflect.defineMetadata('workerContext:typeId', guid, target);
            WorkerContextRegistry_1.WorkerContextRegistry.registerContextCaller(target);
            return;
        }
        const original = target;
        const f = function (...args) {
            const self = new proxyType(...args);
            Object.getOwnPropertyNames(original.prototype).forEach(name => {
                const sdesc = Object.getOwnPropertyDescriptor(self, name);
                let sFunc = false;
                if (!sdesc) {
                    try {
                        sFunc = typeof self[name] === 'function';
                    }
                    catch (e) {
                        sFunc = true;
                    }
                }
                if (name !== 'constructor' && !sdesc && !sFunc) {
                    const desc = Object.getOwnPropertyDescriptor(original.prototype, name);
                    Object.defineProperty(self, name, desc);
                }
            });
            Reflect.defineMetadata('workerContext:typeId', guid, self.constructor);
            WorkerContextRegistry_1.WorkerContextRegistry.registerContextCaller(self.constructor);
            return self;
        };
        f.prototype = original.prototype;
        return f;
    };
}
exports.WorkerContextCaller = WorkerContextCaller;
function ReplayWorkerContext(guid) {
    return WorkerContextCaller(guid, ReplayContextCaller_1.ReplayContextCaller);
}
exports.ReplayWorkerContext = ReplayWorkerContext;
function ReplayAnalyserContext(guid) {
    return WorkerContextCaller(guid, ReplayAnalyserContextCaller_1.ReplayAnalyserContextCaller);
}
exports.ReplayAnalyserContext = ReplayAnalyserContext;
function wrapProxiedMethod(methodId, cacheResult) {
    const fn = function (...args) {
        return this.workerContext.callMethod(this, methodId, args, cacheResult);
    };
    return fn;
}
function wrapProxiedGetter(propertyId, cacheResult) {
    const pId = propertyId;
    const fn = function () {
        return this.workerContext.getProperty(this, pId, cacheResult);
    };
    return fn;
}
function buildWorkerPoxyMethod(target, methodNum, propertyKey, descriptor) {
    const type = Reflect.getMetadata('design:returnType', target, propertyKey);
    /*if (!(type === Promise || type.prototype instanceof Promise)) {
        throw new Error(`Method "${propertyKey}" must return a promise.`);
    }*/
    return {
        enumerable: descriptor.enumerable,
        writable: descriptor.writable,
        value: wrapProxiedMethod(methodNum, true)
    };
}
function buildWorkerPoxyGetterProperty(target, methodNum, propertyKey, descriptor) {
    if (descriptor.set) {
        throw Error(`Cannot wrap setter "${propertyKey}". Only readonly properties are supported.`);
    }
    const type = Reflect.getMetadata('design:type', target, propertyKey);
    /*if (!(type === Promise || type.prototype instanceof Promise)) {
        throw new Error(`Property "${propertyKey}" must return a promise.`);
    }*/
    const desc = {
        get: wrapProxiedGetter(methodNum, true)
    };
    return desc;
}
let callAddress = -1;
function RunOnWorker() {
    return (target, propertyKey, descriptor) => {
        let proxyMap = Reflect.getOwnMetadata('woker:proxyMethods', target.constructor);
        if (!proxyMap) {
            proxyMap = {};
            Reflect.defineMetadata('woker:proxyMethods', proxyMap, target.constructor);
        }
        const mCount = ++callAddress;
        proxyMap[mCount] = propertyKey;
        if (isRunningInWorker()) {
            return;
        }
        if (typeof (descriptor.value) === 'function') {
            return buildWorkerPoxyMethod(target, mCount, propertyKey, descriptor);
        }
        else {
            return buildWorkerPoxyGetterProperty(target, mCount, propertyKey, descriptor);
        }
    };
}
exports.RunOnWorker = RunOnWorker;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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Q0FtQkMiLCJmaWxlIjoicmVwbGF5L2RlY29yYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWNsYXJlIHZhciBpbXBvcnRTY3JpcHRzO1xyXG5pbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBXb3JrZXJDb250ZXh0UmVnaXN0cnkgfSBmcm9tICcuL3Byb3h5L2NvbnRleHQvV29ya2VyQ29udGV4dFJlZ2lzdHJ5JztcclxuaW1wb3J0IHsgSVdvcmtlckNvbnRleHRIb3N0IH0gZnJvbSAnLi9wcm94eS9jb250ZXh0L0lXb3JrZXJDb250ZXh0SG9zdCc7XHJcbmltcG9ydCB7IFJlcGxheUNvbnRleHRDYWxsZXIgfSBmcm9tICcuL3Byb3h5L1JlcGxheUNvbnRleHRDYWxsZXInO1xyXG5pbXBvcnQgeyBSZXBsYXlBbmFseXNlckNvbnRleHRDYWxsZXIgfSBmcm9tICcuL3Byb3h5L1JlcGxheUFuYWx5c2VyQ29udGV4dENhbGxlcic7XHJcbmltcG9ydCB7IFR5cGUgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5mdW5jdGlvbiBpc1J1bm5pbmdJbldvcmtlcigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyAmJiBuYXZpZ2F0b3IuY29uc3RydWN0b3IubmFtZSA9PT0gJ1dvcmtlck5hdmlnYXRvcic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFByb3RvSWZSZXF1aXJlZChvYmo6IGFueSwgcHJvdG9Ub0FkZDogYW55KSB7XHJcbiAgICBsZXQgcHJvdG8gPSBvYmpbJ19fcHJvdG9fXyddO1xyXG4gICAgd2hpbGUgKHByb3RvKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dFByb3RvID0gcHJvdG9bJ19fcHJvdG9fXyddO1xyXG4gICAgICAgIGlmIChuZXh0UHJvdG8pIHtcclxuICAgICAgICAgICAgaWYgKG5leHRQcm90byA9PT0gcHJvdG9Ub0FkZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0UHJvdG8uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgcHJvdG9bJ19fcHJvdG9fXyddID0gcHJvdG9Ub0FkZDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90byA9IG5leHRQcm90bztcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFdvcmtlckNvbnRleHRDYWxsZXIoZ3VpZDogc3RyaW5nLCBwcm94eVR5cGU6IFR5cGU8SVdvcmtlckNvbnRleHRIb3N0Pik6IENsYXNzRGVjb3JhdG9yIHtcclxuICAgIHJldHVybiA8VEZ1bmN0aW9uIGV4dGVuZHMgRnVuY3Rpb24+KHRhcmdldDogVEZ1bmN0aW9uKTogVEZ1bmN0aW9uIHwgdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKGlzUnVubmluZ0luV29ya2VyKCkpIHtcclxuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgnd29ya2VyQ29udGV4dDp0eXBlSWQnLCBndWlkLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICBXb3JrZXJDb250ZXh0UmVnaXN0cnkucmVnaXN0ZXJDb250ZXh0Q2FsbGVyKDxhbnk+dGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcmlnaW5hbDogYW55ID0gdGFyZ2V0O1xyXG4gICAgICAgIGNvbnN0IGY6IGFueSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzZWxmID0gbmV3IHByb3h5VHlwZSguLi5hcmdzKTtcclxuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWwucHJvdG90eXBlKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Rlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlbGYsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBsZXQgc0Z1bmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmKCFzZGVzYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzRnVuYyA9IHR5cGVvZiBzZWxmW25hbWVdID09PSAnZnVuY3Rpb24nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc0Z1bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKG5hbWUgIT09ICdjb25zdHJ1Y3RvcicgJiYgIXNkZXNjICYmICFzRnVuYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWwucHJvdG90eXBlLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgbmFtZSwgZGVzYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCd3b3JrZXJDb250ZXh0OnR5cGVJZCcsIGd1aWQsIHNlbGYuY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBXb3JrZXJDb250ZXh0UmVnaXN0cnkucmVnaXN0ZXJDb250ZXh0Q2FsbGVyKDxUeXBlPGFueT4+c2VsZi5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZi5wcm90b3R5cGUgPSBvcmlnaW5hbC5wcm90b3R5cGU7XHJcbiAgICAgICAgcmV0dXJuIGY7XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUmVwbGF5V29ya2VyQ29udGV4dChndWlkOiBzdHJpbmcpOiBDbGFzc0RlY29yYXRvciB7XHJcbiAgICByZXR1cm4gV29ya2VyQ29udGV4dENhbGxlcihndWlkLCBSZXBsYXlDb250ZXh0Q2FsbGVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFJlcGxheUFuYWx5c2VyQ29udGV4dChndWlkOiBzdHJpbmcpOiBDbGFzc0RlY29yYXRvciB7XHJcbiAgICByZXR1cm4gV29ya2VyQ29udGV4dENhbGxlcihndWlkLCBSZXBsYXlBbmFseXNlckNvbnRleHRDYWxsZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwUHJveGllZE1ldGhvZDxUPihtZXRob2RJZDogbnVtYmVyLCBjYWNoZVJlc3VsdDogYm9vbGVhbik6ICgpID0+IFByb21pc2U8YW55PiB7XHJcbiAgICBjb25zdCBmbiA9IGZ1bmN0aW9uICh0aGlzOiBJV29ya2VyQ29udGV4dEhvc3QsIC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2VyQ29udGV4dC5jYWxsTWV0aG9kKHRoaXMsIG1ldGhvZElkLCBhcmdzLCBjYWNoZVJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZuO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwUHJveGllZEdldHRlcihwcm9wZXJ0eUlkOiBudW1iZXIsIGNhY2hlUmVzdWx0OiBib29sZWFuKTogKCkgPT4gUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IHBJZCA9IHByb3BlcnR5SWQ7XHJcbiAgICBjb25zdCBmbiA9IGZ1bmN0aW9uICh0aGlzOiBJV29ya2VyQ29udGV4dEhvc3QpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlckNvbnRleHQuZ2V0UHJvcGVydHkodGhpcywgcElkLCBjYWNoZVJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZuO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZFdvcmtlclBveHlNZXRob2Q8VD4oXHJcbiAgICB0YXJnZXQ6IE9iamVjdCxcclxuICAgIG1ldGhvZE51bTogbnVtYmVyLFxyXG4gICAgcHJvcGVydHlLZXk6IHN0cmluZyB8IHN5bWJvbCxcclxuICAgIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPFQ+XHJcbik6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPFQ+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246cmV0dXJuVHlwZScsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgLyppZiAoISh0eXBlID09PSBQcm9taXNlIHx8IHR5cGUucHJvdG90eXBlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCBcIiR7cHJvcGVydHlLZXl9XCIgbXVzdCByZXR1cm4gYSBwcm9taXNlLmApO1xyXG4gICAgfSovXHJcblxyXG4gICAgcmV0dXJuIDxUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxUPj57XHJcbiAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxyXG4gICAgICAgIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLFxyXG4gICAgICAgIHZhbHVlOiA8YW55PndyYXBQcm94aWVkTWV0aG9kKG1ldGhvZE51bSwgdHJ1ZSlcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkV29ya2VyUG94eUdldHRlclByb3BlcnR5PFQ+KFxyXG4gICAgdGFyZ2V0OiBPYmplY3QsXHJcbiAgICBtZXRob2ROdW06IG51bWJlcixcclxuICAgIHByb3BlcnR5S2V5OiBzdHJpbmcgfCBzeW1ib2wsXHJcbiAgICBkZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxUPlxyXG4pOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxUPiB7XHJcbiAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHdyYXAgc2V0dGVyIFwiJHtwcm9wZXJ0eUtleX1cIi4gT25seSByZWFkb25seSBwcm9wZXJ0aWVzIGFyZSBzdXBwb3J0ZWQuYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdHlwZSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAvKmlmICghKHR5cGUgPT09IFByb21pc2UgfHwgdHlwZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgXCIke3Byb3BlcnR5S2V5fVwiIG11c3QgcmV0dXJuIGEgcHJvbWlzZS5gKTtcclxuICAgIH0qL1xyXG4gICAgY29uc3QgZGVzYyA9IDxUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxUPj57XHJcbiAgICAgICAgZ2V0OiA8YW55PndyYXBQcm94aWVkR2V0dGVyKG1ldGhvZE51bSwgdHJ1ZSlcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVzYztcclxufVxyXG5cclxubGV0IGNhbGxBZGRyZXNzID0gLTE7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFJ1bk9uV29ya2VyPFQ+KCk6IE1ldGhvZERlY29yYXRvciB7XHJcbiAgICByZXR1cm4gPFQ+KHRhcmdldDogT2JqZWN0LCBwcm9wZXJ0eUtleTogc3RyaW5nIHwgc3ltYm9sLCBkZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxUPik6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPFQ+IHwgdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IHByb3h5TWFwID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnd29rZXI6cHJveHlNZXRob2RzJywgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBpZiAoIXByb3h5TWFwKSB7XHJcbiAgICAgICAgICAgIHByb3h5TWFwID0ge307XHJcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3dva2VyOnByb3h5TWV0aG9kcycsIHByb3h5TWFwLCB0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtQ291bnQgPSArK2NhbGxBZGRyZXNzO1xyXG4gICAgICAgIHByb3h5TWFwW21Db3VudF0gPSBwcm9wZXJ0eUtleTtcclxuICAgICAgICBpZiAoaXNSdW5uaW5nSW5Xb3JrZXIoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIChkZXNjcmlwdG9yLnZhbHVlKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRXb3JrZXJQb3h5TWV0aG9kKHRhcmdldCwgbUNvdW50LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkV29ya2VyUG94eUdldHRlclByb3BlcnR5KHRhcmdldCwgbUNvdW50LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/replay/analyzers/index.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/Replay.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/decorators.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/index.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUE0QjtBQUM1Qiw4QkFBeUI7QUFDekIsa0NBQTZCO0FBQzdCLDZCQUF3QiIsImZpbGUiOiJyZXBsYXkvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FuYWx5emVycyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vUmVwbGF5JztcclxuZXhwb3J0ICogZnJvbSAnLi9kZWNvcmF0b3JzJztcclxuZXhwb3J0ICogZnJvbSAnLi9wcm94eSc7XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/ReplayAnalyserContextCaller.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ReplayAnalyserContextCaller {
    get workerContext() {
        return this._replay ? this._replay.workerContext : undefined;
    }
    constructor(replay) {
        this._replay = replay;
        this.workerContext.addCallContext(this);
    }
    dispose() {
        if (this._replay) {
            this.workerContext.removeCallContext(this);
            this._replay = undefined;
        }
    }
}
exports.ReplayAnalyserContextCaller = ReplayAnalyserContextCaller;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9SZXBsYXlBbmFseXNlckNvbnRleHRDYWxsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFJQTtJQUdJLElBQVcsYUFBYTtRQUNwQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDakUsQ0FBQztJQUVELFlBQW1CLE1BQTJCO1FBQzFDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFTSxPQUFPO1FBQ1YsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztTQUM1QjtJQUNMLENBQUM7Q0FFSjtBQW5CRCxrRUFtQkMiLCJmaWxlIjoicmVwbGF5L3Byb3h5L1JlcGxheUFuYWx5c2VyQ29udGV4dENhbGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgeyBJV29ya2VyQ29udGV4dEhvc3QgfSBmcm9tICcuL2NvbnRleHQvSVdvcmtlckNvbnRleHRIb3N0JztcclxuaW1wb3J0IHsgSVdvcmtlckNvbnRleHQgfSBmcm9tICcuL2NvbnRleHQvSVdvcmtlckNvbnRleHQnO1xyXG5pbXBvcnQgeyBSZXBsYXlDb250ZXh0Q2FsbGVyIH0gZnJvbSAnLi9SZXBsYXlDb250ZXh0Q2FsbGVyJztcclxuZXhwb3J0IGNsYXNzIFJlcGxheUFuYWx5c2VyQ29udGV4dENhbGxlciBpbXBsZW1lbnRzIElXb3JrZXJDb250ZXh0SG9zdCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfcmVwbGF5OiBSZXBsYXlDb250ZXh0Q2FsbGVyO1xyXG4gICAgcHVibGljIGdldCB3b3JrZXJDb250ZXh0KCk6IElXb3JrZXJDb250ZXh0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwbGF5ID8gdGhpcy5fcmVwbGF5LndvcmtlckNvbnRleHQgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHJlcGxheTogUmVwbGF5Q29udGV4dENhbGxlcikge1xyXG4gICAgICAgIHRoaXMuX3JlcGxheSA9IHJlcGxheTtcclxuICAgICAgICB0aGlzLndvcmtlckNvbnRleHQuYWRkQ2FsbENvbnRleHQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcGxheSkge1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQucmVtb3ZlQ2FsbENvbnRleHQodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxheSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/ReplayContextCaller.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WorkerContext_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/context/WorkerContext.js");
const messages_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/index.js");
const heroprotocol_1 = __webpack_require__("../heroprotocol/dist/lib/heroprotocol.js");
const Subject_1 = __webpack_require__("./node_modules/rxjs/Subject.js");
const operators_1 = __webpack_require__("./node_modules/rxjs/operators.js");
class ReplayContextCaller {
    constructor(mpqData) {
        this._statusSubject = new Subject_1.Subject();
        this._workerContext = new WorkerContext_1.WorkerContext(`./assets/webworker/replay-worker${heroprotocol_1.HeroProtocol.env === 'production' ? '.min' : ''}.js`, mpqData, [mpqData]);
        this._workerContext.addCallContext(this);
        this._statusSubjectSubscription = this._workerContext.channelMessages.pipe(operators_1.filter(msg => messages_1.isReplayStatusMessage(msg))).subscribe(((statusMessage) => {
            this._statusSubject.next(statusMessage);
        }));
        this._protocolLoaderSubscription = this._workerContext.channelMessages.pipe(operators_1.filter(msg => messages_1.isLoadProtocolMessage(msg))).subscribe(((protocolMessage) => __awaiter(this, void 0, void 0, function* () {
            console.log('ILoadProtocolMessage', protocolMessage);
            const code = yield heroprotocol_1.HeroProtocol.loadProtocol(protocolMessage.version);
            this.workerContext.send({
                type: 'load-protocol-result',
                version: protocolMessage.version,
                code: code
            });
        })));
    }
    get workerContext() {
        return this._workerContext;
    }
    get status() {
        return this._statusSubject.asObservable();
    }
    get protocol() {
        throw new Error('Protocol can only be accessed in the web worker context');
    }
    dispose() {
        if (this._workerContext) {
            this._statusSubjectSubscription.unsubscribe();
            this._statusSubjectSubscription = undefined;
            this._statusSubject = undefined;
            this.workerContext.dispose();
            this._workerContext = undefined;
        }
    }
}
exports.ReplayContextCaller = ReplayContextCaller;
/*import { AbstractWorkerProxy } from './AbstractWorkerProxy';
import { isLoadProtocolMessage, ILoadProtocolResultMessage, isReplayStatusMessage, IReplayStatusMessage } from './messages';
import { HeroProtocol } from '../../';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

export class ReplayProxy extends AbstractWorkerProxy {

    private _statusSubject: BehaviorSubject<IReplayStatusMessage> = new BehaviorSubject(undefined);

    public constructor(mpqData?: ArrayBuffer) {
        super(new Worker('./assets/worker/worker.js'), mpqData, [mpqData]);
    }

    public get status(): BehaviorSubject<IReplayStatusMessage> {
        return this._statusSubject;
    }

    public get protocol(): Promise<any> {
        throw new Error('Protocol can only be accessed in the web worker context');
    }

    protected async handleWorkerMessage(data: any) {
        if (isLoadProtocolMessage(data)) {
            const code = await HeroProtocol.loadProtocol(data.version);
            this.send(<ILoadProtocolResultMessage>{
                type: 'load-protocol-result',
                version: data.version,
                code: code
            });
        } else if (isReplayStatusMessage(data)) {
            console.log(data);
            this._statusSubject.next(data);
        } else {
            super.handleWorkerMessage(data);
        }
    }
}
*/

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9SZXBsYXlDb250ZXh0Q2FsbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHQSwyREFBd0Q7QUFDeEQseUNBR29CO0FBQ3BCLHFEQUFrRDtBQUNsRCwwQ0FBdUM7QUFHdkMsOENBQXdDO0FBRXhDO0lBb0JJLFlBQW1CLE9BQXFCO1FBakJoQyxtQkFBYyxHQUFrQyxJQUFJLGlCQUFPLEVBQUUsQ0FBQztRQWtCbEUsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLDZCQUFhLENBQUMsbUNBQW1DLDJCQUFZLENBQUMsR0FBRyxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3JKLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQywwQkFBMEIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQ3RFLGtCQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQ0FBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFtQyxFQUFFLEVBQUU7WUFDMUYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNSLElBQUksQ0FBQywyQkFBMkIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQ3ZFLGtCQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQ0FBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBTyxlQUFxQyxFQUFFLEVBQUU7WUFDbEcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBRSxlQUFlLENBQUMsQ0FBQztZQUNyRCxNQUFNLElBQUksR0FBRyxNQUFNLDJCQUFZLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0RSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBNkI7Z0JBQ2hELElBQUksRUFBRSxzQkFBc0I7Z0JBQzVCLE9BQU8sRUFBRSxlQUFlLENBQUMsT0FBTztnQkFDaEMsSUFBSSxFQUFFLElBQUk7YUFDYixDQUFDLENBQUM7UUFDUCxDQUFDLENBQUEsQ0FBQyxDQUFDLENBQUM7SUFDWixDQUFDO0lBN0JELElBQVcsYUFBYTtRQUNwQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQVcsTUFBTTtRQUNiLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUM5QyxDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFxQk0sT0FBTztRQUNWLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNyQixJQUFJLENBQUMsMEJBQTBCLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDOUMsSUFBSSxDQUFDLDBCQUEwQixHQUFHLFNBQVMsQ0FBQztZQUM1QyxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQztZQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzdCLElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxDQUFDO1NBQ25DO0lBQ0wsQ0FBQztDQUNKO0FBaERELGtEQWdEQztBQUdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBcUNFIiwiZmlsZSI6InJlcGxheS9wcm94eS9SZXBsYXlDb250ZXh0Q2FsbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbmltcG9ydCB7IElXb3JrZXJDb250ZXh0SG9zdCB9IGZyb20gJy4vY29udGV4dC9JV29ya2VyQ29udGV4dEhvc3QnO1xyXG5pbXBvcnQgeyBJV29ya2VyQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC9JV29ya2VyQ29udGV4dCc7XHJcbmltcG9ydCB7IFdvcmtlckNvbnRleHQgfSBmcm9tICcuL2NvbnRleHQvV29ya2VyQ29udGV4dCc7XHJcbmltcG9ydCB7XHJcbiAgICBJUmVwbGF5U3RhdHVzTWVzc2FnZSwgaXNSZXBsYXlTdGF0dXNNZXNzYWdlLFxyXG4gICAgSUxvYWRQcm90b2NvbE1lc3NhZ2UsIGlzTG9hZFByb3RvY29sTWVzc2FnZSwgSUxvYWRQcm90b2NvbFJlc3VsdE1lc3NhZ2VcclxufSBmcm9tICcuL21lc3NhZ2VzJztcclxuaW1wb3J0IHsgSGVyb1Byb3RvY29sIH0gZnJvbSAnLi4vLi4vaGVyb3Byb3RvY29sJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBSZXBsYXlDb250ZXh0Q2FsbGVyIGltcGxlbWVudHMgSVdvcmtlckNvbnRleHRIb3N0IHtcclxuXHJcbiAgICBwcml2YXRlIF93b3JrZXJDb250ZXh0OiBJV29ya2VyQ29udGV4dDtcclxuICAgIHByaXZhdGUgX3N0YXR1c1N1YmplY3Q6IFN1YmplY3Q8SVJlcGxheVN0YXR1c01lc3NhZ2U+ID0gbmV3IFN1YmplY3QoKTtcclxuICAgIHByaXZhdGUgX3N0YXR1c1N1YmplY3RTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBwcml2YXRlIF9wcm90b2NvbExvYWRlclN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIHB1YmxpYyBnZXQgd29ya2VyQ29udGV4dCgpOiBJV29ya2VyQ29udGV4dCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlckNvbnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBzdGF0dXMoKTogT2JzZXJ2YWJsZTxJUmVwbGF5U3RhdHVzTWVzc2FnZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvdG9jb2woKTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3RvY29sIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGluIHRoZSB3ZWIgd29ya2VyIGNvbnRleHQnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IobXBxRGF0YT86IEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyQ29udGV4dCA9IG5ldyBXb3JrZXJDb250ZXh0KGAuL2Fzc2V0cy93ZWJ3b3JrZXIvcmVwbGF5LXdvcmtlciR7SGVyb1Byb3RvY29sLmVudiA9PT0gJ3Byb2R1Y3Rpb24nID8gJy5taW4nIDogJyd9LmpzYCwgbXBxRGF0YSwgW21wcURhdGFdKTtcclxuICAgICAgICB0aGlzLl93b3JrZXJDb250ZXh0LmFkZENhbGxDb250ZXh0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3N0YXR1c1N1YmplY3RTdWJzY3JpcHRpb24gPSB0aGlzLl93b3JrZXJDb250ZXh0LmNoYW5uZWxNZXNzYWdlcy5waXBlKFxyXG4gICAgICAgICAgICBmaWx0ZXIobXNnID0+IGlzUmVwbGF5U3RhdHVzTWVzc2FnZShtc2cpKSkuc3Vic2NyaWJlKCgoc3RhdHVzTWVzc2FnZTogSVJlcGxheVN0YXR1c01lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c1N1YmplY3QubmV4dChzdGF0dXNNZXNzYWdlKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sTG9hZGVyU3Vic2NyaXB0aW9uID0gdGhpcy5fd29ya2VyQ29udGV4dC5jaGFubmVsTWVzc2FnZXMucGlwZShcclxuICAgICAgICAgICAgZmlsdGVyKG1zZyA9PiBpc0xvYWRQcm90b2NvbE1lc3NhZ2UobXNnKSkpLnN1YnNjcmliZSgoYXN5bmMgKHByb3RvY29sTWVzc2FnZTogSUxvYWRQcm90b2NvbE1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJTG9hZFByb3RvY29sTWVzc2FnZScsIHByb3RvY29sTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgSGVyb1Byb3RvY29sLmxvYWRQcm90b2NvbChwcm90b2NvbE1lc3NhZ2UudmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQuc2VuZCg8SUxvYWRQcm90b2NvbFJlc3VsdE1lc3NhZ2U+e1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkLXByb3RvY29sLXJlc3VsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcHJvdG9jb2xNZXNzYWdlLnZlcnNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fd29ya2VyQ29udGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNTdWJqZWN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c1N1YmplY3RTdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c1N1YmplY3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMud29ya2VyQ29udGV4dC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlckNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyppbXBvcnQgeyBBYnN0cmFjdFdvcmtlclByb3h5IH0gZnJvbSAnLi9BYnN0cmFjdFdvcmtlclByb3h5JztcclxuaW1wb3J0IHsgaXNMb2FkUHJvdG9jb2xNZXNzYWdlLCBJTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZSwgaXNSZXBsYXlTdGF0dXNNZXNzYWdlLCBJUmVwbGF5U3RhdHVzTWVzc2FnZSB9IGZyb20gJy4vbWVzc2FnZXMnO1xyXG5pbXBvcnQgeyBIZXJvUHJvdG9jb2wgfSBmcm9tICcuLi8uLi8nO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVwbGF5UHJveHkgZXh0ZW5kcyBBYnN0cmFjdFdvcmtlclByb3h5IHtcclxuXHJcbiAgICBwcml2YXRlIF9zdGF0dXNTdWJqZWN0OiBCZWhhdmlvclN1YmplY3Q8SVJlcGxheVN0YXR1c01lc3NhZ2U+ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihtcHFEYXRhPzogQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICBzdXBlcihuZXcgV29ya2VyKCcuL2Fzc2V0cy93b3JrZXIvd29ya2VyLmpzJyksIG1wcURhdGEsIFttcHFEYXRhXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBzdGF0dXMoKTogQmVoYXZpb3JTdWJqZWN0PElSZXBsYXlTdGF0dXNNZXNzYWdlPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1c1N1YmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBwcm90b2NvbCgpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgY2FuIG9ubHkgYmUgYWNjZXNzZWQgaW4gdGhlIHdlYiB3b3JrZXIgY29udGV4dCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhc3luYyBoYW5kbGVXb3JrZXJNZXNzYWdlKGRhdGE6IGFueSkge1xyXG4gICAgICAgIGlmIChpc0xvYWRQcm90b2NvbE1lc3NhZ2UoZGF0YSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IEhlcm9Qcm90b2NvbC5sb2FkUHJvdG9jb2woZGF0YS52ZXJzaW9uKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kKDxJTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZT57XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZC1wcm90b2NvbC1yZXN1bHQnLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogZGF0YS52ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgY29kZTogY29kZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzUmVwbGF5U3RhdHVzTWVzc2FnZShkYXRhKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzU3ViamVjdC5uZXh0KGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN1cGVyLmhhbmRsZVdvcmtlck1lc3NhZ2UoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiovXHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/ReplayWorker.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/index.js");
const WorkerContextRegistry_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/context/WorkerContextRegistry.js");
__webpack_require__("../heroprotocol/node_modules/reflect-metadata/Reflect.js");
__webpack_require__("./node_modules/rxjs/operators/debounce.js");
const Replay_1 = __webpack_require__("../heroprotocol/dist/lib/replay/Replay.js");
class ReplayWorker {
    constructor(initCmd) {
        this._protocolPromisies = {};
        this._loadedContexts = new Map();
        this._messagePort = initCmd.port;
        this._messagePort.onmessage = (event) => __awaiter(this, void 0, void 0, function* () {
            if (messages_1.isWorkerCallMessage(event.data)) {
                try {
                    this.send(yield this.handleWorkerCallMessage(event.data));
                }
                catch (e) {
                    const errMsg = {
                        type: 'worker-call-result',
                        callId: event.data.callId,
                        error: true,
                        result: {
                            name: e.name,
                            message: e.message,
                            stack: e.stack
                        }
                    };
                }
            }
            else if (messages_1.isLoadProtocolResultMessage(event.data)) {
                this.handleProtocolResult(event.data);
            }
        });
        this._replay = new Replay_1.Replay(initCmd.data);
        const replayContextId = WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerId(this._replay);
        this._loadedContexts.set(replayContextId, this._replay);
        this._replay.status.subscribe((status) => {
            if (status) {
                this.send(status);
            }
        });
        const oldLoad = this._replay.loadProtocol;
        this._replay.loadProtocol = (version) => {
            if (this._protocolPromisies[version]) {
                return this._protocolPromisies[version].promise;
            }
            const promise = new Promise((resolve, reject) => {
                this._protocolPromisies[version] = {
                    resolve,
                    reject,
                    promise: undefined
                };
            });
            this._protocolPromisies[version].promise = promise;
            this.send({
                type: 'load-protocol',
                version: version
            });
            return promise;
        };
    }
    send(data, transfer = []) {
        this._messagePort.postMessage(data, transfer);
    }
    handleProtocolResult(data) {
        const promise = this._protocolPromisies[data.version];
        promise.resolve(data.code);
    }
    handleWorkerCallMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (messages_1.isWorkerPropertyCall(msg.data)) {
                return yield this.handleWorkerPropertyCall(msg.callId, msg.data);
            }
            else if (messages_1.isWorkerMethodCall(msg.data)) {
                return yield this.handleWorkerMethodCall(msg.callId, msg.data);
            }
            else {
                throw new Error(`Unhandled Worker Call Message "${msg.type}"`);
            }
        });
    }
    handleWorkerPropertyCall(callId, call) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = this.getContextInstance(call.context);
            const value = yield context[this.getPropertyName(context, call.propertyId)];
            const result = {
                type: 'worker-call-result',
                callId,
                result: value
            };
            return result;
        });
    }
    handleWorkerMethodCall(callId, call) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = this.getContextInstance(call.context);
            const fn = context[this.getPropertyName(context, call.methodId)];
            const value = yield fn.apply(context, call.args || []);
            const result = {
                type: 'worker-call-result',
                callId,
                result: value
            };
            return result;
        });
    }
    /*private async handleWorkerCmd(cmd: IWorkerCommand): Promise<IWorkerCommandResult> {
        const context = this.getContextInstance(cmd.context);
        let result: IWorkerCommandResult;
        if (isWorkerGetPropertyCommand(cmd)) {
            const value = await context[this.getPropertyName(context, cmd.id)];
            result = {
                type: 'command-result',
                messageId: cmd.messageId,
                result: value
            };
        } else if (isWorkerCallMethodCommand(cmd)) {
            const fn: Function = context[this.getPropertyName(context, cmd.id)];
            return await fn.apply(context, cmd.args);
        }
        return result;
    }*/
    getContextInstance(contextId) {
        if (this._loadedContexts.has(contextId)) {
            return this._loadedContexts.get(contextId);
        }
        const contextType = WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerById(contextId);
        const contextInst = new contextType(this._replay);
        this._loadedContexts.set(contextId, contextInst);
        return contextInst;
    }
    getPropertyName(context, id) {
        const proxyMap = Reflect.getOwnMetadata('woker:proxyMethods', context.constructor);
        return proxyMap[id];
    }
}
exports.ReplayWorker = ReplayWorker;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9SZXBsYXlXb3JrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHlDQWFvQjtBQUNwQiwyRUFBd0U7QUFDeEUsNEJBQTBCO0FBRzFCLG1DQUFpQztBQUVqQyxzQ0FBbUM7QUFDbkM7SUFPSSxZQUFZLE9BQTJCO1FBSi9CLHVCQUFrQixHQUE2RixFQUFFLENBQUM7UUFFbEgsb0JBQWUsR0FBcUIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUdsRCxJQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDakMsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsQ0FBTyxLQUFLLEVBQUUsRUFBRTtZQUMxQyxJQUFJLDhCQUFtQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDakMsSUFBSTtvQkFDQSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2lCQUM3RDtnQkFBQyxPQUFPLENBQUMsRUFBRTtvQkFDUixNQUFNLE1BQU0sR0FBNkI7d0JBQ3JDLElBQUksRUFBRSxvQkFBb0I7d0JBQzFCLE1BQU0sRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU07d0JBQ3pCLEtBQUssRUFBRSxJQUFJO3dCQUNYLE1BQU0sRUFBRTs0QkFDSixJQUFJLEVBQVUsQ0FBRSxDQUFDLElBQUk7NEJBQ3JCLE9BQU8sRUFBVSxDQUFFLENBQUMsT0FBTzs0QkFDM0IsS0FBSyxFQUFVLENBQUUsQ0FBQyxLQUFLO3lCQUMxQjtxQkFDSixDQUFDO2lCQUNMO2FBQ0o7aUJBQU0sSUFBSSxzQ0FBMkIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2hELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDekM7UUFDTCxDQUFDLENBQUEsQ0FBQztRQUNGLElB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Q0FBQztJQUN2QixDQUFDO0lBRU8sZUFBZSxDQUFDLE9BQWUsRUFBRSxFQUFVO1FBQy9DLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ25GLE9BQU8sUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Q0FFSjtBQXhJRCxvQ0F3SUMiLCJmaWxlIjoicmVwbGF5L3Byb3h5L1JlcGxheVdvcmtlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBJSW5pdGlhbGl6ZUNvbW1hbmQsXHJcbiAgICBJV29ya2VyQ2FsbE1lc3NhZ2UsIGlzV29ya2VyQ2FsbE1lc3NhZ2UsXHJcbiAgICBpc1dvcmtlclByb3BlcnR5Q2FsbCwgSVdvcmtlclByb3BlcnR5Q2FsbCxcclxuICAgIGlzV29ya2VyTWV0aG9kQ2FsbCwgSVdvcmtlck1ldGhvZENhbGwsXHJcbiAgICBJV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2UsXHJcblxyXG4gICAgSVdvcmtlckNvbW1hbmQsIGlzV29ya2VyQ29tbWFuZCxcclxuICAgIElXb3JrZXJDb21tYW5kUmVzdWx0LCBpc1dvcmtlckNvbW1hbmRSZXN1bHQsXHJcbiAgICBpc1dvcmtlckNhbGxNZXRob2RDb21tYW5kLCBJV29ya2VyQ2FsbE1ldGhvZENvbW1hbmQsXHJcbiAgICBpc1dvcmtlckdldFByb3BlcnR5Q29tbWFuZCwgSVdvcmtlckdldFByb3BlcnR5Q29tbWFuZCxcclxuICAgIElMb2FkUHJvdG9jb2xNZXNzYWdlLCBpc0xvYWRQcm90b2NvbFJlc3VsdE1lc3NhZ2UsIElMb2FkUHJvdG9jb2xSZXN1bHRNZXNzYWdlXHJcblxyXG59IGZyb20gJy4vbWVzc2FnZXMnO1xyXG5pbXBvcnQgeyBXb3JrZXJDb250ZXh0UmVnaXN0cnkgfSBmcm9tICcuL2NvbnRleHQvV29ya2VyQ29udGV4dFJlZ2lzdHJ5JztcclxuaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMvZGVib3VuY2VUaW1lJztcclxuaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzL09ic2VydmFibGUvdGltZXInO1xyXG5pbXBvcnQgJ3J4anMvb3BlcmF0b3JzL2RlYm91bmNlJztcclxuXHJcbmltcG9ydCB7IFJlcGxheSB9IGZyb20gJy4uL1JlcGxheSc7XHJcbmV4cG9ydCBjbGFzcyBSZXBsYXlXb3JrZXIge1xyXG4gICAgcHJpdmF0ZSBfcmVwbGF5OiBSZXBsYXk7XHJcbiAgICBwcml2YXRlIF9tZXNzYWdlUG9ydDogTWVzc2FnZVBvcnQ7XHJcbiAgICBwcml2YXRlIF9wcm90b2NvbFByb21pc2llczogeyBbdmVyc2lvbjogbnVtYmVyXTogeyByZXNvbHZlOiBGdW5jdGlvbiwgcmVqZWN0OiBGdW5jdGlvbiwgcHJvbWlzZTogUHJvbWlzZTxzdHJpbmc+IH0gfSA9IHt9O1xyXG5cclxuICAgIHByaXZhdGUgX2xvYWRlZENvbnRleHRzOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGluaXRDbWQ6IElJbml0aWFsaXplQ29tbWFuZCkge1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VQb3J0ID0gaW5pdENtZC5wb3J0O1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VQb3J0Lm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNXb3JrZXJDYWxsTWVzc2FnZShldmVudC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoYXdhaXQgdGhpcy5oYW5kbGVXb3JrZXJDYWxsTWVzc2FnZShldmVudC5kYXRhKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnOiBJV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXItY2FsbC1yZXN1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsSWQ6IGV2ZW50LmRhdGEuY2FsbElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAoPEVycm9yPmUpLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoPEVycm9yPmUpLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKDxFcnJvcj5lKS5zdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xvYWRQcm90b2NvbFJlc3VsdE1lc3NhZ2UoZXZlbnQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvdG9jb2xSZXN1bHQoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3JlcGxheSA9IG5ldyBSZXBsYXkoaW5pdENtZC5kYXRhKTtcclxuICAgICAgICBjb25zdCByZXBsYXlDb250ZXh0SWQgPSBXb3JrZXJDb250ZXh0UmVnaXN0cnkuZ2V0Q29udGV4dENhbGxlcklkKHRoaXMuX3JlcGxheSk7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVkQ29udGV4dHMuc2V0KHJlcGxheUNvbnRleHRJZCwgdGhpcy5fcmVwbGF5KTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVwbGF5LnN0YXR1cy5zdWJzY3JpYmUoKHN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQoc3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IG9sZExvYWQgPSB0aGlzLl9yZXBsYXkubG9hZFByb3RvY29sO1xyXG4gICAgICAgIHRoaXMuX3JlcGxheS5sb2FkUHJvdG9jb2wgPSAodmVyc2lvbjogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sUHJvbWlzaWVzW3ZlcnNpb25dKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2xQcm9taXNpZXNbdmVyc2lvbl0ucHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2xQcm9taXNpZXNbdmVyc2lvbl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2xQcm9taXNpZXNbdmVyc2lvbl0ucHJvbWlzZSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZCg8SUxvYWRQcm90b2NvbE1lc3NhZ2U+e1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQtcHJvdG9jb2wnLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBzZW5kKGRhdGE6IGFueSwgdHJhbnNmZXI6IGFueVtdID0gW10pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlUG9ydC5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVQcm90b2NvbFJlc3VsdChkYXRhOiBJTG9hZFByb3RvY29sUmVzdWx0TWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9wcm90b2NvbFByb21pc2llc1tkYXRhLnZlcnNpb25dO1xyXG4gICAgICAgIHByb21pc2UucmVzb2x2ZShkYXRhLmNvZGUpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZVdvcmtlckNhbGxNZXNzYWdlKG1zZzogSVdvcmtlckNhbGxNZXNzYWdlKTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICBpZiAoaXNXb3JrZXJQcm9wZXJ0eUNhbGwobXNnLmRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVdvcmtlclByb3BlcnR5Q2FsbChtc2cuY2FsbElkLCBtc2cuZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1dvcmtlck1ldGhvZENhbGwobXNnLmRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVdvcmtlck1ldGhvZENhbGwobXNnLmNhbGxJZCwgbXNnLmRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIFdvcmtlciBDYWxsIE1lc3NhZ2UgXCIke21zZy50eXBlfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlV29ya2VyUHJvcGVydHlDYWxsKGNhbGxJZDogbnVtYmVyLCBjYWxsOiBJV29ya2VyUHJvcGVydHlDYWxsKSB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dEluc3RhbmNlKGNhbGwuY29udGV4dCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBjb250ZXh0W3RoaXMuZ2V0UHJvcGVydHlOYW1lKGNvbnRleHQsIGNhbGwucHJvcGVydHlJZCldO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdDogSVdvcmtlckNhbGxSZXN1bHRNZXNzYWdlID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnd29ya2VyLWNhbGwtcmVzdWx0JyxcclxuICAgICAgICAgICAgY2FsbElkLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlV29ya2VyTWV0aG9kQ2FsbChjYWxsSWQ6IG51bWJlciwgY2FsbDogSVdvcmtlck1ldGhvZENhbGwpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0SW5zdGFuY2UoY2FsbC5jb250ZXh0KTtcclxuICAgICAgICBjb25zdCBmbjogRnVuY3Rpb24gPSBjb250ZXh0W3RoaXMuZ2V0UHJvcGVydHlOYW1lKGNvbnRleHQsIGNhbGwubWV0aG9kSWQpXTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGZuLmFwcGx5KGNvbnRleHQsIGNhbGwuYXJncyB8fCBbXSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0OiBJV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd3b3JrZXItY2FsbC1yZXN1bHQnLFxyXG4gICAgICAgICAgICBjYWxsSWQsXHJcbiAgICAgICAgICAgIHJlc3VsdDogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLypwcml2YXRlIGFzeW5jIGhhbmRsZVdvcmtlckNtZChjbWQ6IElXb3JrZXJDb21tYW5kKTogUHJvbWlzZTxJV29ya2VyQ29tbWFuZFJlc3VsdD4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHRJbnN0YW5jZShjbWQuY29udGV4dCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogSVdvcmtlckNvbW1hbmRSZXN1bHQ7XHJcbiAgICAgICAgaWYgKGlzV29ya2VyR2V0UHJvcGVydHlDb21tYW5kKGNtZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBjb250ZXh0W3RoaXMuZ2V0UHJvcGVydHlOYW1lKGNvbnRleHQsIGNtZC5pZCldO1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29tbWFuZC1yZXN1bHQnLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBjbWQubWVzc2FnZUlkLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB2YWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNXb3JrZXJDYWxsTWV0aG9kQ29tbWFuZChjbWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZuOiBGdW5jdGlvbiA9IGNvbnRleHRbdGhpcy5nZXRQcm9wZXJ0eU5hbWUoY29udGV4dCwgY21kLmlkKV07XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbi5hcHBseShjb250ZXh0LCBjbWQuYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9Ki9cclxuXHJcbiAgICBwcml2YXRlIGdldENvbnRleHRJbnN0YW5jZShjb250ZXh0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2FkZWRDb250ZXh0cy5oYXMoY29udGV4dElkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkQ29udGV4dHMuZ2V0KGNvbnRleHRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRleHRUeXBlID0gV29ya2VyQ29udGV4dFJlZ2lzdHJ5LmdldENvbnRleHRDYWxsZXJCeUlkKGNvbnRleHRJZCk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dEluc3QgPSBuZXcgY29udGV4dFR5cGUodGhpcy5fcmVwbGF5KTtcclxuICAgICAgICB0aGlzLl9sb2FkZWRDb250ZXh0cy5zZXQoY29udGV4dElkLCBjb250ZXh0SW5zdCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHRJbnN0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0UHJvcGVydHlOYW1lKGNvbnRleHQ6IE9iamVjdCwgaWQ6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHByb3h5TWFwID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnd29rZXI6cHJveHlNZXRob2RzJywgY29udGV4dC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIHByb3h5TWFwW2lkXTtcclxuICAgIH1cclxuXHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/context/WorkerContext.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/index.js");
const WorkerContextRegistry_1 = __webpack_require__("../heroprotocol/dist/lib/replay/proxy/context/WorkerContextRegistry.js");
const Subject_1 = __webpack_require__("./node_modules/rxjs/Subject.js");
const sha1 = __webpack_require__("../heroprotocol/node_modules/sha1/sha1.js");
class WorkerContext {
    constructor(workerPath, initData, initTransfer = []) {
        this.workerPath = workerPath;
        this._initMessageQueue = [];
        this._workerMessages = new Subject_1.Subject();
        this._channelMessages = new Subject_1.Subject();
        this._callId = 0;
        this._resultCache = new Map();
        this._callPromises = {};
        this._pendingCachePromises = {};
        this._contextCallers = new Set();
        this._worker = new Worker(workerPath);
        this.initialize(initData, initTransfer);
    }
    get workerMessages() {
        return this._workerMessages.asObservable();
    }
    get channelMessages() {
        return this._channelMessages.asObservable();
    }
    initialize(initData, initTransfer) {
        this._worker.onmessage = (event) => {
            if (event.data === 'WORKER_INITIALIZED') {
                this._initialized = true;
                for (let i = 0; i < this._initMessageQueue.length; i++) {
                    const arg = this._initMessageQueue[i];
                    this.send(arg[0], arg[1]);
                }
            }
            else {
                this._workerMessages.next(event.data);
            }
        };
        const messageChannel = new MessageChannel();
        this._port = messageChannel.port1;
        this._port.onmessage = (event) => {
            if (!this.handleChannelMessage(event.data)) {
                this._channelMessages.next(event.data);
            }
        };
        const initCommand = {
            type: 'initialize',
            port: messageChannel.port2,
            data: initData
        };
        this._worker.postMessage(initCommand, [messageChannel.port2, ...initTransfer]);
    }
    handleChannelMessage(msg) {
        if (messages_1.isWorkerCallResultMessage(msg)) {
            this.handleWorkerCallResult(msg);
            return true;
        }
        return false;
    }
    computeCacheKey(...args) {
        const dataStr = JSON.stringify(args, (key, value) => {
            return value;
        });
        return sha1(dataStr);
    }
    hasCache(key) {
        return this._resultCache.has(key);
    }
    getCache(key) {
        return this._resultCache.get(key);
    }
    setCache(key, value) {
        this._resultCache.set(key, value);
    }
    handleWorkerCallResult(data) {
        const promise = this._callPromises[data.callId];
        delete this._callPromises[data.callId];
        if (promise.cacheKey) {
            delete this._pendingCachePromises[promise.cacheKey];
        }
        if (data.error) {
            promise.reject(data.result);
        }
        else {
            if (promise.cacheKey) {
                this.setCache(promise.cacheKey, data.result);
            }
            promise.resolve(data.result);
        }
    }
    send(data, transfer) {
        if (!this._initialized) {
            this._initMessageQueue.push([data, transfer]);
        }
        else {
            this._port.postMessage(data, transfer);
        }
    }
    call(data, cacheResult = true, transfer) {
        const callId = this._callId++;
        const cacheKey = cacheResult ? this.computeCacheKey(data) : undefined;
        if (cacheResult && this.hasCache(cacheKey)) {
            return new Promise((res) => {
                res(this.getCache(cacheKey));
            });
        }
        if (cacheResult && this._pendingCachePromises[cacheKey]) {
            return this._pendingCachePromises[cacheKey];
        }
        const promise = new Promise((resolve, reject) => {
            this._callPromises[callId] = {
                resolve,
                reject,
                cacheKey
            };
            this.send({
                type: 'worker-call',
                callId,
                data
            });
        });
        if (cacheResult) {
            this._pendingCachePromises[cacheKey] = promise;
        }
        return promise;
    }
    getProperty(context, propertyId, cacheResult) {
        const call = {
            type: 'get-property',
            context: WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerId(context),
            propertyId
        };
        return this.call(call, cacheResult);
    }
    callMethod(context, methodId, args, cacheResult, transfer) {
        const call = {
            type: 'call-method',
            context: WorkerContextRegistry_1.WorkerContextRegistry.getContextCallerId(context),
            methodId,
            args
        };
        return this.call(call, cacheResult, transfer);
    }
    addCallContext(context) {
        this._contextCallers.add(context);
    }
    removeCallContext(context) {
        this._contextCallers.delete(context);
    }
    tryDispose() {
        if (this._contextCallers.size > 0) {
            return false;
        }
        this.dispose();
        return true;
    }
    dispose() {
        if (this._worker) {
            this._worker.terminate();
            this._worker = undefined;
            this._initialized = false;
            this._port = undefined;
            this._initMessageQueue = undefined;
            this._callPromises = undefined;
            this._pendingCachePromises = undefined;
        }
    }
}
exports.WorkerContext = WorkerContext;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9jb250ZXh0L1dvcmtlckNvbnRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFHQSwwQ0FJcUI7QUFDckIsbUVBQWdFO0FBRWhFLDBDQUF1QztBQUd2Qyw2QkFBNkI7QUFFN0I7SUEyQkksWUFBMkIsVUFBa0IsRUFBRSxRQUFjLEVBQUUsZUFBc0IsRUFBRTtRQUE1RCxlQUFVLEdBQVYsVUFBVSxDQUFRO1FBcEJyQyxzQkFBaUIsR0FBc0IsRUFBRSxDQUFDO1FBQzFDLG9CQUFlLEdBQWlCLElBQUksaUJBQU8sRUFBRSxDQUFDO1FBQzlDLHFCQUFnQixHQUFpQixJQUFJLGlCQUFPLEVBQUUsQ0FBQztRQUUvQyxZQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ1osaUJBQVksR0FBcUIsSUFBSSxHQUFHLEVBQWUsQ0FBQztRQUN4RCxrQkFBYSxHQUErRSxFQUFFLENBQUM7UUFDL0YsMEJBQXFCLEdBQW9DLEVBQUUsQ0FBQztRQUc1RCxvQkFBZSxHQUE0QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBV3pELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQVhELElBQVcsY0FBYztRQUNyQixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQUVELElBQVcsZUFBZTtRQUN0QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBT08sVUFBVSxDQUFDLFFBQWEsRUFBRSxZQUFtQjtRQUNqRCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQy9CLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxvQkFBb0IsRUFBRTtnQkFDckMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7Z0JBQ3pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNwRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM3QjthQUNKO2lCQUFNO2dCQUNILElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6QztRQUNMLENBQUMsQ0FBQztRQUVGLE1BQU0sY0FBYyxHQUFHLElBQUksY0FBYyxFQUFFLENBQUM7UUFDNUMsSUFBSSxDQUFDLEtBQUssR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO1FBRWxDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzFDO1FBQ0wsQ0FBQyxDQUFDO1FBRUYsTUFBTSxXQUFXLEdBQXVCO1lBQ3BDLElBQUksRUFBRSxZQUFZO1lBQ2xCLElBQUksRUFBRSxjQUFjLENBQUMsS0FBSztZQUMxQixJQUFJLEVBQUUsUUFBUTtTQUNqQixDQUFDO1FBRUYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDbkYsQ0FBQztJQUVPLG9CQUFvQixDQUFDLEdBQVE7UUFDakMsSUFBSSxvQ0FBeUIsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFTyxlQUFlLENBQUMsR0FBRyxJQUFJO1FBQzNCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ2hELE9BQU8sS0FBSyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVPLFFBQVEsQ0FBQyxHQUFXO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVPLFFBQVEsQ0FBQyxHQUFXO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVPLFFBQVEsQ0FBQyxHQUFXLEVBQUUsS0FBVTtRQUNwQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVPLHNCQUFzQixDQUFDLElBQThCO1FBQ3pELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFdkMsSUFBSSxPQUFPLENBQUMsUUFBUSxFQUFFO1lBQ2xCLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN2RDtRQUVELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNaLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQy9CO2FBQU07WUFDSCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDaEQ7WUFDRCxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoQztJQUNMLENBQUM7SUFFTSxJQUFJLENBQUMsSUFBUyxFQUFFLFFBQWdCO1FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQzFDO0lBQ0wsQ0FBQztJQUVNLElBQUksQ0FBVSxJQUFTLEVBQUUsV0FBVyxHQUFHLElBQUksRUFBRSxRQUFnQjtRQUNoRSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDOUIsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFFdEUsSUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN4QyxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7Z0JBQ3ZCLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDakMsQ0FBQyxDQUFDLENBQUM7U0FDTjtRQUVELElBQUksV0FBVyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNyRCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMvQztRQUVELE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFVLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3JELElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUc7Z0JBQ3pCLE9BQU87Z0JBQ1AsTUFBTTtnQkFDTixRQUFRO2FBQ1gsQ0FBQztZQUNGLElBQUksQ0FBQyxJQUFJLENBQXFCO2dCQUMxQixJQUFJLEVBQUUsYUFBYTtnQkFDbkIsTUFBTTtnQkFDTixJQUFJO2FBQ1AsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLFdBQVcsRUFBRTtZQUNiLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxPQUFPLENBQUM7U0FDbEQ7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0lBRU0sV0FBVyxDQUFVLE9BQTJCLEVBQUUsVUFBa0IsRUFBRSxXQUFxQjtRQUM5RixNQUFNLElBQUksR0FBd0I7WUFDOUIsSUFBSSxFQUFFLGNBQWM7WUFDcEIsT0FBTyxFQUFFLDZDQUFxQixDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQztZQUMxRCxVQUFVO1NBQ2IsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUNNLFVBQVUsQ0FDYixPQUEyQixFQUFFLFFBQWdCLEVBQUUsSUFBWSxFQUFFLFdBQXFCLEVBQUUsUUFBZ0I7UUFFcEcsTUFBTSxJQUFJLEdBQXNCO1lBQzVCLElBQUksRUFBRSxhQUFhO1lBQ25CLE9BQU8sRUFBRSw2Q0FBcUIsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7WUFDMUQsUUFBUTtZQUNSLElBQUk7U0FDUCxDQUFDO1FBQ0YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVNLGNBQWMsQ0FBQyxPQUEyQjtRQUM3QyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBQ00saUJBQWlCLENBQUMsT0FBMkI7UUFDaEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVNLFVBQVU7UUFDYixJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtZQUMvQixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUNELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNmLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxPQUFPO1FBQ1YsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztZQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztZQUN2QixJQUFJLENBQUMsaUJBQWlCLEdBQUcsU0FBUyxDQUFDO1lBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO1lBQy9CLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxTQUFTLENBQUM7U0FDMUM7SUFDTCxDQUFDO0NBQ0o7QUFsTUQsc0NBa01DIiwiZmlsZSI6InJlcGxheS9wcm94eS9jb250ZXh0L1dvcmtlckNvbnRleHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuaW1wb3J0IHsgSVdvcmtlckNvbnRleHQgfSBmcm9tICcuL0lXb3JrZXJDb250ZXh0JztcclxuaW1wb3J0IHsgSVdvcmtlckNvbnRleHRIb3N0IH0gZnJvbSAnLi9JV29ya2VyQ29udGV4dEhvc3QnO1xyXG5pbXBvcnQge1xyXG4gICAgSUluaXRpYWxpemVDb21tYW5kLCBJV29ya2VyQ2FsbE1lc3NhZ2UsXHJcbiAgICBpc1dvcmtlckNhbGxSZXN1bHRNZXNzYWdlLCBJV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2UsXHJcbiAgICBJV29ya2VyUHJvcGVydHlDYWxsLCBJV29ya2VyTWV0aG9kQ2FsbFxyXG59IGZyb20gJy4uL21lc3NhZ2VzJztcclxuaW1wb3J0IHsgV29ya2VyQ29udGV4dFJlZ2lzdHJ5IH0gZnJvbSAnLi9Xb3JrZXJDb250ZXh0UmVnaXN0cnknO1xyXG5cclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5cclxuaW1wb3J0ICogYXMgc2hhMSBmcm9tICdzaGExJztcclxuXHJcbmV4cG9ydCBjbGFzcyBXb3JrZXJDb250ZXh0IGltcGxlbWVudHMgSVdvcmtlckNvbnRleHQge1xyXG5cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF93b3JrZXI6IFdvcmtlcjtcclxuICAgIHByaXZhdGUgX3BvcnQ6IE1lc3NhZ2VQb3J0O1xyXG4gICAgcHJpdmF0ZSBfaW5pdE1lc3NhZ2VRdWV1ZTogQXJyYXk8QXJyYXk8YW55Pj4gPSBbXTtcclxuICAgIHByaXZhdGUgX3dvcmtlck1lc3NhZ2VzOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xyXG4gICAgcHJpdmF0ZSBfY2hhbm5lbE1lc3NhZ2VzOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xyXG5cclxuICAgIHByaXZhdGUgX2NhbGxJZCA9IDA7XHJcbiAgICBwcml2YXRlIF9yZXN1bHRDYWNoZTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcbiAgICBwcml2YXRlIF9jYWxsUHJvbWlzZXM6IHsgW19tZXNzYWdlSWQ6IG51bWJlcl06IHsgcmVzb2x2ZTogYW55LCByZWplY3Q6IGFueSwgY2FjaGVLZXk/OiBzdHJpbmcgfSB9ID0ge307XHJcbiAgICBwcml2YXRlIF9wZW5kaW5nQ2FjaGVQcm9taXNlczogeyBba2V5OiBzdHJpbmddOiBQcm9taXNlPGFueT4gfSA9IHt9O1xyXG5cclxuXHJcbiAgICBwcml2YXRlIF9jb250ZXh0Q2FsbGVyczogU2V0PElXb3JrZXJDb250ZXh0SG9zdD4gPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgcHVibGljIGdldCB3b3JrZXJNZXNzYWdlcygpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JrZXJNZXNzYWdlcy5hc09ic2VydmFibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGNoYW5uZWxNZXNzYWdlcygpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsTWVzc2FnZXMuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgd29ya2VyUGF0aDogc3RyaW5nLCBpbml0RGF0YT86IGFueSwgaW5pdFRyYW5zZmVyOiBhbnlbXSA9IFtdKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJQYXRoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoaW5pdERhdGEsIGluaXRUcmFuc2Zlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplKGluaXREYXRhOiBhbnksIGluaXRUcmFuc2ZlcjogYW55W10pIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhID09PSAnV09SS0VSX0lOSVRJQUxJWkVEJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbml0TWVzc2FnZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnID0gdGhpcy5faW5pdE1lc3NhZ2VRdWV1ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoYXJnWzBdLCBhcmdbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyTWVzc2FnZXMubmV4dChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XHJcbiAgICAgICAgdGhpcy5fcG9ydCA9IG1lc3NhZ2VDaGFubmVsLnBvcnQxO1xyXG5cclxuICAgICAgICB0aGlzLl9wb3J0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFuZGxlQ2hhbm5lbE1lc3NhZ2UoZXZlbnQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5uZWxNZXNzYWdlcy5uZXh0KGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5pdENvbW1hbmQ6IElJbml0aWFsaXplQ29tbWFuZCA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2luaXRpYWxpemUnLFxyXG4gICAgICAgICAgICBwb3J0OiBtZXNzYWdlQ2hhbm5lbC5wb3J0MixcclxuICAgICAgICAgICAgZGF0YTogaW5pdERhdGFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoaW5pdENvbW1hbmQsIFttZXNzYWdlQ2hhbm5lbC5wb3J0MiwgLi4uaW5pdFRyYW5zZmVyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVDaGFubmVsTWVzc2FnZShtc2c6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmIChpc1dvcmtlckNhbGxSZXN1bHRNZXNzYWdlKG1zZykpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVXb3JrZXJDYWxsUmVzdWx0KG1zZyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb21wdXRlQ2FjaGVLZXkoLi4uYXJncyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9IEpTT04uc3RyaW5naWZ5KGFyZ3MsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2hhMShkYXRhU3RyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhc0NhY2hlKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdENhY2hlLmhhcyhrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0Q2FjaGUoa2V5OiBzdHJpbmcpOiBhbnkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRDYWNoZS5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldENhY2hlKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0Q2FjaGUuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlV29ya2VyQ2FsbFJlc3VsdChkYXRhOiBJV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fY2FsbFByb21pc2VzW2RhdGEuY2FsbElkXTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fY2FsbFByb21pc2VzW2RhdGEuY2FsbElkXTtcclxuXHJcbiAgICAgICAgaWYgKHByb21pc2UuY2FjaGVLZXkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdDYWNoZVByb21pc2VzW3Byb21pc2UuY2FjaGVLZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZGF0YS5yZXN1bHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9taXNlLmNhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldENhY2hlKHByb21pc2UuY2FjaGVLZXksIGRhdGEucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoZGF0YS5yZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VuZChkYXRhOiBhbnksIHRyYW5zZmVyPzogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRNZXNzYWdlUXVldWUucHVzaChbZGF0YSwgdHJhbnNmZXJdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3J0LnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNhbGw8VFJlc3VsdD4oZGF0YTogYW55LCBjYWNoZVJlc3VsdCA9IHRydWUsIHRyYW5zZmVyPzogYW55W10pOiBQcm9taXNlPFRSZXN1bHQ+IHtcclxuICAgICAgICBjb25zdCBjYWxsSWQgPSB0aGlzLl9jYWxsSWQrKztcclxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlUmVzdWx0ID8gdGhpcy5jb21wdXRlQ2FjaGVLZXkoZGF0YSkgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmIChjYWNoZVJlc3VsdCAmJiB0aGlzLmhhc0NhY2hlKGNhY2hlS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzKHRoaXMuZ2V0Q2FjaGUoY2FjaGVLZXkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FjaGVSZXN1bHQgJiYgdGhpcy5fcGVuZGluZ0NhY2hlUHJvbWlzZXNbY2FjaGVLZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ2FjaGVQcm9taXNlc1tjYWNoZUtleV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VFJlc3VsdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsUHJvbWlzZXNbY2FsbElkXSA9IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICByZWplY3QsXHJcbiAgICAgICAgICAgICAgICBjYWNoZUtleVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNlbmQoPElXb3JrZXJDYWxsTWVzc2FnZT57XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyLWNhbGwnLFxyXG4gICAgICAgICAgICAgICAgY2FsbElkLFxyXG4gICAgICAgICAgICAgICAgZGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY2FjaGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NhY2hlUHJvbWlzZXNbY2FjaGVLZXldID0gcHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFByb3BlcnR5PFRSZXN1bHQ+KGNvbnRleHQ6IElXb3JrZXJDb250ZXh0SG9zdCwgcHJvcGVydHlJZDogbnVtYmVyLCBjYWNoZVJlc3VsdD86IGJvb2xlYW4pOiBQcm9taXNlPFRSZXN1bHQ+IHtcclxuICAgICAgICBjb25zdCBjYWxsOiBJV29ya2VyUHJvcGVydHlDYWxsID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnZ2V0LXByb3BlcnR5JyxcclxuICAgICAgICAgICAgY29udGV4dDogV29ya2VyQ29udGV4dFJlZ2lzdHJ5LmdldENvbnRleHRDYWxsZXJJZChjb250ZXh0KSxcclxuICAgICAgICAgICAgcHJvcGVydHlJZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsLCBjYWNoZVJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgY2FsbE1ldGhvZDxUUmVzdWx0PihcclxuICAgICAgICBjb250ZXh0OiBJV29ya2VyQ29udGV4dEhvc3QsIG1ldGhvZElkOiBudW1iZXIsIGFyZ3M/OiBhbnlbXSwgY2FjaGVSZXN1bHQ/OiBib29sZWFuLCB0cmFuc2Zlcj86IGFueVtdXHJcbiAgICApOiBQcm9taXNlPFRSZXN1bHQ+IHtcclxuICAgICAgICBjb25zdCBjYWxsOiBJV29ya2VyTWV0aG9kQ2FsbCA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2NhbGwtbWV0aG9kJyxcclxuICAgICAgICAgICAgY29udGV4dDogV29ya2VyQ29udGV4dFJlZ2lzdHJ5LmdldENvbnRleHRDYWxsZXJJZChjb250ZXh0KSxcclxuICAgICAgICAgICAgbWV0aG9kSWQsXHJcbiAgICAgICAgICAgIGFyZ3NcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbCwgY2FjaGVSZXN1bHQsIHRyYW5zZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkQ2FsbENvbnRleHQoY29udGV4dDogSVdvcmtlckNvbnRleHRIb3N0KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dENhbGxlcnMuYWRkKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHJlbW92ZUNhbGxDb250ZXh0KGNvbnRleHQ6IElXb3JrZXJDb250ZXh0SG9zdCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRDYWxsZXJzLmRlbGV0ZShjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdHJ5RGlzcG9zZSgpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5fY29udGV4dENhbGxlcnMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0TWVzc2FnZVF1ZXVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsUHJvbWlzZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWNoZVByb21pc2VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/context/WorkerContextRegistry.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__("../heroprotocol/dist/lib/types/index.js");
__webpack_require__("../heroprotocol/node_modules/reflect-metadata/Reflect.js");
class WorkerContextRegistry {
    static registerContextCaller(type) {
        const id = Reflect.getOwnMetadata('workerContext:typeId', type);
        if (WorkerContextRegistry._contextCallers.has(id)) {
            const regType = WorkerContextRegistry._contextCallers.get(id);
            if (regType !== type) {
                throw new Error('Duplicate TypeId');
            }
        }
        else {
            WorkerContextRegistry._contextCallers.set(id, type);
        }
    }
    static getContextCallerId(type) {
        if (!types_1.isType(type)) {
            type = type.constructor;
        }
        const id = Reflect.getOwnMetadata('workerContext:typeId', type);
        if (WorkerContextRegistry._contextCallers.has(id)) {
            return id;
        }
    }
    static getContextCallerById(id) {
        return WorkerContextRegistry._contextCallers.get(id);
    }
}
WorkerContextRegistry._contextCallers = new Map();
exports.WorkerContextRegistry = WorkerContextRegistry;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9jb250ZXh0L1dvcmtlckNvbnRleHRSZWdpc3RyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBDQUE4QztBQUc5Qyw0QkFBMEI7QUFFMUI7SUFJVyxNQUFNLENBQUMscUJBQXFCLENBQUMsSUFBOEI7UUFDOUQsTUFBTSxFQUFFLEdBQVcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN4RSxJQUFJLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDL0MsTUFBTSxPQUFPLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM5RCxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7Z0JBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUN2QztTQUNKO2FBQU07WUFDSCxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN2RDtJQUNMLENBQUM7SUFFTSxNQUFNLENBQUMsa0JBQWtCLENBQUMsSUFBbUQ7UUFDaEYsSUFBSSxDQUFDLGNBQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNmLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1NBQzNCO1FBQ0QsTUFBTSxFQUFFLEdBQVcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN4RSxJQUFJLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDL0MsT0FBTyxFQUFFLENBQUM7U0FDYjtJQUNMLENBQUM7SUFFTSxNQUFNLENBQUMsb0JBQW9CLENBQUMsRUFBVTtRQUN6QyxPQUFPLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQzs7QUEzQmMscUNBQWUsR0FBMEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUR0RixzREE4QkMiLCJmaWxlIjoicmVwbGF5L3Byb3h5L2NvbnRleHQvV29ya2VyQ29udGV4dFJlZ2lzdHJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZSwgaXNUeXBlIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgSVdvcmtlckNhbGxDb250ZXh0IH0gZnJvbSAnLi9JV29ya2VyQ2FsbENvbnRleHQnO1xyXG5pbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFdvcmtlckNvbnRleHRSZWdpc3RyeSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfY29udGV4dENhbGxlcnM6IE1hcDxzdHJpbmcsIFR5cGU8SVdvcmtlckNhbGxDb250ZXh0Pj4gPSBuZXcgTWFwKCk7XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJDb250ZXh0Q2FsbGVyKHR5cGU6IFR5cGU8SVdvcmtlckNhbGxDb250ZXh0Pik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGlkOiBzdHJpbmcgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKCd3b3JrZXJDb250ZXh0OnR5cGVJZCcsIHR5cGUpO1xyXG4gICAgICAgIGlmIChXb3JrZXJDb250ZXh0UmVnaXN0cnkuX2NvbnRleHRDYWxsZXJzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVnVHlwZSA9IFdvcmtlckNvbnRleHRSZWdpc3RyeS5fY29udGV4dENhbGxlcnMuZ2V0KGlkKTtcclxuICAgICAgICAgICAgaWYgKHJlZ1R5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIFR5cGVJZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgV29ya2VyQ29udGV4dFJlZ2lzdHJ5Ll9jb250ZXh0Q2FsbGVycy5zZXQoaWQsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvbnRleHRDYWxsZXJJZCh0eXBlOiBJV29ya2VyQ2FsbENvbnRleHQgfCBUeXBlPElXb3JrZXJDYWxsQ29udGV4dD4pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICghaXNUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZDogc3RyaW5nID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnd29ya2VyQ29udGV4dDp0eXBlSWQnLCB0eXBlKTtcclxuICAgICAgICBpZiAoV29ya2VyQ29udGV4dFJlZ2lzdHJ5Ll9jb250ZXh0Q2FsbGVycy5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb250ZXh0Q2FsbGVyQnlJZChpZDogc3RyaW5nKTogVHlwZTxJV29ya2VyQ2FsbENvbnRleHQ+IHtcclxuICAgICAgICByZXR1cm4gV29ya2VyQ29udGV4dFJlZ2lzdHJ5Ll9jb250ZXh0Q2FsbGVycy5nZXQoaWQpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/index.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/ReplayContextCaller.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/ReplayWorker.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdDQUEyQjtBQUMzQiwyQ0FBc0M7QUFDdEMsb0NBQStCIiwiZmlsZSI6InJlcGxheS9wcm94eS9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vbWVzc2FnZXMnO1xyXG5leHBvcnQgKiBmcm9tICcuL1JlcGxheUNvbnRleHRDYWxsZXInO1xyXG5leHBvcnQgKiBmcm9tICcuL1JlcGxheVdvcmtlcic7XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/messages/call.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerCallMessage(obj) {
    return !!obj && obj.type === 'worker-call' && typeof obj.callId === 'number' && 'data' in obj;
}
exports.isWorkerCallMessage = isWorkerCallMessage;
function isWorkerCallResultMessage(obj) {
    return !!obj && obj.type === 'worker-call-result' && typeof obj.callId === 'number';
}
exports.isWorkerCallResultMessage = isWorkerCallResultMessage;
function isWorkerPropertyCall(obj) {
    return !!obj && obj.type === 'get-property' && typeof obj.context === 'string' && typeof obj.propertyId === 'number';
}
exports.isWorkerPropertyCall = isWorkerPropertyCall;
function isWorkerMethodCall(obj) {
    return !!obj && obj.type === 'call-method' && typeof obj.context === 'string' && typeof obj.methodId === 'number';
}
exports.isWorkerMethodCall = isWorkerMethodCall;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9tZXNzYWdlcy9jYWxsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBTUEsNkJBQW9DLEdBQVE7SUFDeEMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssYUFBYSxJQUFJLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLElBQUksTUFBTSxJQUFJLEdBQUcsQ0FBQztBQUNsRyxDQUFDO0FBRkQsa0RBRUM7QUFVRCxtQ0FBMEMsR0FBUTtJQUM5QyxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxvQkFBb0IsSUFBSSxPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQ3hGLENBQUM7QUFGRCw4REFFQztBQVNELDhCQUFxQyxHQUFRO0lBQ3pDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLGNBQWMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxPQUFPLEtBQUssUUFBUSxJQUFJLE9BQU8sR0FBRyxDQUFDLFVBQVUsS0FBSyxRQUFRLENBQUM7QUFDekgsQ0FBQztBQUZELG9EQUVDO0FBU0QsNEJBQW1DLEdBQVE7SUFDdkMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssYUFBYSxJQUFJLE9BQU8sR0FBRyxDQUFDLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxHQUFHLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUN0SCxDQUFDO0FBRkQsZ0RBRUMiLCJmaWxlIjoicmVwbGF5L3Byb3h5L21lc3NhZ2VzL2NhbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIElXb3JrZXJDYWxsTWVzc2FnZSB7XHJcbiAgICB0eXBlOiAnd29ya2VyLWNhbGwnO1xyXG4gICAgY2FsbElkOiBudW1iZXI7XHJcbiAgICBkYXRhOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dvcmtlckNhbGxNZXNzYWdlKG9iajogYW55KTogb2JqIGlzIElXb3JrZXJDYWxsTWVzc2FnZSB7XHJcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLnR5cGUgPT09ICd3b3JrZXItY2FsbCcgJiYgdHlwZW9mIG9iai5jYWxsSWQgPT09ICdudW1iZXInICYmICdkYXRhJyBpbiBvYmo7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElXb3JrZXJDYWxsUmVzdWx0TWVzc2FnZSB7XHJcbiAgICB0eXBlOiAnd29ya2VyLWNhbGwtcmVzdWx0JztcclxuICAgIGNhbGxJZDogbnVtYmVyO1xyXG4gICAgZXJyb3I/OiBib29sZWFuO1xyXG4gICAgcmVzdWx0PzogYW55O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNXb3JrZXJDYWxsUmVzdWx0TWVzc2FnZShvYmo6IGFueSk6IG9iaiBpcyBJV29ya2VyQ2FsbFJlc3VsdE1lc3NhZ2Uge1xyXG4gICAgcmV0dXJuICEhb2JqICYmIG9iai50eXBlID09PSAnd29ya2VyLWNhbGwtcmVzdWx0JyAmJiB0eXBlb2Ygb2JqLmNhbGxJZCA9PT0gJ251bWJlcic7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElXb3JrZXJQcm9wZXJ0eUNhbGwge1xyXG4gICAgdHlwZTogJ2dldC1wcm9wZXJ0eSc7XHJcbiAgICBjb250ZXh0OiBzdHJpbmc7XHJcbiAgICBwcm9wZXJ0eUlkOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dvcmtlclByb3BlcnR5Q2FsbChvYmo6IGFueSk6IG9iaiBpcyBJV29ya2VyUHJvcGVydHlDYWxsIHtcclxuICAgIHJldHVybiAhIW9iaiAmJiBvYmoudHlwZSA9PT0gJ2dldC1wcm9wZXJ0eScgJiYgdHlwZW9mIG9iai5jb250ZXh0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb2JqLnByb3BlcnR5SWQgPT09ICdudW1iZXInO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElXb3JrZXJNZXRob2RDYWxsIHtcclxuICAgIHR5cGU6ICdjYWxsLW1ldGhvZCc7XHJcbiAgICBjb250ZXh0OiBzdHJpbmc7XHJcbiAgICBtZXRob2RJZDogbnVtYmVyO1xyXG4gICAgYXJncz86IGFueVtdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNXb3JrZXJNZXRob2RDYWxsKG9iajogYW55KTogb2JqIGlzIElXb3JrZXJNZXRob2RDYWxsIHtcclxuICAgIHJldHVybiAhIW9iaiAmJiBvYmoudHlwZSA9PT0gJ2NhbGwtbWV0aG9kJyAmJiB0eXBlb2Ygb2JqLmNvbnRleHQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvYmoubWV0aG9kSWQgPT09ICdudW1iZXInO1xyXG59XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/messages/cmds.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isWorkerCommand(obj) {
    return 'type' in obj && 'messageId' in obj
        && typeof obj.messageId === 'number'
        && typeof obj.context === 'string' && typeof obj.id === 'number';
}
exports.isWorkerCommand = isWorkerCommand;
function isWorkerGetPropertyCommand(obj) {
    return isWorkerCommand(obj) && obj.type === 'property';
}
exports.isWorkerGetPropertyCommand = isWorkerGetPropertyCommand;
function isWorkerCallMethodCommand(obj) {
    return isWorkerCommand(obj) && obj.type === 'method';
}
exports.isWorkerCallMethodCommand = isWorkerCallMethodCommand;
function isWorkerCommandResult(obj) {
    return obj.type === 'command-result' && typeof obj.messageId === 'number';
}
exports.isWorkerCommandResult = isWorkerCommandResult;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9tZXNzYWdlcy9jbWRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBT0EseUJBQWdDLEdBQVE7SUFDcEMsT0FBTyxNQUFNLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxHQUFHO1dBQ25DLE9BQU8sR0FBRyxDQUFDLFNBQVMsS0FBSyxRQUFRO1dBQ2pDLE9BQU8sR0FBRyxDQUFDLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQztBQUN6RSxDQUFDO0FBSkQsMENBSUM7QUFPRCxvQ0FBMkMsR0FBUTtJQUMvQyxPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQztBQUMzRCxDQUFDO0FBRkQsZ0VBRUM7QUFRRCxtQ0FBMEMsR0FBUTtJQUM5QyxPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztBQUN6RCxDQUFDO0FBRkQsOERBRUM7QUFVRCwrQkFBc0MsR0FBUTtJQUMxQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLElBQUksT0FBTyxHQUFHLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQztBQUM5RSxDQUFDO0FBRkQsc0RBRUMiLCJmaWxlIjoicmVwbGF5L3Byb3h5L21lc3NhZ2VzL2NtZHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIElXb3JrZXJDb21tYW5kIHtcclxuICAgIHR5cGU6ICdtZXRob2QnIHwgJ3Byb3BlcnR5JztcclxuICAgIG1lc3NhZ2VJZDogbnVtYmVyO1xyXG4gICAgY29udGV4dDogc3RyaW5nO1xyXG4gICAgaWQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV29ya2VyQ29tbWFuZChvYmo6IGFueSk6IG9iaiBpcyBJV29ya2VyQ29tbWFuZCB7XHJcbiAgICByZXR1cm4gJ3R5cGUnIGluIG9iaiAmJiAnbWVzc2FnZUlkJyBpbiBvYmpcclxuICAgICAgICAmJiB0eXBlb2Ygb2JqLm1lc3NhZ2VJZCA9PT0gJ251bWJlcidcclxuICAgICAgICAmJiB0eXBlb2Ygb2JqLmNvbnRleHQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvYmouaWQgPT09ICdudW1iZXInO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJV29ya2VyR2V0UHJvcGVydHlDb21tYW5kIGV4dGVuZHMgSVdvcmtlckNvbW1hbmQge1xyXG4gICAgdHlwZTogJ3Byb3BlcnR5JztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV29ya2VyR2V0UHJvcGVydHlDb21tYW5kKG9iajogYW55KTogb2JqIGlzIElXb3JrZXJHZXRQcm9wZXJ0eUNvbW1hbmQge1xyXG4gICAgcmV0dXJuIGlzV29ya2VyQ29tbWFuZChvYmopICYmIG9iai50eXBlID09PSAncHJvcGVydHknO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJV29ya2VyQ2FsbE1ldGhvZENvbW1hbmQgZXh0ZW5kcyBJV29ya2VyQ29tbWFuZCB7XHJcbiAgICB0eXBlOiAnbWV0aG9kJztcclxuICAgIGFyZ3M6IGFueVtdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNXb3JrZXJDYWxsTWV0aG9kQ29tbWFuZChvYmo6IGFueSk6IG9iaiBpcyBJV29ya2VyQ2FsbE1ldGhvZENvbW1hbmQge1xyXG4gICAgcmV0dXJuIGlzV29ya2VyQ29tbWFuZChvYmopICYmIG9iai50eXBlID09PSAnbWV0aG9kJztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVdvcmtlckNvbW1hbmRSZXN1bHQge1xyXG4gICAgdHlwZTogJ2NvbW1hbmQtcmVzdWx0JztcclxuICAgIG1lc3NhZ2VJZDogbnVtYmVyO1xyXG4gICAgZXJyb3I/OiB0cnVlO1xyXG4gICAgcmVzdWx0OiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dvcmtlckNvbW1hbmRSZXN1bHQob2JqOiBhbnkpOiBvYmogaXMgSVdvcmtlckNvbW1hbmRSZXN1bHQge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnY29tbWFuZC1yZXN1bHQnICYmIHR5cGVvZiBvYmoubWVzc2FnZUlkID09PSAnbnVtYmVyJztcclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/messages/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/init.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/protocol.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/cmds.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/status.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/replay/proxy/messages/call.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9tZXNzYWdlcy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRCQUF1QjtBQUN2QixnQ0FBMkI7QUFDM0IsNEJBQXVCO0FBQ3ZCLDhCQUF5QjtBQUN6Qiw0QkFBdUIiLCJmaWxlIjoicmVwbGF5L3Byb3h5L21lc3NhZ2VzL2luZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9pbml0JztcclxuZXhwb3J0ICogZnJvbSAnLi9wcm90b2NvbCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY21kcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vc3RhdHVzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jYWxsJztcclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/messages/init.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isInitializeCommand(obj) {
    return obj.type === 'initialize' && obj.data instanceof ArrayBuffer && obj.port instanceof MessagePort;
}
exports.isInitializeCommand = isInitializeCommand;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9tZXNzYWdlcy9pbml0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBTUEsNkJBQW9DLEdBQVE7SUFDeEMsT0FBTyxHQUFHLENBQUMsSUFBSSxLQUFLLFlBQVksSUFBSSxHQUFHLENBQUMsSUFBSSxZQUFZLFdBQVcsSUFBSSxHQUFHLENBQUMsSUFBSSxZQUFZLFdBQVcsQ0FBQztBQUMzRyxDQUFDO0FBRkQsa0RBRUMiLCJmaWxlIjoicmVwbGF5L3Byb3h5L21lc3NhZ2VzL2luaXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIElJbml0aWFsaXplQ29tbWFuZCB7XHJcbiAgICB0eXBlOiAnaW5pdGlhbGl6ZSc7XHJcbiAgICBwb3J0OiBNZXNzYWdlUG9ydDtcclxuICAgIGRhdGE6IEFycmF5QnVmZmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNJbml0aWFsaXplQ29tbWFuZChvYmo6IGFueSk6IG9iaiBpcyBJSW5pdGlhbGl6ZUNvbW1hbmQge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnaW5pdGlhbGl6ZScgJiYgb2JqLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJiBvYmoucG9ydCBpbnN0YW5jZW9mIE1lc3NhZ2VQb3J0O1xyXG59XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/messages/protocol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isLoadProtocolMessage(obj) {
    return obj.type === 'load-protocol';
}
exports.isLoadProtocolMessage = isLoadProtocolMessage;
function isLoadProtocolResultMessage(obj) {
    return obj.type === 'load-protocol-result';
}
exports.isLoadProtocolResultMessage = isLoadProtocolResultMessage;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9tZXNzYWdlcy9wcm90b2NvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQU1BLCtCQUFzQyxHQUFRO0lBQzFDLE9BQU8sR0FBRyxDQUFDLElBQUksS0FBSyxlQUFlLENBQUM7QUFDeEMsQ0FBQztBQUZELHNEQUVDO0FBU0QscUNBQTRDLEdBQVE7SUFDaEQsT0FBTyxHQUFHLENBQUMsSUFBSSxLQUFLLHNCQUFzQixDQUFDO0FBQy9DLENBQUM7QUFGRCxrRUFFQyIsImZpbGUiOiJyZXBsYXkvcHJveHkvbWVzc2FnZXMvcHJvdG9jb2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuZXhwb3J0IGludGVyZmFjZSBJTG9hZFByb3RvY29sTWVzc2FnZSB7XHJcbiAgICB0eXBlOiAnbG9hZC1wcm90b2NvbCc7XHJcbiAgICB2ZXJzaW9uOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvYWRQcm90b2NvbE1lc3NhZ2Uob2JqOiBhbnkpOiBvYmogaXMgSUxvYWRQcm90b2NvbE1lc3NhZ2Uge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnbG9hZC1wcm90b2NvbCc7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElMb2FkUHJvdG9jb2xSZXN1bHRNZXNzYWdlIHtcclxuICAgIHR5cGU6ICdsb2FkLXByb3RvY29sLXJlc3VsdCc7XHJcbiAgICB2ZXJzaW9uOiBudW1iZXI7XHJcbiAgICBjb2RlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvYWRQcm90b2NvbFJlc3VsdE1lc3NhZ2Uob2JqOiBhbnkpOiBvYmogaXMgSUxvYWRQcm90b2NvbFJlc3VsdE1lc3NhZ2Uge1xyXG4gICAgcmV0dXJuIG9iai50eXBlID09PSAnbG9hZC1wcm90b2NvbC1yZXN1bHQnO1xyXG59XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/replay/proxy/messages/status.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isReplayStatusMessage(obj) {
    return obj.type === 'replay-status' && typeof obj.status === 'string';
}
exports.isReplayStatusMessage = isReplayStatusMessage;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlcGxheS9wcm94eS9tZXNzYWdlcy9zdGF0dXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFPQSwrQkFBc0MsR0FBUTtJQUMxQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssZUFBZSxJQUFJLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUM7QUFDMUUsQ0FBQztBQUZELHNEQUVDIiwiZmlsZSI6InJlcGxheS9wcm94eS9tZXNzYWdlcy9zdGF0dXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIElSZXBsYXlTdGF0dXNNZXNzYWdlIHtcclxuICAgIHR5cGU6ICdyZXBsYXktc3RhdHVzJztcclxuICAgIHN0YXR1czogc3RyaW5nO1xyXG4gICAgY3VycmVudD86IG51bWJlcjtcclxuICAgIHRvdGFsPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNSZXBsYXlTdGF0dXNNZXNzYWdlKG9iajogYW55KTogb2JqIGlzIElSZXBsYXlTdGF0dXNNZXNzYWdlIHtcclxuICAgIHJldHVybiBvYmoudHlwZSA9PT0gJ3JlcGxheS1zdGF0dXMnICYmIHR5cGVvZiBvYmouc3RhdHVzID09PSAnc3RyaW5nJztcclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/types/events/FilteredEvents.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FilteredEvents = [
    'NNet.Game.SLoadingProgressMessage',
    'NNet.Replay.Tracker.SPlayerStatsEvent',
    'NNet.Replay.Tracker.SUnitPositionsEvent',
    'NNet.Game.SUserFinishedLoadingSyncEvent',
    'NNet.Game.STriggerSoundLengthSyncEvent',
    'NNet.Game.STriggerMouseMovedEvent',
    'NNet.Game.SCameraUpdateEvent',
    'NNet.Game.STriggerSoundOffsetEvent',
    'NNet.Game.SSelectionDeltaEvent',
    'NNet.Game.SControlGroupUpdateEvent',
    'NNet.Game.SCommandManagerStateEvent',
    'NNet.Game.SCmdUpdateTargetPointEvent',
    'NNet.Game.SCmdEvent',
    'NNet.Game.SCmdUpdateTargetUnitEvent',
    'NNet.Game.STriggerSoundtrackDoneEvent',
    'NNet.Game.STriggerDialogControlEvent',
    'NNet.Game.STriggerTransmissionCompleteEvent',
    'NNet.Game.STriggerTransmissionOffsetEvent',
    'NNet.Game.STriggerCutsceneEndSceneFiredEvent',
    'NNet.Game.STriggerTargetModeUpdateEvent',
    'NNet.Game.SCommandManagerResetEvent',
    // 'NNet.Game.SHeroTalentTreeSelectedEvent',
    'NNet.Game.STriggerKeyPressedEvent',
    'NNet.Game.SUnitClickEvent',
    //'NNet.Game.SUserOptionsEvent',
    // tmp
    'NNet.Game.STriggerPingEvent',
];

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL2V2ZW50cy9GaWx0ZXJlZEV2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFhLFFBQUEsY0FBYyxHQUFhO0lBQ3BDLG1DQUFtQztJQUNuQyx1Q0FBdUM7SUFDdkMseUNBQXlDO0lBRXpDLHlDQUF5QztJQUN6Qyx3Q0FBd0M7SUFDeEMsbUNBQW1DO0lBQ25DLDhCQUE4QjtJQUM5QixvQ0FBb0M7SUFDcEMsZ0NBQWdDO0lBQ2hDLG9DQUFvQztJQUNwQyxxQ0FBcUM7SUFDckMsc0NBQXNDO0lBQ3RDLHFCQUFxQjtJQUNyQixxQ0FBcUM7SUFDckMsdUNBQXVDO0lBQ3ZDLHNDQUFzQztJQUN0Qyw2Q0FBNkM7SUFDN0MsMkNBQTJDO0lBQzNDLDhDQUE4QztJQUM5Qyx5Q0FBeUM7SUFDekMscUNBQXFDO0lBQ3RDLDRDQUE0QztJQUM1QyxtQ0FBbUM7SUFDbkMsMkJBQTJCO0lBQzFCLGdDQUFnQztJQUVoQyxNQUFNO0lBQ04sNkJBQTZCO0NBV2hDLENBQUMiLCJmaWxlIjoidHlwZXMvZXZlbnRzL0ZpbHRlcmVkRXZlbnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEZpbHRlcmVkRXZlbnRzOiBzdHJpbmdbXSA9IFtcclxuICAgICdOTmV0LkdhbWUuU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2UnLFxyXG4gICAgJ05OZXQuUmVwbGF5LlRyYWNrZXIuU1BsYXllclN0YXRzRXZlbnQnLFxyXG4gICAgJ05OZXQuUmVwbGF5LlRyYWNrZXIuU1VuaXRQb3NpdGlvbnNFdmVudCcsXHJcblxyXG4gICAgJ05OZXQuR2FtZS5TVXNlckZpbmlzaGVkTG9hZGluZ1N5bmNFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyU291bmRMZW5ndGhTeW5jRXZlbnQnLFxyXG4gICAgJ05OZXQuR2FtZS5TVHJpZ2dlck1vdXNlTW92ZWRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNDYW1lcmFVcGRhdGVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyU291bmRPZmZzZXRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNTZWxlY3Rpb25EZWx0YUV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NvbnRyb2xHcm91cFVwZGF0ZUV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NvbW1hbmRNYW5hZ2VyU3RhdGVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNDbWRVcGRhdGVUYXJnZXRQb2ludEV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NtZEV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU0NtZFVwZGF0ZVRhcmdldFVuaXRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyU291bmR0cmFja0RvbmVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyRGlhbG9nQ29udHJvbEV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU1RyaWdnZXJUcmFuc21pc3Npb25Db21wbGV0ZUV2ZW50JyxcclxuICAgICdOTmV0LkdhbWUuU1RyaWdnZXJUcmFuc21pc3Npb25PZmZzZXRFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNUcmlnZ2VyQ3V0c2NlbmVFbmRTY2VuZUZpcmVkRXZlbnQnLFxyXG4gICAgJ05OZXQuR2FtZS5TVHJpZ2dlclRhcmdldE1vZGVVcGRhdGVFdmVudCcsXHJcbiAgICAnTk5ldC5HYW1lLlNDb21tYW5kTWFuYWdlclJlc2V0RXZlbnQnLFxyXG4gICAvLyAnTk5ldC5HYW1lLlNIZXJvVGFsZW50VHJlZVNlbGVjdGVkRXZlbnQnLFxyXG4gICAnTk5ldC5HYW1lLlNUcmlnZ2VyS2V5UHJlc3NlZEV2ZW50JyxcclxuICAgJ05OZXQuR2FtZS5TVW5pdENsaWNrRXZlbnQnLFxyXG4gICAgLy8nTk5ldC5HYW1lLlNVc2VyT3B0aW9uc0V2ZW50JyxcclxuXHJcbiAgICAvLyB0bXBcclxuICAgICdOTmV0LkdhbWUuU1RyaWdnZXJQaW5nRXZlbnQnLFxyXG4gICAvLyAnTk5ldC5SZXBsYXkuVHJhY2tlci5TVW5pdEJvcm5FdmVudCcsXHJcbiAgIC8vICdOTmV0LlJlcGxheS5UcmFja2VyLlNVbml0RGllZEV2ZW50JyxcclxuICAgLy8gJ05OZXQuUmVwbGF5LlRyYWNrZXIuU1VuaXRPd25lckNoYW5nZUV2ZW50JyxcclxuICAgLy8gJ05OZXQuUmVwbGF5LlRyYWNrZXIuU1VuaXRUeXBlQ2hhbmdlRXZlbnQnLFxyXG4gICAvLyAnTk5ldC5SZXBsYXkuVHJhY2tlci5TSGVyb0Jhbm5lZEV2ZW50JyxcclxuICAvLyAgJ05OZXQuUmVwbGF5LlRyYWNrZXIuU0hlcm9QaWNrZWRFdmVudCcsXHJcbiAgIC8vICdOTmV0LlJlcGxheS5UcmFja2VyLlNTdGF0R2FtZUV2ZW50JyxcclxuLy8gLy8gICAnTk5ldC5SZXBsYXkuVHJhY2tlci5TVW5pdFJldml2ZWRFdmVudCcsXHJcbi8vICAgICdOTmV0LlJlcGxheS5UcmFja2VyLlNVcGdyYWRlRXZlbnQnLFxyXG4gLy8gICAnTk5ldC5SZXBsYXkuVHJhY2tlci5TUGxheWVyU2V0dXBFdmVudCdcclxuXTtcclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/types/events/IMessageEvents.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-empty-interface
const IReplayEvent_1 = __webpack_require__("../heroprotocol/dist/lib/types/events/IReplayEvent.js");
exports.MessageEventTypes = [
    'NNet.Game.SLoadingProgressMessage',
    'NNet.Game.SPingMessage',
    'NNet.Game.SChatMessage',
    'NNet.Game.SPlayerAnnounceMessage',
    'NNet.Game.SReconnectNotifyMessage'
];
function isIReplayMessageEvent(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && exports.MessageEventTypes.indexOf(obj._event) !== -1;
}
exports.isIReplayMessageEvent = isIReplayMessageEvent;
function isISLoadingProgressMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SLoadingProgressMessage';
}
exports.isISLoadingProgressMessage = isISLoadingProgressMessage;
function isISPingMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SPingMessage';
}
exports.isISPingMessage = isISPingMessage;
function isISChatMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SChatMessage';
}
exports.isISChatMessage = isISChatMessage;
function isISPlayerAnnounceMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SPlayerAnnounceMessage';
}
exports.isISPlayerAnnounceMessage = isISPlayerAnnounceMessage;
function isISReconnectNotifyMessage(obj) {
    return IReplayEvent_1.isIReplayGameEventBase(obj) && obj._event === 'NNet.Game.SReconnectNotifyMessage';
}
exports.isISReconnectNotifyMessage = isISReconnectNotifyMessage;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL2V2ZW50cy9JTWVzc2FnZUV2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG9DQUFvQztBQUNwQyxpREFBOEU7QUFHakUsUUFBQSxpQkFBaUIsR0FBYTtJQUN2QyxtQ0FBbUM7SUFDbkMsd0JBQXdCO0lBQ3hCLHdCQUF3QjtJQUN4QixrQ0FBa0M7SUFDbEMsbUNBQW1DO0NBQ3RDLENBQUM7QUFNRiwrQkFBc0MsR0FBUTtJQUMxQyxPQUFPLHFDQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLHlCQUFpQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDdkYsQ0FBQztBQUZELHNEQUVDO0FBT0Qsb0NBQTJDLEdBQVE7SUFDL0MsT0FBTyxxQ0FBc0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLG1DQUFtQyxDQUFDO0FBQzdGLENBQUM7QUFGRCxnRUFFQztBQVFELHlCQUFnQyxHQUFRO0lBQ3BDLE9BQU8scUNBQXNCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyx3QkFBd0IsQ0FBQztBQUNsRixDQUFDO0FBRkQsMENBRUM7QUFRRCx5QkFBZ0MsR0FBUTtJQUNwQyxPQUFPLHFDQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssd0JBQXdCLENBQUM7QUFDbEYsQ0FBQztBQUZELDBDQUVDO0FBVUQsbUNBQTBDLEdBQVE7SUFDOUMsT0FBTyxxQ0FBc0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLGtDQUFrQyxDQUFDO0FBQzVGLENBQUM7QUFGRCw4REFFQztBQVFELG9DQUEyQyxHQUFRO0lBQy9DLE9BQU8scUNBQXNCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxtQ0FBbUMsQ0FBQztBQUM3RixDQUFDO0FBRkQsZ0VBRUMiLCJmaWxlIjoidHlwZXMvZXZlbnRzL0lNZXNzYWdlRXZlbnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tZW1wdHktaW50ZXJmYWNlXHJcbmltcG9ydCB7IElSZXBsYXlHYW1lRXZlbnRCYXNlLCBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlIH0gZnJvbSAnLi9JUmVwbGF5RXZlbnQnO1xyXG5pbXBvcnQgeyBJQWJpbGl0eSB9IGZyb20gJy4uL0lCYXNlVHlwZXMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1lc3NhZ2VFdmVudFR5cGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICdOTmV0LkdhbWUuU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2UnLFxyXG4gICAgJ05OZXQuR2FtZS5TUGluZ01lc3NhZ2UnLFxyXG4gICAgJ05OZXQuR2FtZS5TQ2hhdE1lc3NhZ2UnLFxyXG4gICAgJ05OZXQuR2FtZS5TUGxheWVyQW5ub3VuY2VNZXNzYWdlJyxcclxuICAgICdOTmV0LkdhbWUuU1JlY29ubmVjdE5vdGlmeU1lc3NhZ2UnXHJcbl07XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJlcGxheU1lc3NhZ2VFdmVudCBleHRlbmRzIElSZXBsYXlHYW1lRXZlbnRCYXNlIHsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSVJlcGxheU1lc3NhZ2VFdmVudChvYmo6IGFueSk6IG9iaiBpcyBJUmVwbGF5TWVzc2FnZUV2ZW50IHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iaikgJiYgTWVzc2FnZUV2ZW50VHlwZXMuaW5kZXhPZihvYmouX2V2ZW50KSAhPT0gLTE7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNMb2FkaW5nUHJvZ3Jlc3NNZXNzYWdlIGV4dGVuZHMgSVJlcGxheU1lc3NhZ2VFdmVudCB7XHJcbiAgICByZWFkb25seSBfZXZlbnQ6ICdOTmV0LkdhbWUuU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2UnO1xyXG4gICAgcmVhZG9ubHkgbV9wcm9ncmVzczogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNJU0xvYWRpbmdQcm9ncmVzc01lc3NhZ2Uob2JqOiBhbnkpOiBvYmogaXMgSVNMb2FkaW5nUHJvZ3Jlc3NNZXNzYWdlIHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iaikgJiYgb2JqLl9ldmVudCA9PT0gJ05OZXQuR2FtZS5TTG9hZGluZ1Byb2dyZXNzTWVzc2FnZSc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNQaW5nTWVzc2FnZSBleHRlbmRzIElSZXBsYXlNZXNzYWdlRXZlbnQge1xyXG4gICAgcmVhZG9ubHkgX2V2ZW50OiAnTk5ldC5HYW1lLlNQaW5nTWVzc2FnZSc7XHJcbiAgICByZWFkb25seSBtX3JlY2lwaWVudDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgbV9wb2ludDogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNJU1BpbmdNZXNzYWdlKG9iajogYW55KTogb2JqIGlzIElTUGluZ01lc3NhZ2Uge1xyXG4gICAgcmV0dXJuIGlzSVJlcGxheUdhbWVFdmVudEJhc2Uob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5HYW1lLlNQaW5nTWVzc2FnZSc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNDaGF0TWVzc2FnZSBleHRlbmRzIElSZXBsYXlNZXNzYWdlRXZlbnQge1xyXG4gICAgcmVhZG9ubHkgX2V2ZW50OiAnTk5ldC5HYW1lLlNDaGF0TWVzc2FnZSc7XHJcbiAgICByZWFkb25seSBtX3JlY2lwaWVudDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgbV9zdHJpbmc6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSVNDaGF0TWVzc2FnZShvYmo6IGFueSk6IG9iaiBpcyBJU0NoYXRNZXNzYWdlIHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iaikgJiYgb2JqLl9ldmVudCA9PT0gJ05OZXQuR2FtZS5TQ2hhdE1lc3NhZ2UnO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTUGxheWVyQW5ub3VuY2VNZXNzYWdlIGV4dGVuZHMgSVJlcGxheU1lc3NhZ2VFdmVudCB7XHJcbiAgICByZWFkb25seSBfZXZlbnQ6ICdOTmV0LkdhbWUuU1BsYXllckFubm91bmNlTWVzc2FnZSc7XHJcbiAgICByZWFkb25seSBtX2Fubm91bmNlTGluazogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgbV9hbm5vdW5jZW1lbnQ6IHsgQWJpbGl0eTogSUFiaWxpdHkgfTtcclxuICAgIHJlYWRvbmx5IG1fb3RoZXJVbml0VGFnOiBudW1iZXI7XHJcbiAgICByZWFkb25seSBtX3VuaXRUYWc6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSVNQbGF5ZXJBbm5vdW5jZU1lc3NhZ2Uob2JqOiBhbnkpOiBvYmogaXMgSVNQbGF5ZXJBbm5vdW5jZU1lc3NhZ2Uge1xyXG4gICAgcmV0dXJuIGlzSVJlcGxheUdhbWVFdmVudEJhc2Uob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5HYW1lLlNQbGF5ZXJBbm5vdW5jZU1lc3NhZ2UnO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJU1JlY29ubmVjdE5vdGlmeU1lc3NhZ2UgZXh0ZW5kcyBJUmVwbGF5TWVzc2FnZUV2ZW50IHtcclxuICAgIHJlYWRvbmx5IF9ldmVudDogJ05OZXQuR2FtZS5TUmVjb25uZWN0Tm90aWZ5TWVzc2FnZSc7XHJcbiAgICByZWFkb25seSBtX3N0YXR1czogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNJU1JlY29ubmVjdE5vdGlmeU1lc3NhZ2Uob2JqOiBhbnkpOiBvYmogaXMgSVNSZWNvbm5lY3ROb3RpZnlNZXNzYWdlIHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iaikgJiYgb2JqLl9ldmVudCA9PT0gJ05OZXQuR2FtZS5TUmVjb25uZWN0Tm90aWZ5TWVzc2FnZSc7XHJcbn0iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/types/events/IReplayEvent.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isIReplayEvent(obj) {
    return '_event' in obj && obj._event.indexOf('NNet.') === 0;
}
exports.isIReplayEvent = isIReplayEvent;
function isIReplayUserEvent(obj) {
    return isIReplayEvent(obj) && '_userid' in obj;
}
exports.isIReplayUserEvent = isIReplayUserEvent;
function isIReplayGameEventBase(obj) {
    return isIReplayEvent(obj) && obj._event.indexOf('NNet.Game.') === 0;
}
exports.isIReplayGameEventBase = isIReplayGameEventBase;
function isIReplayTrackerEvent(obj) {
    return isIReplayEvent(obj) && obj._event.indexOf('NNet.Replay.Tracker.') === 0;
}
exports.isIReplayTrackerEvent = isIReplayTrackerEvent;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL2V2ZW50cy9JUmVwbGF5RXZlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFRQSx3QkFBK0IsR0FBUTtJQUNuQyxPQUFPLFFBQVEsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFGRCx3Q0FFQztBQU9ELDRCQUFtQyxHQUFRO0lBQ3ZDLE9BQU8sY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQVMsSUFBSSxHQUFHLENBQUM7QUFDbkQsQ0FBQztBQUZELGdEQUVDO0FBS0QsZ0NBQXVDLEdBQVE7SUFDM0MsT0FBTyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFGRCx3REFFQztBQUlELCtCQUFzQyxHQUFRO0lBQzFDLE9BQU8sY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25GLENBQUM7QUFGRCxzREFFQyIsImZpbGUiOiJ0eXBlcy9ldmVudHMvSVJlcGxheUV2ZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tZW1wdHktaW50ZXJmYWNlXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVJlcGxheUV2ZW50IHtcclxuICAgIHJlYWRvbmx5IF9ldmVudDogc3RyaW5nO1xyXG4gICAgcmVhZG9ubHkgX2V2ZW50aWQ6IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IF9nYW1lbG9vcDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgX2JpdHM6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSVJlcGxheUV2ZW50KG9iajogYW55KTogb2JqIGlzIElSZXBsYXlFdmVudCB7XHJcbiAgICByZXR1cm4gJ19ldmVudCcgaW4gb2JqICYmIG9iai5fZXZlbnQuaW5kZXhPZignTk5ldC4nKSA9PT0gMDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJUmVwbGF5VXNlckV2ZW50IGV4dGVuZHMgSVJlcGxheUV2ZW50IHtcclxuICAgIHJlYWRvbmx5IF91c2VyaWQ6IHsgbV91c2VySWQ6IG51bWJlciB9O1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSVJlcGxheVVzZXJFdmVudChvYmo6IGFueSk6IG9iaiBpcyBJUmVwbGF5VXNlckV2ZW50IHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlFdmVudChvYmopICYmICdfdXNlcmlkJyBpbiBvYmo7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElSZXBsYXlHYW1lRXZlbnRCYXNlIGV4dGVuZHMgSVJlcGxheVVzZXJFdmVudCB7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0lSZXBsYXlHYW1lRXZlbnRCYXNlKG9iajogYW55KTogb2JqIGlzIElSZXBsYXlHYW1lRXZlbnRCYXNlIHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlFdmVudChvYmopICYmIG9iai5fZXZlbnQuaW5kZXhPZignTk5ldC5HYW1lLicpID09PSAwO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElSZXBsYXlUcmFja2VyRXZlbnQgZXh0ZW5kcyBJUmVwbGF5RXZlbnQgeyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNJUmVwbGF5VHJhY2tlckV2ZW50KG9iajogYW55KTogb2JqIGlzIElSZXBsYXlUcmFja2VyRXZlbnQge1xyXG4gICAgcmV0dXJuIGlzSVJlcGxheUV2ZW50KG9iaikgJiYgb2JqLl9ldmVudC5pbmRleE9mKCdOTmV0LlJlcGxheS5UcmFja2VyLicpID09PSAwO1xyXG59XHJcblxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/types/events/ITrackerEvents.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IReplayEvent_1 = __webpack_require__("../heroprotocol/dist/lib/types/events/IReplayEvent.js");
function isSUnitBornEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SUnitBornEvent';
}
exports.isSUnitBornEvent = isSUnitBornEvent;
function isSScoreResultEvent(obj) {
    return IReplayEvent_1.isIReplayTrackerEvent(obj) && obj._event === 'NNet.Replay.Tracker.SScoreResultEvent';
}
exports.isSScoreResultEvent = isSScoreResultEvent;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL2V2ZW50cy9JVHJhY2tlckV2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlEQUE0RTtBQWE1RSwwQkFBaUMsR0FBUTtJQUNyQyxPQUFPLG9DQUFxQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssb0NBQW9DLENBQUM7QUFDN0YsQ0FBQztBQUZELDRDQUVDO0FBaUJELDZCQUFvQyxHQUFRO0lBQ3hDLE9BQU8sb0NBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyx1Q0FBdUMsQ0FBQztBQUNoRyxDQUFDO0FBRkQsa0RBRUMiLCJmaWxlIjoidHlwZXMvZXZlbnRzL0lUcmFja2VyRXZlbnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSVJlcGxheVRyYWNrZXJFdmVudCwgaXNJUmVwbGF5VHJhY2tlckV2ZW50IH0gZnJvbSAnLi9JUmVwbGF5RXZlbnQnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJU1VuaXRCb3JuRXZlbnQgZXh0ZW5kcyBJUmVwbGF5VHJhY2tlckV2ZW50IHtcclxuICAgIHJlYWRvbmx5IF9ldmVudDogJ05OZXQuUmVwbGF5LlRyYWNrZXIuU1VuaXRCb3JuRXZlbnQnO1xyXG4gICAgcmVhZG9ubHkgbV9jb250cm9sUGxheWVySWQ6IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IG1fdW5pdFRhZ0luZGV4OiBudW1iZXI7XHJcbiAgICByZWFkb25seSBtX3VuaXRUYWdSZWN5Y2xlOiBudW1iZXI7XHJcbiAgICByZWFkb25seSBtX3VuaXRUeXBlTmFtZTogc3RyaW5nO1xyXG4gICAgcmVhZG9ubHkgbV91cGtlZXBQbGF5ZXJJZDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgbV94OiBudW1iZXI7XHJcbiAgICByZWFkb25seSBtX3k6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU1VuaXRCb3JuRXZlbnQob2JqOiBhbnkpOiBvYmogaXMgSVNVbml0Qm9ybkV2ZW50IHtcclxuICAgIHJldHVybiBpc0lSZXBsYXlUcmFja2VyRXZlbnQob2JqKSAmJiBvYmouX2V2ZW50ID09PSAnTk5ldC5SZXBsYXkuVHJhY2tlci5TVW5pdEJvcm5FdmVudCc7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElLZXlWYWx1ZUFycmF5PFQ+e1xyXG4gICAgcmVhZG9ubHkgbV9uYW1lOiBzdHJpbmc7XHJcbiAgICByZWFkb25seSBtX3ZhbHVlczogVFtdW107XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBJU2NvcmVSZXN1bHQge1xyXG4gICAgcmVhZG9ubHkgbV90aW1lOiBudW1iZXI7XHJcbiAgICByZWFkb25seSBtX3ZhbHVlOiBudW1iZXI7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTU2NvcmVSZXN1bHRFdmVudCB7XHJcbiAgICByZWFkb25seSBtX2luc3RhbmNlTGlzdDogSUtleVZhbHVlQXJyYXk8SVNjb3JlUmVzdWx0PltdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNTU2NvcmVSZXN1bHRFdmVudChvYmo6IGFueSk6IG9iaiBpcyBJU1Njb3JlUmVzdWx0RXZlbnQge1xyXG4gICAgcmV0dXJuIGlzSVJlcGxheVRyYWNrZXJFdmVudChvYmopICYmIG9iai5fZXZlbnQgPT09ICdOTmV0LlJlcGxheS5UcmFja2VyLlNTY29yZVJlc3VsdEV2ZW50JztcclxufSJdfQ==


/***/ }),

/***/ "../heroprotocol/dist/lib/types/events/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/types/events/IReplayEvent.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/types/events/IMessageEvents.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/types/events/FilteredEvents.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/types/events/ITrackerEvents.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL2V2ZW50cy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUErQjtBQUMvQixzQ0FBaUM7QUFDakMsc0NBQWlDO0FBQ2pDLHNDQUFpQyIsImZpbGUiOiJ0eXBlcy9ldmVudHMvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL0lSZXBsYXlFdmVudCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vSU1lc3NhZ2VFdmVudHMnO1xyXG5leHBvcnQgKiBmcm9tICcuL0ZpbHRlcmVkRXZlbnRzJztcclxuZXhwb3J0ICogZnJvbSAnLi9JVHJhY2tlckV2ZW50cyc7XHJcblxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/dist/lib/types/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/dist/lib/types/events/index.js"));
__export(__webpack_require__("../heroprotocol/dist/lib/types/type.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBS0EsOEJBQXlCO0FBQ3pCLDRCQUF1QiIsImZpbGUiOiJ0eXBlcy9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vSUhlcm9Qcm90b2NvbCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vSUJhc2VUeXBlcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vSVJlcGxheUhlYWRlcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vSVJlcGxheUluaXREYXRhJztcclxuZXhwb3J0ICogZnJvbSAnLi9JUmVwbGF5RGV0YWlscyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZXZlbnRzJztcclxuZXhwb3J0ICogZnJvbSAnLi90eXBlJztcclxuIl19


/***/ }),

/***/ "../heroprotocol/dist/lib/types/type.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = Function;
function isType(v) {
    return typeof v === 'function';
}
exports.isType = isType;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR5cGVzL3R5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBYSxRQUFBLElBQUksR0FBRyxRQUFRLENBQUM7QUFFN0IsZ0JBQXVCLENBQU07SUFDM0IsT0FBTyxPQUFPLENBQUMsS0FBSyxVQUFVLENBQUM7QUFDakMsQ0FBQztBQUZELHdCQUVDIiwiZmlsZSI6InR5cGVzL3R5cGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVHlwZSA9IEZ1bmN0aW9uO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZSh2OiBhbnkpOiB2IGlzIFR5cGU8YW55PiB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGU8VD4gZXh0ZW5kcyBGdW5jdGlvbiB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUOyB9XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/headers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MPQUserDataHeader {
    constructor(data) {
        this.magic = data.toString('utf8', 0, 4);
        this.userDataSize = data.readUInt32LE(4);
        this.mpqHeaderOffset = data.readUInt32LE(8);
        this.userDataHeaderSize = data.readUInt32LE(12);
    }
}
exports.MPQUserDataHeader = MPQUserDataHeader;
class MPQFileHeader {
    constructor(data) {
        if (data) {
            this.magic = data.toString('utf8', 0, 4);
            this.headerSize = data.readUInt32LE(4);
            this.archiveSize = data.readUInt32LE(8);
            this.formatVersion = data.readUInt16LE(12);
            this.sectorSizeShift = data.readUInt16LE(14);
            this.hashTableOffset = data.readUInt32LE(16);
            this.blockTableOffset = data.readUInt32LE(20);
            this.hashTableEntries = data.readUInt32LE(24);
            this.blockTableEntries = data.readUInt32LE(28);
        }
    }
}
exports.MPQFileHeader = MPQFileHeader;
class MPQFileHeaderExt extends MPQFileHeader {
    constructor(data) {
        super(null);
        this.extendedBlockTableOffset = data.readIntLE(0, 8);
        this.hashTableOffsetHigh = data.readInt8(8);
        this.blockTableOffsetHigh = data.readInt8(10);
    }
}
exports.MPQFileHeaderExt = MPQFileHeaderExt;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGEvaGVhZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUVBO0lBT0ksWUFBbUIsSUFBWTtRQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7Q0FFSjtBQWRELDhDQWNDO0FBRUQ7SUFZSSxZQUFtQixJQUFZO1FBQzNCLElBQUksSUFBSSxFQUFFO1lBQ04sSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNsRDtJQUNMLENBQUM7Q0FDSjtBQXpCRCxzQ0F5QkM7QUFFRCxzQkFBOEIsU0FBUSxhQUFhO0lBSy9DLFlBQW1CLElBQVk7UUFDM0IsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELENBQUM7Q0FDSjtBQVhELDRDQVdDIiwiZmlsZSI6ImRhdGEvaGVhZGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgTVBRVXNlckRhdGFIZWFkZXIge1xyXG4gICAgcHVibGljIG1hZ2ljOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgdXNlckRhdGFTaXplOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgbXBxSGVhZGVyT2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdXNlckRhdGFIZWFkZXJTaXplOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgY29udGVudDogQnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLm1hZ2ljID0gZGF0YS50b1N0cmluZygndXRmOCcsIDAsIDQpO1xyXG4gICAgICAgIHRoaXMudXNlckRhdGFTaXplID0gZGF0YS5yZWFkVUludDMyTEUoNCk7XHJcbiAgICAgICAgdGhpcy5tcHFIZWFkZXJPZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRSg4KTtcclxuICAgICAgICB0aGlzLnVzZXJEYXRhSGVhZGVyU2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKDEyKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNUFFGaWxlSGVhZGVyIHtcclxuICAgIHB1YmxpYyBtYWdpYzogc3RyaW5nO1xyXG4gICAgcHVibGljIGhlYWRlclNpemU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhcmNoaXZlU2l6ZTogbnVtYmVyO1xyXG4gICAgcHVibGljIHNlY3RvclNpemVTaGlmdDogbnVtYmVyO1xyXG4gICAgcHVibGljIGhhc2hUYWJsZU9mZnNldDogbnVtYmVyO1xyXG4gICAgcHVibGljIGJsb2NrVGFibGVPZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBoYXNoVGFibGVFbnRyaWVzOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYmxvY2tUYWJsZUVudHJpZXM6IG51bWJlcjtcclxuICAgIHB1YmxpYyBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBmb3JtYXRWZXJzaW9uOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdXNlckRhdGFIZWFkZXI6IE1QUVVzZXJEYXRhSGVhZGVyO1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFnaWMgPSBkYXRhLnRvU3RyaW5nKCd1dGY4JywgMCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyU2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKDQpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY2hpdmVTaXplID0gZGF0YS5yZWFkVUludDMyTEUoOCk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0VmVyc2lvbiA9IGRhdGEucmVhZFVJbnQxNkxFKDEyKTtcclxuICAgICAgICAgICAgdGhpcy5zZWN0b3JTaXplU2hpZnQgPSBkYXRhLnJlYWRVSW50MTZMRSgxNCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzaFRhYmxlT2Zmc2V0ID0gZGF0YS5yZWFkVUludDMyTEUoMTYpO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrVGFibGVPZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRSgyMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzaFRhYmxlRW50cmllcyA9IGRhdGEucmVhZFVJbnQzMkxFKDI0KTtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja1RhYmxlRW50cmllcyA9IGRhdGEucmVhZFVJbnQzMkxFKDI4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNUFFGaWxlSGVhZGVyRXh0IGV4dGVuZHMgTVBRRmlsZUhlYWRlciB7XHJcbiAgICBwdWJsaWMgZXh0ZW5kZWRCbG9ja1RhYmxlT2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaGFzaFRhYmxlT2Zmc2V0SGlnaDogbnVtYmVyO1xyXG4gICAgcHVibGljIGJsb2NrVGFibGVPZmZzZXRIaWdoOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xyXG4gICAgICAgIHN1cGVyKG51bGwpO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kZWRCbG9ja1RhYmxlT2Zmc2V0ID0gZGF0YS5yZWFkSW50TEUoMCwgOCk7XHJcbiAgICAgICAgdGhpcy5oYXNoVGFibGVPZmZzZXRIaWdoID0gZGF0YS5yZWFkSW50OCg4KTtcclxuICAgICAgICB0aGlzLmJsb2NrVGFibGVPZmZzZXRIaWdoID0gZGF0YS5yZWFkSW50OCgxMCk7XHJcbiAgICB9XHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/headers.js"));
__export(__webpack_require__("../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/tables.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGEvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBMEI7QUFDMUIsOEJBQXlCIiwiZmlsZSI6ImRhdGEvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2hlYWRlcnMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3RhYmxlcyc7XHJcbiJdfQ==


/***/ }),

/***/ "../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/tables.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MPQHashTableEntry {
    constructor(data) {
        this.hashA = data.readUInt32BE(0);
        this.hashB = data.readUInt32BE(4);
        this.locale = data.readUInt16BE(8);
        this.platform = data.readUInt16BE(10);
        this.blockTableIndex = data.readUInt32BE(12);
    }
}
exports.MPQHashTableEntry = MPQHashTableEntry;
class MPQBlockTableEntry {
    constructor(data) {
        this.offset = data.readUInt32BE(0);
        this.archivedSize = data.readUInt32BE(4);
        this.size = data.readUInt32BE(8);
        this.flags = data.readUInt32BE(12);
    }
}
exports.MPQBlockTableEntry = MPQBlockTableEntry;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRhdGEvdGFibGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7SUFPSSxZQUFtQixJQUFZO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakQsQ0FBQztDQUNKO0FBZEQsOENBY0M7QUFFRDtJQUtJLFlBQW1CLElBQVk7UUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Q0FDSjtBQVhELGdEQVdDIiwiZmlsZSI6ImRhdGEvdGFibGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBNUFFIYXNoVGFibGVFbnRyeSB7XHJcbiAgICBwdWJsaWMgaGFzaEE6IG51bWJlcjtcclxuICAgIHB1YmxpYyBoYXNoQjogbnVtYmVyO1xyXG4gICAgcHVibGljIGxvY2FsZTogbnVtYmVyO1xyXG4gICAgcHVibGljIHBsYXRmb3JtOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYmxvY2tUYWJsZUluZGV4OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGRhdGE6IEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuaGFzaEEgPSBkYXRhLnJlYWRVSW50MzJCRSgwKTtcclxuICAgICAgICB0aGlzLmhhc2hCID0gZGF0YS5yZWFkVUludDMyQkUoNCk7XHJcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBkYXRhLnJlYWRVSW50MTZCRSg4KTtcclxuICAgICAgICB0aGlzLnBsYXRmb3JtID0gZGF0YS5yZWFkVUludDE2QkUoMTApO1xyXG4gICAgICAgIHRoaXMuYmxvY2tUYWJsZUluZGV4ID0gZGF0YS5yZWFkVUludDMyQkUoMTIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTVBRQmxvY2tUYWJsZUVudHJ5IHtcclxuICAgIHB1YmxpYyBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhcmNoaXZlZFNpemU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBzaXplOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgZmxhZ3M6IG51bWJlcjtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IGRhdGEucmVhZFVJbnQzMkJFKDApO1xyXG4gICAgICAgIHRoaXMuYXJjaGl2ZWRTaXplID0gZGF0YS5yZWFkVUludDMyQkUoNCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5yZWFkVUludDMyQkUoOCk7XHJcbiAgICAgICAgdGhpcy5mbGFncyA9IGRhdGEucmVhZFVJbnQzMkJFKDEyKTtcclxuICAgIH1cclxufVxyXG4iXX0=


/***/ }),

/***/ "../heroprotocol/node_modules/@heroesbrowser/mpq/dist/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__("../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/index.js"));
__export(__webpack_require__("../heroprotocol/node_modules/@heroesbrowser/mpq/dist/mpq.js"));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsNEJBQXVCO0FBQ3ZCLDJCQUFzQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZGF0YSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vbXBxJzsiXX0=


/***/ }),

/***/ "../heroprotocol/node_modules/@heroesbrowser/mpq/dist/mpq.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**************************************************************
    This is a port of
    https://github.com/nexus-devtools/empeeku
    to typescript and modifies it to run in the browser

    https://github.com/nexus-devtools/empeeku is a fork of
    https://github.com/Farof/mpyqjs which is a port of
    https://github.com/eagleflo/mpyq
  
 ***************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-bitwise
const buffer_1 = __webpack_require__("./node_modules/buffer/index.js");
const Long = __webpack_require__("../heroprotocol/node_modules/long/src/long.js");
const data_1 = __webpack_require__("../heroprotocol/node_modules/@heroesbrowser/mpq/dist/data/index.js");
const compress = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/main2.js");
const hashTypes = {
    'TABLE_OFFSET': 0,
    'HASH_A': 1,
    'HASH_B': 2,
    'TABLE': 3
};
const MPQ_FILE_IMPLODE = 0x00000100;
const MPQ_FILE_COMPRESS = 0x00000200;
const MPQ_FILE_ENCRYPTED = 0x00010000;
const MPQ_FILE_FIX_KEY = 0x00020000;
const MPQ_FILE_SINGLE_UNIT = 0x01000000;
const MPQ_FILE_DELETE_MARKER = 0x02000000;
const MPQ_FILE_SECTOR_CRC = 0x04000000;
const MPQ_FILE_EXISTS = 0x80000000;
class MPQArchive {
    constructor(mpqData, listFiles = true) {
        this._encryptionTable = (function () {
            const table = {};
            let index;
            let seed = new Long.fromValue(0x00100001, true);
            for (let i = 0; i < 256; i++) {
                index = i;
                for (let j = 0; j < 5; j++) {
                    seed = seed.mul(125).add(3).mod(0x2AAAAB);
                    const t1 = seed.and(0xFFFF).shiftLeft(0x10);
                    seed = seed.mul(125).add(3).mod(0x2AAAAB);
                    const t2 = seed.and(0xFFFF);
                    table[index] = t1.or(t2).toNumber();
                    index += 0x100;
                }
            }
            return table;
        })();
        this._data = new buffer_1.Buffer(mpqData);
        this._header = this._readHeader();
        this._hashTable = this._readTable('hash');
        this._blockTable = this._readTable('block');
        if (listFiles) {
            const listFile = this.readFile('(listfile)');
            if (listFile) {
                this._files = listFile.toString('utf-8').trim().split('\r\n');
            }
        }
    }
    get files() {
        return this._files;
    }
    get header() {
        return this._header;
    }
    printHeaders() {
        console.info('MPQ archive header');
        console.info('------------------');
        for (const key in this._header) {
            if (key === 'userDataHeader') {
                continue;
            }
            console.info(key + ' - ' + this._header[key]);
        }
        if (this._header.userDataHeader) {
            console.info();
            console.info('MPQ user data header');
            console.info('--------------------');
            console.info();
            // tslint:disable-next-line:forin
            for (const key in this._header.userDataHeader) {
                console.info(key + ' - ' + this._header.userDataHeader[key]);
            }
            console.info();
        }
    }
    printHashTable() {
        console.info('MPQ archive hash table');
        console.info('----------------------');
        console.info('Hash A\t\tHash B\t\tLocl\tPlat\tBlockIdx');
        const format = [8, 8, 4, 4, 8];
        this._hashTable.forEach(entry => {
            console.info(Object.keys(entry).map((key, i) => {
                return this._formatWord(entry[key], format[i]);
            }).join('\t'));
        });
        console.info();
    }
    ;
    printBlockTable() {
        console.info('MPQ archive block table');
        console.info('-----------------------');
        console.info('Offset\t\tArchSize\tRealSize\tFlags');
        this._blockTable.forEach(entry => {
            console.info([
                this._formatWord(entry.offset, 8),
                this._leadingChar(entry.archivedSize, ' ', 8),
                this._leadingChar(entry.size, ' ', 8),
                this._formatWord(entry.flags, 8)
            ].join('\t'));
        });
        console.info();
    }
    ;
    readFile(filename, forceDecompress = false) {
        function decompress(data) {
            const compressionType = data.readUInt8(0);
            if (compressionType === 0) {
                return data;
            }
            else if (compressionType === 2) {
                throw new Error('Unsupported compression type "zlib".');
            }
            else if (compressionType === 16) {
                return new buffer_1.Buffer(compress.Bzip2.decompressFile(data.slice(1)));
            }
            else {
                throw new Error('Unsupported compression type.');
            }
        }
        const hashEntry = this._getHashTableEntry(filename);
        if (!hashEntry) {
            return null;
        }
        const blockEntry = this._blockTable[hashEntry.blockTableIndex];
        if (blockEntry.flags & MPQ_FILE_EXISTS) {
            if (blockEntry.archivedSize === 0) {
                return null;
            }
            const offset = blockEntry.offset + this._header.offset;
            let fileData = this._data.slice(offset, offset + blockEntry.archivedSize);
            if (blockEntry.flags & MPQ_FILE_ENCRYPTED) {
                throw new Error('Encryption is not supported yet');
            }
            if (!(blockEntry.flags & MPQ_FILE_SINGLE_UNIT)) {
                const sectorSize = 512 << this._header.sectorSizeShift;
                let sectors = Math.trunc(blockEntry.size / sectorSize) + 1;
                let crc;
                if (blockEntry.flags & MPQ_FILE_SECTOR_CRC) {
                    crc = true;
                    sectors += 1;
                }
                else {
                    crc = false;
                }
                const positions = [];
                for (let i = 0; i < (sectors + 1); i++) {
                    positions[i] = fileData.readUInt32LE(4 * i);
                }
                const ln = positions.length - (crc ? 2 : 1);
                let result = new buffer_1.Buffer(0);
                let sectorBytesLeft = blockEntry.size;
                for (let i = 0; i < ln; i++) {
                    let sector = fileData.slice(positions[i], positions[i + 1]);
                    if ((blockEntry.flags & MPQ_FILE_COMPRESS) && (forceDecompress || (sectorBytesLeft > sector.length))) {
                        sector = decompress(sector);
                    }
                    sectorBytesLeft -= sector.length;
                    result = buffer_1.Buffer.concat([result, sector]);
                }
                fileData = result;
            }
            else {
                if ((blockEntry.flags & MPQ_FILE_COMPRESS) && (forceDecompress || (blockEntry.size > blockEntry.archivedSize))) {
                    fileData = decompress(fileData);
                }
            }
            return fileData;
        }
    }
    _leadingChar(str, ch, ln, after = false) {
        str = '' + str;
        while (str.length < ln) {
            str = after ? str + ch : ch + str;
        }
        return str;
    }
    _formatWord(data, ln) {
        return this._leadingChar(data.toString(16).toUpperCase(), '0', ln);
    }
    _getHashTableEntry(filename) {
        const hashA = this._hash(filename, 'HASH_A');
        const hashB = this._hash(filename, 'HASH_B');
        for (const entry of this._hashTable) {
            if (entry.hashA === hashA && entry.hashB === hashB) {
                return entry;
            }
            ;
        }
        return undefined;
    }
    _readHeader() {
        let header;
        const head = this._data.toString('utf-8', 0, 4);
        if (head === 'MPQ\x1a') {
            header = this._readMPQHeader();
            header.offset = 0;
        }
        else if (head === 'MPQ\x1b') {
            const userDataHeader = this._readMPQUserDataHeader();
            header = this._readMPQHeader(userDataHeader.mpqHeaderOffset);
            header.offset = userDataHeader.mpqHeaderOffset;
            header.userDataHeader = userDataHeader;
        }
        else {
            throw new Error('Invalid MPQ file header');
        }
        return header;
    }
    _readMPQUserDataHeader() {
        const data = this._data.slice(0, 16);
        const header = new data_1.MPQUserDataHeader(data);
        header.content = this._data.slice(16, 16 + header.userDataHeaderSize);
        return header;
    }
    _readMPQHeader(offset = 0) {
        let data = this._data.slice(offset, offset + 32);
        let header = new data_1.MPQFileHeader(data);
        if (header.formatVersion === 1) {
            data = this._data.slice(offset + 32, offset + 32 + 12);
            header = Object.assign(new data_1.MPQFileHeaderExt(data), header);
        }
        return header;
    }
    _readTable(tableType) {
        let type;
        switch (tableType) {
            case 'hash':
                type = data_1.MPQHashTableEntry;
                break;
            case 'block':
                type = type = data_1.MPQBlockTableEntry;
                break;
        }
        const tableOffset = this._header[tableType + 'TableOffset'];
        const tableEntries = this._header[tableType + 'TableEntries'];
        const key = this._hash('(' + tableType + ' table)', 'TABLE');
        let data = this._data.slice(tableOffset + this._header.offset, tableOffset + this._header.offset + tableEntries * 16);
        data = this._decrypt(data, key);
        const entries = [];
        for (let i = 0; i < tableEntries; i++) {
            entries[i] = new type(data.slice(i * 16, i * 16 + 16));
        }
        return entries;
    }
    _hash(value, hashType) {
        let seed1 = new Long.fromValue(0x7FED7FED, true);
        let seed2 = new Long.fromValue(0xEEEEEEEE, true);
        let result;
        let ch;
        for (ch of value.toUpperCase()) {
            if (isNaN(parseInt(ch, 10))) {
                ch = ch.codePointAt(0);
            }
            result = new Long.fromValue(this._encryptionTable[(hashTypes[hashType] << 8) + ch], true);
            seed1 = result.xor(seed1.add(seed2)).and(0xFFFFFFFF);
            seed2 = seed1.add(seed2).add(ch).add(seed2.shiftLeft(5)).add(3).and(0xFFFFFFFF);
        }
        return seed1.toNumber();
    }
    _decrypt(data, key) {
        const result = new buffer_1.Buffer(data.length);
        const ln = data.length / 4;
        let seed1 = new Long.fromValue(key, true);
        let seed2 = new Long.fromValue(0xEEEEEEEE, true);
        for (let i = 0; i < ln; i++) {
            // tslint:disable-next-line:no-bitwise
            seed2 = seed2.add(this._encryptionTable[0x400 + (seed1 & 0xFF)]);
            seed2 = seed2.and(0xFFFFFFFF);
            let value = new Long.fromValue(data.readUInt32LE(i * 4), true);
            value = value.xor(seed1.add(seed2)).and(0xFFFFFFFF);
            seed1 = seed1.xor(-1).shiftLeft(0x15).add(0x11111111).or(seed1.shiftRight(0x0B));
            seed1 = seed1.and(0xFFFFFFFF);
            seed2 = value.add(seed2).add(seed2.shiftLeft(5)).add(3).and(0xFFFFFFFF);
            result.writeUInt32BE(value.toNumber(), i * 4);
        }
        return result;
    }
}
exports.MPQArchive = MPQArchive;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2pGLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzlCLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN4RSxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDakQ7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0NBQ0o7QUF0UkQsZ0NBc1JDIiwiZmlsZSI6Im1wcS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgVGhpcyBpcyBhIHBvcnQgb2YgIFxyXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL25leHVzLWRldnRvb2xzL2VtcGVla3UgXHJcbiAgICB0byB0eXBlc2NyaXB0IGFuZCBtb2RpZmllcyBpdCB0byBydW4gaW4gdGhlIGJyb3dzZXJcclxuXHJcbiAgICBodHRwczovL2dpdGh1Yi5jb20vbmV4dXMtZGV2dG9vbHMvZW1wZWVrdSBpcyBhIGZvcmsgb2YgXHJcbiAgICBodHRwczovL2dpdGh1Yi5jb20vRmFyb2YvbXB5cWpzIHdoaWNoIGlzIGEgcG9ydCBvZlxyXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2VhZ2xlZmxvL21weXFcclxuICBcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcclxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcclxuaW1wb3J0ICogYXMgTG9uZyBmcm9tICdsb25nJztcclxuaW1wb3J0IHsgTVBRVXNlckRhdGFIZWFkZXIsIE1QUUZpbGVIZWFkZXIsIE1QUUZpbGVIZWFkZXJFeHQsIE1QUUJsb2NrVGFibGVFbnRyeSwgTVBRSGFzaFRhYmxlRW50cnkgfSBmcm9tICcuL2RhdGEnO1xyXG5pbXBvcnQgKiBhcyBjb21wcmVzcyBmcm9tICdrZXliYXNlLWNvbXByZXNzanMnO1xyXG5cclxuY29uc3QgaGFzaFR5cGVzID0ge1xyXG4gICAgJ1RBQkxFX09GRlNFVCc6IDAsXHJcbiAgICAnSEFTSF9BJzogMSxcclxuICAgICdIQVNIX0InOiAyLFxyXG4gICAgJ1RBQkxFJzogM1xyXG59O1xyXG5cclxuY29uc3QgTVBRX0ZJTEVfSU1QTE9ERSA9IDB4MDAwMDAxMDA7XHJcbmNvbnN0IE1QUV9GSUxFX0NPTVBSRVNTID0gMHgwMDAwMDIwMDtcclxuY29uc3QgTVBRX0ZJTEVfRU5DUllQVEVEID0gMHgwMDAxMDAwMDtcclxuY29uc3QgTVBRX0ZJTEVfRklYX0tFWSA9IDB4MDAwMjAwMDA7XHJcbmNvbnN0IE1QUV9GSUxFX1NJTkdMRV9VTklUID0gMHgwMTAwMDAwMDtcclxuY29uc3QgTVBRX0ZJTEVfREVMRVRFX01BUktFUiA9IDB4MDIwMDAwMDA7XHJcbmNvbnN0IE1QUV9GSUxFX1NFQ1RPUl9DUkMgPSAweDA0MDAwMDAwO1xyXG5jb25zdCBNUFFfRklMRV9FWElTVFMgPSAweDgwMDAwMDAwO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1QUUFyY2hpdmUge1xyXG5cclxuICAgIHByaXZhdGUgX2RhdGE6IEJ1ZmZlcjtcclxuICAgIHByaXZhdGUgX2hlYWRlcjogTVBRRmlsZUhlYWRlcjtcclxuXHJcbiAgICBwcml2YXRlIF9oYXNoVGFibGU6IE1QUUhhc2hUYWJsZUVudHJ5W107XHJcbiAgICBwcml2YXRlIF9ibG9ja1RhYmxlOiBNUFFCbG9ja1RhYmxlRW50cnlbXTtcclxuXHJcbiAgICBwcml2YXRlIF9maWxlczogc3RyaW5nW107XHJcblxyXG4gICAgcHJpdmF0ZSBfZW5jcnlwdGlvblRhYmxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCB0YWJsZSA9IHt9O1xyXG4gICAgICAgIGxldCBpbmRleDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBzZWVkID0gbmV3IExvbmcuZnJvbVZhbHVlKDB4MDAxMDAwMDEsIHRydWUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgc2VlZCA9IHNlZWQubXVsKDEyNSkuYWRkKDMpLm1vZCgweDJBQUFBQik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0MSA9IHNlZWQuYW5kKDB4RkZGRikuc2hpZnRMZWZ0KDB4MTApO1xyXG4gICAgICAgICAgICAgICAgc2VlZCA9IHNlZWQubXVsKDEyNSkuYWRkKDMpLm1vZCgweDJBQUFBQik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0MiA9IHNlZWQuYW5kKDB4RkZGRik7XHJcbiAgICAgICAgICAgICAgICB0YWJsZVtpbmRleF0gPSB0MS5vcih0MikudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDB4MTAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFibGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHB1YmxpYyBnZXQgZmlsZXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGhlYWRlcigpOiBNUFFGaWxlSGVhZGVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihtcHFEYXRhOiBBcnJheUJ1ZmZlciwgbGlzdEZpbGVzID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgQnVmZmVyKG1wcURhdGEpO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHRoaXMuX3JlYWRIZWFkZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFzaFRhYmxlID0gdGhpcy5fcmVhZFRhYmxlKCdoYXNoJyk7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tUYWJsZSA9IHRoaXMuX3JlYWRUYWJsZSgnYmxvY2snKTtcclxuXHJcbiAgICAgICAgaWYgKGxpc3RGaWxlcykge1xyXG4gICAgICAgICAgICBjb25zdCBsaXN0RmlsZSA9IHRoaXMucmVhZEZpbGUoJyhsaXN0ZmlsZSknKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlcyA9IGxpc3RGaWxlLnRvU3RyaW5nKCd1dGYtOCcpLnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHByaW50SGVhZGVycygpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oJ01QUSBhcmNoaXZlIGhlYWRlcicpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tJyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5faGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd1c2VyRGF0YUhlYWRlcicpIHsgY29udGludWU7IH1cclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKGtleSArICcgLSAnICsgdGhpcy5faGVhZGVyW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5faGVhZGVyLnVzZXJEYXRhSGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ01QUSB1c2VyIGRhdGEgaGVhZGVyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKCk7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9oZWFkZXIudXNlckRhdGFIZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhrZXkgKyAnIC0gJyArIHRoaXMuX2hlYWRlci51c2VyRGF0YUhlYWRlcltrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHByaW50SGFzaFRhYmxlKCkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnTVBRIGFyY2hpdmUgaGFzaCB0YWJsZScpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnSGFzaCBBXFx0XFx0SGFzaCBCXFx0XFx0TG9jbFxcdFBsYXRcXHRCbG9ja0lkeCcpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IFs4LCA4LCA0LCA0LCA4XTtcclxuICAgICAgICB0aGlzLl9oYXNoVGFibGUuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhPYmplY3Qua2V5cyhlbnRyeSkubWFwKChrZXksIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRXb3JkKGVudHJ5W2tleV0sIGZvcm1hdFtpXSk7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcdCcpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmluZm8oKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHByaW50QmxvY2tUYWJsZSgpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oJ01QUSBhcmNoaXZlIGJsb2NrIHRhYmxlJyk7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbygnT2Zmc2V0XFx0XFx0QXJjaFNpemVcXHRSZWFsU2l6ZVxcdEZsYWdzJyk7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tUYWJsZS5mb3JFYWNoKGVudHJ5ID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdFdvcmQoZW50cnkub2Zmc2V0LCA4KSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlYWRpbmdDaGFyKGVudHJ5LmFyY2hpdmVkU2l6ZSwgJyAnLCA4KSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlYWRpbmdDaGFyKGVudHJ5LnNpemUsICcgJywgOCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtYXRXb3JkKGVudHJ5LmZsYWdzLCA4KVxyXG4gICAgICAgICAgICBdLmpvaW4oJ1xcdCcpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmluZm8oKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlYWRGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGZvcmNlRGVjb21wcmVzcyA9IGZhbHNlKTogQnVmZmVyIHtcclxuICAgICAgICBmdW5jdGlvbiBkZWNvbXByZXNzKGRhdGE6IEJ1ZmZlcik6IEJ1ZmZlciB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzaW9uVHlwZSA9IGRhdGEucmVhZFVJbnQ4KDApO1xyXG4gICAgICAgICAgICBpZiAoY29tcHJlc3Npb25UeXBlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wcmVzc2lvblR5cGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gdHlwZSBcInpsaWJcIi4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wcmVzc2lvblR5cGUgPT09IDE2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihjb21wcmVzcy5CemlwMi5kZWNvbXByZXNzRmlsZShkYXRhLnNsaWNlKDEpKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbXByZXNzaW9uIHR5cGUuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGhhc2hFbnRyeSA9IHRoaXMuX2dldEhhc2hUYWJsZUVudHJ5KGZpbGVuYW1lKTtcclxuICAgICAgICBpZiAoIWhhc2hFbnRyeSkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgIGNvbnN0IGJsb2NrRW50cnkgPSB0aGlzLl9ibG9ja1RhYmxlW2hhc2hFbnRyeS5ibG9ja1RhYmxlSW5kZXhdO1xyXG4gICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfRVhJU1RTKSB7XHJcbiAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmFyY2hpdmVkU2l6ZSA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBibG9ja0VudHJ5Lm9mZnNldCArIHRoaXMuX2hlYWRlci5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMuX2RhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja0VudHJ5LmFyY2hpdmVkU2l6ZSk7XHJcbiAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfRU5DUllQVEVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIShibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfU0lOR0xFX1VOSVQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0b3JTaXplID0gNTEyIDw8IHRoaXMuX2hlYWRlci5zZWN0b3JTaXplU2hpZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdG9ycyA9IE1hdGgudHJ1bmMoYmxvY2tFbnRyeS5zaXplIC8gc2VjdG9yU2l6ZSkgKyAxO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNyYzogYm9vbGVhbjtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja0VudHJ5LmZsYWdzICYgTVBRX0ZJTEVfU0VDVE9SX0NSQykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdG9ycyArPSAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjcmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc2VjdG9ycyArIDEpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaV0gPSBmaWxlRGF0YS5yZWFkVUludDMyTEUoNCAqIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbG4gPSBwb3NpdGlvbnMubGVuZ3RoIC0gKGNyYyA/IDIgOiAxKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgQnVmZmVyKDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3RvckJ5dGVzTGVmdCA9IGJsb2NrRW50cnkuc2l6ZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWN0b3IgPSBmaWxlRGF0YS5zbGljZShwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tFbnRyeS5mbGFncyAmIE1QUV9GSUxFX0NPTVBSRVNTKSAmJiAoZm9yY2VEZWNvbXByZXNzIHx8IChzZWN0b3JCeXRlc0xlZnQgPiBzZWN0b3IubGVuZ3RoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdG9yID0gZGVjb21wcmVzcyhzZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWN0b3JCeXRlc0xlZnQgLT0gc2VjdG9yLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtyZXN1bHQsIHNlY3Rvcl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsZURhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGJsb2NrRW50cnkuZmxhZ3MgJiBNUFFfRklMRV9DT01QUkVTUykgJiYgKGZvcmNlRGVjb21wcmVzcyB8fCAoYmxvY2tFbnRyeS5zaXplID4gYmxvY2tFbnRyeS5hcmNoaXZlZFNpemUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVEYXRhID0gZGVjb21wcmVzcyhmaWxlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sZWFkaW5nQ2hhcihzdHI6IHN0cmluZyB8IG51bWJlciwgY2g6IHN0cmluZywgbG46IG51bWJlciwgYWZ0ZXIgPSBmYWxzZSk6IHN0cmluZyB7XHJcbiAgICAgICAgc3RyID0gJycgKyBzdHI7XHJcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsbikge1xyXG4gICAgICAgICAgICBzdHIgPSBhZnRlciA/IHN0ciArIGNoIDogY2ggKyBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZm9ybWF0V29yZChkYXRhOiBudW1iZXIsIGxuOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFkaW5nQ2hhcihkYXRhLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBfZ2V0SGFzaFRhYmxlRW50cnkoZmlsZW5hbWU6IHN0cmluZyk6IE1QUUhhc2hUYWJsZUVudHJ5IHtcclxuICAgICAgICBjb25zdCBoYXNoQSA9IHRoaXMuX2hhc2goZmlsZW5hbWUsICdIQVNIX0EnKTtcclxuICAgICAgICBjb25zdCBoYXNoQiA9IHRoaXMuX2hhc2goZmlsZW5hbWUsICdIQVNIX0InKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuX2hhc2hUYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnkuaGFzaEEgPT09IGhhc2hBICYmIGVudHJ5Lmhhc2hCID09PSBoYXNoQikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3JlYWRIZWFkZXIoKTogTVBRRmlsZUhlYWRlciB7XHJcbiAgICAgICAgbGV0IGhlYWRlcjogTVBRRmlsZUhlYWRlcjtcclxuXHJcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2RhdGEudG9TdHJpbmcoJ3V0Zi04JywgMCwgNCk7XHJcbiAgICAgICAgaWYgKGhlYWQgPT09ICdNUFFcXHgxYScpIHtcclxuICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5fcmVhZE1QUUhlYWRlcigpO1xyXG4gICAgICAgICAgICBoZWFkZXIub2Zmc2V0ID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYgKGhlYWQgPT09ICdNUFFcXHgxYicpIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlckRhdGFIZWFkZXIgPSB0aGlzLl9yZWFkTVBRVXNlckRhdGFIZWFkZXIoKTtcclxuICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5fcmVhZE1QUUhlYWRlcih1c2VyRGF0YUhlYWRlci5tcHFIZWFkZXJPZmZzZXQpO1xyXG4gICAgICAgICAgICBoZWFkZXIub2Zmc2V0ID0gdXNlckRhdGFIZWFkZXIubXBxSGVhZGVyT2Zmc2V0O1xyXG4gICAgICAgICAgICBoZWFkZXIudXNlckRhdGFIZWFkZXIgPSB1c2VyRGF0YUhlYWRlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTVBRIGZpbGUgaGVhZGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcmVhZE1QUVVzZXJEYXRhSGVhZGVyKCk6IE1QUVVzZXJEYXRhSGVhZGVyIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZSgwLCAxNik7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IE1QUVVzZXJEYXRhSGVhZGVyKGRhdGEpO1xyXG4gICAgICAgIGhlYWRlci5jb250ZW50ID0gdGhpcy5fZGF0YS5zbGljZSgxNiwgMTYgKyBoZWFkZXIudXNlckRhdGFIZWFkZXJTaXplKTtcclxuICAgICAgICByZXR1cm4gaGVhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3JlYWRNUFFIZWFkZXIob2Zmc2V0ID0gMCk6IE1QUUZpbGVIZWFkZXIge1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKTtcclxuICAgICAgICBsZXQgaGVhZGVyID0gbmV3IE1QUUZpbGVIZWFkZXIoZGF0YSk7XHJcbiAgICAgICAgaWYgKGhlYWRlci5mb3JtYXRWZXJzaW9uID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLnNsaWNlKG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIDEyKTtcclxuICAgICAgICAgICAgaGVhZGVyID0gPE1QUUZpbGVIZWFkZXI+T2JqZWN0LmFzc2lnbihuZXcgTVBRRmlsZUhlYWRlckV4dChkYXRhKSwgaGVhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9yZWFkVGFibGUodGFibGVUeXBlOiAnaGFzaCcpOiBNUFFIYXNoVGFibGVFbnRyeVtdO1xyXG4gICAgcHJpdmF0ZSBfcmVhZFRhYmxlKHRhYmxlVHlwZTogJ2Jsb2NrJyk6IE1QUUJsb2NrVGFibGVFbnRyeVtdO1xyXG4gICAgcHJpdmF0ZSBfcmVhZFRhYmxlKHRhYmxlVHlwZTogJ2hhc2gnIHwgJ2Jsb2NrJykge1xyXG4gICAgICAgIGxldCB0eXBlOiBhbnk7XHJcbiAgICAgICAgc3dpdGNoICh0YWJsZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnaGFzaCc6XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gTVBRSGFzaFRhYmxlRW50cnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgPSBNUFFCbG9ja1RhYmxlRW50cnk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFibGVPZmZzZXQgPSB0aGlzLl9oZWFkZXJbdGFibGVUeXBlICsgJ1RhYmxlT2Zmc2V0J107XHJcbiAgICAgICAgY29uc3QgdGFibGVFbnRyaWVzID0gdGhpcy5faGVhZGVyW3RhYmxlVHlwZSArICdUYWJsZUVudHJpZXMnXTtcclxuXHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5faGFzaCgnKCcgKyB0YWJsZVR5cGUgKyAnIHRhYmxlKScsICdUQUJMRScpO1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YS5zbGljZSh0YWJsZU9mZnNldCArIHRoaXMuX2hlYWRlci5vZmZzZXQsIHRhYmxlT2Zmc2V0ICsgdGhpcy5faGVhZGVyLm9mZnNldCArIHRhYmxlRW50cmllcyAqIDE2KTtcclxuICAgICAgICBkYXRhID0gdGhpcy5fZGVjcnlwdChkYXRhLCBrZXkpO1xyXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlRW50cmllczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBuZXcgdHlwZShkYXRhLnNsaWNlKGkgKiAxNiwgaSAqIDE2ICsgMTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfaGFzaCh2YWx1ZTogc3RyaW5nLCBoYXNoVHlwZTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgc2VlZDEgPSBuZXcgTG9uZy5mcm9tVmFsdWUoMHg3RkVEN0ZFRCwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IHNlZWQyID0gbmV3IExvbmcuZnJvbVZhbHVlKDB4RUVFRUVFRUUsIHRydWUpO1xyXG4gICAgICAgIGxldCByZXN1bHQ6IGFueTtcclxuICAgICAgICBsZXQgY2g6IGFueTtcclxuICAgICAgICBmb3IgKGNoIG9mIHZhbHVlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlSW50KGNoLCAxMCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjaCA9IGNoLmNvZGVQb2ludEF0KDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBMb25nLmZyb21WYWx1ZSh0aGlzLl9lbmNyeXB0aW9uVGFibGVbKGhhc2hUeXBlc1toYXNoVHlwZV0gPDwgOCkgKyBjaF0sIHRydWUpO1xyXG4gICAgICAgICAgICBzZWVkMSA9IHJlc3VsdC54b3Ioc2VlZDEuYWRkKHNlZWQyKSkuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICBzZWVkMiA9IHNlZWQxLmFkZChzZWVkMikuYWRkKGNoKS5hZGQoc2VlZDIuc2hpZnRMZWZ0KDUpKS5hZGQoMykuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlZWQxLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZGVjcnlwdChkYXRhOiBCdWZmZXIsIGtleTogbnVtYmVyKTogQnVmZmVyIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQnVmZmVyKGRhdGEubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBsbiA9IGRhdGEubGVuZ3RoIC8gNDtcclxuICAgICAgICBsZXQgc2VlZDEgPSBuZXcgTG9uZy5mcm9tVmFsdWUoa2V5LCB0cnVlKTtcclxuICAgICAgICBsZXQgc2VlZDIgPSBuZXcgTG9uZy5mcm9tVmFsdWUoMHhFRUVFRUVFRSwgdHJ1ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIHNlZWQyID0gc2VlZDIuYWRkKHRoaXMuX2VuY3J5cHRpb25UYWJsZVsweDQwMCArIChzZWVkMSAmIDB4RkYpXSk7XHJcbiAgICAgICAgICAgIHNlZWQyID0gc2VlZDIuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXcgTG9uZy5mcm9tVmFsdWUoZGF0YS5yZWFkVUludDMyTEUoaSAqIDQpLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS54b3Ioc2VlZDEuYWRkKHNlZWQyKSkuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICBzZWVkMSA9IHNlZWQxLnhvcigtMSkuc2hpZnRMZWZ0KDB4MTUpLmFkZCgweDExMTExMTExKS5vcihzZWVkMS5zaGlmdFJpZ2h0KDB4MEIpKTtcclxuICAgICAgICAgICAgc2VlZDEgPSBzZWVkMS5hbmQoMHhGRkZGRkZGRik7XHJcbiAgICAgICAgICAgIHNlZWQyID0gdmFsdWUuYWRkKHNlZWQyKS5hZGQoc2VlZDIuc2hpZnRMZWZ0KDUpKS5hZGQoMykuYW5kKDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICByZXN1bHQud3JpdGVVSW50MzJCRSh2YWx1ZS50b051bWJlcigpLCBpICogNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuIl19


/***/ }),

/***/ "../heroprotocol/node_modules/charenc/charenc.js":
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),

/***/ "../heroprotocol/node_modules/crypt/crypt.js":
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/main2.js":
/***/ (function(module, exports, __webpack_require__) {

if (typeof console.assert !== "function") { console.assert = function () {} };
exports.BWT = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BWT.js");
exports.BWTC = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BWTC.js");
exports.BitStream = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js");
exports.Bzip2 = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Bzip2.js");
exports.CRC32 = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/CRC32.js");
exports.Context1Model = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Context1Model.js");
exports.DefSumModel = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/DefSumModel.js");
exports.DeflateDistanceModel = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/DeflateDistanceModel.js");
exports.Dmc = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Dmc.js");
exports.DummyRangeCoder = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/DummyRangeCoder.js");
exports.FenwickModel = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/FenwickModel.js");
exports.Huffman = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Huffman.js");
exports.HuffmanAllocator = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/HuffmanAllocator.js");
exports.LogDistanceModel = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/LogDistanceModel.js");
exports.Lzjb = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Lzjb.js");
exports.LzjbR = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/LzjbR.js");
exports.Lzp3 = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Lzp3.js");
exports.MTFModel = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/MTFModel.js");
exports.NoModel = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/NoModel.js");
exports.PPM = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/PPM.js");
exports.RangeCoder = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js");
exports.Simple = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Simple.js");
exports.Stream = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js");
exports.Util = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js");
exports.freeze = __webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js");


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/BWT.js":
/***/ (function(module, exports, __webpack_require__) {

/** Burrows-Wheeler transform, computed with the Induced Sorting Suffix Array
 *  construction mechanism (sais).  Code is a port of:
 *    https://sites.google.com/site/yuta256/sais
 *  which is:
 *    Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.
 *  and licensed under an MIT/X11 license.  I generally looked at both
 *  the C and the Java implementations to guide my work.
 *
 * This JavaScript port is:
 *    Copyright (c) 2013 C. Scott Ananian
 * and licensed under GPLv2; see the README at the top level of this package.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, Util) {
    var ASSERT = console.assert.bind(console);

    // we're dispensing with the "arbitrary alphabet" stuff of the source
    // and just using Uint8Arrays.

    /** Find the start or end of each bucket. */
    var getCounts = function(T, C, n, k) {
        var i;
        for (i = 0; i < k; i++) { C[i] = 0; }
        for (i = 0; i < n; i++) { C[T[i]]++; }
    };
    var getBuckets = function(C, B, k, end) {
        var i, sum = 0;
        if (end) {
            for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum; }
        } else {
            for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum - C[i]; }
        }
    };

    /** Sort all type LMS suffixes */
    var LMSsort = function(T, SA, C, B, n, k) {
        var b, i, j;
        var c0, c1;
        /* compute SAl */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, false); /* find starts of buckets */
        j = n - 1;
        b = B[c1 = T[j]];
        j--;
        SA[b++] = (T[j] < c1) ? ~j : j;
        for (i = 0; i < n; i++) {
            if ((j = SA[i]) > 0) {
                ASSERT(T[j] >= T[j+1]);
                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT(i < b);
                j--;
                SA[b++] = (T[j] < c1) ? ~j : j;
                SA[i] = 0;
            } else if (j < 0) {
                SA[i] = ~j;
            }
        }
        /* compute SAs */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, 1); /* find ends of buckets */
        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
            if ((j = SA[i]) > 0) {
                ASSERT(T[j] <= T[j+1]);
                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT(b <= i);
                j--;
                SA[--b] = (T[j] > c1) ? ~(j+1) : j;
                SA[i] = 0;
            }
        }
    };

    var LMSpostproc = function(T, SA, n, m) {
        var i, j, p, q, plen, qlen, name;
        var c0, c1;
        var diff;

        /* compact all the sorted substrings into the first m items of SA
         * 2*m must not be larger than n (provable) */
        ASSERT(n > 0);
        for (i = 0; (p = SA[i]) < 0; i++) { SA[i] = ~p; ASSERT((i+1) < n); }
        if (i < m) {
            for (j = i, i++; ; i++) {
                ASSERT(i < n);
                if ((p = SA[i]) < 0) {
                    SA[j++] = ~p; SA[i] = 0;
                    if (j === m) { break; }
                }
            }
        }

        /* store the length of all substrings */
        c0 = T[i = j = n - 1];
        do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );
        for (; i >= 0; ) {
            do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) <= c1) );
            if (i >= 0) {
                SA[m + ((i + 1) >>> 1)] = j - i; j = i + 1;
                do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );
            }
        }

        /* find the lexicographic names of all substrings */
        for (i = 0, name = 0, q = n, qlen = 0; i < m; i++) {
            p = SA[i]; plen = SA[m + (p >>> 1)]; diff = true;
            if ((plen === qlen) && ((q + plen) < n)) {
                for (j = 0; (j < plen) && (T[p + j] === T[q + j]); ) { j++; }
                if (j === plen) { diff = false; }
            }
            if (diff) { name++; q = p; qlen = plen; }
            SA[m + (p >>> 1)] = name;
        }

        return name;
    };

    /* compute SA and BWT */
    var induceSA = function(T, SA, C, B, n, k) {
        var b, i, j;
        var c0, c1;
        /* compute SAl */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, false); /* find starts of buckets */
        j = n - 1;
        b = B[c1 = T[j]];
        SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;
        for (i = 0; i < n; i++) {
            j = SA[i]; SA[i] = ~j;
            if (j > 0) {
                j--;
                ASSERT( T[j] >= T[j + 1] );
                if ((c0 = T[j]) !== c1) { B[c1]  = b; b = B[c1=c0]; }
                ASSERT( i < b );
                SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;
            }
        }
        /* compute SAs */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, true); /* find ends of buckets */
        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
            if ((j = SA[i]) > 0) {
                j--;
                ASSERT( T[j] <= T[j + 1] );
                if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT( b <= i );
                SA[--b] = ((j === 0) || (T[j - 1] > c1)) ? ~j : j;
            } else {
                SA[i] = ~j;
            }
        }
    };

    var computeBWT = function(T, SA, C, B, n, k) {
        var b, i, j, pidx = -1;
        var c0, c1;
        /* compute SAl */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, false); /* find starts of buckets */
        j = n - 1;
        b = B[c1 = T[j]];
        SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;
        for (i = 0; i < n; i++) {
            if ((j=SA[i]) > 0) {
                j--;
                ASSERT( T[j] >= T[j+1] );
                SA[i] = ~(c0 = T[j]);
                if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT( i < b );
                SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;
            } else if (j !== 0) {
                SA[i] = ~j;
            }
        }
        /* compute SAs */
        if (C === B) { getCounts(T, C, n, k); }
        getBuckets(C, B, k, true); /* find ends of buckets */
        for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
            if ((j = SA[i]) > 0) {
                j--;
                ASSERT( T[j] <= T[j+1] );
                SA[i] = c0 = T[j];
                if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }
                ASSERT( b <= i );
                SA[--b] = ((j > 0) && (T[j-1] > c1)) ? (~T[j-1]) : j;
            } else if (j !== 0) {
                SA[i] = ~j;
            } else {
                pidx = i;
            }
        }
        return pidx;
    };

    /* find the suffix array SA of T[0..n-1] in {0..k-1}^n
       use a working space (excluding T and SA) of at most 2n+O(1) for a
       constant alphabet */
    var SA_IS = function(T, SA, fs, n, k, isbwt) {
        var C, B, RA;
        var i, j, b, c, m, p, q, name, pidx = 0, newfs;
        var c0, c1;
        var flags = 0;

        // allocate temporary storage [CSA]
        if (k <= 256) {
            C = Util.makeS32Buffer(k);
            if (k <= fs) { B = SA.subarray(n + fs - k); flags = 1; }
            else { B = Util.makeS32Buffer(k); flags = 3; }
        } else if (k <= fs) {
            C = SA.subarray(n + fs - k);
            if (k <= (fs - k)) { B = SA.subarray(n + fs - k * 2); flags = 0; }
            else if (k <= 1024) { B = Util.makeS32Buffer(k); flags = 2; }
            else { B = C; flags = 8; }
        } else {
            C = B = Util.makeS32Buffer(k);
            flags = 4 | 8;
        }

        /* stage 1: reduce the problem by at least 1/2
           sort all the LMS-substrings */
        getCounts(T, C, n, k);
        getBuckets(C, B, k, true); /* find ends of buckets */
        for (i = 0; i < n; i++) { SA[i] = 0; }
        b = -1; i = n - 1; j = n; m = 0; c0 = T[n - 1];
        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
        for (; i >= 0 ;) {
            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));
            if ( i >= 0 ) {
                if ( b >= 0 ) { SA[b] = j; }
                b = --B[c1];
                j = i;
                ++m;
                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
            }
        }

        if (m > 1) {
            LMSsort(T, SA, C, B, n, k);
            name = LMSpostproc(T, SA, n, m);
        } else if (m === 1) {
            SA[b] = j + 1;
            name = 1;
        } else {
            name = 0;
        }

        /* stage 2: solve the reduced problem
           recurse if names are not yet unique */
        if(name < m) {
            if((flags & 4) !== 0) { C = null; B = null; }
            if((flags & 2) !== 0) { B = null; }
            newfs = (n + fs) - (m * 2);
            if((flags & (1 | 4 | 8)) === 0) {
                if((k + name) <= newfs) { newfs -= k; }
                else { flags |= 8; }
            }
            ASSERT( (n >>> 1) <= (newfs + m) );
            for (i = m + (n >>> 1) - 1, j = m * 2 + newfs - 1; m <= i; i--) {
                if(SA[i] !== 0) { SA[j--] = SA[i] - 1; }
            }
            RA = SA.subarray(m + newfs);
            SA_IS(RA, SA, newfs, m, name, false);
            RA = null;

            i = n - 1; j = m * 2 - 1; c0 = T[n - 1];
            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
            for (; i >= 0 ;) {
                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));
                if ( i >= 0 ) {
                    SA[j--] = i + 1;
                    do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
                }
            }

            for (i = 0; i < m; i++) { SA[i] = SA[m + SA[i]]; }
            if((flags & 4) !== 0) { C = B = Util.makeS32Buffer(k); }
            if((flags & 2) !== 0) { B = Util.makeS32Buffer(k); }
        }

        /* stage 3: induce the result for the original problem */
        if((flags & 8) !== 0) { getCounts(T, C, n, k); }
        /* put all left-most S characters into their buckets */
        if (m > 1) {
            getBuckets(C, B, k, true); /* find ends of buckets */
            i = m - 1; j = n; p = SA[m - 1]; c1 = T[p];
            do {
                q = B[c0 = c1];
                while (q < j) { SA[--j] = 0; }
                do {
                    SA[--j] = p;
                    if(--i < 0) { break; }
                    p = SA[i];
                } while((c1 = T[p]) === c0);
            } while (i >= 0 );
            while ( j > 0 ) { SA[--j] = 0; }
        }
        if (!isbwt) { induceSA(T, SA, C, B, n, k); }
        else { pidx = computeBWT(T, SA, C, B, n, k); }
        C = null; B = null;
        return pidx;
    };

    var BWT = Object.create(null);
    /** SA should be a Int32Array (signed!); T can be any typed array.
     *  alphabetSize is optional if T is an Uint8Array or Uint16Array. */
    BWT.suffixsort = function(T, SA, n, alphabetSize) {
        ASSERT( T && SA && T.length >= n && SA.length >= n );
        if (n <= 1) {
            if (n === 1) { SA[0] = 0; }
            return 0;
        }
        if (!alphabetSize) {
            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
            else throw new Error('Need to specify alphabetSize');
        }
        ASSERT( alphabetSize > 0 );
        if (T.BYTES_PER_ELEMENT) {
            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
        }
        return SA_IS(T, SA, 0, n, alphabetSize, false);
    };
    /** Burrows-Wheeler Transform.
        A should be Int32Array (signed!); T can be any typed array.
        U is the same type as T (it is used for output).
        alphabetSize is optional if T is an Uint8Array or Uint16Array.
        ASSUMES STRING IS TERMINATED WITH AN EOF CHARACTER.
    */
    BWT.bwtransform = function(T, U, A, n, alphabetSize) {
        var i, pidx;
        ASSERT( T && U && A );
        ASSERT( T.length >= n && U.length >= n && A.length >= n );
        if (n <= 1) {
            if (n === 1) { U[0] = T[0]; }
            return n;
        }
        if (!alphabetSize) {
            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
            else throw new Error('Need to specify alphabetSize');
        }
        ASSERT( alphabetSize > 0 );
        if (T.BYTES_PER_ELEMENT) {
            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
        }
        pidx = SA_IS(T, A, 0, n, alphabetSize, true);
        U[0] = T[n - 1];
        for (i = 0; i < pidx ; i++) { U[i + 1] = A[i]; }
        for (i += 1; i < n; i++) { U[i] = A[i]; }
        return pidx + 1;
    };
    /** Reverses transform above. (ASSUMED STRING IS TERMINATED WITH EOF.) */
    BWT.unbwtransform = function(T, U, LF, n, pidx) {
        var C = Util.makeU32Buffer(256);
        var i, t;
        for (i=0; i<256; i++) { C[i] = 0; }
        for (i=0; i<n; i++) { LF[i] = C[T[i]]++; }
        for (i=0, t=0; i<256; i++) { t += C[i]; C[i] = t - C[i]; }
        for (i=n-1, t=0; i>=0; i--) {
            t = LF[t] + C[U[i]=T[t]];
            t += (t<pidx) ? 1 : 0;
        }
        C = null;
    };

    /** Burrows-Wheeler Transform.
        A should be Int32Array (signed!); T can be any typed array.
        U is the same type as T (it is used for output).
        alphabetSize is optional if T is an Uint8Array or Uint16Array.
        ASSUMES STRING IS CYCLIC.
        (XXX: this is twice as inefficient as I'd like! [CSA])
    */
    BWT.bwtransform2 = function(T, U, n, alphabetSize) {
        var i, j, pidx = 0;
        ASSERT( T && U );
        ASSERT( T.length >= n && U.length >= n );
        if (n <= 1) {
            if (n === 1) { U[0] = T[0]; }
            return 0;
        }
        if (!alphabetSize) {
            if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
            else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
            else throw new Error('Need to specify alphabetSize');
        }
        ASSERT( alphabetSize > 0 );
        if (T.BYTES_PER_ELEMENT) {
            ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
        }
        // double length of T
        var TT;
        if (T.length >= n*2) {
            TT = T; // do it in place if possible
        } else if (alphabetSize <= 256) {
            TT = Util.makeU8Buffer(n*2);
        } else if (alphabetSize <= 65536) {
            TT = Util.makeU16Buffer(n*2);
        } else {
            TT = Util.makeU32Buffer(n*2);
        }
        if (TT!==T) {
            for (i=0; i<n; i++) { TT[i] = T[i]; }
        }
        for (i=0; i<n; i++) { TT[n+i] = TT[i]; }
        // sort doubled string
        var A = Util.makeS32Buffer(n*2);
        SA_IS(TT, A, 0, n*2, alphabetSize, false);
        for (i=0, j=0; i<2*n; i++) {
            var s = A[i];
            if (s < n) {
                if (s === 0) { pidx = j; }
                if (--s < 0) { s = n-1; }
                U[j++] = T[s];
            }
        }
        ASSERT(j===n);
        return pidx;
    };

    return freeze(BWT);
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/BWTC.js":
/***/ (function(module, exports, __webpack_require__) {

/* A simple bzip-like BWT compressor with a range encoder; written as a
 * self-test of the BWT package. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BWT.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/DefSumModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/FenwickModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/LogDistanceModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/NoModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, BWT, DefSumModel, FenwickModel, LogDistanceModel, NoModel, RangeCoder, Stream, Util) {
    var EOF = Stream.EOF;

    var F_PROB_MAX  = 0xFF00;
    var F_PROB_INCR = 0x0100;

    BWTC = Object.create(null);
    BWTC.MAGIC = "bwtc";
    BWTC.compressFile = Util.compressFileHelper(BWTC.MAGIC, function(input, output, size, props, finalByte) {
        var encoder = new RangeCoder(output);
        encoder.encodeStart(finalByte, 1);

        var blockSize = 9;
        if (typeof(props)==='number' && props >= 1 && props <= 9) {
            blockSize = props;
        }
        encoder.encodeByte(blockSize);
        var fast = (blockSize <= 5);
        blockSize *= 100000;

        var block = Util.makeU8Buffer(blockSize);
        var readBlock = function() {
            var pos;
            for (pos=0; pos < blockSize; ) {
                var ch = input.readByte();
                if (ch < 0) { break; }
                block[pos++] = ch;
            }
            return pos;
        };
        var U = Util.makeU8Buffer(blockSize);
        var A = Util.makeS32Buffer(blockSize);
        var M = Util.makeU8Buffer(256); // move to front array
        var bitModelFactory = NoModel.factory(encoder);
        var lenModel = new LogDistanceModel(blockSize, 0,
                                            bitModelFactory,
                                            bitModelFactory);
        var length, b, c, pidx, i, j;
        do {
            length = readBlock();
            if (length === 0) { break; }
            // indicate that there's another block comin'
            // and encode the length of the block if necessary
            if (length === block.length) {
                encoder.encodeFreq(1, 0, 3); // "full size block"
                b = block;
            } else {
                encoder.encodeFreq(1, 1, 3); // "short block"
                lenModel.encode(length);
                b = block.subarray(0, length);
            }
            pidx = BWT.bwtransform(b, U, A, length, 256);
            lenModel.encode(pidx); // starting index
            // encode the alphabet subset used
            var useTree = Util.makeU16Buffer(512);
            for (i=0; i<length; i++) {
                c = U[i];
                useTree[256+c] = 1;
            }
            for (i=255; i>0; i--) { // sum all the way up the tree
                useTree[i] = useTree[2*i] + useTree[2*i + 1];
            }
            useTree[0] = 1; // sentinel
            for (i=1; i<512; i++) {
                var parent = i>>>1;
                var full = 1 << (9-Util.fls(i));
                if (useTree[parent] === 0 || useTree[parent] === (full*2)) {
                    /* already known full/empty */
                } else if (i >= 256) {
                    encoder.encodeBit(useTree[i]); // leaf node
                } else {
                    var v = useTree[i];
                    v = (v===0) ? 0 : (v===full) ? 2 : 1;
                    encoder.encodeFreq(1, v, 3);
                }
            }
            // remap symbols to this subset
            var alphabetSize = 0;
            for (i=0; i<256; i++) {
                if (useTree[256+i]) { // symbol in use
                    M[alphabetSize++] = i;
                }
            }
            useTree = null;
            // MTF encoding of U
            for (i=0; i<length; i++) {
                c = U[i];
                for (j=0; j<alphabetSize; j++) {
                    if (M[j] === c) {
                        break;
                    }
                }
                console.assert(j<alphabetSize);
                U[i] = j;
                // move to front
                for (; j>0; j--) {
                    M[j] = M[j-1];
                }
                M[0] = c;
            }
            // RLE/range encoding
            var model = new FenwickModel(encoder, alphabetSize+1,
                                         F_PROB_MAX, F_PROB_INCR);
            if (fast) { model = new DefSumModel(encoder, alphabetSize+1); }
            var runLength = 0;
            var emitLastRun = function() {
                // binary encode runs of zeros
                while (runLength !== 0) {
                    if (runLength&1) {
                        model.encode(0); // RUNA
                        runLength-=1;
                    } else {
                        model.encode(1); // RUNB
                        runLength-=2;
                    }
                    runLength >>>= 1;
                }
            };
            for (i=0; i<length; i++) {
                c = U[i];
                if (c === 0) {
                    runLength++;
                } else {
                    emitLastRun();
                    model.encode(c+1);
                    // reset for next
                    runLength = 0;
                }
            }
            emitLastRun();
            // done with this block!
        } while (length === block.length);

        encoder.encodeFreq(1, 2, 3); // "no more blocks"
        encoder.encodeFinish();
    }, true);

    BWTC.decompressFile = Util.decompressFileHelper(BWTC.MAGIC, function(input, output, size) {
        var decoder = new RangeCoder(input);
        decoder.decodeStart(true/* already read the extra byte */);
        var blockSize = decoder.decodeByte();
        console.assert(blockSize >= 1 && blockSize <= 9);
        var fast = (blockSize <= 5);
        blockSize *= 100000;

        var block = Util.makeU8Buffer(blockSize);
        var U = Util.makeU8Buffer(blockSize);
        var A = Util.makeS32Buffer(blockSize);
        var M = Util.makeU8Buffer(256); // move to front array
        var bitModelFactory = NoModel.factory(decoder);
        var lenModel = new LogDistanceModel(blockSize, 0,
                                            bitModelFactory,
                                            bitModelFactory);
        var b, length, i, j, c;
        while (true) {
            var blockIndicator = decoder.decodeCulFreq(3);
            decoder.decodeUpdate(1, blockIndicator, 3);
            if (blockIndicator === 0) { // full-length block
                length = blockSize;
                b = block;
            } else if (blockIndicator === 1) { // short block
                length = lenModel.decode();
                b = block.subarray(0, length);
            } else if (blockIndicator === 2) { // all done, no more blocks
                break;
            }
            // read starting index for unBWT
            var pidx = lenModel.decode();
            // decode the alphabet subset used
            var useTree = Util.makeU16Buffer(512);
            useTree[0] = 1; // sentinel
            for (i=1; i<512; i++) {
                var parent = i>>>1;
                var full = 1 << (9-Util.fls(i));
                if (useTree[parent] === 0 || useTree[parent] === (full*2)) {
                    /* already known full/empty */
                    useTree[i] = useTree[parent] >>> 1;
                } else if (i >= 256) {
                    useTree[i] = decoder.decodeBit(); // leaf node
                } else {
                    var v = decoder.decodeCulFreq(3);
                    decoder.decodeUpdate(1, v, 3);
                    useTree[i] = (v===2) ? full : v;
                }
            }
            // remap symbols to this subset
            var alphabetSize = 0;
            for (i=0; i<256; i++) {
                if (useTree[256+i]) { // symbol in use
                    M[alphabetSize++] = i;
                }
            }
            useTree = null;
            // RLE/range decoding
            var model = new FenwickModel(decoder, alphabetSize+1,
                                         F_PROB_MAX, F_PROB_INCR);
            if (fast) { model = new DefSumModel(decoder, alphabetSize+1, true);}
            var val = 1; // repeat count
            for (i=0; i<length; ) {
                c = model.decode();
                if (c===0) {
                    for (j=0; j<val; j++) { b[i++] = 0; }
                    val *= 2;
                } else if (c===1) {
                    for (j=0; j<val; j++) { b[i++] = 0; b[i++] = 0; }
                    val *= 2;
                } else {
                    val = 1;
                    b[i++] = c-1;
                }
            }
            // MTF decode
            for (i=0; i<length; i++) {
                j = b[i];
                b[i] = c = M[j];
                // move to front
                for (; j>0; j--) {
                    M[j] = M[j-1];
                }
                M[0] = c;
            }
            // unBWT
            BWT.unbwtransform(block, U, A, length, pidx);
            // emit!
            output.write(U, 0, length);
        }
        decoder.decodeFinish();
    });

    return BWTC;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js":
/***/ (function(module, exports, __webpack_require__) {

/** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js")
];
var body_fn = function (Stream) {

    var BitStream = function(stream) {
        (function() {
            var bufferByte = 0x100; // private var for readers
            this.readBit = function() {
                if ((bufferByte & 0xFF) === 0) {
                    var ch = stream.readByte();
                    if (ch === Stream.EOF) {
                        this._eof = true;
                        return ch; /* !!! */
                    }
                    bufferByte = (ch << 1) | 1;
                }
                var bit = (bufferByte & 0x100) ? 1 : 0;
                bufferByte <<= 1;
                return bit;
            };
            // seekable iff the provided stream is
            this.seekBit = function(pos) {
                var n_byte = pos >>> 3;
                var n_bit = pos - (n_byte*8);
                this.seek(n_byte);
                this._eof = false;
                this.readBits(n_bit);
            };
            this.tellBit = function() {
                var pos = stream.tell() * 8;
                var b = bufferByte;
                while ((b & 0xFF) !== 0) {
                    pos--;
                    b <<= 1;
                }
                return pos;
            };
            // implement byte stream interface as well.
            this.readByte = function() {
                if ((bufferByte & 0xFF) === 0) {
                    return stream.readByte();
                }
                return this.readBits(8);
            };
            this.seek = function(pos) {
                stream.seek(pos);
                bufferByte = 0x100;
            };
        }).call(this);
        (function() {
            var bufferByte = 1; // private var for writers
            this.writeBit = function(b) {
                bufferByte <<= 1;
                if (b) { bufferByte |= 1; }
                if (bufferByte & 0x100) {
                    stream.writeByte(bufferByte & 0xFF);
                    bufferByte = 1;
                }
            };
            // implement byte stream interface as well
            this.writeByte = function(_byte) {
                if (bufferByte===1) {
                    stream.writeByte(_byte);
                } else {
                    stream.writeBits(8, _byte);
                }
            };
            this.flush = function() {
                while (bufferByte !== 1) {
                    this.writeBit(0);
                }
                if (stream.flush) { stream.flush(); }
            };
        }).call(this);
    };
    // inherit read/write methods from Stream.
    BitStream.EOF = Stream.EOF;
    BitStream.prototype = Object.create(Stream.prototype);
    // bit chunk read/write
    BitStream.prototype.readBits = function(n) {
        var i, r = 0, b;
        if (n > 31) {
            r = this.readBits(n-16)*0x10000; // fp multiply, not shift
            return r + this.readBits(16);
        }
        for (i = 0; i < n; i++) {
            r <<= 1; // this could make a negative value if n>31
            // bits read past EOF are all zeros!
            if (this.readBit() > 0) { r++; }
        }
        return r;
    };
    BitStream.prototype.writeBits = function(n, value) {
        if (n > 32) {
            var low = (value & 0xFFFF);
            var high = (value - low) / (0x10000); // fp division, not shift
            this.writeBits(n-16, high);
            this.writeBits(16, low);
            return;
        }
        var i;
        for (i = n-1; i >= 0; i--) {
            this.writeBit( (value >>> i) & 1 );
        }
    };

    return BitStream;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Bzip2.js":
/***/ (function(module, exports, __webpack_require__) {

/*
An implementation of Bzip2 de/compression, including the ability to
seek within bzip2 data.

Copyright (C) 2013 C. Scott Ananian
Copyright (C) 2012 Eli Skeggs
Copyright (C) 2011 Kevin Kwok

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, see
http://www.gnu.org/licenses/lgpl-2.1.html

Adapted from node-bzip, copyright 2012 Eli Skeggs.
Adapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.

BWT implementation based on work by Yuta Mori; see BWT.js for details.

bzip2 compression code inspired by https://code.google.com/p/jbzip2
*/
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BWT.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/CRC32.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/HuffmanAllocator.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, BitStream, BWT, CRC32, HuffmanAllocator, Stream, Util) {

var MAX_HUFCODE_BITS = 20;
var MAX_SYMBOLS = 258;
var SYMBOL_RUNA = 0;
var SYMBOL_RUNB = 1;
var MIN_GROUPS = 2;
var MAX_GROUPS = 6;
var GROUP_SIZE = 50;

var WHOLEPI = 0x314159265359; // 48-bit integer
var SQRTPI =  0x177245385090; // 48-bit integer

var EOF = Stream.EOF;

var mtf = function(array, index) {
  var src = array[index], i;
  for (i = index; i > 0; i--) {
    array[i] = array[i-1];
  }
  array[0] = src;
  return src;
};

var Err = {
  OK: 0,
  LAST_BLOCK: -1,
  NOT_BZIP_DATA: -2,
  UNEXPECTED_INPUT_EOF: -3,
  UNEXPECTED_OUTPUT_EOF: -4,
  DATA_ERROR: -5,
  OUT_OF_MEMORY: -6,
  OBSOLETE_INPUT: -7,
  END_OF_BLOCK: -8
};
var ErrorMessages = {};
ErrorMessages[Err.LAST_BLOCK] =            "Bad file checksum";
ErrorMessages[Err.NOT_BZIP_DATA] =         "Not bzip data";
ErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  "Unexpected input EOF";
ErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
ErrorMessages[Err.DATA_ERROR] =            "Data error";
ErrorMessages[Err.OUT_OF_MEMORY] =         "Out of memory";
ErrorMessages[Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";

var _throw = function(status, optDetail) {
  var msg = ErrorMessages[status] || 'unknown error';
  if (optDetail) { msg += ': '+optDetail; }
  var e = new TypeError(msg);
  e.errorCode = status;
  throw e;
};

var Bunzip = function(inputStream, outputStream) {
  this.writePos = this.writeCurrent = this.writeCount = 0;

  this._start_bunzip(inputStream, outputStream);
};
Bunzip.prototype._init_block = function() {
  var moreBlocks = this._get_next_block();
  if ( !moreBlocks ) {
    this.writeCount = -1;
    return false; /* no more blocks */
  }
  this.blockCRC = new CRC32();
  return true;
};
/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */
Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
  /* Ensure that file starts with "BZh['1'-'9']." */
  var buf = Util.makeU8Buffer(4);
  if (inputStream.read(buf, 0, 4) !== 4 ||
      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')
    _throw(Err.NOT_BZIP_DATA, 'bad magic');

  var level = buf[3] - 0x30;
  if (level < 1 || level > 9)
    _throw(Err.NOT_BZIP_DATA, 'level out of range');

  this.reader = new BitStream(inputStream);

  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of
     uncompressed data.  Allocate intermediate buffer for block. */
  this.dbufSize = 100000 * level;
  this.nextoutput = 0;
  this.outputStream = outputStream;
  this.streamCRC = 0;
};
Bunzip.prototype._get_next_block = function() {
  var i, j, k;
  var reader = this.reader;
  // this is get_next_block() function from micro-bunzip:
  /* Read in header signature and CRC, then validate signature.
     (last block signature means CRC is for whole file, return now) */
  var h = reader.readBits(48);
  if (h === SQRTPI) { // last block
    return false; /* no more blocks */
  }
  if (h !== WHOLEPI)
    _throw(Err.NOT_BZIP_DATA);
  this.targetBlockCRC = reader.readBits(32);
  this.streamCRC = (this.targetBlockCRC ^
                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;
  /* We can add support for blockRandomised if anybody complains.  There was
     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that
     it didn't actually work. */
  if (reader.readBits(1))
    _throw(Err.OBSOLETE_INPUT);
  var origPointer = reader.readBits(24);
  if (origPointer > this.dbufSize)
    _throw(Err.DATA_ERROR, 'initial position out of bounds');
  /* mapping table: if some byte values are never used (encoding things
     like ASCII text), the compression code removes the gaps to have fewer
     symbols to deal with, and writes a sparse bitfield indicating which
     values were present.  We make a translation table to convert the symbols
     back to the corresponding bytes. */
  var t = reader.readBits(16);
  var symToByte = Util.makeU8Buffer(256), symTotal = 0;
  for (i = 0; i < 16; i++) {
    if (t & (1 << (0xF - i))) {
      var o = i * 16;
      k = reader.readBits(16);
      for (j = 0; j < 16; j++)
        if (k & (1 << (0xF - j)))
          symToByte[symTotal++] = o + j;
    }
  }

  /* How many different Huffman coding groups does this block use? */
  var groupCount = reader.readBits(3);
  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)
    _throw(Err.DATA_ERROR);
  /* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding
     group.  Read in the group selector list, which is stored as MTF encoded
     bit runs.  (MTF=Move To Front, as each value is used it's moved to the
     start of the list.) */
  var nSelectors = reader.readBits(15);
  if (nSelectors === 0)
    _throw(Err.DATA_ERROR);

  var mtfSymbol = Util.makeU8Buffer(256);
  for (i = 0; i < groupCount; i++)
    mtfSymbol[i] = i;

  var selectors = Util.makeU8Buffer(nSelectors); // was 32768...

  for (i = 0; i < nSelectors; i++) {
    /* Get next value */
    for (j = 0; reader.readBits(1); j++)
      if (j >= groupCount) _throw(Err.DATA_ERROR);
    /* Decode MTF to get the next selector */
    selectors[i] = mtf(mtfSymbol, j);
  }

  /* Read the Huffman coding tables for each group, which code for symTotal
     literal symbols, plus two run symbols (RUNA, RUNB) */
  var symCount = symTotal + 2;
  var groups = [], hufGroup;
  for (j = 0; j < groupCount; j++) {
    var length = Util.makeU8Buffer(symCount), temp = Util.makeU8Buffer(MAX_HUFCODE_BITS + 1);
    /* Read Huffman code lengths for each symbol.  They're stored in
       a way similar to MTF; record a starting value for the first symbol,
       and an offset from the previous value for every symbol after that. */
    t = reader.readBits(5); // lengths
    for (i = 0; i < symCount; i++) {
      for (;;) {
        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);
        /* If first bit is 0, stop.  Else second bit indicates whether
           to increment or decrement the value. */
        if(!reader.readBits(1))
          break;
        if(!reader.readBits(1))
          t++;
        else
          t--;
      }
      length[i] = t;
    }

    /* Find largest and smallest lengths in this group */
    var minLen,  maxLen;
    minLen = maxLen = length[0];
    for (i = 1; i < symCount; i++) {
      if (length[i] > maxLen)
        maxLen = length[i];
      else if (length[i] < minLen)
        minLen = length[i];
    }

    /* Calculate permute[], base[], and limit[] tables from length[].
     *
     * permute[] is the lookup table for converting Huffman coded symbols
     * into decoded symbols.  base[] is the amount to subtract from the
     * value of a Huffman symbol of a given length when using permute[].
     *
     * limit[] indicates the largest numerical value a symbol with a given
     * number of bits can have.  This is how the Huffman codes can vary in
     * length: each code with a value>limit[length] needs another bit.
     */
    hufGroup = {};
    groups.push(hufGroup);
    hufGroup.permute = Util.makeU16Buffer(MAX_SYMBOLS);
    hufGroup.limit = Util.makeU32Buffer(MAX_HUFCODE_BITS + 2);
    hufGroup.base = Util.makeU32Buffer(MAX_HUFCODE_BITS + 1);
    hufGroup.minLen = minLen;
    hufGroup.maxLen = maxLen;
    /* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */
    var pp = 0;
    for (i = minLen; i <= maxLen; i++) {
      temp[i] = hufGroup.limit[i] = 0;
      for (t = 0; t < symCount; t++)
        if (length[t] === i)
          hufGroup.permute[pp++] = t;
    }
    /* Count symbols coded for at each bit length */
    for (i = 0; i < symCount; i++)
      temp[length[i]]++;
    /* Calculate limit[] (the largest symbol-coding value at each bit
     * length, which is (previous limit<<1)+symbols at this level), and
     * base[] (number of symbols to ignore at each bit length, which is
     * limit minus the cumulative count of symbols coded for already). */
    pp = t = 0;
    for (i = minLen; i < maxLen; i++) {
      pp += temp[i];
      /* We read the largest possible symbol size and then unget bits
         after determining how many we need, and those extra bits could
         be set to anything.  (They're noise from future symbols.)  At
         each level we're really only interested in the first few bits,
         so here we set all the trailing to-be-ignored bits to 1 so they
         don't affect the value>limit[length] comparison. */
      hufGroup.limit[i] = pp - 1;
      pp <<= 1;
      t += temp[i];
      hufGroup.base[i + 1] = pp - t;
    }
    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinel value for reading next sym. */
    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
    hufGroup.base[minLen] = 0;
  }
  /* We've finished reading and digesting the block header.  Now read this
     block's Huffman coded symbols from the file and undo the Huffman coding
     and run length encoding, saving the result into dbuf[dbufCount++]=uc */

  /* Initialize symbol occurrence counters and symbol Move To Front table */
  var byteCount = Util.makeU32Buffer(256);
  for (i = 0; i < 256; i++)
    mtfSymbol[i] = i;
  /* Loop through compressed symbols. */
  var runPos = 0, dbufCount = 0, selector = 0, uc;
  var dbuf = this.dbuf = Util.makeU32Buffer(this.dbufSize);
  symCount = 0;
  for (;;) {
    /* Determine which Huffman coding group to use. */
    if (!(symCount--)) {
      symCount = GROUP_SIZE - 1;
      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }
      hufGroup = groups[selectors[selector++]];
    }
    /* Read next Huffman-coded symbol. */
    i = hufGroup.minLen;
    j = reader.readBits(i);
    for (;;i++) {
      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }
      if (j <= hufGroup.limit[i])
        break;
      j = (j << 1) | reader.readBits(1);
    }
    /* Huffman decode value to get nextSym (with bounds checking) */
    j -= hufGroup.base[i];
    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }
    var nextSym = hufGroup.permute[j];
    /* We have now decoded the symbol, which indicates either a new literal
       byte, or a repeated run of the most recent literal byte.  First,
       check if nextSym indicates a repeated run, and if so loop collecting
       how many times to repeat the last literal. */
    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {
      /* If this is the start of a new run, zero out counter */
      if (!runPos){
        runPos = 1;
        t = 0;
      }
      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at
         each bit position, add 1 or 2 instead.  For example,
         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.
         You can make any bit pattern that way using 1 less symbol than
         the basic or 0/1 method (except all bits 0, which would use no
         symbols, but a run of length 0 doesn't mean anything in this
         context).  Thus space is saved. */
      if (nextSym === SYMBOL_RUNA)
        t += runPos;
      else
        t += 2 * runPos;
      runPos <<= 1;
      continue;
    }
    /* When we hit the first non-run symbol after a run, we now know
       how many times to repeat the last literal, so append that many
       copies to our buffer of decoded symbols (dbuf) now.  (The last
       literal used is the one at the head of the mtfSymbol array.) */
    if (runPos){
      runPos = 0;
      if (dbufCount + t >= this.dbufSize) { _throw(Err.DATA_ERROR); }
      uc = symToByte[mtfSymbol[0]];
      byteCount[uc] += t;
      while (t--)
        dbuf[dbufCount++] = uc;
    }
    /* Is this the terminating symbol? */
    if (nextSym > symTotal)
      break;
    /* At this point, nextSym indicates a new literal character.  Subtract
       one to get the position in the MTF array at which this literal is
       currently to be found.  (Note that the result can't be -1 or 0,
       because 0 and 1 are RUNA and RUNB.  But another instance of the
       first symbol in the MTF array, position 0, would have been handled
       as part of a run above.  Therefore 1 unused MTF position minus
       2 non-literal nextSym values equals -1.) */
    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }
    i = nextSym - 1;
    uc = mtf(mtfSymbol, i);
    uc = symToByte[uc];
    /* We have our literal byte.  Save it into dbuf. */
    byteCount[uc]++;
    dbuf[dbufCount++] = uc;
  }
  /* At this point, we've read all the Huffman-coded symbols (and repeated
     runs) for this block from the input stream, and decoded them into the
     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].
     Now undo the Burrows-Wheeler transform on dbuf.
     See http://dogma.net/markn/articles/bwt/bwt.htm
  */
  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }
  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */
  j = 0;
  for (i = 0; i < 256; i++) {
    k = j + byteCount[i];
    byteCount[i] = j;
    j = k;
  }
  /* Figure out what order dbuf would be in if we sorted it. */
  for (i = 0; i < dbufCount; i++) {
    uc = dbuf[i] & 0xff;
    dbuf[byteCount[uc]] |= (i << 8);
    byteCount[uc]++;
  }
  /* Decode first byte by hand to initialize "previous" byte.  Note that it
     doesn't get output, and if the first three characters are identical
     it doesn't qualify as a run (hence writeRunCountdown=5). */
  var pos = 0, current = 0, run = 0;
  if (dbufCount) {
    pos = dbuf[origPointer];
    current = (pos & 0xff);
    pos >>= 8;
    run = -1;
  }
  this.writePos = pos;
  this.writeCurrent = current;
  this.writeCount = dbufCount;
  this.writeRun = run;

  return true; /* more blocks to come */
};
/* Undo burrows-wheeler transform on intermediate buffer to produce output.
   If start_bunzip was initialized with out_fd=-1, then up to len bytes of
   data are written to outbuf.  Return value is number of bytes written or
   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len
   are ignored, data is written to out_fd and return is RETVAL_OK or error.
*/
Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
    var copies, previous, outbyte;
    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully
       decoded, which results in this returning RETVAL_LAST_BLOCK, also
       equal to -1... Confusing, I'm returning 0 here to indicate no
       bytes written into the buffer */
  if (this.writeCount < 0) { return 0; }

  var gotcount = 0;
  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
  var dbufCount = this.writeCount, outputsize = this.outputsize;
  var run = this.writeRun;

  while (dbufCount) {
    dbufCount--;
    previous = current;
    pos = dbuf[pos];
    current = pos & 0xff;
    pos >>= 8;
    if (run++ === 3){
      copies = current;
      outbyte = previous;
      current = -1;
    } else {
      copies = 1;
      outbyte = current;
    }
    this.blockCRC.updateCRCRun(outbyte, copies);
    while (copies--) {
      this.outputStream.writeByte(outbyte);
      this.nextoutput++;
    }
    if (current != previous)
      run = 0;
  }
  this.writeCount = dbufCount;
  // check CRC
  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {
    _throw(Err.DATA_ERROR, "Bad block CRC "+
           "(got "+this.blockCRC.getCRC().toString(16)+
           " expected "+this.targetBlockCRC.toString(16)+")");
  }
  return this.nextoutput;
};

/* Static helper functions */
Bunzip.Err = Err;
// 'input' can be a stream or a buffer
// 'output' can be a stream or a buffer or a number (buffer size)
Bunzip.decode = function(input, output, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;

  var bz = new Bunzip(inputStream, outputStream);
  while (true) {
    if ('eof' in inputStream && inputStream.eof()) break;
    if (bz._init_block()) {
      bz._read_bunzip();
    } else {
      var targetStreamCRC = bz.reader.readBits(32);
      if (targetStreamCRC !== bz.streamCRC) {
        _throw(Err.DATA_ERROR, "Bad stream CRC "+
               "(got "+bz.streamCRC.toString(16)+
               " expected "+targetStreamCRC.toString(16)+")");
      }
      if (multistream &&
          'eof' in inputStream &&
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
      } else break;
    }
  }
  return o.retval;
};
Bunzip.decodeBlock = function(input, pos, output) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;
  var bz = new Bunzip(inputStream, outputStream);
  bz.reader.seekBit(pos);
  /* Fill the decode buffer for the block */
  var moreBlocks = bz._get_next_block();
  if (moreBlocks) {
    /* Init the CRC for writing */
    bz.blockCRC = new CRC32();

    /* Zero this so the current byte from before the seek is not written */
    bz.writeCopies = 0;

    /* Decompress the block and write to stdout */
    bz._read_bunzip();
    // XXX keep writing?
  }
  return o.retval;
};
/* Reads bzip2 file from stream or buffer `input`, and invoke
 * `callback(position, size)` once for each bzip2 block,
 * where position gives the starting position (in *bits*)
 * and size gives uncompressed size of the block (in *bytes*). */
Bunzip.table = function(input, callback, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = new Stream();
  inputStream.delegate = Util.coerceInputStream(input);
  inputStream.pos = 0;
  inputStream.readByte = function() {
    this.pos++;
    return this.delegate.readByte();
  };
  inputStream.tell = function() { return this.pos; };
  if (inputStream.delegate.eof) {
    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
  }
  var outputStream = new Stream();
  outputStream.pos = 0;
  outputStream.writeByte = function() { this.pos++; };

  var bz = new Bunzip(inputStream, outputStream);
  var blockSize = bz.dbufSize;
  while (true) {
    if ('eof' in inputStream && inputStream.eof()) break;

    var position = bz.reader.tellBit();

    if (bz._init_block()) {
      var start = outputStream.pos;
      bz._read_bunzip();
      callback(position, outputStream.pos - start);
    } else {
      var crc = bz.reader.readBits(32); // (but we ignore the crc)
      if (multistream &&
          'eof' in inputStream &&
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
        console.assert(bz.dbufSize === blockSize,
                       "shouldn't change block size within multistream file");
      } else break;
    }
  }
};

// create a Huffman tree from the table of frequencies
var StaticHuffman = function(freq, alphabetSize) {
  // As in BZip2HuffmanStageEncoder.java (from jbzip2):
  // The Huffman allocator needs its input symbol frequencies to be
  // sorted, but we need to return code lengths in the same order as
  // the corresponding frequencies are passed in.
  // The symbol frequency and index are merged into a single array of
  // integers - frequency in the high 23 bits, index in the low 9
  // bits.
  //     2^23 = 8,388,608 which is higher than the maximum possible
  //            frequency for one symbol in a block
  //     2^9 = 512 which is higher than the maximum possible
  //            alphabet size (== 258)
  // Sorting this array simultaneously sorts the frequencies and
  // leaves a lookup that can be used to cheaply invert the sort
  var i, mergedFreq = [];
  for (i=0; i<alphabetSize; i++) {
    mergedFreq[i] = (freq[i] << 9) | i;
  }
  mergedFreq.sort(function(a,b) { return a-b; });
  var sortedFreq = mergedFreq.map(function(v) { return v>>>9; });
  // allocate code lengths in place. (result in sortedFreq array)
  HuffmanAllocator.allocateHuffmanCodeLengths(sortedFreq, MAX_HUFCODE_BITS);
  // reverse the sort to put codes & code lengths in order of input symbols
  this.codeLengths = Util.makeU8Buffer(alphabetSize);
  for (i=0; i<alphabetSize; i++) {
    var sym = mergedFreq[i] & 0x1FF;
    this.codeLengths[sym] = sortedFreq[i];
  }
};
// compute canonical Huffman codes, given code lengths
StaticHuffman.prototype.computeCanonical = function() {
  var alphabetSize = this.codeLengths.length;
  // merge arrays; sort first by length then by symbol.
  var i, merged = [];
  for (i=0; i<alphabetSize; i++) {
    merged[i] = (this.codeLengths[i] << 9) | i;
  }
  merged.sort(function(a,b) { return a-b; });
  // use sorted lengths to assign codes
  this.code = Util.makeU32Buffer(alphabetSize);
  var code = 0, prevLen = 0;
  for (i=0; i<alphabetSize; i++) {
    var curLen = merged[i] >>> 9;
    var sym = merged[i] & 0x1FF;
    console.assert(prevLen <= curLen);
    code <<= (curLen - prevLen);
    this.code[sym] = code++;
    prevLen = curLen;
  }
};
// compute the cost of encoding the given range of symbols w/ this Huffman code
StaticHuffman.prototype.cost = function(array, offset, length) {
  var i, cost = 0;
  for (i=0; i<length; i++) {
    cost += this.codeLengths[array[offset+i]];
  }
  return cost;
};
// emit the bit lengths used by this Huffman code
StaticHuffman.prototype.emit = function(outStream) {
  // write the starting length
  var i, currentLength = this.codeLengths[0];
  outStream.writeBits(5, currentLength);
  for (i=0; i<this.codeLengths.length; i++) {
    var codeLength = this.codeLengths[i];
    var value, delta;
    console.assert(codeLength > 0 && codeLength <= MAX_HUFCODE_BITS);
    if (currentLength < codeLength) {
      value = 2; delta = codeLength - currentLength;
    } else {
      value = 3; delta = currentLength - codeLength;
    }
    while (delta-- > 0) {
      outStream.writeBits(2, value);
    }
    outStream.writeBit(0);
    currentLength = codeLength;
  }
};
// encode the given symbol with this Huffman code
StaticHuffman.prototype.encode = function(outStream, symbol) {
  outStream.writeBits(this.codeLengths[symbol], this.code[symbol]);
};

// read a block for bzip2 compression.
var readBlock = function(inStream, block, length, crc) {
  var pos = 0;
  var lastChar = -1;
  var runLength = 0;
  while (pos < length) {
    if (runLength===4) {
      block[pos++] = 0;
      if (pos >= length) { break; }
    }
    var ch = inStream.readByte();
    if (ch === EOF) {
      break;
    }
    crc.updateCRC(ch);
    if (ch !== lastChar) {
      lastChar = ch;
      runLength = 1;
    } else {
      runLength++;
      if (runLength > 4) {
        if (runLength < 256) {
          block[pos-1]++;
          continue;
        } else {
          runLength = 1;
        }
      }
    }
    block[pos++] = ch;
  }
  return pos;
};

// divide the input into groups at most GROUP_SIZE symbols long.
// assign each group to the Huffman table which compresses it best.
var assignSelectors = function(selectors, groups, input) {
  var i, j, k;
  for (i=0, k=0; i<input.length; i+=GROUP_SIZE) {
    var groupSize = Math.min(GROUP_SIZE, input.length - i);
    var best = 0, bestCost = groups[0].cost(input, i, groupSize);
    for (j=1; j<groups.length; j++) {
      var groupCost = groups[j].cost(input, i, groupSize);
      if (groupCost < bestCost) {
        best = j; bestCost = groupCost;
      }
    }
    selectors[k++] = best;
  }
};
var optimizeHuffmanGroups = function(groups, targetGroups, input,
                                     selectors, alphabetSize) {
  // until we've got "targetGroups" Huffman codes, pick the Huffman code which
  // matches the largest # of groups and split it by picking the groups
  // which require more than the median number of bits to encode.
  // then recompute frequencies and reassign Huffman codes.
  var i, j, k, groupCounts = [];
  while (groups.length < targetGroups) {
    assignSelectors(selectors, groups, input);
    // which code gets used the most?
    for (i=0; i<groups.length; i++) { groupCounts[i] = 0; }
    for (i=0; i<selectors.length; i++) {
      groupCounts[selectors[i]]++;
    }
    var which = groupCounts.indexOf(Math.max.apply(Math, groupCounts));
    // ok, let's look at the size of those blocks
    var splits = [];
    for (i=0, j=0; i<selectors.length; i++) {
      if (selectors[i] !== which) { continue; }
      var start = i*GROUP_SIZE;
      var end = Math.min(start + GROUP_SIZE, input.length);
      splits.push({index: i, cost:groups[which].cost(input, start, end-start)});
    }
    // find the median.  there are O(n) algorithms to do this, but we'll
    // be lazy and use a full O(n ln n) sort.
    splits.sort(function(s1, s2) { return s1.cost - s2.cost; });
    // assign the groups in the top half to the "new" selector
    for (i=(splits.length>>>1); i<splits.length; i++) {
      selectors[splits[i].index] = groups.length;
    }
    groups.push(null);
    // recompute frequencies
    var freq = [], f;
    for (i=0; i<groups.length; i++) {
      f = freq[i] = [];
      for (j=0; j<alphabetSize; j++) { f[j] = 0; }
    }
    for (i=0, j=0; i<input.length; ) {
      f = freq[selectors[j++]];
      for (k=0; k<GROUP_SIZE && i<input.length; k++) {
        f[input[i++]]++;
      }
    }
    // reconstruct Huffman codes
    for (i=0; i<groups.length; i++) {
      groups[i] = new StaticHuffman(freq[i], alphabetSize);
    }
  }
};

var compressBlock = function(block, length, outStream) {
  var c, i, j, k;
  // do BWT transform
  var U = Util.makeU8Buffer(length);
  var pidx = BWT.bwtransform2(block, U, length, 256);
  outStream.writeBit(0); // not randomized
  outStream.writeBits(24, pidx);
  // track values used; write bitmap
  var used = [], compact = [];
  for (i=0; i<length; i++) {
    c = block[i];
    used[c] = true;
    compact[c>>>4] = true;
  }
  for (i=0; i<16; i++) {
    outStream.writeBit(!!compact[i]);
  }
  for (i=0; i<16; i++) {
    if (compact[i]) {
      for (j=0; j<16; j++) {
        outStream.writeBit(!!used[(i<<4)|j]);
      }
    }
  }
  var alphabetSize = 0;
  for (i=0; i<256; i++) {
    if (used[i]) {
      alphabetSize++;
    }
  }
  // now MTF and RLE/2 encoding, while tracking symbol statistics.
  // output can be one longer than length, because we include the
  // end-of-block character at the end. Similarly, we need a U16
  // array because the end-of-block character can be 256.
  var A = Util.makeU16Buffer(length+1);
  var endOfBlock = alphabetSize + 1;
  var freq = [];
  for (i=0; i<=endOfBlock; i++) { freq[i] = 0; }
  var M = Util.makeU8Buffer(alphabetSize);
  for (i=0, j=0; i<256; i++) {
    if (used[i]) { M[j++] = i; }
  }
  used = null; compact = null;
  var pos = 0, runLength = 0;
  var emit = function(c) {
    A[pos++] = c;
    freq[c]++;
  };
  var emitLastRun = function() {
    while (runLength !== 0) {
      if (runLength & 1) {
        emit(0); // RUNA
        runLength -= 1;
      } else {
        emit(1); // RUNB
        runLength -= 2;
      }
      runLength >>>= 1;
    }
  };
  for (i=0; i<U.length; i++) {
    c = U[i];
    // look for C in M
    for (j=0; j<alphabetSize; j++) {
      if (M[j]===c) { break; }
    }
    console.assert(j!==alphabetSize);
    // shift MTF array
    mtf(M, j);
    // emit j
    if (j===0) {
      runLength++;
    } else {
      emitLastRun();
      emit(j+1);
      runLength = 0;
    }
  }
  emitLastRun();
  emit(endOfBlock); // end of block symbol
  A = A.subarray(0, pos);
  // now A[0...pos) has the encoded output, and freq[0-alphabetSize] has the
  // frequencies.  Use these to construct Huffman tables.
  // the canonical bzip2 encoder does some complicated optimization
  // to attempt to select the best tables.  We're going to simplify things:
  // (unless the block is very short) we're always going to create MAX_GROUPS
  // tables; 1 based on global frequencies, and the rest based on dividing the
  // block into MAX_GROUPS-1 pieces.
  var groups = [];
  var targetGroups; // how many Huffman groups should we create?
  // look at length of MTF-encoded block to pick a good number of groups
  if (pos >= 2400) { targetGroups = 6; }
  else if (pos >= 1200) { targetGroups = 5; }
  else if (pos >= 600) { targetGroups = 4; }
  else if (pos >= 200) { targetGroups = 3; }
  else { targetGroups = 2; }
  // start with two Huffman groups: one with the global frequencies, and
  // a second with a flat frequency distribution (which is also the smallest
  // possible Huffman table to encode, which is handy to prevent excessive
  // bloat if the input file size is very small)
  groups.push(new StaticHuffman(freq, endOfBlock+1));
  for (i=0; i<=endOfBlock; i++) { freq[i] = 1; }
  groups.push(new StaticHuffman(freq, endOfBlock+1));
  freq = null;
  // Now optimize the Huffman groups!  this is a black art.
  // we probably don't want to waste too much time on it, though.
  var selectors = Util.makeU8Buffer(Math.ceil(pos / GROUP_SIZE));
  optimizeHuffmanGroups(groups, targetGroups, A, selectors, endOfBlock+1);
  assignSelectors(selectors, groups, A);

  // okay, let's start writing out our Huffman tables
  console.assert(groups.length >= MIN_GROUPS && groups.length <= MAX_GROUPS);
  outStream.writeBits(3, groups.length);
  // and write out the best selector for each group
  outStream.writeBits(15, selectors.length);
  for (i=0; i<groups.length; i++) { M[i] = i; } // initialize MTF table.
  for (i=0; i<selectors.length; i++) {
    var s = selectors[i];
    // find selector in MTF list
    for (j=0; j<groups.length; j++) { if (M[j]===s) { break; } }
    console.assert(j<groups.length);
    mtf(M, j);
    // emit 'j' as a unary number
    for (;j>0; j--) {
      outStream.writeBit(1);
    }
    outStream.writeBit(0);
  }
  // okay, now emit the Huffman tables in order.
  for (i=0; i<groups.length; i++) {
    groups[i].emit(outStream);
    groups[i].computeCanonical(); // get ready for next step while we're at it
  }
  // okay, now (finally!) emit the actual data!
  for (i=0, k=0; i<pos; ) {
    var huff = groups[selectors[k++]];
    for (j=0; j<GROUP_SIZE && i<pos; j++) {
      huff.encode(outStream, A[i++]);
    }
  }
  // done.
};

var Bzip2 = Object.create(null);
Bzip2.compressFile = function(inStream, outStream, props) {
  inStream = Util.coerceInputStream(inStream);
  var o = Util.coerceOutputStream(outStream, outStream);
  outStream = new BitStream(o.stream);

  var blockSizeMultiplier = 9;
  if (typeof(props)==='number') {
    blockSizeMultiplier = props;
  }
  if (blockSizeMultiplier < 1 || blockSizeMultiplier > 9) {
    throw new Error('Invalid block size multiplier');
  }

  var blockSize = blockSizeMultiplier * 100000;
  // the C implementation always writes at least length-19 characters,
  // but it reads ahead enough that if the last character written was part
  // of a run, it writes out the full run.
  // That's really annoying to implement.
  // So instead just subtract 19 from the blockSize; in most cases (unless
  // there's a run at the end of the block) this will yield block divisions
  // matching the C implementation.
  blockSize -= 19;

  // write file magic
  outStream.writeByte('B'.charCodeAt(0));
  outStream.writeByte('Z'.charCodeAt(0));
  outStream.writeByte('h'.charCodeAt(0)); // Huffman-coded bzip
  outStream.writeByte('0'.charCodeAt(0) + blockSizeMultiplier);

  // allocate a buffer for the block
  var block = Util.makeU8Buffer(blockSize);
  var streamCRC = 0;
  var length;

  do {
    var crc = new CRC32();
    length = readBlock(inStream, block, blockSize, crc);
    if (length > 0) {
      streamCRC = (((streamCRC << 1) | (streamCRC>>>31)) ^ crc.getCRC()) >>> 0;
      outStream.writeBits(48, WHOLEPI);
      outStream.writeBits(32, crc.getCRC());
      compressBlock(block, length, outStream);
    }
  } while (length === blockSize);

  // finish up
  outStream.writeBits(48, SQRTPI);
  outStream.writeBits(32, streamCRC);
  outStream.flush(); // get the last bits flushed out
  return o.retval;
};

Bzip2.decompressFile = Bunzip.decode;
Bzip2.decompressBlock = Bunzip.decodeBlock;
Bzip2.table = Bunzip.table;

return Bzip2;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/CRC32.js":
/***/ (function(module, exports, __webpack_require__) {

/* CRC32, used in Bzip2 implementation.
 * This is a port of CRC32.java from the jbzip2 implementation at
 *   https://code.google.com/p/jbzip2
 * which is:
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Util) {

  /**
   * A static CRC lookup table
   */
    var crc32Lookup = Util.arraycopy(Util.makeU32Buffer(256), [
    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
  ]);

  var CRC32 = function() {
    /**
     * The current CRC
     */
    var crc = 0xffffffff;

    /**
     * @return The current CRC
     */
    this.getCRC = function() {
      return (~crc) >>> 0; // return an unsigned value
    };

    /**
     * Update the CRC with a single byte
     * @param value The value to update the CRC with
     */
    this.updateCRC = function(value) {
      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
    };

    /**
     * Update the CRC with a sequence of identical bytes
     * @param value The value to update the CRC with
     * @param count The number of bytes
     */
    this.updateCRCRun = function(value, count) {
      while (count-- > 0) {
        crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
      }
    };
  };
  return CRC32;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Context1Model.js":
/***/ (function(module, exports, __webpack_require__) {

/** A simple context-1 model. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Huffman.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream,Huffman,Util) {

var Context1Model = function(modelFactory, contextSize, alphabetSize) {
  var i;
  this.literalModel = [];
  // even if there's an EOF symbol, we don't need a context for it!
  for (i=0; i<contextSize; i++) {
    this.literalModel[i] = modelFactory(alphabetSize);
  }
};
Context1Model.prototype.encode = function(ch, context) {
  this.literalModel[context].encode(ch);
};
Context1Model.prototype.decode = function(context) {
  return this.literalModel[context].decode();
};

/** Simple self-test. */
Context1Model.MAGIC='ctx1';
Context1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {
  var bitstream = new BitStream(outStream);
  var alphabetSize = 256;
  if (fileSize < 0) { alphabetSize++; }
  var coder = Huffman.factory(bitstream, 8191);
  var model = new Context1Model(coder, 256, alphabetSize);
  var lastchar = 0x20;
  var modelp = {
    encode: function(symbol) {
      model.encode(symbol, lastchar);
      lastchar = symbol;
    }
  };
  Util.compressWithModel(inStream, fileSize, modelp);
  bitstream.flush();
});
Context1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {
  var bitstream = new BitStream(inStream);
  var alphabetSize = 256;
  if (fileSize < 0) { alphabetSize++; }
  var coder = Huffman.factory(bitstream, 8191);
  var model = new Context1Model(coder, 256, alphabetSize);
  var lastchar = 0x20;
  var modelp = {
    decode: function() {
      var symbol = model.decode(lastchar);
      lastchar = symbol;
      return symbol;
    }
  };
  Util.decompressWithModel(outStream, fileSize, modelp);
});

return Context1Model;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/DefSumModel.js":
/***/ (function(module, exports, __webpack_require__) {

/** Deferred-sum model, suitable for small ( ~ 256 ) ranges. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){

var LOG_PROB_TOTAL = 8;
var PROB_TOTAL = 1 << LOG_PROB_TOTAL;
var MAX_ESCAPE_COUNT = 40;

var DefSumModel = function(coder, size, isDecoder) {
  var i;
  console.assert(size < 300); // not meant for sparse
  var ESCAPE = this.numSyms = size;
  this.coder = coder;
  this.prob = Util.makeU16Buffer(size+2); /* size + ESC + 1 */
  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/
  this.update = Util.makeU16Buffer(size+1); /* size + ESC */
  this.prob[ESCAPE+1] = PROB_TOTAL;
  for (i=0; i<=this.numSyms; i++) {
    this.escape[i] = i;
  }
  this.updateCount = 0;
  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);
  if (!isDecoder) { return; }
  // extra tables for fast decoding
  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);
  this.escProbToSym = Util.makeU16Buffer(this.numSyms);
  for (i=0; i<PROB_TOTAL; i++) {
    this.probToSym[i] = ESCAPE;
  }
  for (i=0; i<this.numSyms; i++) {
    this.escProbToSym[i] = i;
  }
};
DefSumModel.factory = function(coder, isDecoder) {
  return function(size) { return new DefSumModel(coder, size, isDecoder); };
};
DefSumModel.prototype._update = function(symbol, isDecoder) {
  if (symbol === this.numSyms) {
    // some special cases for the escape character
    if (this.update[symbol] >= MAX_ESCAPE_COUNT) { return; } // hard limit
    // don't let an escape character trigger an update, because then the
    // escaped character might find itself unescaped after the tables have
    // been updated!
    if (this.updateCount >= (this.updateThresh - 1)) { return; }
  }
  this.update[symbol]++;
  this.updateCount++;
  // is it time to transfer the updated probabilities?
  if (this.updateCount < this.updateThresh) {
    return; //defer update
  }
  var cumProb, cumEscProb, odd, i, j, k;
  this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;
  for (i=0; i < this.numSyms+1; i++) {
    var newProb = ((this.prob[i+1]-this.prob[i]) >>> 1) + this.update[i];
    if (newProb) {
      // live 'un
      this.prob[i] = cumProb;
      cumProb += newProb;
      if (newProb & 1) { odd++; }
      this.escape[i] = cumEscProb;
    } else {
      // this symbol will escape
      this.prob[i] = cumProb;
      this.escape[i] = cumEscProb;
      cumEscProb++;
    }
  }
  this.prob[i] = cumProb;
  console.assert(cumProb === PROB_TOTAL);
  /* how many updates will be required after current probs are halved? */
  this.updateThresh = PROB_TOTAL - Math.floor((cumProb-odd) / 2);
  /* reset the update table */
  for (i=0; i < (this.numSyms + 1); i++) {
    this.update[i] = 0;
  }
  this.update[this.numSyms] = 1; // ensure that escape never goes away
  this.updateCount = 1;
  /* compute decode table, if this is a decoder */
  if (!isDecoder) { return; }
  for (i=0, j=0, k=0; i<(this.numSyms+1); i++) {
    var probLimit = this.prob[i+1];
    for (; j<probLimit; j++) {
      this.probToSym[j] = i;
    }
    var escProbLimit = this.escape[i+1];
    for (; k<escProbLimit; k++) {
      this.escProbToSym[k] = i;
    }
  }
};
DefSumModel.prototype.encode = function(symbol) {
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  console.assert(this.prob[this.numSyms+1] === PROB_TOTAL);
  if (sy_f) {
    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);
    return this._update(symbol);
  }
  // escape!
  console.assert(symbol !== this.numSyms); // catch infinite recursion
  this.encode(this.numSyms); // guaranteed non-zero probability
  // code symbol as literal, taking advantage of reduced escape range.
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  var tot_f = this.escape[this.numSyms];
  this.coder.encodeFreq(sy_f, lt_f, tot_f);
  return this._update(symbol);
};
DefSumModel.prototype.decode = function() {
  var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);
  var symbol = this.probToSym[prob];
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);
  this._update(symbol, true);
  if (symbol !== this.numSyms) {
    return symbol;
  }
  // escape!
  var tot_f = this.escape[this.numSyms];
  prob = this.coder.decodeCulFreq(tot_f);
  symbol = this.escProbToSym[prob];
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, tot_f);
  this._update(symbol, true);
  return symbol;
};

DefSumModel.MAGIC='dfsm';
/** Simple order-0 compressor, as self-test. */
DefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
},true);
/** Simple order-0 decompresser, as self-test. */
DefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*already read the final byte*/);
  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256, true);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

return DefSumModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/DeflateDistanceModel.js":
/***/ (function(module, exports, __webpack_require__) {

/** Distance model used by gzip/deflate.
 *  Encodes distances starting at 0 (for deflate compatibility, subtract
 *  one from distance to encode).
 *  Uses ~32-entry model to predict ln2(distance) (more-or-less) and then
 *  encodes a few more bits for the actual distance. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Util){

    // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
    // and must return an appropriate model or coder.
    var DeflateDistanceModel = function(size, extraStates,
                                        lgDistanceModelFactory,
                                        lengthBitsModelFactory) {
        var i;
        var bits = Util.fls(size-1);
        this.extraStates = +extraStates || 0;
        this.lgDistanceModel = lgDistanceModelFactory(2*bits + extraStates);
        // this.distanceModel[n] used for distances which are n-bits long,
        // but only n-2 bits are encoded: the top bit is known to be one,
        // and the next bit is encoded by the lgDistanceModel.
        this.distanceModel = [];
        for (i=3 ; i <= bits; i++) {
            var numBits = i - 2;
            this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);
        }
    };
    /* you can give this model arguments between 0 and (size-1), or else
       a negative argument which is one of the 'extra states'. */
    DeflateDistanceModel.prototype.encode = function(distance) {
        if (distance < 4) { // small distance or an 'extra state'
            this.lgDistanceModel.encode(distance + this.extraStates);
            return;
        }
        var lgDistance = Util.fls(distance);
        console.assert(distance & (1<<(lgDistance-1))); // top bit is set
        console.assert(lgDistance >= 3);
        var nextBit = (distance & (1 << (lgDistance-2))) ? 1 : 0;
        var l = 4 + ((lgDistance-3)*2) + nextBit;
        this.lgDistanceModel.encode(l + this.extraStates);
        // now encode the rest of the bits.
        var rest = distance & ((1 << (lgDistance-2)) - 1);
        this.distanceModel[lgDistance].encode(rest);
    };
    DeflateDistanceModel.prototype.decode = function() {
        var l = this.lgDistanceModel.decode() - this.extraStates;
        if (l < 4) {
            return l; // this is a small distance or an 'extra state'
        }
        var nextBit = (l&1);
        var lgDistance = ((l-4) >>> 1) + 3;
        var rest = this.distanceModel[lgDistance].decode();
        return ((2+nextBit) << (lgDistance-2)) + rest;
    };
    return DeflateDistanceModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Dmc.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Implementation of Dynamic Markov Compression, using byte-oriented
 * nodes/transitions.
 *
 * Currently no model-shrinking is done, so be careful trying to use
 * this on large inputs!
 *
 * Notes for the future / TO DO:
 *
 * Add node merging to Dmc:
 *  - once (total states traversed / total node count) exceeds a certain value
 *    - find the median node w/rt total visits
 *    - combine all nodes w/ less visits into a single node, with transitions
 *      to node[0] - node[255] (initial context-1 states)
 *      - initially transition counts are zero?  or summed from components?
 *        needs to be summed so kirchoff principle holds
 *    - halve the edge counts of all nodes, to provide for adaptation
 *      - enforce property that all nodes point "higher" except for
 *        links to nodes 0-255.  So we can resum all nodes in one pass,
 *        after resetting all node.sum to zero. X YES because we know
 *        what the total sum must be, so we can arrange to scale to maintain
 *        proper sum. XXX what about node 0-255? XXX maybe just clear all
 *        edge counts XXX
 *
 * Fix buglet: ensure that kirchoff principle *exactly* holds by
 * paying attention to rounding when we distribute edge counts.  track
 * highest edge and give (desiredSum - newSum) extra counts to that
 * outgoing edge? add one to each nonzero edge until all gone?
 *
 * Split 'to' nodes when to.sum grows too high -- only if we're
 * highest incoming edge?  Fix bug again here with saturating counts;
 * we can't ignore counts w/o violating kirchoff principle, so we need
 * to clone it.  Maybe start trying to clone early (before our counter
 * saturates) so we have a better chance of cloning on the high
 * incoming edge? XXX we don't track incoming edges.  XXX so just
 * clone when we visit.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/MTFModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (MTFModel, RangeCoder, Stream, Util){

// nm = no model cloning, MAX_TRANS_CNT=0xFF, MAX_MODEL_PROB=0xFFFF
// nm2 = "                            0xFFFF                 0xFFFF
// nm3 = "                             0xFFF                 0x0FFF
// nm4 = "                            0xFFFF                   0xFF
// cl1 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFF
// cl2 = model cloning, MAX_TRANS_CNT=  0xFF  MAX_MODEL_PROB=0xFF
// cl3 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFFFF
var MAX_TRANS_CNT = 0xFFFF;
var DEFAULT_MIN_CNT1 = 8;
var DEFAULT_MIN_CNT2 = 128;
var MODEL_PROB_MAX = 0xFF00;
var MODEL_PROB_INCR= 0x0100;
var CLONE_MODELS=false;
var PRINT_STATS=false; // for quick benchmarking

// XXX need to limit growth of model (throw away and retrain if model
//     gets too large)

var Dmc = Object.create(null);
Dmc.MAGIC = 'dmc!';

var MarkovNode = function(coder, size, optModel) {
  this.out = [];
  this.model = optModel ? optModel.clone() :
    new MTFModel(coder, size, MODEL_PROB_MAX, MODEL_PROB_INCR);
  this.count = Util.makeU16Buffer(size);
  this.sum = 0;
};
MarkovNode.prototype.clone = function(coder, size) {
  var i;
  var newNode = new MarkovNode(coder, size, CLONE_MODELS ? this.model : null);
  for (i=0; i<size; i++) {
    newNode.out[i] = this.out[i];
  }
  return newNode;
};

var MarkovModel = function(coder, size, MIN_CNT1, MIN_CNT2) {
  var i, j;
  // initial model is 'size' states, completely linked.
  this.coder = coder;
  this.size = size;
  this.MIN_CNT1 = MIN_CNT1 || DEFAULT_MIN_CNT1;
  this.MIN_CNT2 = MIN_CNT2 || DEFAULT_MIN_CNT2;
  this.nodes = [];
  for (i=0; i<size; i++) {
    this.nodes[i] = new MarkovNode(coder, size);
  }
  // now link nodes
  for (i=0; i<size; i++) {
    for (j=0; j<size; j++) {
      this.nodes[i].out[j] = this.nodes[j];
    }
  }
  // select an arbitrary node as the start state.
  this.current = this.nodes[0];
};
MarkovModel.prototype.maybeSplit = function(from, symbol, to) {
  var trans_cnt = from.count[symbol];
  var next_cnt = to.sum;
  var i;
  if ( (trans_cnt <= this.MIN_CNT1) ||
       (next_cnt - trans_cnt <= this.MIN_CNT2) ) {
    return to; // no split
  }

  // split this guy!
  var newNode = to.clone(this.coder, this.size);
  this.nodes.push(newNode);
  from.out[symbol] = newNode;
  // distribute transition counts among new and cloned node
  newNode.sum = to.sum = 0;
  for (i=0; i<this.size; i++) {
    newNode.count[i] = to.count[i] * trans_cnt / next_cnt;
    newNode.sum += newNode.count[i];
    to.count[i] -= newNode.count[i];
    to.sum += to.count[i];
  }

  return newNode;
};
MarkovModel.prototype.encode = function(symbol) {
  var from = this.current;
  from.model.encode(symbol);
  var to = from.out[symbol];
  if (from.count[symbol] !== MAX_TRANS_CNT) {
      from.count[symbol]++;
      from.sum++;
  }
  this.current = this.maybeSplit(from, symbol, to);
};
MarkovModel.prototype.decode = function() {
  var from = this.current;
  var symbol = from.model.decode();
  var to = from.out[symbol];
  if (from.count[symbol] !== MAX_TRANS_CNT) {
      from.count[symbol]++;
      from.sum++;
  }
  this.current = this.maybeSplit(from, symbol, to);
  return symbol;
};

Dmc.compressFile = Util.compressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize, props) {

  props = props || {};
  var MIN_CNT1 = (+props.m) || DEFAULT_MIN_CNT1;
  var MIN_CNT2 = (+props.n) || DEFAULT_MIN_CNT2;
  Util.writeUnsignedNumber(outStream, MIN_CNT1);
  Util.writeUnsignedNumber(outStream, MIN_CNT2);

  var range = new RangeCoder(outStream);
  range.encodeStart(0xCA, 0);

  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,
                           MIN_CNT1, MIN_CNT2);
  var inSize = 0;
  while (inSize !== fileSize) {
    var ch = inStream.readByte();
    if (ch===Stream.EOF) {
      mm.encode(256); // end of stream
      break;
    }
    mm.encode(ch);
    inSize++;
  }
  var outSize = range.encodeFinish();
  if (PRINT_STATS) {
    console.log('M1', mm.MIN_CNT1, 'M2', mm.MIN_CNT2,
                'states', mm.nodes.length, 'size', outSize);
  }
});

Dmc.decompressFile = Util.decompressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize) {

  var MIN_CNT1 = Util.readUnsignedNumber(inStream);
  var MIN_CNT2 = Util.readUnsignedNumber(inStream);

  var range = new RangeCoder(inStream);
  range.decodeStart();

  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,
                           MIN_CNT1, MIN_CNT2);
  var outSize = 0;
  while (outSize !== fileSize) {
    var ch = mm.decode();
    if (ch===256) {
      break; // EOF
    }
    outStream.writeByte(ch);
    outSize++;
  }
  range.decodeFinish();
});

return Dmc;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/DummyRangeCoder.js":
/***/ (function(module, exports, __webpack_require__) {

/* Dummy Range Coder, for debugging.
 * This has the same interface as RangeCoder, but just dumps the frequency
 * parameters given to the file.  This helps debug problems with the model
 * driving the range coder.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Util){
    var Dummy = function(stream) {
        RangeCoder.call(this, stream);
    };
    Dummy.prototype = Object.create(RangeCoder.prototype);
    Dummy.prototype._write8 = function(b) {
        Util.writeUnsignedNumber(this.stream, b);
        this.stream.writeByte(b);
    };
    Dummy.prototype._write16 = function(s) {
        this.stream.writeByte((s >>> 8) & 0xFF);
        this.stream.writeByte(s & 0xFF);
    };
    Dummy.prototype._read8 = function() {
        return this.stream.readByte();
    };
    Dummy.prototype._read16 = function() {
        var hi = this.stream.readByte();
        var lo = this.stream.readByte();
        return (hi<<8) | lo;
    };
    Dummy.prototype.encodeStart = function(c, initlength) {
        this.stream.writeByte(c);
    };
    Dummy.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {
        console.assert(sy_f > 0);
        console.assert(tot_f > 0);
        console.assert(tot_f <= (1<<23));
        if ((sy_f + lt_f) > tot_f) {
            console.error('dummy coder: lt_f + sy_f > tot_f',
                          sy_f, lt_f, tot_f);
        }
        Util.writeUnsignedNumber(this.stream, sy_f);
        Util.writeUnsignedNumber(this.stream, lt_f);
        Util.writeUnsignedNumber(this.stream, tot_f);
    };
    Dummy.prototype.encodeShift = function(sy_f, lt_f, shift) {
        this.encodeFreq(sy_f, lt_f, 1 << shift);
    };
    Dummy.prototype.encodeFinish = function() {
        return 0;
    };
    Dummy.prototype.decodeStart = function(skipInitialRead) {
        return skipInitialRead ? 0 : this.stream.readByte();
    };
    Dummy.prototype.decodeCulFreq = function(tot_f) {
        console.assert(tot_f > 0);
        this.sy_f = Util.readUnsignedNumber(this.stream);
        this.lt_f = Util.readUnsignedNumber(this.stream);
        this.tot_f= Util.readUnsignedNumber(this.stream);
        if (tot_f !== this.tot_f) {
            console.error('decodeCul* wrong total: got', tot_f,
                          'expected', this.tot_f);
        }
        return (this.sy_f>>>1) + this.lt_f;
    };
    Dummy.prototype.decodeCulShift = function(shift) {
        return this.decodeCulFreq(1<<shift);
    };
    Dummy.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
        console.assert(sy_f > 0);
        console.assert(tot_f > 0);
        if (sy_f !== this.sy_f ||
            lt_f !== this.lt_f ||
            tot_f!== this.tot_f) {
            console.error('decodeUpdate wrong parameters; got',
                          sy_f, lt_f, tot_f, 'expected',
                          this.sy_f, this.lt_f, this.tot_f);
        }
    };
    Dummy.prototype.decodeFinish = function() {
    };

    return Dummy;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/FenwickModel.js":
/***/ (function(module, exports, __webpack_require__) {

/** Range coding model based on Fenwick trees for O(ln N) query/update. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){

/** We store two probabilities in a U32, so max prob is going to be 0xFFFF */
var DEFAULT_MAX_PROB = 0xFF00;
var DEFAULT_INCREMENT= 0x0100;

var ESC_MASK = 0x0000FFFF, ESC_SHIFT = 0;
var SYM_MASK = 0xFFFF0000, SYM_SHIFT = 16;
var SCALE_MASK=0xFFFEFFFE;

var FenwickModel = function(coder, size, max_prob, increment) {
    this.coder = coder;
    this.numSyms = size + 1; // save space for an escape symbol
    this.tree = Util.makeU32Buffer(this.numSyms*2);
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    // sanity-check to prevent overflow.
    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);
    console.assert(size <= 0xFFFF);
    // record escape probability as 1.
    var i;
    for (i=0; i<size; i++) {
        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0
            (1 << ESC_SHIFT) | (0 << SYM_SHIFT);
    }
    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1
        (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);
    this._sumTree();
    // probability sums are in this.tree[1].  this.tree[0] is unused.
};
FenwickModel.factory = function(coder, max_prob, increment) {
    return function(size) {
        return new FenwickModel(coder, size, max_prob, increment);
    };
};
FenwickModel.prototype.clone = function() {
    var newModel = new FenwickModel(this.coder, this.size,
                                    this.max_prob, this.increment);
    var i;
    for (i=1; i<this.tree.length; i++) {
        newModel.tree[i] = this.tree[i];
    }
    return newModel;
};
FenwickModel.prototype.encode = function(symbol) {
    var i = this.numSyms + symbol;
    var sy_f = this.tree[i];
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment << SYM_SHIFT);

    if ((sy_f & SYM_MASK) === 0) { // escape!
        this.encode(this.numSyms-1);
        mask = ESC_MASK;
        update -= (1<<ESC_SHIFT); // not going to escape no mo'
        shift = ESC_SHIFT;
    } else if (symbol === (this.numSyms-1) &&
               ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
        // this is the last escape, zero it out
        update = -this.tree[i];
    }
    // sum up the proper lt_f
    var lt_f = 0;
    while (i > 1) {
        var isRight = (i & 1);
        var parent = (i >>> 1);
        // if we're the right child, we need to
        // add the prob from the left child
        if (isRight) {
            lt_f += this.tree[2*parent];
        }
        // update sums
        this.tree[i] += update; // increase sym / decrease esc
        i = parent;
    }
    var tot_f = this.tree[1];
    this.tree[1] += update; // update prob in root
    sy_f = (sy_f & mask) >>> shift;
    lt_f = (lt_f & mask) >>> shift;
    tot_f =(tot_f& mask) >>> shift;
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // rescale?
    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {
        this._rescale();
    }
};
FenwickModel.prototype._decode = function(isEscape) {
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment << SYM_SHIFT);
    if (isEscape) {
        mask = ESC_MASK;
        update -= (1 << ESC_SHIFT);
        shift = ESC_SHIFT;
    }
    var tot_f = (this.tree[1] & mask) >>> shift;
    var prob = this.coder.decodeCulFreq(tot_f);
    // travel down the tree looking for this
    var i = 1, lt_f = 0;
    while (i < this.numSyms) {
        this.tree[i] += update;
        // look at probability in left child.
        var leftProb = (this.tree[2*i] & mask) >>> shift;
        i *= 2;
        if ((prob-lt_f) >= leftProb) {
            lt_f += leftProb;
            i++; // take the right child.
        }
    }
    var symbol = i - this.numSyms;
    var sy_f = (this.tree[i] & mask) >>> shift;
    this.tree[i] += update;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    // was this the last escape?
    if (symbol === (this.numSyms-1) &&
        ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
        update = -this.tree[i]; // zero it out
        while (i >= 1) {
            this.tree[i] += update;
            i = (i >>> 1); // parent
        }
    }
    // rescale?
    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {
        this._rescale();
    }
    return symbol;
};
FenwickModel.prototype.decode = function() {
    var symbol = this._decode(false); // not escape
    if (symbol === (this.numSyms-1)) {
        // this was an escape!
        symbol = this._decode(true); // an escape!
    }
    return symbol;
};
FenwickModel.prototype._rescale = function() {
    var i, prob, noEscape = true;
    // scale symbols (possible causing them to escape)
    for (i=0; i < this.numSyms-1; i++) {
        prob = this.tree[this.numSyms + i];
        if ((prob & ESC_MASK) !== 0) {
            // this symbol escapes
            noEscape = false;
            continue;
        }
        prob = (prob & SCALE_MASK) >>> 1;
        if (prob === 0) {
            // this symbol newly escapes
            prob = (1 << ESC_SHIFT);
            noEscape = false;
        }
        this.tree[this.numSyms + i] = prob;
    }
    // scale the escape symbol
    prob = this.tree[this.numSyms + i];
    prob = (prob & SCALE_MASK) >>> 1;
    // prob should be zero if there are no escaping symbols, otherwise
    // it must be at least 1.
    if (noEscape) { prob = 0; }
    else if (prob === 0) { prob = (1 << SYM_SHIFT); }
    this.tree[this.numSyms + i] = prob;
    // sum it all up afresh
    this._sumTree();
};
FenwickModel.prototype._sumTree = function() {
    var i;
    // sum it all. (we know we won't overflow)
    for (i=this.numSyms - 1; i > 0; i--) {
        this.tree[i] = this.tree[2*i] + this.tree[2*i + 1];
    }
};

FenwickModel.MAGIC = 'fenw';
/** Simple order-0 compressor, as self-test. */
FenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var range = new RangeCoder(outStream);
    range.encodeStart(finalByte, 1);
    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    range.encodeFinish();
}, true);

/** Simple order-0 decompresser, as self-test. */
FenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {
    var range = new RangeCoder(inStream);
    range.decodeStart(true/*already read the final byte*/);
    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
    range.decodeFinish();
});

return FenwickModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Huffman.js":
/***/ (function(module, exports, __webpack_require__) {

/* Adaptive Huffman code, using Vitter's algorithm ported from
 * vitter.c at http://code.google.com/p/compression-code/downloads/list
 * The original code was placed in the public domain, and so I
 * also place this JavaScript port in the public domain.
 *   -- C. Scott Ananian <cscott@cscott.net>, 2013
 * ps. some truly grotty C code in the originally, faithfully ported to
 *     evil comma-operator-using, assignment-in-if-condition JavaScript.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream,Util) {
//  This code is adapted from Professor Vitter's
//  article, Design and Analysis of Dynamic Huffman Codes,
//  which appeared in JACM October 1987

//  A design trade-off has been made to simplify the
//  code:  a node's block is determined dynamically,
//  and the implicit tree structure is maintained,
//  e.g. explicit node numbers are also implicit.

//  Dynamic Huffman table weight ranking
//  is maintained per Professor Vitter's
//  invariant (*) for algorithm FGK:

//  leaves precede internal nodes of the
//  same weight in a non-decreasing ranking
//  of weights using implicit node numbers:

//  1) leaves slide over internal nodes, internal nodes
//  swap over groups of leaves, leaves are swapped
//  into group leader position, but two internal
//  nodes never change positions relative
//  to one another.

//  2) weights are incremented by 2:
//  leaves always have even weight values;
//  internal nodes always have odd values.

//  3) even node numbers are always right children;
//  odd numbers are left children in the tree.

//  node 2 * HuffSize - 1 is always the tree root;
//  node HuffEsc is the escape node;

//  the tree is initialized by creating an
//  escape node as the root.

//  each new leaf symbol is paired with a new escape
//  node into the previous escape node in the tree,
//  until the last symbol which takes over the
//  tree position of the escape node, and
//  HuffEsc is left at zero.

//  overall table size: 2 * HuffSize

//  huff_init(alphabet_size, potential symbols used)
//  huff_encode(next_symbol)
//  next_symbol = huff_decode()

//  huff_scale(by_bits) -- scale weights and re-balance tree

var HTable = function(up, down, symbol, weight) {
    this.up = up; // next node up the tree
    this.down = down; // pair of down nodes
    this.symbol = symbol;       // node symbol value
    this.weight = weight;       // node weight
};
HTable.prototype.clone = function() {
  return new HTable(this.up, this.down, this.symbol, this.weight);
};
HTable.prototype.set = function(htable) {
  this.up = htable.up;
  this.down = htable.down;
  this.symbol = htable.symbol;
  this.weight = htable.weight;
};

//  initialize an adaptive coder
//  for alphabet size, and count
//  of nodes to be used
var Huffman = function(size, root, bitstream, max_weight) {
  var i;
  //  default: all alphabet symbols are used

  console.assert(size && typeof(size)==='number');
  if( !root || root > size )
      root = size;

  //  create the initial escape node
  //  at the tree root

  if ( root <<= 1 ) {
      root--;
  }

  // create root+1 htables (coding table)
  // XXX this could be views on a backing Uint32 array?
  this.table = [];
  for (i=0; i<=root; i++) {
    this.table[i] = new HTable(0,0,0,0);
  }

  // this.map => mapping for symbols to nodes
  this.map = [];
  // this.size => the alphabet size
  if( this.size = size ) {
    for (i=0; i<size; i++) {
      this.map[i] = 0;
    }
  }

  // this.esc  => the current tree height
  // this.root => the root of the tree
  this.esc = this.root = root;

  if (bitstream) {
    this.readBit = bitstream.readBit.bind(bitstream);
    this.writeBit = bitstream.writeBit.bind(bitstream);
  }
  this.max_weight = max_weight; // may be null or undefined
}
// factory interface
Huffman.factory = function(bitstream, max_weight) {
  return function(size) {
    return new Huffman(size, size, bitstream, max_weight);
  };
};


// split escape node to incorporate new symbol

Huffman.prototype.split = function(symbol) {
  var pair, node;

  //  is the tree already full???

  if( pair = this.esc ) {
    this.esc--;
  } else {
    console.assert(false);
    return 0;
  }

  //  if this is the last symbol, it moves into
  //  the escape node's old position, and
  //  this.esc is set to zero.

  //  otherwise, the escape node is promoted to
  //  parent a new escape node and the new symbol.

  if( node = this.esc ) {
    this.table[pair].down = node;
    this.table[pair].weight = 1;
    this.table[node].up = pair;
    this.esc--;
  } else {
    pair = 0;
    node = 1;
  }

  //  initialize the new symbol node

  this.table[node].symbol = symbol;
  this.table[node].weight = 0;
  this.table[node].down = 0;
  this.map[symbol] = node;

  //  initialize a new escape node.

  this.table[this.esc].weight = 0;
  this.table[this.esc].down = 0;
  this.table[this.esc].up = pair;
  return node;
};

//  swap leaf to group leader position
//  return symbol's new node

Huffman.prototype.leader = function(node) {
  var weight = this.table[node].weight;
  var leader = node, prev, symbol;

  while( weight === this.table[leader + 1].weight ) {
    leader++;
  }

  if( leader === node ) {
    return node;
  }

  // swap the leaf nodes

  symbol = this.table[node].symbol;
  prev = this.table[leader].symbol;

  this.table[leader].symbol = symbol;
  this.table[node].symbol = prev;
  this.map[symbol] = leader;
  this.map[prev] = node;
  return leader;
};

//  slide internal node up over all leaves of equal weight;
//  or exchange leaf with next smaller weight internal node

//  return node's new position

Huffman.prototype.slide = function(node) {
  var next = node;
  var swap;

  swap = this.table[next++].clone();

  // if we're sliding an internal node, find the
  // highest possible leaf to exchange with

  if( swap.weight & 1 ) {
    while( swap.weight > this.table[next + 1].weight ) {
      next++;
    }
  }

  //  swap the two nodes

  this.table[node].set(this.table[next]);
  this.table[next].set(swap);

  this.table[next].up = this.table[node].up;
  this.table[node].up = swap.up;

  //  repair the symbol map and tree structure

  if( swap.weight & 1 ) {
    this.table[swap.down].up = next;
    this.table[swap.down - 1].up = next;
    this.map[this.table[node].symbol] = node;
  } else {
    this.table[this.table[node].down - 1].up = node;
    this.table[this.table[node].down].up = node;
    this.map[swap.symbol] = next;
  }

  return next;
};

//  increment symbol weight and re balance the tree.

Huffman.prototype.increment = function(node) {
  var up;

  //  obviate swapping a parent with its child:
  //    increment the leaf and proceed
  //    directly to its parent.

  //  otherwise, promote leaf to group leader position in the tree

  if( this.table[node].up === node + 1 ) {
    this.table[node].weight += 2;
    node++;
  } else {
    node = this.leader (node);
  }

  //  increase the weight of each node and slide
  //  over any smaller weights ahead of it
  //  until reaching the root

  //  internal nodes work upwards from
  //  their initial positions; while
  //  symbol nodes slide over first,
  //  then work up from their final
  //  positions.

  while( this.table[node].weight += 2, up = this.table[node].up ) {
    while( this.table[node].weight > this.table[node + 1].weight ) {
        node = this.slide (node);
    }

    if( this.table[node].weight & 1 ) {
        node = up;
    } else {
        node = this.table[node].up;
    }
  }

  /* Re-scale if necessary. */
  if (this.max_weight) {
    if (this.table[this.root].weight >= this.max_weight) {
      this.scale(1);
    }
  }
};

//  scale all weights and re-balance the tree

//  zero weight nodes are removed from the tree
//  by sliding them out the left of the rank list

Huffman.prototype.scale = function(bits) {
  var node = this.esc, weight, prev;

  //  work up the tree from the escape node
  //  scaling weights by the value of bits

  while( ++node <= this.root ) {
    //  recompute the weight of internal nodes;
    //  slide down and out any unused ones

    if( this.table[node].weight & 1 ) {
      if( weight = this.table[this.table[node].down].weight & ~1 ) {
        weight += this.table[this.table[node].down - 1].weight | 1;
      }

      //  remove zero weight leaves by incrementing HuffEsc
      //  and removing them from the symbol map.  take care

    } else if( !(weight = this.table[node].weight >> bits & ~1) ) {
      if( this.map[this.table[node].symbol] = 0, this.esc++ ) {
        this.esc++;
      }
    }

    // slide the scaled node back down over any
    // previous nodes with larger weights

    this.table[node].weight = weight;
    prev = node;

    while( weight < this.table[--prev].weight ) {
      this.slide(prev);
    }
  }

  // prepare a new escape node

  this.table[this.esc].down = 0;
};

//  send the bits for an escaped symbol

Huffman.prototype.sendid = function(symbol) {
  var empty = 0, max;

  //  count the number of empty symbols
  //  before the symbol in the table

  while( symbol-- ) {
    if( !this.map[symbol] ) {
      empty++;
    }
  }

  //  send LSB of this count first, using
  //  as many bits as are required for
  //  the maximum possible count

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      this.writeBit(empty & 1);
      empty >>= 1;
    } while( max >>= 1 );
  }
};

//  encode the next symbol

Huffman.prototype.encode = function(symbol) {
  var emit = 1, bit;
  var up, idx, node;

  if( symbol < this.size ) {
    node = this.map[symbol];
  } else {
    console.assert(false);
    return;
  }

  //  for a new symbol, direct the receiver to the escape node
  //  but refuse input if table is already full.

  if( !(idx = node) ) {
    if( !(idx = this.esc) ) {
      return;
    }
  }

  //  accumulate the code bits by
  //  working up the tree from
  //  the node to the root

  while( up = this.table[idx].up ) {
    emit <<= 1; emit |= idx & 1; idx = up;
  }

  //  send the code, root selector bit first

  while( bit = emit & 1, emit >>= 1 ) {
    this.writeBit(bit);
  }

  //  send identification and incorporate
  //  new symbols into the tree

  if( !node ) {
    this.sendid(symbol);
    node = this.split(symbol);
  }

  //  adjust and re-balance the tree

  this.increment(node);
};

//  read the identification bits
//  for an escaped symbol

Huffman.prototype.readid = function() {
  var empty = 0, bit = 1, max, symbol;

  //  receive the symbol, LSB first, reading
  //  only the number of bits necessary to
  //  transmit the maximum possible symbol value

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      empty |= this.readBit() ? bit : 0;
      bit <<= 1;
    } while( max >>= 1 );
  }

  //  the count is of unmapped symbols
  //  in the table before the new one

  for( symbol = 0; symbol < this.size; symbol++ ) {
    if( !this.map[symbol] ) {
      if( !empty-- ) {
        return symbol;
      }
    }
  }

  //  oops!  our count is too big, either due
  //  to a bit error, or a short node count
  //  given to huff_init.

  console.assert(false);
  return 0;
};

//  decode the next symbol

Huffman.prototype.decode = function() {
  var node = this.root;
  var symbol, down;

  //  work down the tree from the root
  //  until reaching either a leaf
  //  or the escape node.  A one
  //  bit means go left, a zero
  //  means go right.

  while( down = this.table[node].down ) {
    if( this.readBit() ) {
      node = down - 1;  // the left child precedes the right child
    } else {
      node = down;
    }
  }

  //  sent to the escape node???
  //  refuse to add to a full tree

  if( node === this.esc ) {
    if( this.esc ) {
      symbol = this.readid ();
      node = this.split (symbol);
    } else {
      console.assert(false);
      return 0;
    }
  } else {
    symbol = this.table[node].symbol;
  }

  //  increment weights and re-balance
  //  the coding tree

  this.increment (node);
  return symbol;
};

// stand alone compressor, mostly for testing
Huffman.MAGIC = 'huff';
Huffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {
  var bitstream = new BitStream(output);

  var alphabetSize = 256;
  if (size < 0) { alphabetSize++; }
  var huff = new Huffman(257, alphabetSize, bitstream, 8191);
  Util.compressWithModel(input, size, huff);
  bitstream.flush();
});

// stand alone decompresser, again for testing
Huffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {
  var bitstream = new BitStream(input);

  var alphabetSize = 256;
  if (size < 0) { alphabetSize++; }
  var huff = new Huffman(257, alphabetSize, bitstream, 8191);
  Util.decompressWithModel(output, size, huff);
});

return Huffman;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/HuffmanAllocator.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * An in-place, length restricted Canonical Huffman code length allocator
 *
 * Based on the algorithm proposed by R. L. Milidiú, A. A. Pessoa and
 * E. S. Laber in "In-place Length-Restricted Prefix Coding" (see:
 * http://www-di.inf.puc-rio.br/~laber/public/spire98.ps) and
 * incorporating additional ideas from the implementation of "shcodec"
 * by Simakov Alexander (see: http://webcenter.ru/~xander/)
 *
 * This JavaScript implementation ported from HuffmanAllocator.java from
 *   https://code.google.com/p/jbzip2
 * which is:
 *
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 *
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (freeze, Util) {

  /**
   * FIRST() function
   * @param array The code length array
   * @param i The input position
   * @param nodesToMove The number of internal nodes to be relocated
   * @return The smallest {@code k} such that {@code nodesToMove <= k <= i} and
   *         {@code i <= (array[k] % array.length)}
   */
  var first = function(array, i, nodesToMove) {
    var length = array.length;
    var limit = i;
    var k = array.length - 2;

    while ((i >= nodesToMove) && ((array[i] % length) > limit)) {
      k = i;
      i -= (limit - i + 1);
    }
    i = Math.max (nodesToMove - 1, i);

    while (k > (i + 1)) {
      var temp = (i + k) >> 1;
      if ((array[temp] % length) > limit) {
        k = temp;
      } else {
        i = temp;
      }
    }

    return k;
  };

  /**
   * Fills the code array with extended parent pointers
   * @param array The code length array
   */
  var setExtendedParentPointers = function(array) {
    var length = array.length;

    array[0] += array[1];

    var headNode, tailNode, topNode, temp;
    for (headNode = 0, tailNode = 1, topNode = 2;
         tailNode < (length - 1);
         tailNode++) {
      if ((topNode >= length) || (array[headNode] < array[topNode])) {
        temp = array[headNode];
        array[headNode++] = tailNode;
      } else {
        temp = array[topNode++];
      }

      if ((topNode >= length) ||
          ((headNode < tailNode) && (array[headNode] < array[topNode]))) {
        temp += array[headNode];
        array[headNode++] = tailNode + length;
      } else {
        temp += array[topNode++];
      }

      array[tailNode] = temp;
    }
  };

  /**
   * Finds the number of nodes to relocate in order to achieve a given code
   * length limit
   * @param array The code length array
   * @param maximumLength The maximum bit length for the generated codes
   * @return The number of nodes to relocate
   */
  var findNodesToRelocate = function(array, maximumLength) {
    var currentNode = array.length - 2;
    var currentDepth;
    for (currentDepth = 1;
         (currentDepth < (maximumLength - 1)) && (currentNode > 1);
         currentDepth++) {
      currentNode =  first (array, currentNode - 1, 0);
    }

    return currentNode;
  };


  /**
   * A final allocation pass with no code length limit
   * @param array The code length array
   */
  var allocateNodeLengths = function(array) {
    var firstNode = array.length - 2;
    var nextNode = array.length - 1;
    var currentDepth, availableNodes, lastNode, i;

    for (currentDepth = 1, availableNodes = 2;
         availableNodes > 0;
         currentDepth++) {
      lastNode = firstNode;
      firstNode = first (array, lastNode - 1, 0);

      for (i = availableNodes - (lastNode - firstNode); i > 0; i--) {
        array[nextNode--] = currentDepth;
      }

      availableNodes = (lastNode - firstNode) << 1;
    }
  };

  /**
   * A final allocation pass that relocates nodes in order to achieve a
   * maximum code length limit
   * @param array The code length array
   * @param nodesToMove The number of internal nodes to be relocated
   * @param insertDepth The depth at which to insert relocated nodes
   */
  var allocateNodeLengthsWithRelocation = function(array, nodesToMove,
                                                   insertDepth) {
    var firstNode = array.length - 2;
    var nextNode = array.length - 1;
    var currentDepth = (insertDepth == 1) ? 2 : 1;
    var nodesLeftToMove = (insertDepth == 1) ? nodesToMove - 2 : nodesToMove;
    var availableNodes, lastNode, offset, i;

    for (availableNodes = currentDepth << 1;
         availableNodes > 0;
         currentDepth++) {
      lastNode = firstNode;
      firstNode = (firstNode <= nodesToMove) ? firstNode : first (array, lastNode - 1, nodesToMove);

      offset = 0;
      if (currentDepth >= insertDepth) {
        offset = Math.min (nodesLeftToMove, 1 << (currentDepth - insertDepth));
      } else if (currentDepth == (insertDepth - 1)) {
        offset = 1;
        if ((array[firstNode]) == lastNode) {
          firstNode++;
        }
      }

      for (i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {
        array[nextNode--] = currentDepth;
      }

      nodesLeftToMove -= offset;
      availableNodes = (lastNode - firstNode + offset) << 1;
    }
  };

  /**
   * Allocates Canonical Huffman code lengths in place based on a sorted
   * frequency array
   * @param array On input, a sorted array of symbol frequencies; On output,
   *              an array of Canonical Huffman code lengths
   * @param maximumLength The maximum code length. Must be at least
   *                      {@code ceil(log2(array.length))}
   */
  // public
  var allocateHuffmanCodeLengths = function(array, maximumLength) {
    switch (array.length) {
    case 2:
      array[1] = 1;
    case 1:
      array[0] = 1;
      return;
    }

    /* Pass 1 : Set extended parent pointers */
    setExtendedParentPointers (array);

    /* Pass 2 : Find number of nodes to relocate in order to achieve
     *          maximum code length */
    var nodesToRelocate = findNodesToRelocate (array, maximumLength);

    /* Pass 3 : Generate code lengths */
    if ((array[0] % array.length) >= nodesToRelocate) {
      allocateNodeLengths (array);
    } else {
      var insertDepth = maximumLength - (Util.fls(nodesToRelocate - 1));
      allocateNodeLengthsWithRelocation (array, nodesToRelocate, insertDepth);
    }
  };

  return freeze({
    allocateHuffmanCodeLengths: allocateHuffmanCodeLengths
  });
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/LogDistanceModel.js":
/***/ (function(module, exports, __webpack_require__) {

/** Simple (log n)(n) distance model. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Util){

    // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
    // and must return an appropriate model or coder.
    var LogDistanceModel = function(size, extraStates,
                                    lgDistanceModelFactory,
                                    lengthBitsModelFactory) {
        var i;
        var bits = Util.fls(size-1);
        this.extraStates = +extraStates || 0;
        this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);
        // this.distanceModel[n] used for distances which are n-bits long,
        // but only n-1 bits are encoded: the top bit is known to be one.
        this.distanceModel = [];
        for (i=2 ; i <= bits; i++) {
            var numBits = i - 1;
            this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);
        }
    };
    /* you can give this model arguments between 0 and (size-1), or else
       a negative argument which is one of the 'extra states'. */
    LogDistanceModel.prototype.encode = function(distance) {
        if (distance < 2) { // small distance or an 'extra state'
            this.lgDistanceModel.encode(distance + this.extraStates);
            return;
        }
        var lgDistance = Util.fls(distance);
        console.assert(distance & (1<<(lgDistance-1))); // top bit is set
        console.assert(lgDistance >= 2);
        this.lgDistanceModel.encode(lgDistance + this.extraStates);
        // now encode the rest of the bits.
        var rest = distance & ((1 << (lgDistance-1)) - 1);
        this.distanceModel[lgDistance].encode(rest);
    };
    LogDistanceModel.prototype.decode = function() {
        var lgDistance = this.lgDistanceModel.decode() - this.extraStates;
        if (lgDistance < 2) {
            return lgDistance; // this is a small distance or an 'extra state'
        }
        var rest = this.distanceModel[lgDistance].decode();
        return (1 << (lgDistance-1)) + rest;
    };
    return LogDistanceModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Lzjb.js":
/***/ (function(module, exports, __webpack_require__) {

/* LZJB compression: http://en.wikipedia.org/wiki/LZJB */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Stream,Util) {
/**
$Id: Iuppiter.js 3026 2010-06-23 10:03:13Z Bear $

Copyright (c) 2010 Nuwa Information Co., Ltd, and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  3. Neither the name of Nuwa Information nor the names of its contributors
     may be used to endorse or promote products derived from this software
     without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

$Author: Bear $
$Date: 2010-06-23 18:03:13 +0800 (星期三, 23 六月 2010) $
$Revision: 3026 $
*/

var Lzjb = Object.create(null);
Lzjb.MAGIC = 'lzjb';

// Constants was used for compress/decompress function.
var NBBY = 8,
    MATCH_BITS = 6,
    MATCH_MIN = 3,
    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),
    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),
    LEMPEL_SIZE_BASE = 1024;
var EOF = Stream.EOF;

// set C_COMPAT to true if you need to decompress with the (untweaked) C lzjb
// implementation, which breaks if offset==0; the javascript
// implementation uses 0 to indicate an offset of OFFSET_MASK+1.
var C_COMPAT = true;

/**
 * Compress string or byte array using fast and efficient algorithm.
 *
 * Because of weak of javascript's natural, many compression algorithm
 * become useless in javascript implementation. The main problem is
 * performance, even the simple Huffman, LZ77/78 algorithm will take many
 * many time to operate. We use LZJB algorithm to do that, it suprisingly
 * fulfills our requirement to compress string fastly and efficiently.
 *
 * Our implementation is based on
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c
 * and
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c
 * It is licensed under CDDL.
 *
 * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array
 *        that you want to compress.
 * @param {stream} output Optional output stream.
 * @return {Array|Uint8Array|Buffer} Compressed byte array, or 'output'
 */
Lzjb.compressFile = Util.compressFileHelper(Lzjb.MAGIC, function(inStream, outStream, fileSize, props) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        hash, hp,
        lempel,
        i, j;
    var retval;

    // in an improvement over the original C implementation, we expand
    // the hash table to track a number of potential matches, not just the
    // most recent.  This doesn't require any changes to the decoder.
    // Sample impact on compression size (on wikipedia data):
    //  EXPAND  Time     Size      Option
    //    1   0m20.321s  50185613    -1
    //    2   0m22.437s  46503301    -2
    //    3   0m23.773s  45744564    -3
    //    4   0m25.666s  45199866    -4
    //    5   0m35.810s  44821413    -5
    //    6   0m40.947s  44666638    -6
    //    8   0m49.639s  44413865    -7
    //   12   0m49.927s  44124825    -8
    //   16   1m01.180s  43972515    -9
    //   32   1m30.530s  43554099
    //   64   2m14.504s  43005530
    //  128   3m43.570s  42361718
    //  256   6m38.681s  41684853
    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;
    var EXPAND = 1; // default to original C impl
    if (typeof(props)==='number') {
        LEMPEL_SIZE *= 2;
        props = Math.max(1, Math.min(9, props)) - 1;
        EXPAND = 1<<Math.floor(props/2);
        if (props&1) EXPAND = Math.round(EXPAND * 1.5);
        if (props >=2 && props <= 4) EXPAND++;
    }

    // use Uint16Array if available (zero-filled)
    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;
    var winput = function(_byte) {
        window[windowpos++] = _byte;
        if (windowpos >= window.length) {
            windowpos = 0;
        }
        return _byte;
    };

    var outwindow = Util.makeU8Buffer(17);
    var outpos = 0;
    var dumpout = function() {
        var i;
        for (i=0; i<outpos; i++) {
            outStream.writeByte(outwindow[i]);
        }
        outpos = 0;
    };

    var unbuffer = [];
    var get = function() {
        if (unbuffer.length)
            return unbuffer.pop();
        return inStream.readByte();
    };
    var unget = function(_byte) {
        unbuffer.push(_byte);
    };

    var copymask = 1 << (NBBY - 1);
    var matchpossibility = [];
    while (true) {
        var c1 = get();
        if (c1 === EOF) break;

        if ((copymask <<= 1) == (1 << NBBY)) {
            dumpout();
            copymask = 1;
            outwindow[0] = 0;
            outpos = 1;
        }

        var c2 = get();
        if (c2 === EOF) {
            outwindow[outpos++] = winput(c1);
            break;
        }
        var c3 = get();
        if (c3 === EOF) {
            outwindow[outpos++] = winput(c1);
            unget(c2);
            continue;
        }

        hash = (c1 << 16) + (c2 << 8) + c3;
        hash ^= (hash >> 9);
        hash += (hash >> 5);
        hash ^= c1;
        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;
        matchpossibility.length = 0;
        for (j=0; j<EXPAND; j++) {
            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;
            cpy = window.length + windowpos - offset;
            var w1 = window[cpy & OFFSET_MASK];
            var w2 = window[(cpy+1) & OFFSET_MASK];
            var w3 = window[(cpy+2) & OFFSET_MASK];
            // if offset is small, we might not have copied the tentative
            // bytes into the window yet.  (Note that offset=0 really means
            // offset=(OFFSET_MASK+1).)
            if (C_COMPAT && offset===0) {
                w1 = c1 ^ 1; // ensure match will fail
            } else if (offset==1) { w2 = c1; w3 = c2; }
            else if (offset==2) { w3 = c1; }
            if (c1 === w1 && c2 === w2 && c3 === w3) {
                matchpossibility.push(offset);
            }
        }
        // store this location in the hash, move the others over to make room
        // oldest match drops off
        for (j=EXPAND-1; j>0; j--)
            lempel[hp+j] = lempel[hp+j-1];
        lempel[hp] = windowpos;
        // did we find any matches?
        if (matchpossibility.length === 0) {
            outwindow[outpos++] = winput(c1);
            unget(c3);
            unget(c2);
        } else {
            // find the longest of the possible matches
            outwindow[0] |= copymask;
            winput(c1); winput(c2); winput(c3);
            var c4 = get(), last = matchpossibility[0];
            var base = window.length + windowpos;
            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {
                if (c4 === EOF) break;
                for (j=0; j < matchpossibility.length; ) {
                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];
                    if (c4 !== w4) {
                        last = matchpossibility[j];
                        matchpossibility.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (matchpossibility.length===0) break; // no more matches
                winput(c4);
                c4 = get();
            }
            if (matchpossibility.length !== 0) {
                // maximum length match, rock on!
                last = matchpossibility[0];
            }
            unget(c4);

            outwindow[outpos++] = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |
                (last >> NBBY);
            outwindow[outpos++] = last & 0xFF;
        }
    }
    dumpout();
});

/**
 * Decompress string or byte array using fast and efficient algorithm.
 *
 * Our implementation is based on
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c
 * and
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c
 * It is licensed under CDDL.
 *
 * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array
 *        that you want to decompress.
 * @param {stream} output Optional output stream.
 * @return {Array|Uint8Array|Buffer} Decompressed byte array, or 'output'
 */
Lzjb.decompressFile = Util.decompressFileHelper(Lzjb.MAGIC, function(inStream, outStream, outSize) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        i, c;
    var retval;

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;

    var copymask = 1 << (NBBY - 1);

    while (outSize !== 0) {
        c = inStream.readByte();
        if (c === EOF) break;

        if ((copymask <<= 1) == (1 << NBBY)) {
            copymask = 1;
            copymap = c;
            c = inStream.readByte();
        }
        if (copymap & copymask) {
            mlen = (c >> (NBBY - MATCH_BITS)) + MATCH_MIN;
            offset = ((c << NBBY) | inStream.readByte()) & OFFSET_MASK;
            cpy = windowpos - offset;
            if (cpy < 0) cpy += window.length;
            if (outSize >= 0) outSize -= mlen;
            while (--mlen >= 0) {
                c = window[windowpos++] = window[cpy++];
                outStream.writeByte(c);
                if (windowpos >= window.length) { windowpos=0; }
                if (cpy >= window.length) { cpy = 0; }
            }
        } else {
            outStream.writeByte(c);
            window[windowpos++] = c;
            if (windowpos >= window.length) { windowpos=0; }
            if (outSize >= 0) outSize--;
        }
    }
});


return Lzjb;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/LzjbR.js":
/***/ (function(module, exports, __webpack_require__) {

/* Tweaked version of LZJB, using range coder. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Context1Model.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/FenwickModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/LogDistanceModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/NoModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (Context1Model,FenwickModel,LogDistanceModel,NoModel,RangeCoder,Stream,Util){

var LzjbR = Object.create(null);
LzjbR.MAGIC = 'lzjR';

// Constants was used for compress/decompress function.
var NBBY = 8,
    MATCH_BITS = 6,
    MATCH_MIN = 3,
    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),
    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),
    LEMPEL_SIZE_BASE = 1024;
var LENGTH_MODEL_CUTOFF = 32;


/**
 * Compress using modified LZJB algorithm.  Instead of using the simple
 * 9-bit literal / 17-bit match format of the original, use a range
 * coder for the literal/match bit and for the offset and length.
 */
LzjbR.compressFile = Util.compressFileHelper(LzjbR.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        hash, hp,
        lempel,
        i, j;

    // in an improvement over the original C implementation of LZJB, we expand
    // the hash table to track a number of potential matches, not just the
    // most recent.  This doesn't require any changes to the decoder.
    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;
    var EXPAND = 1; // default to original C impl
    if (typeof(props)==='number') {
        LEMPEL_SIZE *= 2;
        props = Math.max(1, Math.min(9, props)) - 1;
        EXPAND = 1<<Math.floor(props/2);
        if (props&1) EXPAND = Math.round(EXPAND * 1.5);
        if (props >=2 && props <= 4) EXPAND++;
    }

    var encoder = new RangeCoder(outStream);
    encoder.encodeStart(finalByte, 1);

    // use Uint16Array if available (zero-filled)
    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;
    var winput = function(_byte) {
        window[windowpos++] = _byte;
        if (windowpos >= window.length) {
            windowpos = 0;
        }
        return _byte;
    };

    var unbuffer = [];
    var get = function() {
        if (unbuffer.length)
            return unbuffer.pop();
        return inStream.readByte();
    };
    var unget = function(_byte) {
        unbuffer.push(_byte);
    };

    var matchpossibility = [];
    var MATCH = 256;
    var EOF_SYM = 257;
    var noModelFactory = NoModel.factory(encoder);
    var modelFactory = FenwickModel.factory(encoder, 0xFF00, 0x100);
    var literalModel = new Context1Model(modelFactory, 256,
                                         ((fileSize<0) ? EOF_SYM : MATCH) + 1);
    var sparseModelFactory = function(size) {
        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }
        return noModelFactory(size);
    };
    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,
                                        modelFactory, sparseModelFactory);
    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,
                                        modelFactory, sparseModelFactory);
    var lastChar = 0x20, lastOffset = 0;
    while (true) {
        var initialPos = windowpos;
        var c1 = get();
        if (c1 === Stream.EOF) break;

        var c2 = get();
        if (c2 === Stream.EOF) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            break;
        }
        var c3 = get();
        if (c3 === Stream.EOF) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            unget(c2); lastChar = c1;
            continue;
        }

        hash = (c1 << 16) + (c2 << 8) + c3;
        hash ^= (hash >> 9);
        hash += (hash >> 5);
        hash ^= c1;
        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;
        matchpossibility.length = 0;
        for (j=0; j<EXPAND; j++) {
            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;
            cpy = window.length + windowpos - offset;
            var w1 = window[cpy & OFFSET_MASK];
            var w2 = window[(cpy+1) & OFFSET_MASK];
            var w3 = window[(cpy+2) & OFFSET_MASK];
            // if offset is small, we might not have copied the tentative
            // bytes into the window yet.  (Note that offset=0 really means
            // offset=(OFFSET_MASK+1).)
            if (offset==1) { w2 = c1; w3 = c2; }
            else if (offset==2) { w3 = c1; }
            if (c1 === w1 && c2 === w2 && c3 === w3) {
                matchpossibility.push(offset);
            }
        }
        // store this location in the hash, move the others over to make room
        // oldest match drops off
        for (j=EXPAND-1; j>0; j--)
            lempel[hp+j] = lempel[hp+j-1];
        lempel[hp] = windowpos;
        // did we find any matches?
        if (matchpossibility.length === 0) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            unget(c3);
            unget(c2);
            lastChar = c1;
        } else {
            literalModel.encode(MATCH, lastChar); // a match!
            // find the longest of the possible matches
            winput(c1); winput(c2); winput(c3); lastChar = c3;
            var c4 = get(), last = matchpossibility[0];
            var base = window.length + windowpos;
            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {
                if (c4 === Stream.EOF) break;
                for (j=0; j < matchpossibility.length; ) {
                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];
                    if (c4 !== w4) {
                        last = matchpossibility[j];
                        matchpossibility.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (matchpossibility.length===0) break; // no more matches
                winput(c4); lastChar = c4;
                c4 = get();
            }
            if (matchpossibility.length !== 0) {
                // maximum length match, rock on!
                last = matchpossibility[0];
            }
            unget(c4);

            // encode match length
            // XXX we could get a bit more compression if we allowed
            // the length to predict the offset (or vice-versa)
            lenModel.encode(mlen - MATCH_MIN);
            offset = (initialPos - last) & OFFSET_MASK;
            if (offset === lastOffset) {
                posModel.encode(-1); // common case!
            } else {
                posModel.encode(offset);
                lastOffset = offset;
            }
        }
    }
    if (fileSize < 0) {
        literalModel.encode(EOF_SYM, lastChar); // end of file (streaming)
    }
    encoder.encodeFinish();
}, true);

/**
 * Decompress using modified LZJB algorithm.
 */
LzjbR.decompressFile = Util.decompressFileHelper(LzjbR.MAGIC, function(inStream, outStream, outSize) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        i, c;

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;

    var decoder = new RangeCoder(inStream);
    decoder.decodeStart(true/* we already read the 'free' byte*/);

    var MATCH = 256;
    var EOF_SYM = 257;
    var noModelFactory = NoModel.factory(decoder);
    var modelFactory = FenwickModel.factory(decoder, 0xFF00, 0x100);
    var literalModel = new Context1Model(modelFactory, 256,
                                         ((outSize<0) ? EOF_SYM : MATCH) + 1);
    var sparseModelFactory = function(size) {
        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }
        return noModelFactory(size);
    };
    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,
                                        modelFactory, sparseModelFactory);
    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,
                                        modelFactory, sparseModelFactory);
    var lastChar = 0x20, lastOffset = 0;
    while (outSize !== 0) {
        c = literalModel.decode(lastChar);
        if (c === EOF_SYM) {
            break;
        } else if (c === MATCH) {
            mlen = lenModel.decode() + MATCH_MIN;
            cpy = posModel.decode();
            if (cpy<0) { cpy = lastOffset; }
            else       { lastOffset = cpy; }
            if (outSize >= 0) outSize -= mlen;
            while (--mlen >= 0) {
                c = lastChar = window[windowpos++] = window[cpy++];
                outStream.writeByte(c);
                if (windowpos >= window.length) { windowpos=0; }
                if (cpy >= window.length) { cpy = 0; }
            }
        } else {
            outStream.writeByte(c);
            window[windowpos++] = lastChar = c;
            if (windowpos >= window.length) { windowpos=0; }
            if (outSize >= 0) outSize--;
        }
    }
    decoder.decodeFinish();
});


return LzjbR;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Lzp3.js":
/***/ (function(module, exports, __webpack_require__) {

/* Implementation of LZP3(ish), with an adaptive Huffman code or a range
 * coder (instead of LZP3's original static Huffman code).
 * See: http://www.cbloom.com/papers/lzp.pdf
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Context1Model.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/DefSumModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/FenwickModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Huffman.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/LogDistanceModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/NoModel.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream, Context1Model, DefSumModel, FenwickModel, Huffman, LogDistanceModel, NoModel, RangeCoder, Stream, Util){

var Lzp3 = Object.create(null);
Lzp3.MAGIC = 'lzp3';

// use Huffman coder (fast) or else use range coder (slow)
var USE_HUFFMAN_CODE = false;
// use deferred-sum model, which is supposed to be faster (but compresses worse)
var USE_DEFSUM = false;
// when to give up attempting to model the length
var LENGTH_MODEL_CUTOFF = 256;
var MODEL_MAX_PROB = 0xFF00;
var MODEL_INCREMENT = 0x100;

// Constants was used for compress/decompress function.
var CTXT4_TABLE_SIZE = 1 << 16;
var CTXT3_TABLE_SIZE = 1 << 12;
var CTXT2_TABLE_SIZE = 1 << 16;
var CONTEXT_LEN = 4;
var LOG_WINDOW_SIZE = 20;
var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;
var MAX_MATCH_LEN = WINDOW_SIZE-1;
var MATCH_LEN_CONTEXTS = 16;

var MAX32 = 0xFFFFFFFF;
var MAX24 = 0x00FFFFFF;
var MAX16 = 0x0000FFFF;
var MAX8  = 0x000000FF;


var Window = function(maxSize) {
  this.buffer = Util.makeU8Buffer(Math.min(maxSize+4, WINDOW_SIZE));
  this.pos = 0;
  // context-4 hash table.
  this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);
  // context-3 hash table
  this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);
  // context-2 table (not really a hash any more)
  this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);
  // initial context
  this.put(0x63); this.put(0x53); this.put(0x61); this.put(0x20);
};
Window.prototype.put = function(_byte) {
  this.buffer[this.pos++] = _byte;
  if (this.pos >= WINDOW_SIZE) { this.pos = 0; }
  return _byte;
};
Window.prototype.get = function(pos) {
  return this.buffer[pos & (WINDOW_SIZE-1)];
};
Window.prototype.context = function(pos, n) {
  var c = 0, i;
  pos = (pos - n) & (WINDOW_SIZE-1);
  for (i=0; i<n; i++) {
    c = (c << 8) | this.buffer[pos++];
    if (pos >= WINDOW_SIZE) { pos = 0; }
  }
  return c;
};
// if matchLen !== 0, update the index; otherwise get index value.
Window.prototype.getIndex = function(s, matchLen) {
  var c = this.context(s, 4);
  // compute context hashes
  var h4 = ((c>>>15) ^ c) & (CTXT4_TABLE_SIZE-1);
  var h3 = ((c>>>11) ^ c) & (CTXT3_TABLE_SIZE-1);
  var h2 = c & MAX16;
  // check order-4 context
  var p = 0, checkc;
  // only do context confirmation if matchLen==0 (that is, if we're not just
  // doing an update)
  if (matchLen===0) {
    p = this.ctxt4[h4];
    if (p !== 0 && c !== this.context(p-1, 4)) {
      p = 0; // context confirmation failed
    }
    if (p === 0) {
      // check order-3 context
      p = this.ctxt3[h3];
      if (p !== 0 && (c & MAX24) !== this.context(p-1, 3)) {
        p = 0; // context confirmation failed
      }
      if (p === 0) {
        // check order-2 context
        p = this.ctxt2[h2];
        if (p !== 0 && (c && MAX16) !== this.context(p-1, 2)) {
          p = 0; // context confirmation failed
        }
      }
    }
  }
  // update context index
  if (matchLen) { matchLen--; }
  this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =
    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;
  // return lookup result.
  return p;
};

/**
 * Compress using modified LZP3 algorithm.  Instead of using static
 * Huffman coding, we use an adaptive Huffman code or range encoding.
 */
Lzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {
  // sliding window & hash table
  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );

  var coderFactory, sparseCoderFactory, flush;

  if (USE_HUFFMAN_CODE) {
    // Huffman contexts
    outStream.writeByte(0x80); // mark that this is Huffman coded.
    var bitstream = new BitStream(outStream);
    flush = bitstream.flush.bind(bitstream);
    coderFactory = Huffman.factory(bitstream, MAX16);
    sparseCoderFactory = NoModel.factory(bitstream);

  } else { // range encoder
    var range = new RangeCoder(outStream);
    range.encodeStart(0x00, 0); // 0x00 == range encoded

    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
    if (USE_DEFSUM) {
      coderFactory = DefSumModel.factory(range, false /* encoder */);
    }
    // switch sparseCoderFactory to a NoModel when size > cutoff
    var noCoderFactory = NoModel.factory(range);
    sparseCoderFactory = function(size) {
      if (size > LENGTH_MODEL_CUTOFF) {
        return noCoderFactory(size);
      }
      return coderFactory(size);
    };
    flush = function() { range.encodeFinish(); };
  }

  var huffLiteral= new Context1Model(coderFactory, 256,
                                     (fileSize<0) ? 257 : 256);
  var huffLen = [], i;
  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {
    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,
                                      coderFactory, sparseCoderFactory);
  }

  var inSize = 0, s, matchContext = 0;
  while (inSize !== fileSize) {
    var ch = inStream.readByte();
    s = window.pos;
    var p = window.getIndex(s, 0);
    if (p !== 0) {
      // great, a match! how long is it?
      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
      var matchLen = 0;
      while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {
        matchLen++;
        window.put(ch);
        ch = inStream.readByte();
      }
      // code match length; match len = 0 means "literal"
      // use "extra state" -1 to mean "same as previous match length"
      if (prevMatchLen===matchLen) {
        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(-1);
      } else {
        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(matchLen);
      }
      // update hash with this match
      window.getIndex(s, matchLen);
      inSize += matchLen;
      matchContext <<= 1;
      if (matchLen > 0) { matchContext |= 1; }
      // XXX: LZMA uses a special "delta match" context here if matchLen==0
      // XXX: it also uses the offset as context for the length (or vice-versa)
    }
    // always encode a literal after a match
    var context1 = window.get(window.pos-1);
    if (ch===Stream.EOF) {
      if (fileSize < 0) {
        huffLiteral.encode(256, context1);
      }
      break;
    }
    huffLiteral.encode(ch, context1);
    window.put(ch);
    inSize++;
  }
  if (flush) flush();
});

/**
 * Decompress using modified LZP3 algorithm.
 */
Lzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {
  var flags = inStream.readByte();
  var use_huffman_code = !!(flags & 0x80);

  // sliding window & hash table
  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );

  var coderFactory, sparseCoderFactory, finish;

  if (use_huffman_code) {
    // Huffman contexts
    var bitstream = new BitStream(inStream);
    coderFactory = Huffman.factory(bitstream, MAX16);
    sparseCoderFactory = NoModel.factory(bitstream);
  } else { // range encoder
    var range = new RangeCoder(inStream);
    range.decodeStart(true/* skip initial read */);
    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
    if (USE_DEFSUM) {
      coderFactory = DefSumModel.factory(range, true /* decoder */);
    }
    // switch sparseCoderFactory to a NoModel when size > cutoff
    var noCoderFactory = NoModel.factory(range);
    sparseCoderFactory = function(size) {
      if (size > LENGTH_MODEL_CUTOFF) {
        return noCoderFactory(size);
      }
      return coderFactory(size);
    };
    finish = function() { range.decodeFinish(); };
  }

  var huffLiteral= new Context1Model(coderFactory, 256,
                                     (fileSize<0) ? 257 : 256);
  var huffLen = [], i;
  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {
    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,
                                      coderFactory, sparseCoderFactory);
  }

  var s, ch, outSize = 0, matchContext = 0;
  while (outSize !== fileSize) {
    s = window.pos;
    var p = window.getIndex(s, 0);
    if (p !== 0) {
      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
      var matchLen = huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].decode();
      if (matchLen < 0) { matchLen = prevMatchLen; }
      // copy characters!
      for (i=0; i<matchLen; i++) {
        ch = window.get(p + i);
        outStream.writeByte(window.put(ch));
      }
      window.getIndex(s, matchLen);
      outSize += matchLen;
      matchContext <<= 1;
      if (matchLen > 0) matchContext |= 1;
    }
    // literal always follows match (or failed match)
    if (outSize === fileSize) {
      break; // EOF
    }
    var context1 = window.get(window.pos-1);
    ch = huffLiteral.decode(context1);
    if (ch === 256) {
      break; // EOF
    }
    outStream.writeByte(window.put(ch));
    outSize++;
  }
  if (finish) finish();
});


return Lzp3;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/MTFModel.js":
/***/ (function(module, exports, __webpack_require__) {

/** Simple range coding model w/ escape, suitable for sparse symbol sets.
 *  Uses a move-to-front list, which is simple and relatively performant,
 *  but slows down a lot if you want to try to model escapes more precisely
 *  (which is why this feature is disabled by default).
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){

var DEFAULT_MAX_PROB = 0xFF00;
var DEFAULT_INCREMENT= 0x0100;

var NUMERIC_SORT = function(a, b) { return a - b; };

var MTFModel = function(coder, size, max_prob, increment, betterEscape) {
    this.coder = coder;
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);
    this.sym = Util.makeU16Buffer(size+1);
    this.prob= Util.makeU16Buffer(size+2);
    this.sym[0] = size; // escape code
    this.prob[0]= 0;
    this.seenSyms = 1;
    // total probability always found in this.prob[this.seenSyms]
    this.prob[this.seenSyms] = this.increment;
    this.numSyms = size;
    if (betterEscape) {
        this.sortedSeen = [size];
    }
};
MTFModel.factory = function(coder, max_prob, increment, betterEscape) {
    return function(size) {
        return new MTFModel(coder, size, max_prob, increment, betterEscape);
    };
};
MTFModel.prototype.clone = function() {
    var newModel = new MTFModel(this.coder, this.numSyms, this.max_prob,
                                this.increment, !!this.sortedSeen);
    var i;
    for (i=0; i<this.seenSyms; i++) {
        newModel.sym[i] = this.sym[i];
        newModel.prob[i] = this.prob[i];
    }
    newModel.prob[i] = this.prob[i]; // total probability
    newModel.seenSyms = this.seenSyms;
    if (this.sortedSeen) {
        newModel.sortedSeen = this.sortedSeen.slice(0);
    }
    return newModel;
};
MTFModel.prototype._update = function(symbol, index, sy_f) {
    var j, tot_f;
    // move this symbol to the end
    for (j=index; j<this.seenSyms-1; j++) {
        this.sym[j] = this.sym[j+1];
        this.prob[j] = this.prob[j+1] - sy_f;
    }
    if (index < this.seenSyms) {
        this.sym[j] = symbol;
        this.prob[j] = this.prob[j+1] - sy_f;
        // increase frequency for this symbol, and total freq at same time
        this.prob[this.seenSyms] = tot_f =
            this.prob[this.seenSyms] + this.increment;
        if (symbol === this.numSyms && this.seenSyms >= this.numSyms) {
            // this is the last time we'll see an escape! remove it.
            tot_f = this.prob[--this.seenSyms];
            if (this.sortedSeen) { this.sortedSeen.length--; }
        }
    } else { // add to the end
        tot_f = this.prob[this.seenSyms];
        this.sym[index] = symbol;
        this.prob[index] = tot_f;
        tot_f += this.increment;
        this.prob[++this.seenSyms] = tot_f;
        if (this.sortedSeen) {
            this.sortedSeen.push(symbol);
            // hopefully sort is very fast on a mostly-sorted array
            this.sortedSeen.sort(NUMERIC_SORT);
        }
    }
    if (tot_f >= this.max_prob) { this._rescale(); }
    return;
};
MTFModel.prototype._rescale = function() {
    var i, j, total=0;
    var noEscape = true;
    if (this.sortedSeen) { this.sortedSeen.length = 0; }
    for(i=0, j=0; i<this.seenSyms; i++) {
        var sym = this.sym[i];
        var sy_f = this.prob[i+1] - this.prob[i];
        sy_f >>>= 1;
        if (sy_f > 0) {
            if (sym === this.numSyms) {
                noEscape = false;
            }
            this.sym[j] = sym;
            this.prob[j++] = total;
            total += sy_f;
            if (this.sortedSeen) { this.sortedSeen.push(sym); }
        }
    }
    this.prob[j] = total;
    this.seenSyms = j;
    if (this.sortedSeen) {
        this.sortedSeen.sort(NUMERIC_SORT);
    }
    // don't allow escape to go to zero prob if we still need it
    if (noEscape && this.seenSyms < this.numSyms) {
        // NOTE this adds this.increment to escape freq; the FenwickModel
        //      just adds one.
        this._update(this.numSyms/*escape*/, this.seenSyms/*at end*/);
    }
};
MTFModel.prototype.decode = function() {
    var tot_f = this.prob[this.seenSyms];
    var prob = this.coder.decodeCulFreq(tot_f);
    // we're expecting to find the probability near the "most recent" side
    // of our array
    var i;
    for (i=this.seenSyms-1; i>=0; i--) {
        if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)
            break;
    }
    console.assert(i>=0);
    var symbol = this.sym[i];
    var lt_f = this.prob[i];
    var sy_f = this.prob[i + 1] - lt_f;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    this._update(symbol, i, sy_f);
    if (symbol === this.numSyms) {
        /* this is an escape */
        /* decode the literal */
        sy_f = 1;
        tot_f = this.numSyms;
        if (this.sortedSeen) {
            // do a slower, but more precise decoding of the literal
            // by excluding the already-seen symbols.
            var seen = this.sortedSeen;
            tot_f = this.numSyms - this.seenSyms;
            if (seen[seen.length-1] === this.numSyms) { tot_f++; }
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
            for (i=0; i < seen.length && seen[i] <= symbol ; i++) {
                symbol++;
            }
        } else {
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
        }
        this.coder.decodeUpdate(sy_f, lt_f, tot_f);
        this._update(symbol, this.seenSyms);
    }
    return symbol;
};
MTFModel.prototype.encode = function(symbol) {
    // look for symbol, from most-recent to oldest
    var i, sy_f, lt_f, tot_f;
    for (i=this.seenSyms-1; i>=0; i--) {
        if (symbol === this.sym[i]) {
            // ok, found it.
            lt_f = this.prob[i];
            sy_f = this.prob[i + 1] - lt_f;
            tot_f = this.prob[this.seenSyms];
            this.coder.encodeFreq(sy_f, lt_f, tot_f);
            return this._update(symbol, i, sy_f);
        }
    }
    // couldn't find this symbol.  encode as escape.
    console.assert(symbol !== this.numSyms); // catch infinite recursion
    this.encode(this.numSyms); // guaranteed to be found in the table.
    // code symbol as literal
    sy_f = 1;
    lt_f = symbol;
    tot_f = this.numSyms;
    if (this.sortedSeen) {
        // do a slower, but more precise encoding of the literal
        // by excluding the already-seen symbols.
        var seen = this.sortedSeen;
        tot_f -= this.seenSyms;
        if (seen[seen.length-1] === this.numSyms) { tot_f++; }
        for (i=0; i < seen.length && seen[i] < symbol; i++) {
            lt_f--;
        }
    }
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // now add symbol to the end.
    return this._update(symbol, this.seenSyms);
};

MTFModel.MAGIC = 'mtfm';
/** Simple order-0 compressor, as self-test. */
MTFModel.compressFile = Util.compressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
}, true);

/** Simple order-0 decompresser, as self-test. */
MTFModel.decompressFile = Util.decompressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*we already read the 'free' byte*/);
  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

return MTFModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/NoModel.js":
/***/ (function(module, exports, __webpack_require__) {

/** Simple "lack of model" -- just encode the bits directly.
 *  Useful especially with sparse spaces or Huffman coders where there's
 *  no obvious prediction to be made that will pay for itself.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/BitStream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (BitStream,Util) {

var NoModel = function(bitstream, size) {
  this.bitstream = bitstream;
  this.bits = Util.fls(size-1);
};
NoModel.factory = function(bitstream) {
  return function(size) { return new NoModel(bitstream, size); };
};
NoModel.prototype.encode = function(symbol) {
  var i;
  for (i=this.bits-1; i>=0; i--) {
    var b = (symbol >>> i) & 1;
    this.bitstream.writeBit(b);
  }
};
NoModel.prototype.decode = function() {
  var i, r = 0;
  for (i=this.bits-1; i>=0; i--) {
    r <<= 1;
    if (this.bitstream.readBit()) r++;
  }
  return r;
};

/** Brain-dead self-test. */
NoModel.MAGIC = 'nomo';
NoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {
    var bitstream = new BitStream(outStream);
    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    bitstream.flush();
});
NoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {
    var bitstream = new BitStream(inStream);
    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
});

return NoModel;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/PPM.js":
/***/ (function(module, exports, __webpack_require__) {

/** Particularly simple-minded implementation of PPM compression. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Util) {

  var MAX_CONTEXT = 5;
  var LOG_WINDOW_SIZE = 18;
  var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;

  var Window = function() {
    this.buffer = Util.makeU8Buffer(WINDOW_SIZE);
    this.pos = 0;
    this.firstPass = true;
    for (var i=0; i<MAX_CONTEXT; i++) {
      this.put('cSaCsA'.charCodeAt(i%6));
    }
  };
  Window.prototype.put = function(_byte) {
    this.buffer[this.pos++] = _byte;
    if (this.pos >= WINDOW_SIZE) { this.pos = 0; this.firstPass = false; }
    return _byte;
  };
  Window.prototype.get = function(pos) {
    return this.buffer[pos & (WINDOW_SIZE-1)];
  };
  // the context ending just before 'pos'
  Window.prototype.context = function(pos, n) {
    var c = [], i;
    pos = (pos - n) & (WINDOW_SIZE-1);
    for (i=0; i<n; i++) {
      c.push(this.buffer[pos++]);
      if (pos >= WINDOW_SIZE) { pos = 0; }
    }
    return String.fromCharCode.apply(String, c);
  };

  var DMM_INCREMENT = 0x100, DMM_MAX_PROB = 0xFF00;

  var PPM = function(coder, size) {
    this.window = new Window();
    this.contexts = Object.create(null);
    // brain-dead '-1' context, using full exclusion
    var Cm1Context = function() { };
    Cm1Context.prototype.encode = function(symbol, exclude) {
      var i, lt_f = 0;
      for (i=0; i<symbol; i++) {
        if (!exclude[i]) {
          lt_f++;
        }
      }
      var tot_f = size - exclude.total;
      coder.encodeFreq(1, lt_f, tot_f);
    };
    Cm1Context.prototype.decode = function(exclude) {
      var i, symbol, lt_f;
      var tot_f = size - exclude.total;
      symbol = lt_f = coder.decodeCulFreq(tot_f);
      for (i=0; i<=symbol; i++) {
        if (exclude[i]) {
          symbol++;
        }
      }
      coder.decodeUpdate(1, lt_f, tot_f);
      return symbol;
    };
    this.cm1coder = new Cm1Context();

    var DenseMTFModel = function() {
      this.sym = [size];
      this.prob= [0, DMM_INCREMENT];
      this.refcount = 0;
    };
    DenseMTFModel.prototype._rescale = function() {
      var seenSyms = this.sym.length;
      var i, j, total=0;
      var noEscape = true;
      for(i=0, j=0; i<seenSyms; i++) {
        var sym = this.sym[i];
        var sy_f = this.prob[i+1] - this.prob[i];
        sy_f >>>= 1;
        if (sy_f > 0) {
          if (sym === size) {
            noEscape = false;
          }
          this.sym[j] = sym;
          this.prob[j++] = total;
          total += sy_f;
        }
      }
      this.prob[j] = total;
      seenSyms = this.sym.length = j;
      this.prob.length = seenSyms + 1;
      // don't allow escape to go to zero prob if we still need it
      if (noEscape && seenSyms < size) {
        total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);
      }
      return total;
    };
    DenseMTFModel.prototype.update = function(symbol, incr) {
      // find symbol
      var i=0;
      for (i=0; i<this.sym.length; i++) {
        if (this.sym[i] === symbol) {
          return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);
        }
      }
      // symbol escaped
      return this._update(symbol, i, 0, incr);
    };
    DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {
      var seenSyms = this.sym.length;
      var i, j, tot_f;
      // move this symbol to the end
      for (j=index; j<seenSyms-1; j++) {
        this.sym[j] = this.sym[j+1];
        this.prob[j] = this.prob[j+1] - sy_f;
      }
      // "method D" -- if we add a new escaped symbol, escape & the symbol
      // both increase by 1/2.
      if (index < seenSyms) {
        this.sym[j] = symbol;
        this.prob[j] = this.prob[j+1] - sy_f;
        // increase frequency for this symbol, and total freq at same time
        this.prob[seenSyms] = tot_f =
          this.prob[seenSyms] + incr;
      } else { // add to the end
        tot_f = this.prob[seenSyms];
        this.sym[index] = symbol;
        this.prob[index] = tot_f;
        tot_f += incr;
        this.prob[++seenSyms] = tot_f;
        // remove probability of escape if table just filled up
        if (this.sym.length > size) {
          for (i=0; i<seenSyms; i++) {
            if (size === this.sym[i]) {
              // found it.
              this._update(size, i, this.prob[i+1] - this.prob[i], -1);
              this.sym.length--;
              this.prob.length--;
              tot_f = this.prob[this.prob.length-1];
            }
          }
        }
      }
      if (tot_f >= DMM_MAX_PROB) { tot_f = this._rescale(); }
      return tot_f;
    };
    DenseMTFModel.prototype.encode = function(symbol, exclude) {
      // look for symbol, from most-recent to oldest
      var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;
      var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
      for (i=seenSyms-1; i>=0; i--) {
        lt_f = this.prob[i];
        sy_f = this.prob[i + 1] - lt_f;
        if (symbol === this.sym[i]) {
          // ok, found it.
          // count up the rest of the probabilities
          for (j=i-1; j>=0 && ex_seen < exclude.total; j--) {
            if (exclude[this.sym[j]]) {
              ex_seen += 1;
              ex_sy_f = this.prob[j+1] - this.prob[j];
              ex_lt_f += ex_sy_f;
              ex_tot_f += ex_sy_f;
            }
          }
          tot_f = this.prob[seenSyms];
          // adjust by excluded symbols
          lt_f -= ex_lt_f;
          tot_f -= ex_tot_f;
          coder.encodeFreq(sy_f, lt_f, tot_f);
          if (symbol === size) { // only update table for escapes
            this._update(symbol, i, sy_f, DMM_INCREMENT/2);
            return false; // escape.
          } // otherwise we'll do update later
          return true; // encoded character!
        } else if (exclude[this.sym[i]]) {
          ex_seen += 1;
          ex_tot_f += sy_f;
        }
      }
      // couldn't find this symbol.  encode as escape.
      this.encode(size, exclude);
      // add symbols to exclusion table
      console.assert(this.sym[this.sym.length-1] === size);//escape
      for (i=0; i<this.sym.length-1; i++) {
        if (!exclude[this.sym[i]]) {
          exclude[this.sym[i]] = true;
          exclude.total++;
        }
      }
    };
    DenseMTFModel.prototype.decode = function(exclude) {
      var seenSyms = this.sym.length;
      var tot_f = this.prob[seenSyms];
      var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
      var i;
      for (i=seenSyms-1; i>=0 && ex_seen < exclude.total; i--) {
        if (exclude[this.sym[i]]) {
          ex_seen += 1;
          ex_tot_f += this.prob[i+1] - this.prob[i];
        }
      }
      var prob = coder.decodeCulFreq(tot_f - ex_tot_f) + ex_tot_f;
      // we're expecting to find the probability near the "most recent" side
      // of our array
      ex_lt_f = ex_tot_f;
      for (i=seenSyms-1; i>=0; i--) {
        if (exclude[this.sym[i]]) {
          ex_sy_f = this.prob[i+1] - this.prob[i];
          ex_lt_f -= ex_sy_f;
          prob -= ex_sy_f;
        } else if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)
          break;
      }
      console.assert(i>=0);
      var symbol = this.sym[i];
      var lt_f = this.prob[i];
      var sy_f = this.prob[i + 1] - lt_f;
      coder.decodeUpdate(sy_f, lt_f - ex_lt_f, tot_f - ex_tot_f);
      // defer update
      if (symbol < size) { return symbol; }
      // an escape
      this._update(symbol, i, sy_f, DMM_INCREMENT/2);
      // add symbols to exclusion table
      console.assert(this.sym[this.sym.length-1] === size);//escape
      for (i=0; i<this.sym.length-1; i++) {
        if (!exclude[this.sym[i]]) {
          exclude[this.sym[i]] = true;
          exclude.total++;
        }
      }
      return -1;
    };
    this.newContext = function(initialSymbol) {
      return new DenseMTFModel();
    };
    this.newExclude = function() {
      var result = Object.create(null);
      result.total = 0; // no excluded symbols (yet)
      return result;
    };
    // set up some initial contexts
    (function() {
      var i, j;
      for (i=0; i<MAX_CONTEXT; i++) {
        for (j=0; j<=i; j++) {
          var cc = this.window.context(j+((MAX_CONTEXT-1)-i), j);
          if (!this.contexts[cc]) { this.contexts[cc] = this.newContext(); }
          this.contexts[cc].refcount++;
        }
      }
    }).call(this);
  };
  PPM.prototype.update = function(symbol, contextString, matchLevel) {
    // slide up the contexts, updating them
    var model, c, cc;
    for (c=0; c <= MAX_CONTEXT; c++) {
      cc = contextString.slice(MAX_CONTEXT - c);
      model = this.contexts[cc];
      if (!model) {
        model = this.contexts[cc] = this.newContext();
      }
      if (c >= matchLevel) {
        // only update useful contexts
        model.update(symbol, DMM_INCREMENT / 2);
      }
      // refcount all contexts, whether used/updated or not
      model.refcount++;
    }
    // now garbage-collect old contexts
    contextString = this.window.context(this.window.pos + MAX_CONTEXT,
                                        MAX_CONTEXT);
    var firstPass = this.window.firstPass;
    for (c=MAX_CONTEXT; c>=0 && !firstPass; c--) {
      cc = contextString.slice(0, c);
      model = this.contexts[cc];
      console.assert(model);
      if ((--model.refcount) <= 0) {
        console.assert(cc !== ''); // don't allow context-0 to be gc'ed!
        delete this.contexts[cc];
      }
    }
    // ok, advance window.
    this.window.put(symbol);
  };
  PPM.prototype.decode = function() {
    var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
    var exclude = this.newExclude();
    var model, c, cc, symbol;
    for (c=MAX_CONTEXT; c>=0; c--) {
      cc = contextString.slice(MAX_CONTEXT - c);
      model = this.contexts[cc];
      if (model) {
        symbol = model.decode(exclude);
        if (symbol >= 0) {
          this.update(symbol, contextString, c);
          return symbol;
        }
      }
    }
    // still no match, fall back to context -1
    symbol = this.cm1coder.decode(exclude);
    this.update(symbol, contextString, c);
    return symbol;
  };
  PPM.prototype.encode = function(symbol) {
    var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
    var exclude = this.newExclude();
    var c;
    for (c=MAX_CONTEXT; c>=0; c--) {
      var cc = contextString.slice(MAX_CONTEXT - c);
      var model = this.contexts[cc];
      if (model) {
        var success = model.encode(symbol, exclude);
        if (success) {
          this.update(symbol, contextString, c);
          return;
        }
      }
    }
    // fall back to context -1 (but still use exclusion table)
    this.cm1coder.encode(symbol, exclude);
    this.update(symbol, contextString, c);
    return;
  };

  PPM.MAGIC = 'ppm2';
  PPM.compressFile = Util.compressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var range = new RangeCoder(outStream);
    range.encodeStart(finalByte, 1);
    var model = new PPM(range, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    range.encodeFinish();
  }, true);
  PPM.decompressFile = Util.decompressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize) {
    var range = new RangeCoder(inStream);
    range.decodeStart(true/*we already read the 'free' byte*/);
    var model = new PPM(range, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
    range.decodeFinish();
  });

  return PPM;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js":
/***/ (function(module, exports) {

/* Range Coder.  Inspired by rangecod.c from rngcod13.zip from
 *    http://www.compressconsult.com/rangecoder/
 * This JavaScript version is:
 *    Copyright (c) 2013 C. Scott Ananian.
 */
var libs = [
];
var body_fn = function (){

    // Uses 32-bit integer math.  Hopefully the JavaScript runtime figures
    // that out. ;)
    // see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript
    // for some hints on doing 32-bit unsigned match in JavaScript.
    // One key is the use of ">>>0" to change a signed result to unsigned.
    var CODE_BITS = 32;
    var Top_value = Math.pow(2, CODE_BITS-1);
    var SHIFT_BITS = (CODE_BITS - 9);
    var EXTRA_BITS = ((CODE_BITS-2) % 8 + 1);
    var Bottom_value = (Top_value >>> 8);

    var MAX_INT = Math.pow(2, CODE_BITS) - 1;

    /* it is highly recommended that the total frequency count is less  */
    /* than 1 << 19 to minimize rounding effects.                       */
    /* the total frequency count MUST be less than 1<<23                */


    var RangeCoder = function(stream) {
        this.low = 0; /* low end of interval */
        this.range = Top_value; /* length of interval */
        this.buffer = 0; /* buffer for input/output */
        this.help = 0; /* bytes_to_follow / intermediate value */
        this.bytecount = 0; /* counter for output bytes */
        this.stream = stream;
    };

    /* Do the normalization before we need a defined state, instead of
     * after messing it up.  This simplifies starting and ending. */
    var enc_normalize = function(rc, outputStream) {
        while (rc.range <= Bottom_value) { /* do we need renormalization? */
            if (rc.low < (0xFF << SHIFT_BITS)) {//no carry possible, so output
                outputStream.writeByte(rc.buffer);
                for (; rc.help; rc.help--)
                    outputStream.writeByte(0xFF);
                rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
            } else if (rc.low & Top_value) { /* carry now, no future carry */
                outputStream.writeByte(rc.buffer+1);
                for (; rc.help; rc.help--)
                    outputStream.writeByte(0x00);
                rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
            } else {
                rc.help++;
                if (rc.help > MAX_INT)
                    throw new Error("Too many bytes outstanding, "+
                                    "file too large!");
            }
            rc.range = (rc.range << 8) >>> 0;/*ensure result remains positive*/
            rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned */
            rc.bytecount++;
        }
    };

    /* Start the encoder                                         */
    /* c is written as the first byte in the datastream.
     * one could do w/o, but then you have an additional if per output byte */
    RangeCoder.prototype.encodeStart = function(c, initlength) {
        this.low = 0;
        this.range = Top_value;
        this.buffer = c;
        this.help = 0;
        this.bytecount = initlength;
    };

   /* Encode a symbol using frequencies                         */
    /* rc is the range coder to be used                          */
    /* sy_f is the interval length (frequency of the symbol)     */
    /* lt_f is the lower end (frequency sum of < symbols)        */
    /* tot_f is the total interval length (total frequency sum)  */
    /* or (faster): tot_f = (code_value)1<<shift                             */
    RangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {
        enc_normalize(this, this.stream);
        var r = (this.range / tot_f) >>> 0; // note coercion to integer
        var tmp = r * lt_f;
        this.low += tmp;
        if ((lt_f + sy_f) < tot_f) {
            this.range = r * sy_f;
        } else {
            this.range -= tmp;
        }
    };
    RangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {
        enc_normalize(this, this.stream);
        var r = this.range >>> shift;
        var tmp = r * lt_f;
        this.low += tmp;
        if ((lt_f + sy_f) >>> shift) {
            this.range -= tmp;
        } else {
            this.range = r * sy_f;
        }
    };
    /* Encode a bit w/o modelling. */
    RangeCoder.prototype.encodeBit = function(b) {
        this.encodeShift(1, b?1:0, 1);
    };
    /* Encode a byte w/o modelling. */
    RangeCoder.prototype.encodeByte = function(b) {
        this.encodeShift(1, b, 8);
    };
    /* Encode a short w/o modelling. */
    RangeCoder.prototype.encodeShort = function(s) {
        this.encodeShift(1, s, 16);
    };

    /* Finish encoding                                           */
    /* returns number of bytes written                           */
    RangeCoder.prototype.encodeFinish = function() {
        var outputStream = this.stream;
        enc_normalize(this, outputStream);
        this.bytecount += 5;
        var tmp = this.low >>> SHIFT_BITS;
        if ((this.low & (Bottom_value-1)) >= ((this.bytecount&0xFFFFFF)>>>1)) {
            tmp++;
        }
        if (tmp > 0xFF) { /* we have a carry */
            outputStream.writeByte(this.buffer + 1);
            for (; this.help; this.help--)
                outputStream.writeByte(0x00);
        } else { /* no carry */
            outputStream.writeByte(this.buffer);
            for (; this.help; this.help--)
                outputStream.writeByte(0xFF);
        }
        outputStream.writeByte(tmp & 0xFF);
        // XXX: i'm pretty sure these could be three arbitrary bytes
        //      they are consumed by the decoder at the end
        outputStream.writeByte((this.bytecount >>> 16) & 0xFF);
        outputStream.writeByte((this.bytecount >>>  8) & 0xFF);
        outputStream.writeByte((this.bytecount       ) & 0xFF);
        return this.bytecount;
    };

    /* Start the decoder; you need to provide the *second* byte from the
     * datastream. (The first byte was provided to startEncoding and is
     * ignored by the decoder.)
     */
    RangeCoder.prototype.decodeStart = function(skipInitialRead) {
        var c = skipInitialRead ? 0 : this.stream.readByte();
        if (typeof(c) !== 'number' || c < 0) {
            return c; // EOF
        }
        this.buffer = this.stream.readByte();
        this.low = this.buffer >>> (8 - EXTRA_BITS);
        this.range = 1 << EXTRA_BITS;
        return c;
    };

    var dec_normalize = function(rc, inputStream) {
        while (rc.range <= Bottom_value) {
            rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);
            /* rc.low could be negative here; don't fix it quite yet */
            rc.buffer = inputStream.readByte();
            rc.low |= rc.buffer >>> (8-EXTRA_BITS);
            rc.low = rc.low >>> 0; /* fix it now */
            rc.range = (rc.range << 8) >>> 0; /* ensure stays positive */
        }
    };

    /* Calculate cumulative frequency for next symbol. Does NO update!*/
    /* rc is the range coder to be used                          */
    /* tot_f is the total frequency                              */
    /* or: totf is (code_value)1<<shift                                      */
    /* returns the <= cumulative frequency                         */
    RangeCoder.prototype.decodeCulFreq = function(tot_f) {
        dec_normalize(this, this.stream);
        this.help = (this.range / tot_f) >>> 0; // note coercion to integer
        var tmp = (this.low / this.help) >>> 0; // again
        return (tmp >= tot_f ? tot_f-1 : tmp);
    };
    RangeCoder.prototype.decodeCulShift = function(shift) {
        dec_normalize(this, this.stream);
        this.help = this.range >>> shift;
        var tmp = (this.low / this.help) >>> 0; // coercion to unsigned
        // shift is less than 31, so shift below will remain positive
        return ((tmp>>>shift) ? (1<<shift)-1 : tmp);
    };

    /* Update decoding state                                     */
    /* rc is the range coder to be used                          */
    /* sy_f is the interval length (frequency of the symbol)     */
    /* lt_f is the lower end (frequency sum of < symbols)        */
    /* tot_f is the total interval length (total frequency sum)  */
    RangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
        var tmp = this.help * lt_f; // should not overflow!
        this.low -= tmp;
        if (lt_f + sy_f < tot_f) {
            this.range = (this.help * sy_f);
        } else {
            this.range -= tmp;
        }
    };

    /* Decode a bit w/o modelling. */
    RangeCoder.prototype.decodeBit = function() {
        var tmp = this.decodeCulShift(1);
        this.decodeUpdate(1, tmp, 1<<1);
        return tmp;
    };
    /* decode a byte w/o modelling */
    RangeCoder.prototype.decodeByte = function() {
        var tmp = this.decodeCulShift(8);
        this.decodeUpdate(1, tmp, 1<<8);
        return tmp;
    };
    /* decode a short w/o modelling */
    RangeCoder.prototype.decodeShort = function() {
        var tmp = this.decodeCulShift(16);
        this.decodeUpdate(1, tmp, 1<<16);
        return tmp;
    };

    /* Finish decoding */
    RangeCoder.prototype.decodeFinish = function() {
        /* normalize to use up all bytes */
        dec_normalize(this, this.stream);
    };

    /** Utility functions */

    // bitstream interface
    RangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;
    RangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;

    // stream interface
    RangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;
    RangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;

    return RangeCoder;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Simple.js":
/***/ (function(module, exports, __webpack_require__) {

/* *Very* simple de/compression utility, based on simple_c and simple_d from
 * rngcod13.zip at http://www.compressconsult.com/rangecoder/
 * Really just a demonstration/test of the rangecoder.
 */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/RangeCoder.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js")
];
var body_fn = function (RangeCoder,Stream,Util){
    var MAX_BLOCK_SIZE = 1<<17;

    var Simple = Object.create(null);
    Simple.MAGIC = 'smpl';
    Simple.compressFile = Util.compressFileHelper(Simple.MAGIC, function(input, output, size, props, finalByte) {
        var encoder = new RangeCoder(output);
        encoder.encodeStart(finalByte, 1);

        // read a block
        var block = Util.makeU8Buffer(MAX_BLOCK_SIZE);
        var counts = [];
        var blockLength = 0, sawEOF = false;

        var readBlock = function() {
            var pos = 0;
            // initialize counts
            for (pos=0; pos < 256; pos++) {
                counts[pos] = 0;
            }
            if (sawEOF) {
                blockLength = 0;
                return;
            }
            for (pos=0; pos < MAX_BLOCK_SIZE; ) {
                var c = input.readByte();
                if (c===Stream.EOF) {
                    sawEOF = true;
                    break;
                }
                block[pos++] = c;
                counts[c]++;
                // bail if some count reaches maximum
                if (counts[c]===0xFFFF) {
                    break;
                }
            }
            blockLength = pos;
        };

        while (true) {
            var i;
            readBlock();
            if (sawEOF && blockLength===0) {
                break;
            }
            // indicate that there's another block comin'
            encoder.encodeBit(true);
            // write all the statistics
            for (i=0; i<256; i++) {
                encoder.encodeShort(counts[i]);
            }
            // convert counts to cumulative counts
            counts[256] = blockLength;
            for (i=256; i; i--) {
                counts[i-1] = counts[i] - counts[i-1];
            }
            // encode the symbols using the probability table.
            for (i=0; i<blockLength; i++) {
                var ch = block[i];
                encoder.encodeFreq(counts[ch+1]-counts[ch], counts[ch],
                                   counts[256]);
            }
        }
        // write a stop bit
        encoder.encodeBit(false);
        // done!
        encoder.encodeFinish();
    }, true);
    Simple.decompressFile = Util.decompressFileHelper(Simple.MAGIC, function(input, output, size) {
        var decoder = new RangeCoder(input);
        decoder.decodeStart(true/*we already read the 'free' byte*/);
        while (decoder.decodeBit()) {
            var i, counts = [];
            // read all the statistics
            for (i=0; i<256; i++) {
                counts[i] = decoder.decodeShort();
            }
            // compute cumulative stats & total block size
            var blocksize = 0;
            for (i=0; i<256; i++) {
                var tmp = counts[i];
                counts[i] = blocksize;
                blocksize += tmp;
            }
            counts[256] = blocksize;

            for (i=0; i<blocksize; i++) {
                var cf = decoder.decodeCulFreq(blocksize);
                // inefficient way to look up the symbol.
                var symbol;
                for (symbol=0; symbol<256; symbol++)
                    // careful, there are length-0 ranges
                    // (where counts[symbol]===counts[symbol+1])
                    if (counts[symbol]<=cf && cf < counts[symbol+1])
                        break;
                var ch = symbol;
                decoder.decodeUpdate(counts[symbol+1] - counts[symbol],
                                     counts[symbol], blocksize);
                output.writeByte(symbol);
            }
        }
        decoder.decodeFinish();
    });
    return Simple;
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js":
/***/ (function(module, exports, __webpack_require__) {

/** Abstract Stream interface, for byte-oriented i/o. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js")
];
var body_fn = function (freeze) {
    var EOF = -1;

    var Stream = function() {
        /* ABSTRACT */
    };
    // you must define one of read / readByte for a readable stream
    Stream.prototype.readByte = function() {
        var buf = [ 0 ];
        var len = this.read(buf, 0, 1);
        if (len===0) { this._eof = true; return EOF; }
        return buf[0];
    };
    Stream.prototype.read = function(buf, bufOffset, length) {
        var ch, bytesRead = 0;
        while (bytesRead < length) {
            ch = this.readByte();
            if (ch === EOF) { this._eof = true; break; }
            buf[bufOffset+(bytesRead++)] = ch;
        }
        return bytesRead;
    };
    // reasonable default implementation of 'eof'
    Stream.prototype.eof = function() { return !!this._eof; };
    // not all readable streams are seekable
    Stream.prototype.seek = function(pos) {
        throw new Error('Stream is not seekable.');
    };
    Stream.prototype.tell = function() {
        throw new Error('Stream is not seekable.');
    };
    // you must define one of write / writeByte for a writable stream
    Stream.prototype.writeByte = function(_byte) {
        var buf = [ _byte ];
        this.write(buf, 0, 1);
    };
    Stream.prototype.write = function(buf, bufOffset, length) {
        var i;
        for (i=0; i<length; i++) {
            this.writeByte(buf[bufOffset + i]);
        }
        return length;
    };
    // flush will happily do nothing if you don't override it.
    Stream.prototype.flush = function() { };

    // export EOF as a constant.
    Stream.EOF = EOF;

    return freeze(Stream);
};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/Util.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {/* Some basic utilities, used in a number of places. */
var libs = [
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js"),
	__webpack_require__("../heroprotocol/node_modules/keybase-compressjs/outlib/Stream.js")
];
var body_fn = function (freeze, Stream) {
    var Util = Object.create(null);

    var EOF = Stream.EOF;

    /* Take a buffer, array, or stream, and return an input stream. */
    Util.coerceInputStream = function(input, forceRead) {
        if (!('readByte' in input)) {
            var buffer = input;
            input = new Stream();
            input.size = buffer.length;
            input.pos = 0;
            input.readByte = function() {
                if (this.pos >= this.size) { return EOF; }
                return buffer[this.pos++];
            };
            input.read = function(buf, bufOffset, length) {
                var bytesRead = 0;
                while (bytesRead < length && this.pos < buffer.length) {
                    buf[bufOffset++] = buffer[this.pos++];
                    bytesRead++;
                }
                return bytesRead;
            };
            input.seek = function(pos) { this.pos = pos; };
            input.tell = function() { return this.pos; };
            input.eof = function() { return this.pos >= buffer.length; };
        } else if (forceRead && !('read' in input)) {
            // wrap input if it doesn't implement read
            var s = input;
            input = new Stream();
            input.readByte = function() {
                var ch = s.readByte();
                if (ch === EOF) { this._eof = true; }
                return ch;
            };
            if ('size' in s) { input.size = s.size; }
            if ('seek' in s) {
                input.seek = function(pos) {
                    s.seek(pos); // may throw if s doesn't implement seek
                    this._eof = false;
                };
            }
            if ('tell' in s) {
                input.tell = s.tell.bind(s);
            }
        }
        return input;
    };

    var BufferStream = function(buffer, resizeOk) {
        this.buffer = buffer;
        this.resizeOk = resizeOk;
        this.pos = 0;
    };
    BufferStream.prototype = Object.create(Stream.prototype);
    BufferStream.prototype.writeByte = function(_byte) {
        if (this.resizeOk && this.pos >= this.buffer.length) {
            var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);
            newBuffer.set(this.buffer);
            this.buffer = newBuffer;
        }
        this.buffer[this.pos++] = _byte;
    };
    BufferStream.prototype.getBuffer = function() {
        // trim buffer if needed
        if (this.pos !== this.buffer.length) {
            if (!this.resizeOk)
                throw new TypeError('outputsize does not match decoded input');
            var newBuffer = Util.makeU8Buffer(this.pos);
            newBuffer.set(this.buffer.subarray(0, this.pos));
            this.buffer = newBuffer;
        }
        return this.buffer;
    };

    /* Take a stream (or not) and an (optional) size, and return an
     * output stream.  Return an object with a 'retval' field equal to
     * the output stream (if that was given) or else a pointer at the
     * internal Uint8Array/buffer/array; and a 'stream' field equal to
     * an output stream to use.
     */
    Util.coerceOutputStream = function(output, size) {
        var r = { stream: output, retval: output };
        if (output) {
            if (typeof(output)==='object' && 'writeByte' in output) {
                return r; /* leave output alone */
            } else if (typeof(size) === 'number') {
                console.assert(size >= 0);
                r.stream = new BufferStream(Util.makeU8Buffer(size), false);
            } else { // output is a buffer
                r.stream = new BufferStream(output, false);
            }
        } else {
            r.stream = new BufferStream(Util.makeU8Buffer(16384), true);
        }
        Object.defineProperty(r, 'retval', {
            get: r.stream.getBuffer.bind(r.stream)
        });
        return r;
    };

    Util.compressFileHelper = function(magic, guts, suppressFinalByte) {
        return function(inStream, outStream, props) {
            inStream = Util.coerceInputStream(inStream);
            var o = Util.coerceOutputStream(outStream, outStream);
            outStream = o.stream;

            // write the magic number to identify this file type
            // (it better be ASCII, we're not doing utf-8 conversion)
            var i;
            for (i=0; i<magic.length; i++) {
                outStream.writeByte(magic.charCodeAt(i));
            }

            // if we know the size, write it
            var fileSize;
            if ('size' in inStream && inStream.size >= 0) {
                fileSize = inStream.size;
            } else {
                fileSize = -1; // size unknown
            }
            if (suppressFinalByte) {
                var tmpOutput = Util.coerceOutputStream([]);
                Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
                tmpOutput = tmpOutput.retval;
                for (i=0; i<tmpOutput.length-1; i++) {
                    outStream.writeByte(tmpOutput[i]);
                }
                suppressFinalByte = tmpOutput[tmpOutput.length-1];
            } else {
                Util.writeUnsignedNumber(outStream, fileSize + 1);
            }

            // call the guts to do the real compression
            guts(inStream, outStream, fileSize, props, suppressFinalByte);

            return o.retval;
        };
    };
    Util.decompressFileHelper = function(magic, guts) {
        return function(inStream, outStream) {
            inStream = Util.coerceInputStream(inStream);

            // read the magic number to confirm this file type
            // (it better be ASCII, we're not doing utf-8 conversion)
            var i;
            for (i=0; i<magic.length; i++) {
                if (magic.charCodeAt(i) !== inStream.readByte()) {
                    throw new Error("Bad magic");
                }
            }

            // read the file size & create an appropriate output stream/buffer
            var fileSize = Util.readUnsignedNumber(inStream) - 1;
            var o = Util.coerceOutputStream(outStream, fileSize);
            outStream = o.stream;

            // call the guts to do the real decompression
            guts(inStream, outStream, fileSize);

            return o.retval;
        };
    };
    // a helper for simple self-test of model encode
    Util.compressWithModel = function(inStream, fileSize, model) {
        var inSize = 0;
        while (inSize !== fileSize) {
            var ch = inStream.readByte();
            if (ch === EOF) {
                model.encode(256); // end of stream;
                break;
            }
            model.encode(ch);
            inSize++;
        }
    };
    // a helper for simple self-test of model decode
    Util.decompressWithModel = function(outStream, fileSize, model) {
        var outSize = 0;
        while (outSize !== fileSize) {
            var ch = model.decode();
            if (ch === 256) {
                break; // end of stream;
            }
            outStream.writeByte(ch);
            outSize++;
        }
    };

    /** Write a number using a self-delimiting big-endian encoding. */
    Util.writeUnsignedNumber = function(output, n) {
        console.assert(n >= 0);
        var bytes = [], i;
        do {
            bytes.push(n & 0x7F);
            // use division instead of shift to allow encoding numbers up to
            // 2^53
            n = Math.floor( n / 128 );
        } while (n !== 0);
        bytes[0] |= 0x80; // mark end of encoding.
        for (i=bytes.length-1; i>=0; i--) {
            output.writeByte(bytes[i]); // write in big-endian order
        }
        return output;
    };

    /** Read a number using a self-delimiting big-endian encoding. */
    Util.readUnsignedNumber = function(input) {
        var n = 0, c;
        while (true) {
            c = input.readByte();
            if (c&0x80) { n += (c&0x7F); break; }
            // using + and * instead of << allows decoding numbers up to 2^53
            n = (n + c) * 128;
        }
        return n;
    };

    // Compatibility thunks for Buffer/TypedArray constructors.

    var zerofill = function(a) {
        for (var i = 0, len = a.length; i < len; i++) {
            a[i] = 0;
        }
        return a;
    };

    var fallbackarray = function(size) {
        return zerofill(new Array(size));
    };

    // Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.
    // See https://github.com/joyent/node/issues/6664
    // Try to detect and workaround the bug.
    var ensureZeroed = function id(a) { return a; };
    if ((typeof(process) !== 'undefined') &&
        Array.prototype.some.call(new Uint32Array(128), function(x) {
            return x !== 0;
        })) {
        //console.warn('Working around broken TypedArray');
        ensureZeroed = zerofill;
    }

    /** Portable 8-bit unsigned buffer. */
    Util.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {
        // Uint8Array ought to be  automatically zero-filled
        return ensureZeroed(new Uint8Array(size));
    } : (typeof(Buffer) !== 'undefined') ? function(size) {
        var b = new Buffer(size);
        b.fill(0);
        return b;
    } : fallbackarray;

    /** Portable 16-bit unsigned buffer. */
    Util.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {
        // Uint16Array ought to be  automatically zero-filled
        return ensureZeroed(new Uint16Array(size));
    } : fallbackarray;

    /** Portable 32-bit unsigned buffer. */
    Util.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {
        // Uint32Array ought to be  automatically zero-filled
        return ensureZeroed(new Uint32Array(size));
    } : fallbackarray;

    /** Portable 32-bit signed buffer. */
    Util.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {
        // Int32Array ought to be  automatically zero-filled
        return ensureZeroed(new Int32Array(size));
    } : fallbackarray;

    Util.arraycopy = function(dst, src) {
        console.assert(dst.length >= src.length);
        for (var i = 0, len = src.length; i < len ; i++) {
            dst[i] = src[i];
        }
        return dst;
    };

    /** Highest bit set in a byte. */
    var bytemsb = [
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 */
    ];
    console.assert(bytemsb.length===0x100);
    /** Find last set (most significant bit).
     *  @return the last bit set in the argument.
     *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. */
    var fls = Util.fls = function(v) {
        console.assert(v>=0);
        if (v > 0xFFFFFFFF) { // use floating-point mojo
            return 32 + fls(Math.floor(v / 0x100000000));
        }
        if ( (v & 0xFFFF0000) !== 0) {
            if ( (v & 0xFF000000) !== 0) {
                return 24 + bytemsb[(v>>>24) & 0xFF];
            } else {
                return 16 + bytemsb[v>>>16];
            }
        } else if ( (v & 0x0000FF00) !== 0) {
            return 8 + bytemsb[v>>>8];
        } else {
            return bytemsb[v];
        }
    };
    /** Returns ceil(log2(n)) */
    Util.log2c = function(v) {
        return (v===0)?-1:fls(v-1);
    };

    return freeze(Util); // ensure constants are recognized as such.
};
module.exports = body_fn.apply(null, libs);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js"), __webpack_require__("./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../heroprotocol/node_modules/keybase-compressjs/outlib/freeze.js":
/***/ (function(module, exports) {


var libs = [
];
var body_fn = function (){
  'use strict';

  // Object.freeze(), or a thunk if that method is not present in this
  // JavaScript environment.

  if (Object.freeze) {
    return Object.freeze;
  } else {
    return function(o) { return o; };
  }

};
module.exports = body_fn.apply(null, libs);


/***/ }),

/***/ "../heroprotocol/node_modules/linq/linq.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;﻿/*--------------------------------------------------------------------------
 * linq.js - LINQ for JavaScript
 * licensed under MIT License
 *------------------------------------------------------------------------*/

(function (root, undefined) {
    // ReadOnly Function
    var Functions = {
        Identity: function (x) { return x; },
        True: function () { return true; },
        Blank: function () { }
    };

    // const Type
    var Types = {
        Boolean: typeof true,
        Number: typeof 0,
        String: typeof "",
        Object: typeof {},
        Undefined: typeof undefined,
        Function: typeof function () { }
    };

    // createLambda cache
    var funcCache = { "": Functions.Identity };

    // private utility methods
    var Utils = {
        // Create anonymous function from lambda expression string
        createLambda: function (expression) {
            if (expression == null) return Functions.Identity;
            if (typeof expression === Types.String) {
                // get from cache
                var f = funcCache[expression];
                if (f != null) {
                    return f;
                }

                if (expression.indexOf("=>") === -1) {
                    var regexp = new RegExp("[$]+", "g");

                    var maxLength = 0;
                    var match;
                    while ((match = regexp.exec(expression)) != null) {
                        var paramNumber = match[0].length;
                        if (paramNumber > maxLength) {
                            maxLength = paramNumber;
                        }
                    }

                    var argArray = [];
                    for (var i = 1; i <= maxLength; i++) {
                        var dollar = "";
                        for (var j = 0; j < i; j++) {
                            dollar += "$";
                        }
                        argArray.push(dollar);
                    }

                    var args = Array.prototype.join.call(argArray, ",");

                    f = new Function(args, "return " + expression);
                    funcCache[expression] = f;
                    return f;
                }
                else {
                    var expr = expression.match(/^[(\s]*([^()]*?)[)\s]*=>(.*)/);
                    f = new Function(expr[1], "return " + expr[2]);
                    funcCache[expression] = f;
                    return f;
                }
            }
            return expression;
        },

        isIEnumerable: function (obj) {
            if (typeof Enumerator !== Types.Undefined) {
                try {
                    new Enumerator(obj); // check JScript(IE)'s Enumerator
                    return true;
                }
                catch (e) { }
            }

            return false;
        },

        // IE8's defineProperty is defined but cannot use, therefore check defineProperties
        defineProperty: (Object.defineProperties != null)
            ? function (target, methodName, value) {
                Object.defineProperty(target, methodName, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                    value: value
                })
            }
            : function (target, methodName, value) {
                target[methodName] = value;
            },

        compare: function (a, b) {
            return (a === b) ? 0
                 : (a > b) ? 1
                 : -1;
        },

        dispose: function (obj) {
            if (obj != null) obj.dispose();
        }
    };

    // IEnumerator State
    var State = { Before: 0, Running: 1, After: 2 };

    // "Enumerator" is conflict JScript's "Enumerator"
    var IEnumerator = function (initialize, tryGetNext, dispose) {
        var yielder = new Yielder();
        var state = State.Before;

        this.current = yielder.current;

        this.moveNext = function () {
            try {
                switch (state) {
                    case State.Before:
                        state = State.Running;
                        initialize();
                        // fall through
                    case State.Running:
                        if (tryGetNext.apply(yielder)) {
                            return true;
                        }
                        else {
                            this.dispose();
                            return false;
                        }
                    case State.After:
                        return false;
                }
            }
            catch (e) {
                this.dispose();
                throw e;
            }
        };

        this.dispose = function () {
            if (state != State.Running) return;

            try {
                dispose();
            }
            finally {
                state = State.After;
            }
        };
    };

    // for tryGetNext
    var Yielder = function () {
        var current = null;
        this.current = function () { return current; };
        this.yieldReturn = function (value) {
            current = value;
            return true;
        };
        this.yieldBreak = function () {
            return false;
        };
    };

    // Enumerable constuctor
    var Enumerable = function (getEnumerator) {
        this.getEnumerator = getEnumerator;
    };

    // Utility

    Enumerable.Utils = {}; // container

    Enumerable.Utils.createLambda = function (expression) {
        return Utils.createLambda(expression);
    };

    Enumerable.Utils.createEnumerable = function (getEnumerator) {
        return new Enumerable(getEnumerator);
    };

    Enumerable.Utils.createEnumerator = function (initialize, tryGetNext, dispose) {
        return new IEnumerator(initialize, tryGetNext, dispose);
    };

    Enumerable.Utils.extendTo = function (type) {
        var typeProto = type.prototype;
        var enumerableProto;

        if (type === Array) {
            enumerableProto = ArrayEnumerable.prototype;
            Utils.defineProperty(typeProto, "getSource", function () {
                return this;
            });
        }
        else {
            enumerableProto = Enumerable.prototype;
            Utils.defineProperty(typeProto, "getEnumerator", function () {
                return Enumerable.from(this).getEnumerator();
            });
        }

        for (var methodName in enumerableProto) {
            var func = enumerableProto[methodName];

            // already extended
            if (typeProto[methodName] == func) continue;

            // already defined(example Array#reverse/join/forEach...)
            if (typeProto[methodName] != null) {
                methodName = methodName + "ByLinq";
                if (typeProto[methodName] == func) continue; // recheck
            }

            if (func instanceof Function) {
                Utils.defineProperty(typeProto, methodName, func);
            }
        }
    };

    // Generator

    Enumerable.choice = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].getEnumerator != null) ? args[0].toArray()
                        : args;
                },
                function () {
                    return this.yieldReturn(args[Math.floor(Math.random() * args.length)]);
                },
                Functions.Blank);
        });
    };

    Enumerable.cycle = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            var index = 0;
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].getEnumerator != null) ? args[0].toArray()
                        : args;
                },
                function () {
                    if (index >= args.length) index = 0;
                    return this.yieldReturn(args[index++]);
                },
                Functions.Blank);
        });
    };

    Enumerable.empty = function () {
        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return false; },
                Functions.Blank);
        });
    };

    Enumerable.from = function (obj) {
        if (obj == null) {
            return Enumerable.empty();
        }
        if (obj instanceof Enumerable) {
            return obj;
        }
        if (typeof obj == Types.Number || typeof obj == Types.Boolean) {
            return Enumerable.repeat(obj, 1);
        }
        if (typeof obj == Types.String) {
            return new Enumerable(function () {
                var index = 0;
                return new IEnumerator(
                    Functions.Blank,
                    function () {
                        return (index < obj.length) ? this.yieldReturn(obj.charAt(index++)) : false;
                    },
                    Functions.Blank);
            });
        }
        if (typeof obj != Types.Function) {
            // array or array like object
            if (typeof obj.length == Types.Number) {
                return new ArrayEnumerable(obj);
            }

            // JScript's IEnumerable
            if (!(obj instanceof Object) && Utils.isIEnumerable(obj)) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = new Enumerator(obj); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.atEnd()) ? false : this.yieldReturn(enumerator.item());
                        },
                        Functions.Blank);
                });
            }

            // WinMD IIterable<T>
            if (typeof Windows === Types.Object && typeof obj.first === Types.Function) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = obj.first(); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.hasCurrent) ? this.yieldReturn(enumerator.current) : this.yieldBreak();
                        },
                        Functions.Blank);
                });
            }
        }

        // case function/object : Create keyValuePair[]
        return new Enumerable(function () {
            var array = [];
            var index = 0;

            return new IEnumerator(
                function () {
                    for (var key in obj) {
                        var value = obj[key];
                        if (!(value instanceof Function) && Object.prototype.hasOwnProperty.call(obj, key)) {
                            array.push({ key: key, value: value });
                        }
                    }
                },
                function () {
                    return (index < array.length)
                        ? this.yieldReturn(array[index++])
                        : false;
                },
                Functions.Blank);
        });
    },

    Enumerable.make = function (element) {
        return Enumerable.repeat(element, 1);
    };

    // Overload:function(input, pattern)
    // Overload:function(input, pattern, flags)
    Enumerable.matches = function (input, pattern, flags) {
        if (flags == null) flags = "";
        if (pattern instanceof RegExp) {
            flags += (pattern.ignoreCase) ? "i" : "";
            flags += (pattern.multiline) ? "m" : "";
            pattern = pattern.source;
        }
        if (flags.indexOf("g") === -1) flags += "g";

        return new Enumerable(function () {
            var regex;
            return new IEnumerator(
                function () { regex = new RegExp(pattern, flags); },
                function () {
                    var match = regex.exec(input);
                    return (match) ? this.yieldReturn(match) : false;
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, count)
    // Overload:function(start, count, step)
    Enumerable.range = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start - step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value += step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, count)
    // Overload:function(start, count, step)
    Enumerable.rangeDown = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start + step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value -= step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, to)
    // Overload:function(start, to, step)
    Enumerable.rangeTo = function (start, to, step) {
        if (step == null) step = 1;

        if (start < to) {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start - step; },
                function () {
                    var next = value += step;
                    return (next <= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
        else {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start + step; },
                function () {
                    var next = value -= step;
                    return (next >= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
    };

    // Overload:function(element)
    // Overload:function(element, count)
    Enumerable.repeat = function (element, count) {
        if (count != null) return Enumerable.repeat(element).take(count);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(element); },
                Functions.Blank);
        });
    };

    Enumerable.repeatWithFinalize = function (initializer, finalizer) {
        initializer = Utils.createLambda(initializer);
        finalizer = Utils.createLambda(finalizer);

        return new Enumerable(function () {
            var element;
            return new IEnumerator(
                function () { element = initializer(); },
                function () { return this.yieldReturn(element); },
                function () {
                    if (element != null) {
                        finalizer(element);
                        element = null;
                    }
                });
        });
    };

    // Overload:function(func)
    // Overload:function(func, count)
    Enumerable.generate = function (func, count) {
        if (count != null) return Enumerable.generate(func).take(count);
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(func()); },
                Functions.Blank);
        });
    };

    // Overload:function()
    // Overload:function(start)
    // Overload:function(start, step)
    Enumerable.toInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start - step; },
                function () { return this.yieldReturn(value += step); },
                Functions.Blank);
        });
    };

    // Overload:function()
    // Overload:function(start)
    // Overload:function(start, step)
    Enumerable.toNegativeInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start + step; },
                function () { return this.yieldReturn(value -= step); },
                Functions.Blank);
        });
    };

    Enumerable.unfold = function (seed, func) {
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            var isFirst = true;
            var value;
            return new IEnumerator(
                Functions.Blank,
                function () {
                    if (isFirst) {
                        isFirst = false;
                        value = seed;
                        return this.yieldReturn(value);
                    }
                    value = func(value);
                    return this.yieldReturn(value);
                },
                Functions.Blank);
        });
    };

    Enumerable.defer = function (enumerableFactory) {

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = Enumerable.from(enumerableFactory()).getEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : this.yieldBreak();
                },
                function () {
                    Utils.dispose(enumerator);
                });
        });
    };

    // Extension Methods

    /* Projection and Filtering Methods */

    // Overload:function(func)
    // Overload:function(func, resultSelector<element>)
    // Overload:function(func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseBreadthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var nestLevel = 0;
            var buffer = [];

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            buffer.push(enumerator.current());
                            return this.yieldReturn(resultSelector(enumerator.current(), nestLevel));
                        }

                        var next = Enumerable.from(buffer).selectMany(function (x) { return func(x); });
                        if (!next.any()) {
                            return false;
                        }
                        else {
                            nestLevel++;
                            buffer = [];
                            Utils.dispose(enumerator);
                            enumerator = next.getEnumerator();
                        }
                    }
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(func)
    // Overload:function(func, resultSelector<element>)
    // Overload:function(func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseDepthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumeratorStack = [];
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            var value = resultSelector(enumerator.current(), enumeratorStack.length);
                            enumeratorStack.push(enumerator);
                            enumerator = Enumerable.from(func(enumerator.current())).getEnumerator();
                            return this.yieldReturn(value);
                        }

                        if (enumeratorStack.length <= 0) return false;
                        Utils.dispose(enumerator);
                        enumerator = enumeratorStack.pop();
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Enumerable.from(enumeratorStack).forEach(function (s) { s.dispose(); });
                    }
                });
        });
    };

    Enumerable.prototype.flatten = function () {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = null;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (middleEnumerator != null) {
                            if (middleEnumerator.moveNext()) {
                                return this.yieldReturn(middleEnumerator.current());
                            }
                            else {
                                middleEnumerator = null;
                            }
                        }

                        if (enumerator.moveNext()) {
                            if (enumerator.current() instanceof Array) {
                                Utils.dispose(middleEnumerator);
                                middleEnumerator = Enumerable.from(enumerator.current())
                                    .selectMany(Functions.Identity)
                                    .flatten()
                                    .getEnumerator();
                                continue;
                            }
                            else {
                                return this.yieldReturn(enumerator.current());
                            }
                        }

                        return false;
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(middleEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.pairwise = function (selector) {
        var source = this;
        selector = Utils.createLambda(selector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    enumerator.moveNext();
                },
                function () {
                    var prev = enumerator.current();
                    return (enumerator.moveNext())
                        ? this.yieldReturn(selector(prev, enumerator.current()))
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(func)
    // Overload:function(seed,func<value,element>)
    Enumerable.prototype.scan = function (seed, func) {
        var isUseSeed;
        if (func == null) {
            func = Utils.createLambda(seed); // arguments[0]
            isUseSeed = false;
        } else {
            func = Utils.createLambda(func);
            isUseSeed = true;
        }
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var value;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (isFirst) {
                        isFirst = false;
                        if (!isUseSeed) {
                            if (enumerator.moveNext()) {
                                return this.yieldReturn(value = enumerator.current());
                            }
                        }
                        else {
                            return this.yieldReturn(value = seed);
                        }
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(value = func(value, enumerator.current()))
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(selector<element>)
    // Overload:function(selector<element,index>)
    Enumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            return new WhereSelectEnumerable(this, null, selector);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.getEnumerator(); },
                    function () {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(selector(enumerator.current(), index++))
                            : false;
                    },
                    function () { Utils.dispose(enumerator); });
            });
        }
    };

    // Overload:function(collectionSelector<element>)
    // Overload:function(collectionSelector<element,index>)
    // Overload:function(collectionSelector<element>,resultSelector)
    // Overload:function(collectionSelector<element,index>,resultSelector)
    Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {
        var source = this;
        collectionSelector = Utils.createLambda(collectionSelector);
        if (resultSelector == null) resultSelector = function (a, b) { return b; };
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = undefined;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (middleEnumerator === undefined) {
                        if (!enumerator.moveNext()) return false;
                    }
                    do {
                        if (middleEnumerator == null) {
                            var middleSeq = collectionSelector(enumerator.current(), index++);
                            middleEnumerator = Enumerable.from(middleSeq).getEnumerator();
                        }
                        if (middleEnumerator.moveNext()) {
                            return this.yieldReturn(resultSelector(enumerator.current(), middleEnumerator.current()));
                        }
                        Utils.dispose(middleEnumerator);
                        middleEnumerator = null;
                    } while (enumerator.moveNext());
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(middleEnumerator);
                    }
                });
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            return new WhereEnumerable(this, predicate);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.getEnumerator(); },
                    function () {
                        while (enumerator.moveNext()) {
                            if (predicate(enumerator.current(), index++)) {
                                return this.yieldReturn(enumerator.current());
                            }
                        }
                        return false;
                    },
                    function () { Utils.dispose(enumerator); });
            });
        }
    };


    // Overload:function(selector<element>)
    // Overload:function(selector<element,index>)
    Enumerable.prototype.choose = function (selector) {
        selector = Utils.createLambda(selector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        var result = selector(enumerator.current(), index++);
                        if (result != null) {
                            return this.yieldReturn(result);
                        }
                    }
                    return this.yieldBreak();
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.ofType = function (type) {
        var typeName;
        switch (type) {
            case Number:
                typeName = Types.Number;
                break;
            case String:
                typeName = Types.String;
                break;
            case Boolean:
                typeName = Types.Boolean;
                break;
            case Function:
                typeName = Types.Function;
                break;
            default:
                typeName = null;
                break;
        }
        return (typeName === null)
            ? this.where(function (x) { return x instanceof type; })
            : this.where(function (x) { return typeof x === typeName; });
    };

    // mutiple arguments, last one is selector, others are enumerable
    Enumerable.prototype.zip = function () {
        var args = arguments;
        var selector = Utils.createLambda(arguments[arguments.length - 1]);

        var source = this;
        // optimized case:argument is 2
        if (arguments.length == 2) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;
                var index = 0;

                return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    secondEnumerator = Enumerable.from(second).getEnumerator();
                },
                function () {
                    if (firstEnumerator.moveNext() && secondEnumerator.moveNext()) {
                        return this.yieldReturn(selector(firstEnumerator.current(), secondEnumerator.current(), index++));
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    } finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            return new Enumerable(function () {
                var enumerators;
                var index = 0;

                return new IEnumerator(
                function () {
                    var array = Enumerable.make(source)
                        .concat(Enumerable.from(args).takeExceptLast().select(Enumerable.from))
                        .select(function (x) { return x.getEnumerator() })
                        .toArray();
                    enumerators = Enumerable.from(array);
                },
                function () {
                    if (enumerators.all(function (x) { return x.moveNext() })) {
                        var array = enumerators
                            .select(function (x) { return x.current() })
                            .toArray();
                        array.push(index++);
                        return this.yieldReturn(selector.apply(null, array));
                    }
                    else {
                        return this.yieldBreak();
                    }
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.dispose);
                });
            });
        }
    };

    // mutiple arguments
    Enumerable.prototype.merge = function () {
        var args = arguments;
        var source = this;

        return new Enumerable(function () {
            var enumerators;
            var index = -1;

            return new IEnumerator(
                function () {
                    enumerators = Enumerable.make(source)
                        .concat(Enumerable.from(args).select(Enumerable.from))
                        .select(function (x) { return x.getEnumerator() })
                        .toArray();
                },
                function () {
                    while (enumerators.length > 0) {
                        index = (index >= enumerators.length - 1) ? 0 : index + 1;
                        var enumerator = enumerators[index];

                        if (enumerator.moveNext()) {
                            return this.yieldReturn(enumerator.current());
                        }
                        else {
                            enumerator.dispose();
                            enumerators.splice(index--, 1);
                        }
                    }
                    return this.yieldBreak();
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.dispose);
                });
        });
    };

    /* Join Methods */

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var outerEnumerator;
            var lookup;
            var innerElements = null;
            var innerCount = 0;

            return new IEnumerator(
                function () {
                    outerEnumerator = source.getEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);
                },
                function () {
                    while (true) {
                        if (innerElements != null) {
                            var innerElement = innerElements[innerCount++];
                            if (innerElement !== undefined) {
                                return this.yieldReturn(resultSelector(outerEnumerator.current(), innerElement));
                            }

                            innerElement = null;
                            innerCount = 0;
                        }

                        if (outerEnumerator.moveNext()) {
                            var key = outerKeySelector(outerEnumerator.current());
                            innerElements = lookup.get(key).toArray();
                        } else {
                            return false;
                        }
                    }
                },
                function () { Utils.dispose(outerEnumerator); });
        });
    };

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator = source.getEnumerator();
            var lookup = null;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);
                },
                function () {
                    if (enumerator.moveNext()) {
                        var innerElement = lookup.get(outerKeySelector(enumerator.current()));
                        return this.yieldReturn(resultSelector(enumerator.current(), innerElement));
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    /* Set Methods */

    Enumerable.prototype.all = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var result = true;
        this.forEach(function (x) {
            if (!predicate(x)) {
                result = false;
                return false; // break
            }
        });
        return result;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.any = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var enumerator = this.getEnumerator();
        try {
            if (arguments.length == 0) return enumerator.moveNext(); // case:function()

            while (enumerator.moveNext()) // case:function(predicate)
            {
                if (predicate(enumerator.current())) return true;
            }
            return false;
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    Enumerable.prototype.isEmpty = function () {
        return !this.any();
    };

    // multiple arguments
    Enumerable.prototype.concat = function () {
        var source = this;

        if (arguments.length == 1) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;

                return new IEnumerator(
                function () { firstEnumerator = source.getEnumerator(); },
                function () {
                    if (secondEnumerator == null) {
                        if (firstEnumerator.moveNext()) return this.yieldReturn(firstEnumerator.current());
                        secondEnumerator = Enumerable.from(second).getEnumerator();
                    }
                    if (secondEnumerator.moveNext()) return this.yieldReturn(secondEnumerator.current());
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            var args = arguments;

            return new Enumerable(function () {
                var enumerators;

                return new IEnumerator(
                    function () {
                        enumerators = Enumerable.make(source)
                            .concat(Enumerable.from(args).select(Enumerable.from))
                            .select(function (x) { return x.getEnumerator() })
                            .toArray();
                    },
                    function () {
                        while (enumerators.length > 0) {
                            var enumerator = enumerators[0];

                            if (enumerator.moveNext()) {
                                return this.yieldReturn(enumerator.current());
                            }
                            else {
                                enumerator.dispose();
                                enumerators.splice(0, 1);
                            }
                        }
                        return this.yieldBreak();
                    },
                    function () {
                        Enumerable.from(enumerators).forEach(Utils.dispose);
                    });
            });
        }
    };

    Enumerable.prototype.insert = function (index, second) {
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var count = 0;
            var isEnumerated = false;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    secondEnumerator = Enumerable.from(second).getEnumerator();
                },
                function () {
                    if (count == index && secondEnumerator.moveNext()) {
                        isEnumerated = true;
                        return this.yieldReturn(secondEnumerator.current());
                    }
                    if (firstEnumerator.moveNext()) {
                        count++;
                        return this.yieldReturn(firstEnumerator.current());
                    }
                    if (!isEnumerated && secondEnumerator.moveNext()) {
                        return this.yieldReturn(secondEnumerator.current());
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.alternate = function (alternateValueOrSequence) {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var enumerator;
            var alternateSequence;
            var alternateEnumerator;

            return new IEnumerator(
                function () {
                    if (alternateValueOrSequence instanceof Array || alternateValueOrSequence.getEnumerator != null) {
                        alternateSequence = Enumerable.from(Enumerable.from(alternateValueOrSequence).toArray()); // freeze
                    }
                    else {
                        alternateSequence = Enumerable.make(alternateValueOrSequence);
                    }
                    enumerator = source.getEnumerator();
                    if (enumerator.moveNext()) buffer = enumerator.current();
                },
                function () {
                    while (true) {
                        if (alternateEnumerator != null) {
                            if (alternateEnumerator.moveNext()) {
                                return this.yieldReturn(alternateEnumerator.current());
                            }
                            else {
                                alternateEnumerator = null;
                            }
                        }

                        if (buffer == null && enumerator.moveNext()) {
                            buffer = enumerator.current(); // hasNext
                            alternateEnumerator = alternateSequence.getEnumerator();
                            continue; // GOTO
                        }
                        else if (buffer != null) {
                            var retVal = buffer;
                            buffer = null;
                            return this.yieldReturn(retVal);
                        }

                        return this.yieldBreak();
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(alternateEnumerator);
                    }
                });
        });
    };

    // Overload:function(value)
    // Overload:function(value, compareSelector)
    Enumerable.prototype.contains = function (value, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var enumerator = this.getEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (compareSelector(enumerator.current()) === value) return true;
            }
            return false;
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    Enumerable.prototype.defaultIfEmpty = function (defaultValue) {
        var source = this;
        if (defaultValue === undefined) defaultValue = null;

        return new Enumerable(function () {
            var enumerator;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        isFirst = false;
                        return this.yieldReturn(enumerator.current());
                    }
                    else if (isFirst) {
                        isFirst = false;
                        return this.yieldReturn(defaultValue);
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function()
    // Overload:function(compareSelector)
    Enumerable.prototype.distinct = function (compareSelector) {
        return this.except(Enumerable.empty(), compareSelector);
    };

    Enumerable.prototype.distinctUntilChanged = function (compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var compareKey;
            var initial;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        var key = compareSelector(enumerator.current());

                        if (initial) {
                            initial = false;
                            compareKey = key;
                            return this.yieldReturn(enumerator.current());
                        }

                        if (compareKey === key) {
                            continue;
                        }

                        compareKey = key;
                        return this.yieldReturn(enumerator.current());
                    }
                    return this.yieldBreak();
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.except = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    keys = new Dictionary(compareSelector);
                    Enumerable.from(second).forEach(function (key) { keys.add(key); });
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.current();
                        if (!keys.contains(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.intersect = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;
            var outs;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();

                    keys = new Dictionary(compareSelector);
                    Enumerable.from(second).forEach(function (key) { keys.add(key); });
                    outs = new Dictionary(compareSelector);
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.current();
                        if (!outs.contains(current) && keys.contains(current)) {
                            outs.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.sequenceEqual = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);

        var firstEnumerator = this.getEnumerator();
        try {
            var secondEnumerator = Enumerable.from(second).getEnumerator();
            try {
                while (firstEnumerator.moveNext()) {
                    if (!secondEnumerator.moveNext()
                    || compareSelector(firstEnumerator.current()) !== compareSelector(secondEnumerator.current())) {
                        return false;
                    }
                }

                if (secondEnumerator.moveNext()) return false;
                return true;
            }
            finally {
                Utils.dispose(secondEnumerator);
            }
        }
        finally {
            Utils.dispose(firstEnumerator);
        }
    };

    Enumerable.prototype.union = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var keys;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    keys = new Dictionary(compareSelector);
                },
                function () {
                    var current;
                    if (secondEnumerator === undefined) {
                        while (firstEnumerator.moveNext()) {
                            current = firstEnumerator.current();
                            if (!keys.contains(current)) {
                                keys.add(current);
                                return this.yieldReturn(current);
                            }
                        }
                        secondEnumerator = Enumerable.from(second).getEnumerator();
                    }
                    while (secondEnumerator.moveNext()) {
                        current = secondEnumerator.current();
                        if (!keys.contains(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
        });
    };

    /* Ordering Methods */

    Enumerable.prototype.orderBy = function (keySelector) {
        return new OrderedEnumerable(this, keySelector, false);
    };

    Enumerable.prototype.orderByDescending = function (keySelector) {
        return new OrderedEnumerable(this, keySelector, true);
    };

    Enumerable.prototype.reverse = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var index;

            return new IEnumerator(
                function () {
                    buffer = source.toArray();
                    index = buffer.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(buffer[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.shuffle = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;

            return new IEnumerator(
                function () { buffer = source.toArray(); },
                function () {
                    if (buffer.length > 0) {
                        var i = Math.floor(Math.random() * buffer.length);
                        return this.yieldReturn(buffer.splice(i, 1)[0]);
                    }
                    return false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.weightedSample = function (weightSelector) {
        weightSelector = Utils.createLambda(weightSelector);
        var source = this;

        return new Enumerable(function () {
            var sortedByBound;
            var totalWeight = 0;

            return new IEnumerator(
                function () {
                    sortedByBound = source
                        .choose(function (x) {
                            var weight = weightSelector(x);
                            if (weight <= 0) return null; // ignore 0

                            totalWeight += weight;
                            return { value: x, bound: totalWeight };
                        })
                        .toArray();
                },
                function () {
                    if (sortedByBound.length > 0) {
                        var draw = Math.floor(Math.random() * totalWeight) + 1;

                        var lower = -1;
                        var upper = sortedByBound.length;
                        while (upper - lower > 1) {
                            var index = Math.floor((lower + upper) / 2);
                            if (sortedByBound[index].bound >= draw) {
                                upper = index;
                            }
                            else {
                                lower = index;
                            }
                        }

                        return this.yieldReturn(sortedByBound[upper].value);
                    }

                    return this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    /* Grouping Methods */

    // Overload:function(keySelector)
    // Overload:function(keySelector,elementSelector)
    // Overload:function(keySelector,elementSelector,resultSelector)
    // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.groupBy = function (keySelector, elementSelector, resultSelector, compareSelector) {
        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        if (resultSelector != null) resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.toLookup(keySelector, elementSelector, compareSelector)
                        .toEnumerable()
                        .getEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        return (resultSelector == null)
                            ? this.yieldReturn(enumerator.current())
                            : this.yieldReturn(resultSelector(enumerator.current().key(), enumerator.current()));
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(keySelector)
    // Overload:function(keySelector,elementSelector)
    // Overload:function(keySelector,elementSelector,resultSelector)
    // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, compareSelector) {

        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var hasResultSelector;
        if (resultSelector == null) {
            hasResultSelector = false;
            resultSelector = function (key, group) { return new Grouping(key, group); };
        }
        else {
            hasResultSelector = true;
            resultSelector = Utils.createLambda(resultSelector);
        }

        return new Enumerable(function () {
            var enumerator;
            var key;
            var compareKey;
            var group = [];

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    if (enumerator.moveNext()) {
                        key = keySelector(enumerator.current());
                        compareKey = compareSelector(key);
                        group.push(elementSelector(enumerator.current()));
                    }
                },
                function () {
                    var hasNext;
                    while ((hasNext = enumerator.moveNext()) == true) {
                        if (compareKey === compareSelector(keySelector(enumerator.current()))) {
                            group.push(elementSelector(enumerator.current()));
                        }
                        else break;
                    }

                    if (group.length > 0) {
                        var result = (hasResultSelector)
                            ? resultSelector(key, Enumerable.from(group))
                            : resultSelector(key, group);
                        if (hasNext) {
                            key = keySelector(enumerator.current());
                            compareKey = compareSelector(key);
                            group = [elementSelector(enumerator.current())];
                        }
                        else group = [];

                        return this.yieldReturn(result);
                    }

                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.buffer = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    var array = [];
                    var index = 0;
                    while (enumerator.moveNext()) {
                        array.push(enumerator.current());
                        if (++index >= count) return this.yieldReturn(array);
                    }
                    if (array.length > 0) return this.yieldReturn(array);
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    /* Aggregate Methods */

    // Overload:function(func)
    // Overload:function(seed,func)
    // Overload:function(seed,func,resultSelector)
    Enumerable.prototype.aggregate = function (seed, func, resultSelector) {
        resultSelector = Utils.createLambda(resultSelector);
        return resultSelector(this.scan(seed, func, resultSelector).last());
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.average = function (selector) {
        selector = Utils.createLambda(selector);

        var sum = 0;
        var count = 0;
        this.forEach(function (x) {
            sum += selector(x);
            ++count;
        });

        return sum / count;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.count = function (predicate) {
        predicate = (predicate == null) ? Functions.True : Utils.createLambda(predicate);

        var count = 0;
        this.forEach(function (x, i) {
            if (predicate(x, i))++count;
        });
        return count;
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.max = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) { return (a > b) ? a : b; });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.min = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) { return (a < b) ? a : b; });
    };

    Enumerable.prototype.maxBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) { return (keySelector(a) > keySelector(b)) ? a : b; });
    };

    Enumerable.prototype.minBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) { return (keySelector(a) < keySelector(b)) ? a : b; });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.sum = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(0, function (a, b) { return a + b; });
    };

    /* Paging Methods */

    Enumerable.prototype.elementAt = function (index) {
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        if (!found) throw new Error("index is less than 0 or greater than or equal to the number of elements in source.");
        return value;
    };

    Enumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.first = function (predicate) {
        if (predicate != null) return this.where(predicate).first();

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });

        if (!found) throw new Error("first:No element satisfies the condition.");
        return value;
    };

    Enumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            if (typeof predicate === Types.Function || typeof Utils.createLambda(predicate) === Types.Function) {
                return this.where(predicate).firstOrDefault(undefined, defaultValue);
            }
            defaultValue = predicate;
        }

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.last = function (predicate) {
        if (predicate != null) return this.where(predicate).last();

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });

        if (!found) throw new Error("last:No element satisfies the condition.");
        return value;
    };

    Enumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            if (typeof predicate === Types.Function || typeof Utils.createLambda(predicate) === Types.Function) {
                return this.where(predicate).lastOrDefault(undefined, defaultValue);
            }
            defaultValue = predicate;
        }

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.single = function (predicate) {
        if (predicate != null) return this.where(predicate).single();

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        if (!found) throw new Error("single:No element satisfies the condition.");
        return value;
    };

    // Overload:function(defaultValue)
    // Overload:function(defaultValue,predicate)
    Enumerable.prototype.singleOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).singleOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        return (!found) ? defaultValue : value;
    };

    Enumerable.prototype.skip = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    while (index++ < count && enumerator.moveNext()) {
                    }
                    ;
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.skipWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;
            var isSkipEnd = false;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (!isSkipEnd) {
                        if (enumerator.moveNext()) {
                            if (!predicate(enumerator.current(), index++)) {
                                isSkipEnd = true;
                                return this.yieldReturn(enumerator.current());
                            }
                            continue;
                        } else return false;
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;

                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.take = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (index++ < count && enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); }
            );
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.takeWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (enumerator.moveNext() && predicate(enumerator.current(), index++))
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function()
    // Overload:function(count)
    Enumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        var source = this;

        return new Enumerable(function () {
            if (count <= 0) return source.getEnumerator(); // do nothing

            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        if (q.length == count) {
                            q.push(enumerator.current());
                            return this.yieldReturn(q.shift());
                        }
                        q.push(enumerator.current());
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.takeFromLast = function (count) {
        if (count <= 0 || count == null) return Enumerable.empty();
        var source = this;

        return new Enumerable(function () {
            var sourceEnumerator;
            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { sourceEnumerator = source.getEnumerator(); },
                function () {
                    while (sourceEnumerator.moveNext()) {
                        if (q.length == count) q.shift();
                        q.push(sourceEnumerator.current());
                    }
                    if (enumerator == null) {
                        enumerator = Enumerable.from(q).getEnumerator();
                    }
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(item)
    // Overload:function(predicate)
    Enumerable.prototype.indexOf = function (item) {
        var found = null;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) {
                    found = i;
                    return false;
                }
            });
        }
        else {
            this.forEach(function (x, i) {
                if (x === item) {
                    found = i;
                    return false;
                }
            });
        }

        return (found !== null) ? found : -1;
    };

    // Overload:function(item)
    // Overload:function(predicate)
    Enumerable.prototype.lastIndexOf = function (item) {
        var result = -1;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) result = i;
            });
        }
        else {
            this.forEach(function (x, i) {
                if (x === item) result = i;
            });
        }

        return result;
    };

    /* Convert Methods */

    Enumerable.prototype.cast = function () {
        return this;
    };

    Enumerable.prototype.asEnumerable = function () {
        return Enumerable.from(this);
    };

    Enumerable.prototype.toArray = function () {
        var array = [];
        this.forEach(function (x) { array.push(x); });
        return array;
    };

    // Overload:function(keySelector)
    // Overload:function(keySelector, elementSelector)
    // Overload:function(keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toLookup = function (keySelector, elementSelector, compareSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);

        var dict = new Dictionary(compareSelector);
        this.forEach(function (x) {
            var key = keySelector(x);
            var element = elementSelector(x);

            var array = dict.get(key);
            if (array !== undefined) array.push(element);
            else dict.add(key, [element]);
        });
        return new Lookup(dict);
    };

    Enumerable.prototype.toObject = function (keySelector, elementSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);

        var obj = {};
        this.forEach(function (x) {
            obj[keySelector(x)] = elementSelector(x);
        });
        return obj;
    };

    // Overload:function(keySelector, elementSelector)
    // Overload:function(keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toDictionary = function (keySelector, elementSelector, compareSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);

        var dict = new Dictionary(compareSelector);
        this.forEach(function (x) {
            dict.add(keySelector(x), elementSelector(x));
        });
        return dict;
    };

    // Overload:function()
    // Overload:function(replacer)
    // Overload:function(replacer, space)
    Enumerable.prototype.toJSONString = function (replacer, space) {
        if (typeof JSON === Types.Undefined || JSON.stringify == null) {
            throw new Error("toJSONString can't find JSON.stringify. This works native JSON support Browser or include json2.js");
        }
        return JSON.stringify(this.toArray(), replacer, space);
    };

    // Overload:function()
    // Overload:function(separator)
    // Overload:function(separator,selector)
    Enumerable.prototype.toJoinedString = function (separator, selector) {
        if (separator == null) separator = "";
        if (selector == null) selector = Functions.Identity;

        return this.select(selector).toArray().join(separator);
    };


    /* Action Methods */

    // Overload:function(action<element>)
    // Overload:function(action<element,index>)
    Enumerable.prototype.doAction = function (action) {
        var source = this;
        action = Utils.createLambda(action);

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        action(enumerator.current(), index++);
                        return this.yieldReturn(enumerator.current());
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(action<element>)
    // Overload:function(action<element,index>)
    // Overload:function(func<element,bool>)
    // Overload:function(func<element,index,bool>)
    Enumerable.prototype.forEach = function (action) {
        action = Utils.createLambda(action);

        var index = 0;
        var enumerator = this.getEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (action(enumerator.current(), index++) === false) break;
            }
        } finally {
            Utils.dispose(enumerator);
        }
    };

    // Overload:function()
    // Overload:function(separator)
    // Overload:function(separator,selector)
    Enumerable.prototype.write = function (separator, selector) {
        if (separator == null) separator = "";
        selector = Utils.createLambda(selector);

        var isFirst = true;
        this.forEach(function (item) {
            if (isFirst) isFirst = false;
            else document.write(separator);
            document.write(selector(item));
        });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.writeLine = function (selector) {
        selector = Utils.createLambda(selector);

        this.forEach(function (item) {
            document.writeln(selector(item) + "<br />");
        });
    };

    Enumerable.prototype.force = function () {
        var enumerator = this.getEnumerator();

        try {
            while (enumerator.moveNext()) {
            }
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    /* Functional Methods */

    Enumerable.prototype.letBind = function (func) {
        func = Utils.createLambda(func);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = Enumerable.from(func(source)).getEnumerator();
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.share = function () {
        var source = this;
        var sharedEnumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            return new IEnumerator(
                function () {
                    if (sharedEnumerator == null) {
                        sharedEnumerator = source.getEnumerator();
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    return (sharedEnumerator.moveNext())
                        ? this.yieldReturn(sharedEnumerator.current())
                        : false;
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.dispose(sharedEnumerator);
        });
    };

    Enumerable.prototype.memoize = function () {
        var source = this;
        var cache;
        var enumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            var index = -1;

            return new IEnumerator(
                function () {
                    if (enumerator == null) {
                        enumerator = source.getEnumerator();
                        cache = [];
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    index++;
                    if (cache.length <= index) {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(cache[index] = enumerator.current())
                            : false;
                    }

                    return this.yieldReturn(cache[index]);
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.dispose(enumerator);
            cache = null;
        });
    };

    /* Error Handling Methods */

    Enumerable.prototype.catchError = function (handler) {
        handler = Utils.createLambda(handler);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    try {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(enumerator.current())
                            : false;
                    } catch (e) {
                        handler(e);
                        return false;
                    }
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.finallyAction = function (finallyAction) {
        finallyAction = Utils.createLambda(finallyAction);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    } finally {
                        finallyAction();
                    }
                });
        });
    };

    /* For Debug Methods */

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.log = function (selector) {
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(selector(item));
            }
        });
    };

    // Overload:function()
    // Overload:function(message)
    // Overload:function(message,selector)
    Enumerable.prototype.trace = function (message, selector) {
        if (message == null) message = "Trace";
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(message, selector(item));
            }
        });
    };

    // private

    var OrderedEnumerable = function (source, keySelector, descending, parent) {
        this.source = source;
        this.keySelector = Utils.createLambda(keySelector);
        this.descending = descending;
        this.parent = parent;
    };
    OrderedEnumerable.prototype = new Enumerable();

    OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, descending) {
        return new OrderedEnumerable(this.source, keySelector, descending, this);
    };

    OrderedEnumerable.prototype.thenBy = function (keySelector) {
        return this.createOrderedEnumerable(keySelector, false);
    };

    OrderedEnumerable.prototype.thenByDescending = function (keySelector) {
        return this.createOrderedEnumerable(keySelector, true);
    };

    OrderedEnumerable.prototype.getEnumerator = function () {
        var self = this;
        var buffer;
        var indexes;
        var index = 0;

        return new IEnumerator(
            function () {
                buffer = [];
                indexes = [];
                self.source.forEach(function (item, index) {
                    buffer.push(item);
                    indexes.push(index);
                });
                var sortContext = SortContext.create(self, null);
                sortContext.GenerateKeys(buffer);

                indexes.sort(function (a, b) { return sortContext.compare(a, b); });
            },
            function () {
                return (index < indexes.length)
                    ? this.yieldReturn(buffer[indexes[index++]])
                    : false;
            },
            Functions.Blank
        );
    };

    var SortContext = function (keySelector, descending, child) {
        this.keySelector = keySelector;
        this.descending = descending;
        this.child = child;
        this.keys = null;
    };

    SortContext.create = function (orderedEnumerable, currentContext) {
        var context = new SortContext(orderedEnumerable.keySelector, orderedEnumerable.descending, currentContext);
        if (orderedEnumerable.parent != null) return SortContext.create(orderedEnumerable.parent, context);
        return context;
    };

    SortContext.prototype.GenerateKeys = function (source) {
        var len = source.length;
        var keySelector = this.keySelector;
        var keys = new Array(len);
        for (var i = 0; i < len; i++) keys[i] = keySelector(source[i]);
        this.keys = keys;

        if (this.child != null) this.child.GenerateKeys(source);
    };

    SortContext.prototype.compare = function (index1, index2) {
        var comparison = Utils.compare(this.keys[index1], this.keys[index2]);

        if (comparison == 0) {
            if (this.child != null) return this.child.compare(index1, index2);
            return Utils.compare(index1, index2);
        }

        return (this.descending) ? -comparison : comparison;
    };

    var DisposableEnumerable = function (getEnumerator, dispose) {
        this.dispose = dispose;
        Enumerable.call(this, getEnumerator);
    };
    DisposableEnumerable.prototype = new Enumerable();

    // optimize array or arraylike object

    var ArrayEnumerable = function (source) {
        this.getSource = function () { return source; };
    };
    ArrayEnumerable.prototype = new Enumerable();

    ArrayEnumerable.prototype.any = function (predicate) {
        return (predicate == null)
            ? (this.getSource().length > 0)
            : Enumerable.prototype.any.apply(this, arguments);
    };

    ArrayEnumerable.prototype.count = function (predicate) {
        return (predicate == null)
            ? this.getSource().length
            : Enumerable.prototype.count.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAt = function (index) {
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : Enumerable.prototype.elementAt.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : defaultValue;
    };

    ArrayEnumerable.prototype.first = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[0]
            : Enumerable.prototype.first.apply(this, arguments);
    };

    ArrayEnumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            return Enumerable.prototype.firstOrDefault.apply(this, arguments);
        }
        defaultValue = predicate;

        var source = this.getSource();
        return source.length > 0 ? source[0] : defaultValue;
    };

    ArrayEnumerable.prototype.last = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[source.length - 1]
            : Enumerable.prototype.last.apply(this, arguments);
    };

    ArrayEnumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (predicate !== undefined) {
            return Enumerable.prototype.lastOrDefault.apply(this, arguments);
        }
        defaultValue = predicate;

        var source = this.getSource();
        return source.length > 0 ? source[source.length - 1] : defaultValue;
    };

    ArrayEnumerable.prototype.skip = function (count) {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () { index = (count < 0) ? 0 : count; },
                function () {
                    return (index < source.length)
                        ? this.yieldReturn(source[index++])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        return this.take(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.takeFromLast = function (count) {
        return this.skip(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.reverse = function () {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () {
                    index = source.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(source[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.sequenceEqual = function (second, compareSelector) {
        if ((second instanceof ArrayEnumerable || second instanceof Array)
            && compareSelector == null
            && Enumerable.from(second).count() != this.count()) {
            return false;
        }

        return Enumerable.prototype.sequenceEqual.apply(this, arguments);
    };

    ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {
        var source = this.getSource();
        if (selector != null || !(source instanceof Array)) {
            return Enumerable.prototype.toJoinedString.apply(this, arguments);
        }

        if (separator == null) separator = "";
        return source.join(separator);
    };

    ArrayEnumerable.prototype.getEnumerator = function () {
        var source = this.getSource();
        var index = -1;

        // fast and simple enumerator
        return {
            current: function () { return source[index]; },
            moveNext: function () {
                return ++index < source.length;
            },
            dispose: Functions.Blank
        };
    };

    // optimization for multiple where and multiple select and whereselect

    var WhereEnumerable = function (source, predicate) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1
    };
    WhereEnumerable.prototype = new Enumerable();

    WhereEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            var prevPredicate = this.prevPredicate;
            var composedPredicate = function (x) { return prevPredicate(x) && predicate(x); };
            return new WhereEnumerable(this.prevSource, composedPredicate);
        }
        else {
            // if predicate use index, can't compose
            return Enumerable.prototype.where.call(this, predicate);
        }
    };

    WhereEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        return (selector.length <= 1)
            ? new WhereSelectEnumerable(this.prevSource, this.prevPredicate, selector)
            : Enumerable.prototype.select.call(this, selector);
    };

    WhereEnumerable.prototype.getEnumerator = function () {
        var predicate = this.prevPredicate;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.getEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate(enumerator.current())) {
                        return this.yieldReturn(enumerator.current());
                    }
                }
                return false;
            },
            function () { Utils.dispose(enumerator); });
    };

    var WhereSelectEnumerable = function (source, predicate, selector) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1 or null
        this.prevSelector = selector; // selector.length always <= 1
    };
    WhereSelectEnumerable.prototype = new Enumerable();

    WhereSelectEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        return (predicate.length <= 1)
            ? new WhereEnumerable(this, predicate)
            : Enumerable.prototype.where.call(this, predicate);
    };

    WhereSelectEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            var prevSelector = this.prevSelector;
            var composedSelector = function (x) { return selector(prevSelector(x)); };
            return new WhereSelectEnumerable(this.prevSource, this.prevPredicate, composedSelector);
        }
        else {
            // if selector use index, can't compose
            return Enumerable.prototype.select.call(this, selector);
        }
    };

    WhereSelectEnumerable.prototype.getEnumerator = function () {
        var predicate = this.prevPredicate;
        var selector = this.prevSelector;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.getEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate == null || predicate(enumerator.current())) {
                        return this.yieldReturn(selector(enumerator.current()));
                    }
                }
                return false;
            },
            function () { Utils.dispose(enumerator); });
    };

    // Collections

    var Dictionary = (function () {
        // static utility methods
        var callHasOwnProperty = function (target, key) {
            return Object.prototype.hasOwnProperty.call(target, key);
        };

        var computeHashCode = function (obj) {
            if (obj === null) return "null";
            if (obj === undefined) return "undefined";

            return (typeof obj.toString === Types.Function)
                ? obj.toString()
                : Object.prototype.toString.call(obj);
        };

        // LinkedList for Dictionary
        var HashEntry = function (key, value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        };

        var EntryList = function () {
            this.first = null;
            this.last = null;
        };
        EntryList.prototype =
        {
            addLast: function (entry) {
                if (this.last != null) {
                    this.last.next = entry;
                    entry.prev = this.last;
                    this.last = entry;
                } else this.first = this.last = entry;
            },

            replace: function (entry, newEntry) {
                if (entry.prev != null) {
                    entry.prev.next = newEntry;
                    newEntry.prev = entry.prev;
                } else this.first = newEntry;

                if (entry.next != null) {
                    entry.next.prev = newEntry;
                    newEntry.next = entry.next;
                } else this.last = newEntry;

            },

            remove: function (entry) {
                if (entry.prev != null) entry.prev.next = entry.next;
                else this.first = entry.next;

                if (entry.next != null) entry.next.prev = entry.prev;
                else this.last = entry.prev;
            }
        };

        // Overload:function()
        // Overload:function(compareSelector)
        var Dictionary = function (compareSelector) {
            this.countField = 0;
            this.entryList = new EntryList();
            this.buckets = {}; // as Dictionary<string,List<object>>
            this.compareSelector = (compareSelector == null) ? Functions.Identity : compareSelector;
        };
        Dictionary.prototype =
        {
            add: function (key, value) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                var entry = new HashEntry(key, value);
                if (callHasOwnProperty(this.buckets, hash)) {
                    var array = this.buckets[hash];
                    for (var i = 0; i < array.length; i++) {
                        if (this.compareSelector(array[i].key) === compareKey) {
                            this.entryList.replace(array[i], entry);
                            array[i] = entry;
                            return;
                        }
                    }
                    array.push(entry);
                } else {
                    this.buckets[hash] = [entry];
                }
                this.countField++;
                this.entryList.addLast(entry);
            },

            get: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return undefined;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    var entry = array[i];
                    if (this.compareSelector(entry.key) === compareKey) return entry.value;
                }
                return undefined;
            },

            set: function (key, value) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (callHasOwnProperty(this.buckets, hash)) {
                    var array = this.buckets[hash];
                    for (var i = 0; i < array.length; i++) {
                        if (this.compareSelector(array[i].key) === compareKey) {
                            var newEntry = new HashEntry(key, value);
                            this.entryList.replace(array[i], newEntry);
                            array[i] = newEntry;
                            return true;
                        }
                    }
                }
                return false;
            },

            contains: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return false;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    if (this.compareSelector(array[i].key) === compareKey) return true;
                }
                return false;
            },

            clear: function () {
                this.countField = 0;
                this.buckets = {};
                this.entryList = new EntryList();
            },

            remove: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    if (this.compareSelector(array[i].key) === compareKey) {
                        this.entryList.remove(array[i]);
                        array.splice(i, 1);
                        if (array.length == 0) delete this.buckets[hash];
                        this.countField--;
                        return;
                    }
                }
            },

            count: function () {
                return this.countField;
            },

            toEnumerable: function () {
                var self = this;
                return new Enumerable(function () {
                    var currentEntry;

                    return new IEnumerator(
                        function () { currentEntry = self.entryList.first; },
                        function () {
                            if (currentEntry != null) {
                                var result = { key: currentEntry.key, value: currentEntry.value };
                                currentEntry = currentEntry.next;
                                return this.yieldReturn(result);
                            }
                            return false;
                        },
                        Functions.Blank);
                });
            }
        };

        return Dictionary;
    })();

    // dictionary = Dictionary<TKey, TValue[]>
    var Lookup = function (dictionary) {
        this.count = function () {
            return dictionary.count();
        };
        this.get = function (key) {
            return Enumerable.from(dictionary.get(key));
        };
        this.contains = function (key) {
            return dictionary.contains(key);
        };
        this.toEnumerable = function () {
            return dictionary.toEnumerable().select(function (kvp) {
                return new Grouping(kvp.key, kvp.value);
            });
        };
    };

    var Grouping = function (groupKey, elements) {
        this.key = function () {
            return groupKey;
        };
        ArrayEnumerable.call(this, elements);
    };
    Grouping.prototype = new ArrayEnumerable();

    // module export
    if ("function" === Types.Function && __webpack_require__("./node_modules/webpack/buildin/amd-options.js")) { // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return Enumerable; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else if (typeof module !== Types.Undefined && module.exports) { // Node
        module.exports = Enumerable;
    }
    else {
        root.Enumerable = Enumerable;
    }
})(this);


/***/ }),

/***/ "../heroprotocol/node_modules/long/src/long.js":
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "../heroprotocol/node_modules/reflect-metadata/Reflect.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js"), __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../heroprotocol/node_modules/sha1/sha1.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {(function() {
  var crypt = __webpack_require__("../heroprotocol/node_modules/crypt/crypt.js"),
      utf8 = __webpack_require__("../heroprotocol/node_modules/charenc/charenc.js").utf8,
      bin = __webpack_require__("../heroprotocol/node_modules/charenc/charenc.js").bin,

  // The core
  sha1 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();

    // otherwise assume byte array

    var m  = crypt.bytesToWords(message),
        l  = message.length * 8,
        w  = [],
        H0 =  1732584193,
        H1 = -271733879,
        H2 = -1732584194,
        H3 =  271733878,
        H4 = -1009589776;

    // Padding
    m[l >> 5] |= 0x80 << (24 - l % 32);
    m[((l + 64 >>> 9) << 4) + 15] = l;

    for (var i = 0; i < m.length; i += 16) {
      var a = H0,
          b = H1,
          c = H2,
          d = H3,
          e = H4;

      for (var j = 0; j < 80; j++) {

        if (j < 16)
          w[j] = m[i + j];
        else {
          var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = (n << 1) | (n >>> 31);
        }

        var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                         (H1 ^ H2 ^ H3) - 899497514);

        H4 = H3;
        H3 = H2;
        H2 = (H1 << 30) | (H1 >>> 2);
        H1 = H0;
        H0 = t;
      }

      H0 += a;
      H1 += b;
      H2 += c;
      H3 += d;
      H4 += e;
    }

    return [H0, H1, H2, H3, H4];
  },

  // Public API
  api = function (message, options) {
    var digestbytes = crypt.wordsToBytes(sha1(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

  api._blocksize = 16;
  api._digestsize = 20;

  module.exports = api;
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/moment/locale recursive ^\\.\\/.*$":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "./node_modules/moment/locale/af.js",
	"./af.js": "./node_modules/moment/locale/af.js",
	"./ar": "./node_modules/moment/locale/ar.js",
	"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
	"./ar.js": "./node_modules/moment/locale/ar.js",
	"./az": "./node_modules/moment/locale/az.js",
	"./az.js": "./node_modules/moment/locale/az.js",
	"./be": "./node_modules/moment/locale/be.js",
	"./be.js": "./node_modules/moment/locale/be.js",
	"./bg": "./node_modules/moment/locale/bg.js",
	"./bg.js": "./node_modules/moment/locale/bg.js",
	"./bm": "./node_modules/moment/locale/bm.js",
	"./bm.js": "./node_modules/moment/locale/bm.js",
	"./bn": "./node_modules/moment/locale/bn.js",
	"./bn.js": "./node_modules/moment/locale/bn.js",
	"./bo": "./node_modules/moment/locale/bo.js",
	"./bo.js": "./node_modules/moment/locale/bo.js",
	"./br": "./node_modules/moment/locale/br.js",
	"./br.js": "./node_modules/moment/locale/br.js",
	"./bs": "./node_modules/moment/locale/bs.js",
	"./bs.js": "./node_modules/moment/locale/bs.js",
	"./ca": "./node_modules/moment/locale/ca.js",
	"./ca.js": "./node_modules/moment/locale/ca.js",
	"./cs": "./node_modules/moment/locale/cs.js",
	"./cs.js": "./node_modules/moment/locale/cs.js",
	"./cv": "./node_modules/moment/locale/cv.js",
	"./cv.js": "./node_modules/moment/locale/cv.js",
	"./cy": "./node_modules/moment/locale/cy.js",
	"./cy.js": "./node_modules/moment/locale/cy.js",
	"./da": "./node_modules/moment/locale/da.js",
	"./da.js": "./node_modules/moment/locale/da.js",
	"./de": "./node_modules/moment/locale/de.js",
	"./de-at": "./node_modules/moment/locale/de-at.js",
	"./de-at.js": "./node_modules/moment/locale/de-at.js",
	"./de-ch": "./node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
	"./de.js": "./node_modules/moment/locale/de.js",
	"./dv": "./node_modules/moment/locale/dv.js",
	"./dv.js": "./node_modules/moment/locale/dv.js",
	"./el": "./node_modules/moment/locale/el.js",
	"./el.js": "./node_modules/moment/locale/el.js",
	"./en-au": "./node_modules/moment/locale/en-au.js",
	"./en-au.js": "./node_modules/moment/locale/en-au.js",
	"./en-ca": "./node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
	"./en-gb": "./node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
	"./en-ie": "./node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
	"./en-il": "./node_modules/moment/locale/en-il.js",
	"./en-il.js": "./node_modules/moment/locale/en-il.js",
	"./en-nz": "./node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
	"./eo": "./node_modules/moment/locale/eo.js",
	"./eo.js": "./node_modules/moment/locale/eo.js",
	"./es": "./node_modules/moment/locale/es.js",
	"./es-do": "./node_modules/moment/locale/es-do.js",
	"./es-do.js": "./node_modules/moment/locale/es-do.js",
	"./es-us": "./node_modules/moment/locale/es-us.js",
	"./es-us.js": "./node_modules/moment/locale/es-us.js",
	"./es.js": "./node_modules/moment/locale/es.js",
	"./et": "./node_modules/moment/locale/et.js",
	"./et.js": "./node_modules/moment/locale/et.js",
	"./eu": "./node_modules/moment/locale/eu.js",
	"./eu.js": "./node_modules/moment/locale/eu.js",
	"./fa": "./node_modules/moment/locale/fa.js",
	"./fa.js": "./node_modules/moment/locale/fa.js",
	"./fi": "./node_modules/moment/locale/fi.js",
	"./fi.js": "./node_modules/moment/locale/fi.js",
	"./fo": "./node_modules/moment/locale/fo.js",
	"./fo.js": "./node_modules/moment/locale/fo.js",
	"./fr": "./node_modules/moment/locale/fr.js",
	"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
	"./fr.js": "./node_modules/moment/locale/fr.js",
	"./fy": "./node_modules/moment/locale/fy.js",
	"./fy.js": "./node_modules/moment/locale/fy.js",
	"./gd": "./node_modules/moment/locale/gd.js",
	"./gd.js": "./node_modules/moment/locale/gd.js",
	"./gl": "./node_modules/moment/locale/gl.js",
	"./gl.js": "./node_modules/moment/locale/gl.js",
	"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
	"./gu": "./node_modules/moment/locale/gu.js",
	"./gu.js": "./node_modules/moment/locale/gu.js",
	"./he": "./node_modules/moment/locale/he.js",
	"./he.js": "./node_modules/moment/locale/he.js",
	"./hi": "./node_modules/moment/locale/hi.js",
	"./hi.js": "./node_modules/moment/locale/hi.js",
	"./hr": "./node_modules/moment/locale/hr.js",
	"./hr.js": "./node_modules/moment/locale/hr.js",
	"./hu": "./node_modules/moment/locale/hu.js",
	"./hu.js": "./node_modules/moment/locale/hu.js",
	"./hy-am": "./node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
	"./id": "./node_modules/moment/locale/id.js",
	"./id.js": "./node_modules/moment/locale/id.js",
	"./is": "./node_modules/moment/locale/is.js",
	"./is.js": "./node_modules/moment/locale/is.js",
	"./it": "./node_modules/moment/locale/it.js",
	"./it.js": "./node_modules/moment/locale/it.js",
	"./ja": "./node_modules/moment/locale/ja.js",
	"./ja.js": "./node_modules/moment/locale/ja.js",
	"./jv": "./node_modules/moment/locale/jv.js",
	"./jv.js": "./node_modules/moment/locale/jv.js",
	"./ka": "./node_modules/moment/locale/ka.js",
	"./ka.js": "./node_modules/moment/locale/ka.js",
	"./kk": "./node_modules/moment/locale/kk.js",
	"./kk.js": "./node_modules/moment/locale/kk.js",
	"./km": "./node_modules/moment/locale/km.js",
	"./km.js": "./node_modules/moment/locale/km.js",
	"./kn": "./node_modules/moment/locale/kn.js",
	"./kn.js": "./node_modules/moment/locale/kn.js",
	"./ko": "./node_modules/moment/locale/ko.js",
	"./ko.js": "./node_modules/moment/locale/ko.js",
	"./ky": "./node_modules/moment/locale/ky.js",
	"./ky.js": "./node_modules/moment/locale/ky.js",
	"./lb": "./node_modules/moment/locale/lb.js",
	"./lb.js": "./node_modules/moment/locale/lb.js",
	"./lo": "./node_modules/moment/locale/lo.js",
	"./lo.js": "./node_modules/moment/locale/lo.js",
	"./lt": "./node_modules/moment/locale/lt.js",
	"./lt.js": "./node_modules/moment/locale/lt.js",
	"./lv": "./node_modules/moment/locale/lv.js",
	"./lv.js": "./node_modules/moment/locale/lv.js",
	"./me": "./node_modules/moment/locale/me.js",
	"./me.js": "./node_modules/moment/locale/me.js",
	"./mi": "./node_modules/moment/locale/mi.js",
	"./mi.js": "./node_modules/moment/locale/mi.js",
	"./mk": "./node_modules/moment/locale/mk.js",
	"./mk.js": "./node_modules/moment/locale/mk.js",
	"./ml": "./node_modules/moment/locale/ml.js",
	"./ml.js": "./node_modules/moment/locale/ml.js",
	"./mn": "./node_modules/moment/locale/mn.js",
	"./mn.js": "./node_modules/moment/locale/mn.js",
	"./mr": "./node_modules/moment/locale/mr.js",
	"./mr.js": "./node_modules/moment/locale/mr.js",
	"./ms": "./node_modules/moment/locale/ms.js",
	"./ms-my": "./node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
	"./ms.js": "./node_modules/moment/locale/ms.js",
	"./mt": "./node_modules/moment/locale/mt.js",
	"./mt.js": "./node_modules/moment/locale/mt.js",
	"./my": "./node_modules/moment/locale/my.js",
	"./my.js": "./node_modules/moment/locale/my.js",
	"./nb": "./node_modules/moment/locale/nb.js",
	"./nb.js": "./node_modules/moment/locale/nb.js",
	"./ne": "./node_modules/moment/locale/ne.js",
	"./ne.js": "./node_modules/moment/locale/ne.js",
	"./nl": "./node_modules/moment/locale/nl.js",
	"./nl-be": "./node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
	"./nl.js": "./node_modules/moment/locale/nl.js",
	"./nn": "./node_modules/moment/locale/nn.js",
	"./nn.js": "./node_modules/moment/locale/nn.js",
	"./pa-in": "./node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
	"./pl": "./node_modules/moment/locale/pl.js",
	"./pl.js": "./node_modules/moment/locale/pl.js",
	"./pt": "./node_modules/moment/locale/pt.js",
	"./pt-br": "./node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
	"./pt.js": "./node_modules/moment/locale/pt.js",
	"./ro": "./node_modules/moment/locale/ro.js",
	"./ro.js": "./node_modules/moment/locale/ro.js",
	"./ru": "./node_modules/moment/locale/ru.js",
	"./ru.js": "./node_modules/moment/locale/ru.js",
	"./sd": "./node_modules/moment/locale/sd.js",
	"./sd.js": "./node_modules/moment/locale/sd.js",
	"./se": "./node_modules/moment/locale/se.js",
	"./se.js": "./node_modules/moment/locale/se.js",
	"./si": "./node_modules/moment/locale/si.js",
	"./si.js": "./node_modules/moment/locale/si.js",
	"./sk": "./node_modules/moment/locale/sk.js",
	"./sk.js": "./node_modules/moment/locale/sk.js",
	"./sl": "./node_modules/moment/locale/sl.js",
	"./sl.js": "./node_modules/moment/locale/sl.js",
	"./sq": "./node_modules/moment/locale/sq.js",
	"./sq.js": "./node_modules/moment/locale/sq.js",
	"./sr": "./node_modules/moment/locale/sr.js",
	"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "./node_modules/moment/locale/sr.js",
	"./ss": "./node_modules/moment/locale/ss.js",
	"./ss.js": "./node_modules/moment/locale/ss.js",
	"./sv": "./node_modules/moment/locale/sv.js",
	"./sv.js": "./node_modules/moment/locale/sv.js",
	"./sw": "./node_modules/moment/locale/sw.js",
	"./sw.js": "./node_modules/moment/locale/sw.js",
	"./ta": "./node_modules/moment/locale/ta.js",
	"./ta.js": "./node_modules/moment/locale/ta.js",
	"./te": "./node_modules/moment/locale/te.js",
	"./te.js": "./node_modules/moment/locale/te.js",
	"./tet": "./node_modules/moment/locale/tet.js",
	"./tet.js": "./node_modules/moment/locale/tet.js",
	"./tg": "./node_modules/moment/locale/tg.js",
	"./tg.js": "./node_modules/moment/locale/tg.js",
	"./th": "./node_modules/moment/locale/th.js",
	"./th.js": "./node_modules/moment/locale/th.js",
	"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
	"./tlh": "./node_modules/moment/locale/tlh.js",
	"./tlh.js": "./node_modules/moment/locale/tlh.js",
	"./tr": "./node_modules/moment/locale/tr.js",
	"./tr.js": "./node_modules/moment/locale/tr.js",
	"./tzl": "./node_modules/moment/locale/tzl.js",
	"./tzl.js": "./node_modules/moment/locale/tzl.js",
	"./tzm": "./node_modules/moment/locale/tzm.js",
	"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "./node_modules/moment/locale/tzm.js",
	"./ug-cn": "./node_modules/moment/locale/ug-cn.js",
	"./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
	"./uk": "./node_modules/moment/locale/uk.js",
	"./uk.js": "./node_modules/moment/locale/uk.js",
	"./ur": "./node_modules/moment/locale/ur.js",
	"./ur.js": "./node_modules/moment/locale/ur.js",
	"./uz": "./node_modules/moment/locale/uz.js",
	"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
	"./uz.js": "./node_modules/moment/locale/uz.js",
	"./vi": "./node_modules/moment/locale/vi.js",
	"./vi.js": "./node_modules/moment/locale/vi.js",
	"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
	"./yo": "./node_modules/moment/locale/yo.js",
	"./yo.js": "./node_modules/moment/locale/yo.js",
	"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
	"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/moment/locale recursive ^\\.\\/.*$";

/***/ }),

/***/ "./src/$$_lazy_route_resource lazy recursive":
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "./src/$$_lazy_route_resource lazy recursive";

/***/ }),

/***/ "./src/app/app-routing.module.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppRoutingModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__("./node_modules/@angular/router/esm5/router.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__environments_environment__ = __webpack_require__("./src/environments/environment.ts");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



var appRoutes = [];
var AppRoutingModule = /** @class */ (function () {
    function AppRoutingModule() {
    }
    AppRoutingModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["K" /* NgModule */])({
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_router__["a" /* RouterModule */].forRoot(appRoutes, { enableTracing: !__WEBPACK_IMPORTED_MODULE_2__environments_environment__["a" /* environment */].production } // <-- debugging purposes only
                )
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_router__["a" /* RouterModule */]
            ]
        })
    ], AppRoutingModule);
    return AppRoutingModule;
}());



/***/ }),

/***/ "./src/app/app.component.html":
/***/ (function(module, exports) {

module.exports = "<router-outlet></router-outlet>"

/***/ }),

/***/ "./src/app/app.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: block;\n  width: 100%;\n  height: 100%; }\n"

/***/ }),

/***/ "./src/app/app.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var AppComponent = /** @class */ (function () {
    function AppComponent() {
        this.title = 'app';
    }
    AppComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'app-root',
            template: __webpack_require__("./src/app/app.component.html"),
            styles: [__webpack_require__("./src/app/app.component.scss")]
        })
    ], AppComponent);
    return AppComponent;
}());



/***/ }),

/***/ "./src/app/app.module.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser__ = __webpack_require__("./node_modules/@angular/platform-browser/esm5/platform-browser.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol__ = __webpack_require__("../heroprotocol/dist/lib/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__environments_environment__ = __webpack_require__("./src/environments/environment.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_component__ = __webpack_require__("./src/app/app.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__replay_viewer_replay_viewer_module__ = __webpack_require__("./src/app/replay-viewer/replay-viewer.module.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__app_routing_module__ = __webpack_require__("./src/app/app-routing.module.ts");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







__WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol__["HeroProtocol"].env = __WEBPACK_IMPORTED_MODULE_3__environments_environment__["a" /* environment */].production ? 'production' : 'developement';
var AppModule = /** @class */ (function () {
    function AppModule() {
    }
    AppModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["K" /* NgModule */])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_4__app_component__["a" /* AppComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser__["a" /* BrowserModule */],
                __WEBPACK_IMPORTED_MODULE_5__replay_viewer_replay_viewer_module__["a" /* ReplayViewerModule */],
                __WEBPACK_IMPORTED_MODULE_6__app_routing_module__["a" /* AppRoutingModule */]
            ],
            providers: [],
            bootstrap: [__WEBPACK_IMPORTED_MODULE_4__app_component__["a" /* AppComponent */]]
        })
    ], AppModule);
    return AppModule;
}());



/***/ }),

/***/ "./src/app/replay-viewer/components/hero-icon/hero-icon.component.html":
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/app/replay-viewer/components/hero-icon/hero-icon.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: block;\n  position: relative; }\n  :host ::ng-deep canvas, :host ::ng-deep img {\n    z-index: 1;\n    width: 100%;\n    height: 100%; }\n"

/***/ }),

/***/ "./src/app/replay-viewer/components/hero-icon/hero-icon.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HeroIconComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_clip_icon_clip_icon_service__ = __webpack_require__("./src/app/replay-viewer/services/clip-icon/clip-icon.service.ts");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var HeroIconComponent = /** @class */ (function () {
    function HeroIconComponent(clipIconService, renderer, elementRef) {
        this.clipIconService = clipIconService;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this._shape = __WEBPACK_IMPORTED_MODULE_1__services_clip_icon_clip_icon_service__["b" /* ClipMethod */].CIRCLE;
    }
    Object.defineProperty(HeroIconComponent.prototype, "shape", {
        get: function () {
            return this._shape;
        },
        set: function (value) {
            if (typeof value === 'string') {
                this._shape = __WEBPACK_IMPORTED_MODULE_1__services_clip_icon_clip_icon_service__["b" /* ClipMethod */][value.toUpperCase()];
            }
            else {
                this._shape = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeroIconComponent.prototype, "heroImage", {
        get: function () {
            return this._heroImage;
        },
        enumerable: true,
        configurable: true
    });
    HeroIconComponent.prototype.ngOnChanges = function (changes) {
        if (changes.hero || changes.shape) {
            if (this.hero) {
                this.clipHeroImage();
                console.log(this.heroImage);
            }
        }
    };
    HeroIconComponent.prototype.clipHeroImage = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.clipIconService.loadAndClip('//d1i1jxrdh2kvwy.cloudfront.net/Images/Heroes/Portraits/' + this.cleanName(this.hero) + '.png', 48, 48, this._shape)];
                    case 1:
                        _a._heroImage = _b.sent();
                        this.renderer.appendChild(this.elementRef.nativeElement, this.heroImage);
                        return [2 /*return*/];
                }
            });
        });
    };
    HeroIconComponent.prototype.cleanName = function (name) {
        return name.replace(/[^\w\dú]/g, '').replace(/ú/g, '%C3%BA');
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* Input */])(),
        __metadata("design:type", String)
    ], HeroIconComponent.prototype, "hero", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* Input */])(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], HeroIconComponent.prototype, "shape", null);
    HeroIconComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'hero-icon',
            template: __webpack_require__("./src/app/replay-viewer/components/hero-icon/hero-icon.component.html"),
            styles: [__webpack_require__("./src/app/replay-viewer/components/hero-icon/hero-icon.component.scss")],
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_clip_icon_clip_icon_service__["a" /* ClipIconService */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["Y" /* Renderer2 */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["u" /* ElementRef */]])
    ], HeroIconComponent);
    return HeroIconComponent;
}());



/***/ }),

/***/ "./src/app/replay-viewer/components/replay-header/replay-header.component.html":
/***/ (function(module, exports) {

module.exports = "<div class=\"team team1\">\n  <div class=\"winner\" [style.visibility]=\"replayDescription?.winningTeam === 0 ? 'visible' : 'hidden'\">Winner</div>\n  <div class=\"players\">\n    <hero-icon *ngFor=\"let player of team1Players\" class=\"player\" [hero]=\"player.hero\">\n      {{cleanName(player.hero)}}\n    </hero-icon>\n  </div>\n</div>\n<div class=\"map\">\n  <div>\n    <div class=\"mode\">{{gameMode}}</div>\n    <div class=\"name\">{{replayDescription.mapName}}</div>\n  </div>\n  <div class=\"date\">{{replayDescription.playedOn | date:'MMMM d, yyy - hh:mm a'}} - {{gameDuration}}</div>\n</div>\n<div class=\"team team2\">\n  <div class=\"winner\" [style.visibility]=\"replayDescription?.winningTeam === 1 ? 'visible' : 'hidden'\">Winner</div>\n  <div class=\"players\">\n    <hero-icon *ngFor=\"let player of team2Players\" class=\"player\" [hero]=\"player.hero\">\n      {{cleanName(player.hero)}}\n    </hero-icon>\n  </div>\n</div>\n"

/***/ }),

/***/ "./src/app/replay-viewer/components/replay-header/replay-header.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  padding: 16px;\n  padding-bottom: 24px;\n  background-repeat: repeat-x, repeat-x, no-repeat;\n  background-size: auto auto, auto auto, 100% auto;\n  background: -webkit-gradient(linear, left top, left bottom, from(rgba(13, 1, 25, 0)), to(#0d0119)), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/game/Overview/TheBasics/BasicsBackground.jpg\");\n  background: linear-gradient(rgba(13, 1, 25, 0), #0d0119), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/game/Overview/TheBasics/BasicsBackground.jpg\");\n  background-position: 0px 0px, 0px 0px, center 0px; }\n  :host.battlefield-of-eternity {\n    background: -webkit-gradient(linear, left top, left bottom, from(rgba(13, 1, 25, 0)), to(#0d0119)), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/battlegrounds/battlefield-of-eternity/front-1940.jpg\");\n    background: linear-gradient(rgba(13, 1, 25, 0), #0d0119), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/battlegrounds/battlefield-of-eternity/front-1940.jpg\");\n    background-position: 0px 0px, 0px 0px, center -40px; }\n  :host.towers-of-doom {\n    background: -webkit-gradient(linear, left top, left bottom, from(rgba(13, 1, 25, 0)), to(#0d0119)), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/battlegrounds/towers-of-doom/front-1940.jpg\");\n    background: linear-gradient(rgba(13, 1, 25, 0), #0d0119), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/battlegrounds/towers-of-doom/front-1940.jpg\");\n    background-position: 0px 0px, 0px 0px, center -10px; }\n  :host.cursed-hollow {\n    background: -webkit-gradient(linear, left top, left bottom, from(rgba(13, 1, 25, 0)), to(#0d0119)), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/battlegrounds/cursed-hollow/front-1940.jpg\");\n    background: linear-gradient(rgba(13, 1, 25, 0), #0d0119), url(https://us.battle.net/heroes/static/images/heroes-2/nav-top-pattern.png), url(\"https://us.battle.net/heroes/static/images/battlegrounds/cursed-hollow/front-1940.jpg\");\n    background-position: 0px 0px, 0px 0px, center -110px; }\n  :host > * {\n    -webkit-box-flex: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column; }\n  :host > * > * {\n      -webkit-box-flex: 0;\n          -ms-flex-positive: 0;\n              flex-grow: 0;\n      -ms-flex-item-align: center;\n          -ms-grid-row-align: center;\n          align-self: center; }\n  :host .map .mode {\n    padding-bottom: 8px; }\n  :host .map .name {\n    font-size: 36px;\n    line-height: 36px;\n    font-weight: 700;\n    margin-bottom: 4px;\n    text-shadow: 0px 0px 2px black, 0px 0px 2px black, 0px 0px 2px black, 0px 0px 24px white, 0px 0px 24px white, 0px 0px 34px white; }\n  :host .map .date {\n    padding-top: 8px; }\n  :host .players {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: row;\n            flex-direction: row; }\n  :host .players .player {\n      width: 48px;\n      height: 48px;\n      border-radius: 50%;\n      margin-left: 3px;\n      margin-right: 3px; }\n  :host .team .winner {\n    padding: 8px;\n    font-size: 16px;\n    font-weight: 700; }\n  :host .team1 .player {\n    border: 2px solid navy;\n    -webkit-box-shadow: 0px 0px 8px blue;\n            box-shadow: 0px 0px 8px blue; }\n  :host .team1 .winner {\n    text-shadow: 0px 0px 18px blue, 0px 0px 18px blue, 0px 0px 18px blue; }\n  :host .team2 .player {\n    border: 2px solid maroon;\n    -webkit-box-shadow: 0px 0px 8px red;\n            box-shadow: 0px 0px 8px red; }\n  :host .team2 .winner {\n    text-shadow: 0px 0px 18px red, 0px 0px 18px red, 0px 0px 18px red; }\n"

/***/ }),

/***/ "./src/app/replay-viewer/components/replay-header/replay-header.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplayHeaderComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__ = __webpack_require__("../heroprotocol/dist/lib/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_linq__ = __webpack_require__("./node_modules/linq/linq.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_linq___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_linq__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_change_case__ = __webpack_require__("./node_modules/change-case/change-case.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_change_case___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_change_case__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__("./node_modules/moment/moment.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var ReplayHeaderComponent = /** @class */ (function () {
    function ReplayHeaderComponent() {
        this.mapClass = [];
    }
    Object.defineProperty(ReplayHeaderComponent.prototype, "replayDescription", {
        get: function () {
            return this._replayDescription;
        },
        set: function (desc) {
            this._replayDescription = desc;
            this.mapClass = [Object(__WEBPACK_IMPORTED_MODULE_3_change_case__["paramCase"])(desc.mapName)];
            console.log(desc);
            this.gameMode = __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__["GameType"][desc.gameType];
            var dur = Object(__WEBPACK_IMPORTED_MODULE_4_moment__["duration"])(desc.gameDuration, 's');
            var min = Math.floor(dur.asMinutes());
            var sec = ('' + Math.floor(dur.subtract(min, 'm').asSeconds())).padStart(2, '0');
            this.gameDuration = min + 'm ' + sec + 's';
            this.team1Players = __WEBPACK_IMPORTED_MODULE_2_linq__["from"](desc.players).where(function (p) { return p.team === 0; }).toArray();
            this.team2Players = __WEBPACK_IMPORTED_MODULE_2_linq__["from"](desc.players).where(function (p) { return p.team === 1; }).toArray();
        },
        enumerable: true,
        configurable: true
    });
    ReplayHeaderComponent.prototype.cleanName = function (name) {
        return name.replace(/[^\w\d]/g, '');
    };
    ReplayHeaderComponent.prototype.ngOnInit = function () {
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["z" /* HostBinding */])('class'),
        __metadata("design:type", Array)
    ], ReplayHeaderComponent.prototype, "mapClass", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* Input */])(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ReplayHeaderComponent.prototype, "replayDescription", null);
    ReplayHeaderComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'replay-header',
            template: __webpack_require__("./src/app/replay-viewer/components/replay-header/replay-header.component.html"),
            styles: [__webpack_require__("./src/app/replay-viewer/components/replay-header/replay-header.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], ReplayHeaderComponent);
    return ReplayHeaderComponent;
}());



/***/ }),

/***/ "./src/app/replay-viewer/components/replay-nav/nav-item/nav-item.component.html":
/***/ (function(module, exports) {

module.exports = "<label>{{item?.label}}</label>\n<div class=\"children\" *ngIf=\"item.type === 'section' && item['children']?.length\">\n  <nav-item *ngFor=\"let child of item['children']\" [item]=\"child\" [level]=\"level + 1\"></nav-item>\n</div>"

/***/ }),

/***/ "./src/app/replay-viewer/components/replay-nav/nav-item/nav-item.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: block; }\n  :host > label {\n    display: block; }\n  :host.section > .children {\n    padding: 8px; }\n  :host.section[level=\"0\"] > label {\n    font-size: 16px;\n    font-weight: 500;\n    padding: 8px;\n    text-align: center;\n    text-transform: uppercase;\n    border-width: 2px;\n    border-style: solid;\n    border-top: none;\n    -o-border-image: linear-gradient(to left, transparent, transparent, aqua, transparent, transparent) 100% 58;\n       border-image: -webkit-gradient(linear, right top, left top, from(transparent), color-stop(transparent), color-stop(aqua), color-stop(transparent), to(transparent)) 100% 58;\n       border-image: linear-gradient(to left, transparent, transparent, aqua, transparent, transparent) 100% 58; }\n  :host.section[level=\"0\"] > .children {\n    padding-left: 20px; }\n  :host.link > label {\n    padding: 8px; }\n  :host.link:hover {\n    background: -webkit-gradient(linear, left top, right top, from(rgba(0, 255, 255, 0.4)), to(rgba(0, 255, 255, 0)));\n    background: linear-gradient(to right, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0)); }\n"

/***/ }),

/***/ "./src/app/replay-viewer/components/replay-nav/nav-item/nav-item.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NavItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var NavItemComponent = /** @class */ (function () {
    function NavItemComponent() {
        this.level = 0;
    }
    Object.defineProperty(NavItemComponent.prototype, "isSection", {
        get: function () {
            return this.item ? this.item.type === 'section' : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavItemComponent.prototype, "isLink", {
        get: function () {
            return this.item ? this.item.type === 'link' : false;
        },
        enumerable: true,
        configurable: true
    });
    NavItemComponent.prototype.ngOnChanges = function (changes) {
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* Input */])(),
        __metadata("design:type", Object)
    ], NavItemComponent.prototype, "item", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* Input */])(),
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["z" /* HostBinding */])('attr.level'),
        __metadata("design:type", Object)
    ], NavItemComponent.prototype, "level", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["z" /* HostBinding */])('class.section'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], NavItemComponent.prototype, "isSection", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["z" /* HostBinding */])('class.link'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], NavItemComponent.prototype, "isLink", null);
    NavItemComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'nav-item',
            template: __webpack_require__("./src/app/replay-viewer/components/replay-nav/nav-item/nav-item.component.html"),
            styles: [__webpack_require__("./src/app/replay-viewer/components/replay-nav/nav-item/nav-item.component.scss")],
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [])
    ], NavItemComponent);
    return NavItemComponent;
}());



/***/ }),

/***/ "./src/app/replay-viewer/components/replay-nav/replay-nav.component.html":
/***/ (function(module, exports) {

module.exports = "\n<nav-item *ngFor=\"let item of navData\" [item]=\"item\"></nav-item>\n<!--<pre>{{navData | json}}</pre>-->\n"

/***/ }),

/***/ "./src/app/replay-viewer/components/replay-nav/replay-nav.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: block;\n  border-width: 2px;\n  border-style: solid;\n  border-bottom: none;\n  -o-border-image: linear-gradient(to left, transparent, transparent, aqua, transparent, transparent) 100% 50;\n     border-image: -webkit-gradient(linear, right top, left top, from(transparent), color-stop(transparent), color-stop(aqua), color-stop(transparent), to(transparent)) 100% 50;\n     border-image: linear-gradient(to left, transparent, transparent, aqua, transparent, transparent) 100% 50;\n  padding-left: 20px;\n  padding-right: 20px;\n  min-width: 300px; }\n"

/***/ }),

/***/ "./src/app/replay-viewer/components/replay-nav/replay-nav.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplayNavComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ReplayNavComponent = /** @class */ (function () {
    function ReplayNavComponent() {
    }
    Object.defineProperty(ReplayNavComponent.prototype, "replayDescription", {
        get: function () {
            return this._replayDescription;
        },
        set: function (desc) {
            this._replayDescription = desc;
        },
        enumerable: true,
        configurable: true
    });
    ReplayNavComponent.prototype.ngOnChanges = function (changes) {
        if (changes.replayDescription) {
            if (this.replayDescription) {
                this.navData = [];
                var overview = {
                    type: 'section',
                    label: 'Overview',
                    children: []
                };
                var scoreScreen = {
                    type: 'link',
                    label: 'Score Screen',
                    path: []
                };
                overview.children.push(scoreScreen);
                var draft = {
                    type: 'link',
                    label: 'Draft',
                    path: []
                };
                overview.children.push(draft);
                this.navData.push(overview);
            }
            else {
                this.navData = undefined;
            }
        }
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["F" /* Input */])(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ReplayNavComponent.prototype, "replayDescription", null);
    ReplayNavComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'replay-nav',
            template: __webpack_require__("./src/app/replay-viewer/components/replay-nav/replay-nav.component.html"),
            styles: [__webpack_require__("./src/app/replay-viewer/components/replay-nav/replay-nav.component.scss")],
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [])
    ], ReplayNavComponent);
    return ReplayNavComponent;
}());



/***/ }),

/***/ "./src/app/replay-viewer/replay-viewer-routing.module.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplayViewerRoutingModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_router__ = __webpack_require__("./node_modules/@angular/router/esm5/router.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__replay_viewer_component__ = __webpack_require__("./src/app/replay-viewer/replay-viewer.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__sections_score_screen_score_screen_component__ = __webpack_require__("./src/app/replay-viewer/sections/score-screen/score-screen.component.ts");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var replayViewerRoutes = [
    {
        path: '',
        component: __WEBPACK_IMPORTED_MODULE_2__replay_viewer_component__["a" /* ReplayViewerComponent */],
        children: [
            {
                path: '',
                component: __WEBPACK_IMPORTED_MODULE_3__sections_score_screen_score_screen_component__["a" /* ScoreScreenComponent */]
            }
        ]
    }
];
var ReplayViewerRoutingModule = /** @class */ (function () {
    function ReplayViewerRoutingModule() {
    }
    ReplayViewerRoutingModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["K" /* NgModule */])({
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_router__["a" /* RouterModule */].forChild(replayViewerRoutes)
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_router__["a" /* RouterModule */]
            ]
        })
    ], ReplayViewerRoutingModule);
    return ReplayViewerRoutingModule;
}());



/***/ }),

/***/ "./src/app/replay-viewer/replay-viewer.component.html":
/***/ (function(module, exports) {

module.exports = "<div class=\"upload-container\" [class.loaded]=\"fileState === FileState.LOADED\" [class.drag]=\"fileState == FileState.DRAGGING\"\n  [class.loading]=\"fileState == FileState.LOADING\" [class.parsing]=\"fileState == FileState.PARSING\">\n  <div class=\"upload\">\n    <input #fileInput type=\"file\" id=\"file\" (change)=\"handleFileSelected($event)\" />\n    <label for=\"file\">\n      <div>\n        <strong>Load Replay</strong>\n        <span class=\"dragndrop\"> or drag it here</span>\n        <div class=\"status\">{{FileState[fileState]}}</div>\n      </div>\n      <mat-progress-bar mode=\"indeterminate\" *ngIf=\"fileState == FileState.LOADING || fileState == FileState.PARSING\"></mat-progress-bar>\n    </label>\n  </div>\n</div>\n<div class=\"viewer-container\" *ngIf=\"replayDescription\">\n  <replay-header [replayDescription]=\"replayDescription\"></replay-header>\n  <mat-sidenav-container>\n    <mat-sidenav mode=\"side\" opened=\"true\">\n      <replay-nav [replayDescription]=\"replayDescription\"></replay-nav>\n    </mat-sidenav>\n    <mat-sidenav-content>\n      <router-outlet></router-outlet>\n    </mat-sidenav-content>\n  </mat-sidenav-container>\n</div>\n"

/***/ }),

/***/ "./src/app/replay-viewer/replay-viewer.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: #0d0119; }\n  :host .upload-container {\n    position: fixed;\n    top: 0px;\n    left: 0px;\n    width: 100vw;\n    height: 100vh;\n    z-index: 5;\n    background-color: navy;\n    padding: 30px; }\n  :host .upload-container.drag .upload {\n      border: 1px dotted darkturquoise; }\n  :host .upload-container .upload {\n      width: 100%;\n      height: 100%;\n      border: 1px dashed darkturquoise; }\n  :host .upload-container .upload input {\n        display: none; }\n  :host .upload-container .upload label {\n        display: -webkit-box;\n        display: -ms-flexbox;\n        display: flex;\n        -webkit-box-orient: vertical;\n        -webkit-box-direction: normal;\n            -ms-flex-direction: column;\n                flex-direction: column;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(255, 255, 255, 0.2);\n        -webkit-box-align: center;\n            -ms-flex-align: center;\n                align-items: center;\n        -webkit-box-pack: center;\n            -ms-flex-pack: center;\n                justify-content: center; }\n  :host .upload-container .upload label > div {\n          text-align: center; }\n  :host .upload-container .upload label .mat-progress-bar {\n          width: 30%;\n          display: block; }\n  :host .upload-container.loaded {\n      position: absolute;\n      right: 0px;\n      left: auto;\n      width: auto;\n      height: auto;\n      padding: 4px; }\n  :host .upload-container.loaded .upload {\n        width: auto;\n        height: auto; }\n  :host .upload-container.loaded .upload label {\n          padding: 4px;\n          width: auto;\n          height: auto; }\n  :host .upload-container.loaded .upload label .status,\n          :host .upload-container.loaded .upload label .dragndrop {\n            display: none; }\n  :host .viewer-container {\n    min-height: 100%;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n    -ms-flex-line-pack: stretch;\n        align-content: stretch; }\n  :host .viewer-container > .mat-sidenav-container {\n      -webkit-box-flex: 1;\n          -ms-flex-positive: 1;\n              flex-grow: 1;\n      background-color: #0d0119; }\n  :host .viewer-container > .mat-sidenav-container .mat-sidenav {\n        background-color: #0d0119;\n        border-width: 1px;\n        border-style: solid;\n        border: none;\n        border-right: solid;\n        -o-border-image: linear-gradient(to bottom, transparent, transparent, rgba(138, 43, 226, 0.4), transparent, transparent) 200 100%;\n           border-image: -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(transparent), color-stop(rgba(138, 43, 226, 0.4)), color-stop(transparent), to(transparent)) 200 100%;\n           border-image: linear-gradient(to bottom, transparent, transparent, rgba(138, 43, 226, 0.4), transparent, transparent) 200 100%; }\n"

/***/ }),

/***/ "./src/app/replay-viewer/replay-viewer.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplayViewerComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__ = __webpack_require__("../heroprotocol/dist/lib/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var FileState;
(function (FileState) {
    FileState[FileState["NONE"] = 0] = "NONE";
    FileState[FileState["DRAGGING"] = 1] = "DRAGGING";
    FileState[FileState["LOADING"] = 2] = "LOADING";
    FileState[FileState["PARSING"] = 3] = "PARSING";
    FileState[FileState["LOADED"] = 4] = "LOADED";
})(FileState || (FileState = {}));
var ReplayViewerComponent = /** @class */ (function () {
    function ReplayViewerComponent(renderer, elmRef, changeDetectorRef) {
        this.renderer = renderer;
        this.elmRef = elmRef;
        this.changeDetectorRef = changeDetectorRef;
        this.FileState = FileState;
        this._fileState = FileState.NONE;
        this.onReplayLoaded = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["x" /* EventEmitter */]();
    }
    Object.defineProperty(ReplayViewerComponent.prototype, "fileState", {
        get: function () {
            return this._fileState;
        },
        set: function (value) {
            if (this._fileState !== value) {
                this._fileState = value;
                this.changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    ReplayViewerComponent.prototype.ngOnInit = function () {
    };
    ReplayViewerComponent.prototype.handleDragStart = function (event) {
        return false;
    };
    ReplayViewerComponent.prototype.handleDragOver = function (event) {
        return false;
    };
    ReplayViewerComponent.prototype.handleDragLeave = function (event) {
        console.log('dragleave', event);
        if (!this.elmRef.nativeElement.contains(event.fromElement)) {
            console.log('handleDragLeave', event);
            this.fileState = this.replay ? FileState.LOADED : FileState.NONE;
            return false;
        }
    };
    ReplayViewerComponent.prototype.handleDragEnter = function (event) {
        this.fileState = FileState.DRAGGING;
        return false;
    };
    ReplayViewerComponent.prototype.handleDrop = function (event) {
        this.renderer.setProperty(this.fileInputRef.nativeElement, 'files', event.dataTransfer.files);
        return false;
    };
    ReplayViewerComponent.prototype.handleFileSelected = function (event) {
        var _this = this;
        var fileList = event.target.files;
        var file = fileList[0];
        if (file) {
            if (file.name.endsWith('.StormReplay')) {
                var fileReader_1 = new FileReader();
                fileReader_1.onload = function (evt) {
                    _this.handleReplayLoaded(fileReader_1.result);
                };
                fileReader_1.onerror = function (evt) {
                    console.log('onerror', evt);
                };
                fileReader_1.onabort = function (evt) {
                    console.log('onabort', evt);
                };
                fileReader_1.onloadstart = function (evt) {
                    _this.fileState = FileState.LOADING;
                };
                fileReader_1.onloadend = function (evt) {
                    _this.renderer.setProperty(_this.fileInputRef.nativeElement, 'value', '');
                };
                fileReader_1.readAsArrayBuffer(file);
            }
        }
    };
    ReplayViewerComponent.prototype.handleReplayLoaded = function (replayData) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.fileState = FileState.PARSING;
                        if (this.replay) {
                            this.replay.dispose();
                        }
                        this.replay = new __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__["Replay"](replayData);
                        this.basicReplayAnalyser = new __WEBPACK_IMPORTED_MODULE_1__heroesbrowser_heroprotocol__["BasicReplayAnalyser"](this.replay);
                        _a = this;
                        return [4 /*yield*/, this.basicReplayAnalyser.replayDescription];
                    case 1:
                        _a.replayDescription = _b.sent();
                        setTimeout(function () {
                            _this.fileState = FileState.LOADED;
                            _this.onReplayLoaded.next(_this.replay);
                        }, 0);
                        return [2 /*return*/];
                }
            });
        });
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewChild */])('fileInput'),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["u" /* ElementRef */])
    ], ReplayViewerComponent.prototype, "fileInputRef", void 0);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* HostListener */])('dragstart', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [DragEvent]),
        __metadata("design:returntype", void 0)
    ], ReplayViewerComponent.prototype, "handleDragStart", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* HostListener */])('dragover', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [DragEvent]),
        __metadata("design:returntype", void 0)
    ], ReplayViewerComponent.prototype, "handleDragOver", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* HostListener */])('dragleave', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [DragEvent]),
        __metadata("design:returntype", void 0)
    ], ReplayViewerComponent.prototype, "handleDragLeave", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* HostListener */])('dragenter', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [DragEvent]),
        __metadata("design:returntype", void 0)
    ], ReplayViewerComponent.prototype, "handleDragEnter", null);
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["A" /* HostListener */])('drop', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [DragEvent]),
        __metadata("design:returntype", void 0)
    ], ReplayViewerComponent.prototype, "handleDrop", null);
    ReplayViewerComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'replay-viewer',
            template: __webpack_require__("./src/app/replay-viewer/replay-viewer.component.html"),
            styles: [__webpack_require__("./src/app/replay-viewer/replay-viewer.component.scss")],
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["Y" /* Renderer2 */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["u" /* ElementRef */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["k" /* ChangeDetectorRef */]])
    ], ReplayViewerComponent);
    return ReplayViewerComponent;
}());



/***/ }),

/***/ "./src/app/replay-viewer/replay-viewer.module.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplayViewerModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__("./node_modules/@angular/common/esm5/common.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__replay_viewer_component__ = __webpack_require__("./src/app/replay-viewer/replay-viewer.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_replay_header_replay_header_component__ = __webpack_require__("./src/app/replay-viewer/components/replay-header/replay-header.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_hero_icon_hero_icon_component__ = __webpack_require__("./src/app/replay-viewer/components/hero-icon/hero-icon.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__services_clip_icon_clip_icon_service__ = __webpack_require__("./src/app/replay-viewer/services/clip-icon/clip-icon.service.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__angular_platform_browser_animations__ = __webpack_require__("./node_modules/@angular/platform-browser/esm5/animations.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_replay_nav_replay_nav_component__ = __webpack_require__("./src/app/replay-viewer/components/replay-nav/replay-nav.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_replay_nav_nav_item_nav_item_component__ = __webpack_require__("./src/app/replay-viewer/components/replay-nav/nav-item/nav-item.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__replay_viewer_routing_module__ = __webpack_require__("./src/app/replay-viewer/replay-viewer-routing.module.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__sections_score_screen_score_screen_component__ = __webpack_require__("./src/app/replay-viewer/sections/score-screen/score-screen.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__angular_material__ = __webpack_require__("./node_modules/@angular/material/esm5/material.es5.js");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












var ReplayViewerModule = /** @class */ (function () {
    function ReplayViewerModule() {
    }
    ReplayViewerModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["K" /* NgModule */])({
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["b" /* CommonModule */],
                __WEBPACK_IMPORTED_MODULE_6__angular_platform_browser_animations__["a" /* BrowserAnimationsModule */],
                __WEBPACK_IMPORTED_MODULE_11__angular_material__["b" /* MatSidenavModule */],
                __WEBPACK_IMPORTED_MODULE_11__angular_material__["a" /* MatProgressBarModule */],
                __WEBPACK_IMPORTED_MODULE_11__angular_material__["f" /* MatTableModule */],
                __WEBPACK_IMPORTED_MODULE_11__angular_material__["d" /* MatSortModule */],
                __WEBPACK_IMPORTED_MODULE_9__replay_viewer_routing_module__["a" /* ReplayViewerRoutingModule */]
            ],
            exports: [
                __WEBPACK_IMPORTED_MODULE_2__replay_viewer_component__["a" /* ReplayViewerComponent */]
            ],
            declarations: [
                __WEBPACK_IMPORTED_MODULE_2__replay_viewer_component__["a" /* ReplayViewerComponent */],
                __WEBPACK_IMPORTED_MODULE_3__components_replay_header_replay_header_component__["a" /* ReplayHeaderComponent */],
                __WEBPACK_IMPORTED_MODULE_4__components_hero_icon_hero_icon_component__["a" /* HeroIconComponent */],
                __WEBPACK_IMPORTED_MODULE_7__components_replay_nav_replay_nav_component__["a" /* ReplayNavComponent */],
                __WEBPACK_IMPORTED_MODULE_8__components_replay_nav_nav_item_nav_item_component__["a" /* NavItemComponent */],
                __WEBPACK_IMPORTED_MODULE_10__sections_score_screen_score_screen_component__["a" /* ScoreScreenComponent */]
            ],
            providers: [__WEBPACK_IMPORTED_MODULE_5__services_clip_icon_clip_icon_service__["a" /* ClipIconService */]]
        })
    ], ReplayViewerModule);
    return ReplayViewerModule;
}());



/***/ }),

/***/ "./src/app/replay-viewer/sections/score-screen/score-screen.component.html":
/***/ (function(module, exports) {

module.exports = "<mat-table #table class=\"score-table\" [dataSource]=\"dataSource\" matSort>\n  <ng-container matColumnDef=\"hero\">\n    <mat-header-cell *matHeaderCellDef></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" style=\"overflow:visible;\">\n      <div class=\"player-cell\">\n        <hero-icon [hero]=\"player.hero\" shape=\"none\"></hero-icon>\n        <div class=\"icon-overlay\"></div>\n        <div class=\"name\">\n          <div class=\"hero-name\">{{player.hero}}</div>\n          <div class=\"player-name\">{{player.name}}</div>\n        </div>\n      </div>\n    </mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"award\">\n    <mat-header-cell *matHeaderCellDef></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\"></mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"kills\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('SoloKill', player)\" [class.best-team]=\"isBest('SoloKill', player, player.team)\">{{player.scores.SoloKill}}</mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"assists\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('Assists', player)\" [class.best-team]=\"isBest('Assists', player, player.team)\">{{player.scores.Assists}}</mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"deaths\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('Deaths', player)\" [class.best-team]=\"isBest('Deaths', player, player.team)\">\n      {{player.scores.Deaths}} </mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"siegeDamage\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('SiegeDamage', player)\" [class.best-team]=\"isBest('SiegeDamage', player, player.team)\">\n      {{player.scores.SiegeDamage | number}} </mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"heroDamage\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('HeroDamage', player)\" [class.best-team]=\"isBest('HeroDamage', player, player.team)\">\n      {{player.scores.HeroDamage | number}} </mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"healing\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('Healing', player)\" [class.best-team]=\"isBest('Healing', player, player.team)\">\n      {{(player.scores.Healing || '') | number}} </mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"damageTaken\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('DamageTaken', player)\" [class.best-team]=\"isBest('DamageTaken', player, player.team)\">\n      {{(player.scores.DamageTaken || '') | number}} </mat-cell>\n  </ng-container>\n  <ng-container matColumnDef=\"xp\">\n    <mat-header-cell *matHeaderCellDef mat-sort-header><div class=\"icon\"></div></mat-header-cell>\n    <mat-cell *matCellDef=\"let player\" [class.best]=\"isBest('ExperienceContribution', player)\" [class.best-team]=\"isBest('ExperienceContribution', player, player.team)\">\n      {{player.scores.ExperienceContribution | number}} </mat-cell>\n  </ng-container>\n  <mat-header-row *matHeaderRowDef=\"displayCols\"></mat-header-row>\n  <mat-row *matRowDef=\"let player; columns: displayCols\" [class.team1]=\"player.team === 0\" [class.team2]=\"player.team === 1\"></mat-row>\n</mat-table>\n"

/***/ }),

/***/ "./src/app/replay-viewer/sections/score-screen/score-screen.component.scss":
/***/ (function(module, exports) {

module.exports = ":host {\n  display: block;\n  padding: 40px; }\n  :host mat-table {\n    /*.mat-column-hero {\r\n      display: flex;\r\n      hero-icon {\r\n        left: -25px;\r\n        padding-left: 10px;\r\n        width: 74px;\r\n        height: 64px\r\n      }\r\n    }*/ }\n  :host mat-table .best-team {\n      font-weight: 500; }\n  :host mat-table .best {\n      font-weight: 700; }\n  :host mat-table .team1 {\n      /*.mat-column-hero {\r\n        hero-icon {\r\n          background-color: blue;\r\n        }\r\n      }*/ }\n  :host mat-table .team2 {\n      /* .mat-column-hero {\r\n        hero-icon {\r\n          background-color: red;\r\n        }\r\n      }*/ }\n  .score-table {\n  background-color: transparent; }\n  .score-table .mat-column-kills {\n    min-width: 75px;\n    max-width: 75px;\n    text-align: center; }\n  .score-table .mat-column-assists {\n    min-width: 75px;\n    max-width: 75px;\n    text-align: center; }\n  .score-table .mat-column-deaths {\n    min-width: 75px;\n    max-width: 75px;\n    text-align: center; }\n  .score-table .mat-column-siegeDamage {\n    min-width: 100px;\n    max-width: 100px;\n    text-align: center; }\n  .score-table .mat-column-heroDamage {\n    min-width: 100px;\n    max-width: 100px;\n    text-align: center; }\n  .score-table .mat-column-healing {\n    min-width: 100px;\n    max-width: 100px;\n    text-align: center; }\n  .score-table .mat-column-damageTaken {\n    min-width: 100px;\n    max-width: 100px;\n    text-align: center; }\n  .score-table .mat-column-xp {\n    min-width: 100px;\n    max-width: 100px;\n    text-align: center; }\n  .score-table .mat-header-row {\n    border: none; }\n  .score-table .mat-header-row .mat-header-cell {\n      text-align: center;\n      display: -webkit-box;\n      display: -ms-flexbox;\n      display: flex;\n      -webkit-box-orient: vertical;\n      -webkit-box-direction: normal;\n          -ms-flex-direction: column;\n              flex-direction: column;\n      -webkit-box-align: center;\n          -ms-flex-align: center;\n              align-items: center; }\n  .score-table .mat-header-row .mat-header-cell .icon {\n        width: 32px;\n        height: 32px; }\n  .score-table .mat-header-row .mat-header-cell.mat-column-kills .icon {\n        background-image: url('storm_ui_scorescreen_icon_kill.9a340ef8457e49eed2a9.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-kills:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_kill_hover.4cd50fb9db4e9d833aa4.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-assists .icon {\n        background-image: url('storm_ui_scorescreen_icon_assist.4faf1a5eac0164d0920d.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-assists:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_assist_hover.1e2723f8aca1ba7fe71e.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-deaths .icon {\n        background-image: url('storm_ui_scorescreen_icon_death.0b028ab5da381bff186c.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-deaths:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_death_hover.0d0e083f2bb6e9280ed2.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-siegeDamage .icon {\n        background-image: url('storm_ui_scorescreen_icon_siegedamage.7e1ce16c3e41af4eeb88.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-siegeDamage:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_siegedamage_hover.743ad3442faaa8a2e1a2.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-heroDamage .icon {\n        background-image: url('storm_ui_scorescreen_icon_herodamage.63e1eb2e50275c2e3452.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-heroDamage:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_herodamage_hover.34ec9ada3edad6fd2db6.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-healing .icon {\n        background-image: url('storm_ui_scorescreen_icon_healedandabsorbed.f2bc6e44231ddc84da42.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-healing:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_healedandabsorbed_hover.55a0cf2cabf95f7352e3.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-damageTaken .icon {\n        background-image: url('storm_ui_scorescreen_icon_damagetaken.5cc94932014f107ffb7e.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-damageTaken:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_damagetaken_hover.ffb107689860530ed193.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-xp .icon {\n        background-image: url('storm_ui_scorescreen_icon_xpcontribution.92b8b9082adae84fd691.png'); }\n  .score-table .mat-header-row .mat-header-cell.mat-column-xp:hover .icon {\n        background-image: url('storm_ui_scorescreen_icon_xpcontribution_hover.86ba96749bbc4a2b9e98.png'); }\n  .score-table .mat-row {\n    margin-bottom: 1px;\n    border-bottom-width: 2px; }\n  .score-table .mat-row::before {\n      content: \" \";\n      position: absolute;\n      top: 1px;\n      left: 1px;\n      bottom: 1px;\n      right: 1px;\n      border-top-width: 1px;\n      border-top-style: solid;\n      z-index: 2; }\n  .score-table .mat-row.team1 {\n      -o-border-image: linear-gradient(to right, rgba(27, 56, 116, 0) 2%, #1b3874 6%) 1;\n         border-image: -webkit-gradient(linear, left top, right top, color-stop(2%, rgba(27, 56, 116, 0)), color-stop(6%, #1b3874)) 1;\n         border-image: linear-gradient(to right, rgba(27, 56, 116, 0) 2%, #1b3874 6%) 1;\n      background: linear-gradient(to right, rgba(17, 16, 52, 0) 20px, #111034 20px) 100%; }\n  .score-table .mat-row.team1::before {\n        -o-border-image: linear-gradient(to right, rgba(27, 56, 116, 0) 2%, rgba(27, 56, 116, 0.3) 6%) 1;\n           border-image: -webkit-gradient(linear, left top, right top, color-stop(2%, rgba(27, 56, 116, 0)), color-stop(6%, rgba(27, 56, 116, 0.3))) 1;\n           border-image: linear-gradient(to right, rgba(27, 56, 116, 0) 2%, rgba(27, 56, 116, 0.3) 6%) 1; }\n  .score-table .mat-row.team2 {\n      -o-border-image: linear-gradient(to right, rgba(102, 7, 48, 0) 2%, #660730 6%) 1;\n         border-image: -webkit-gradient(linear, left top, right top, color-stop(2%, rgba(102, 7, 48, 0)), color-stop(6%, #660730)) 1;\n         border-image: linear-gradient(to right, rgba(102, 7, 48, 0) 2%, #660730 6%) 1;\n      background: linear-gradient(to right, rgba(39, 2, 31, 0) 20px, #27021f 20px) 100%; }\n  .score-table .mat-row.team2::before {\n        -o-border-image: linear-gradient(to right, rgba(102, 7, 48, 0) 2%, rgba(102, 7, 48, 0.3) 6%) 1;\n           border-image: -webkit-gradient(linear, left top, right top, color-stop(2%, rgba(102, 7, 48, 0)), color-stop(6%, rgba(102, 7, 48, 0.3))) 1;\n           border-image: linear-gradient(to right, rgba(102, 7, 48, 0) 2%, rgba(102, 7, 48, 0.3) 6%) 1; }\n  .score-table .mat-row .mat-cell {\n      font-size: 18px;\n      font-weight: 500;\n      text-shadow: 0px 0px 1px black, 0px 0px 1px black, 1px 3px 2px black, 1px 3px 2px black; }\n  .score-table .mat-row .mat-cell .player-cell {\n        display: -webkit-box;\n        display: -ms-flexbox;\n        display: flex;\n        background-repeat: no-repeat;\n        background-position-y: -6px;\n        height: 54px;\n        left: -28px;\n        min-width: 260px;\n        overflow-y: hidden; }\n  .score-table .mat-row .mat-cell .player-cell hero-icon {\n          top: -24px;\n          left: 16px;\n          width: 96px;\n          height: 96px; }\n  .score-table .mat-row .mat-cell .player-cell .icon-overlay {\n          position: absolute;\n          top: 0px;\n          left: 16px;\n          width: 96px;\n          height: 54px;\n          z-index: 5; }\n  .score-table .mat-row .mat-cell .player-cell .name {\n          margin-left: 28px;\n          padding-right: 14px; }\n  .score-table .mat-row .mat-cell .player-cell .name > * {\n            white-space: nowrap; }\n  .score-table .mat-row .mat-cell .player-cell .name .hero-name {\n            font-weight: 700;\n            padding-top: 8px;\n            padding-bottom: 2px; }\n  .score-table .mat-row .mat-cell .player-cell .name .player-name {\n            font-size: 14px; }\n  .score-table .mat-row.team1 .mat-cell {\n      color: #ccccff; }\n  .score-table .mat-row.team1 .mat-cell .player-cell {\n        background-image: url('player_row_blue.8c98df4c64229fe0e580.png'); }\n  .score-table .mat-row.team1 .mat-cell .player-cell .icon-overlay {\n          background: -webkit-gradient(linear, left top, right top, color-stop(16%, rgba(17, 16, 52, 0)), to(#111034)) 100%;\n          background: linear-gradient(to right, rgba(17, 16, 52, 0) 16%, #111034 100%) 100%; }\n  .score-table .mat-row.team1 .mat-cell .player-cell .name .hero-name {\n          color: #e6e6ff;\n          text-shadow: 0px 0px 1px black, 0px 0px 1px black, 0px 0px 1px black, 0px 0px 4px blue, 0px 0px 4px blue, 0px 0px 4px blue, 0px 0px 4px blue; }\n  .score-table .mat-row.team1 .mat-cell.best-team {\n        color: #e6e6ff;\n        font-weight: 700; }\n  .score-table .mat-row.team1 .mat-cell.best {\n        font-weight: 700;\n        color: #e6e6ff;\n        text-shadow: 0px 0px 1px black, 0px 0px 1px black, 0px 0px 1px black, 0px 0px 4px blue, 0px 0px 4px blue, 0px 0px 4px blue, 0px 0px 4px blue; }\n  .score-table .mat-row.team2 .mat-cell {\n      color: #ffcccc; }\n  .score-table .mat-row.team2 .mat-cell .player-cell {\n        background-image: url('player_row_red.5caa877b50425325d8e4.png'); }\n  .score-table .mat-row.team2 .mat-cell .player-cell .icon-overlay {\n          background: -webkit-gradient(linear, left top, right top, color-stop(16%, rgba(39, 2, 31, 0)), to(#27021f)) 100%;\n          background: linear-gradient(to right, rgba(39, 2, 31, 0) 16%, #27021f 100%) 100%; }\n  .score-table .mat-row.team2 .mat-cell .player-cell .name .hero-name {\n          color: #ffe6e6;\n          text-shadow: 0px 0px 1px black, 0px 0px 1px black, 0px 0px 1px black, 0px 0px 4px red, 0px 0px 4px red, 0px 0px 4px red, 0px 0px 4px red; }\n  .score-table .mat-row.team2 .mat-cell.best-team {\n        color: #ffe6e6;\n        font-weight: 700; }\n  .score-table .mat-row.team2 .mat-cell.best {\n        font-weight: 700;\n        color: #ffe6e6;\n        text-shadow: 0px 0px 1px black, 0px 0px 1px black, 0px 0px 1px black, 0px 0px 4px red, 0px 0px 4px red, 0px 0px 4px red, 0px 0px 4px red; }\n"

/***/ }),

/***/ "./src/app/replay-viewer/sections/score-screen/score-screen.component.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScoreScreenComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__replay_viewer_component__ = __webpack_require__("./src/app/replay-viewer/replay-viewer.component.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol__ = __webpack_require__("../heroprotocol/dist/lib/index.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_material__ = __webpack_require__("./node_modules/@angular/material/esm5/material.es5.js");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var ScoreScreenComponent = /** @class */ (function () {
    function ScoreScreenComponent(replayViewer, changeDetectorRef) {
        var _this = this;
        this.replayViewer = replayViewer;
        this.changeDetectorRef = changeDetectorRef;
        this.dataSource = new __WEBPACK_IMPORTED_MODULE_3__angular_material__["e" /* MatTableDataSource */]();
        this.displayCols = [
            'hero',
            'award',
            'kills',
            'assists',
            'deaths',
            'siegeDamage',
            'heroDamage',
            'healing',
            'damageTaken',
            'xp'
        ];
        replayViewer.onReplayLoaded.subscribe(function (replay) {
            _this.replayLoaded();
        });
        this.dataSource.sortingDataAccessor = this.getSortData.bind(this);
    }
    ScoreScreenComponent.prototype.ngOnInit = function () {
    };
    ScoreScreenComponent.prototype.ngAfterViewInit = function () {
        this.replayLoaded();
        this.dataSource.sort = this.sort;
        this.sort.start = 'desc';
    };
    ScoreScreenComponent.prototype.getSortData = function (data, sortHeaderId) {
        switch (sortHeaderId) {
            case 'kills':
                return data.scores.SoloKill;
            case 'assists':
                return data.scores.Assists;
            case 'deaths':
                return data.scores.Deaths;
            case 'siegeDamage':
                return data.scores.SiegeDamage;
            case 'heroDamage':
                return data.scores.HeroDamage;
            case 'healing':
                return data.scores.Healing;
            case 'damageTaken':
                return data.scores.DamageTaken;
            case 'xp':
                return data.scores.ExperienceContribution;
            default:
                return 0;
        }
    };
    ScoreScreenComponent.prototype.replayLoaded = function () {
        return __awaiter(this, void 0, void 0, function () {
            var hs, scoreData, i, player, pScore, stat, value;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hs = {
                            'Takedowns': 0,
                            'Deaths': Number.MAX_SAFE_INTEGER,
                            'SoloKill': 0,
                            'Assists': 0,
                            'ExperienceContribution': 0,
                            'Healing': 0,
                            'SiegeDamage': 0,
                            'HeroDamage': 0,
                            'DamageTaken': 0
                        };
                        this.highScores = {
                            game: Object.assign({}, hs),
                            0: Object.assign({}, hs),
                            1: Object.assign({}, hs)
                        };
                        this.replay = this.replayViewer.replay;
                        this.replayDescription = this.replayViewer.replayDescription;
                        this.scoreScreenAnalyser = new __WEBPACK_IMPORTED_MODULE_2__heroesbrowser_heroprotocol__["ScoreAnalyser"](this.replay);
                        return [4 /*yield*/, this.scoreScreenAnalyser.scoreScreenData];
                    case 1:
                        scoreData = _a.sent();
                        this.scoreData = [];
                        for (i = 0; i < scoreData.length; i++) {
                            player = this.replayDescription.players[i];
                            pScore = scoreData[i];
                            for (stat in pScore) {
                                if (pScore.hasOwnProperty(stat)) {
                                    value = pScore[stat];
                                    if (stat === 'Deaths') {
                                        if (this.highScores.game[stat] > value) {
                                            this.highScores.game[stat] = value;
                                        }
                                        if (this.highScores[player.team][stat] > value) {
                                            this.highScores[player.team][stat] = value;
                                        }
                                    }
                                    else {
                                        if (this.highScores.game[stat] < value) {
                                            this.highScores.game[stat] = value;
                                        }
                                        if (this.highScores[player.team][stat] < value) {
                                            this.highScores[player.team][stat] = value;
                                        }
                                    }
                                }
                            }
                            this.scoreData.push({
                                hero: player.hero,
                                name: player.name,
                                team: player.team,
                                won: player.won,
                                scores: pScore
                            });
                        }
                        this.dataSource.data = this.scoreData;
                        this.changeDetectorRef.markForCheck();
                        return [2 /*return*/];
                }
            });
        });
    };
    ScoreScreenComponent.prototype.isBest = function (statName, player, scope) {
        if (scope === void 0) { scope = 'game'; }
        return this.highScores[scope][statName] === player.scores[statName];
    };
    __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_11" /* ViewChild */])(__WEBPACK_IMPORTED_MODULE_3__angular_material__["c" /* MatSort */]),
        __metadata("design:type", __WEBPACK_IMPORTED_MODULE_3__angular_material__["c" /* MatSort */])
    ], ScoreScreenComponent.prototype, "sort", void 0);
    ScoreScreenComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["n" /* Component */])({
            selector: 'score-screen',
            template: __webpack_require__("./src/app/replay-viewer/sections/score-screen/score-screen.component.html"),
            styles: [__webpack_require__("./src/app/replay-viewer/sections/score-screen/score-screen.component.scss")],
            changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__["j" /* ChangeDetectionStrategy */].OnPush
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__replay_viewer_component__["a" /* ReplayViewerComponent */],
            __WEBPACK_IMPORTED_MODULE_0__angular_core__["k" /* ChangeDetectorRef */]])
    ], ScoreScreenComponent);
    return ScoreScreenComponent;
}());



/***/ }),

/***/ "./src/app/replay-viewer/services/clip-icon/clip-icon.service.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ClipMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClipIconService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var ClipMethod;
(function (ClipMethod) {
    ClipMethod[ClipMethod["NONE"] = 0] = "NONE";
    ClipMethod[ClipMethod["CIRCLE"] = 1] = "CIRCLE";
    ClipMethod[ClipMethod["HEXEGON"] = 2] = "HEXEGON";
})(ClipMethod || (ClipMethod = {}));
var clipMethods = (_a = {},
    _a[ClipMethod.CIRCLE] = function (ctx, w, h) {
        ctx.arc(w / 2, w / 2, w / 2, 0, 2 * Math.PI);
    },
    _a[ClipMethod.HEXEGON] = function (ctx, w, h) {
        ctx.moveTo(w * 0.52, h * 0.04);
        ctx.lineTo(w, h * 0.28);
        ctx.lineTo(w, h * 0.78);
        ctx.lineTo(w * 0.52, h * 1.01);
        ctx.lineTo(w * 0.05, h * 0.78);
        ctx.lineTo(w * 0.05, h * 0.28);
    },
    _a);
var ClipIconService = /** @class */ (function () {
    function ClipIconService() {
    }
    ClipIconService.prototype.clip = function (imgData, w, h, shape) {
        return __awaiter(this, void 0, void 0, function () {
            var img, canvas, ctx, clipFn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, createImageBitmap(imgData)];
                    case 1:
                        img = _a.sent();
                        console.log(img);
                        canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, w, h);
                        ctx.save();
                        ctx.beginPath();
                        if (typeof shape !== 'function') {
                            clipFn = clipMethods[shape];
                        }
                        else {
                            clipFn = shape;
                        }
                        clipFn(ctx, w, h);
                        ctx.clip();
                        ctx.drawImage(img, 0, 0, w, h);
                        ctx.restore();
                        console.log('!!!!!!', canvas);
                        return [2 /*return*/, canvas];
                }
            });
        });
    };
    ClipIconService.prototype.loadAndClip = function (imgUrl, width, height, shape) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var img = new Image(width, height);
            // img.setAttribute('crossOrigin', '*');
            img.onload = function (event) {
                if (!shape) {
                    resolve(img);
                    return;
                }
                _this.clip(img, width, height, shape).then(function (clipped) {
                    console.log('clipCallback', clipped);
                    resolve(clipped);
                }).catch(function (err) {
                    reject(err);
                });
            };
            img.onerror = function (event) {
                reject(event);
            };
            img.src = imgUrl;
        });
    };
    ClipIconService = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["C" /* Injectable */])()
    ], ClipIconService);
    return ClipIconService;
}());

var _a;


/***/ }),

/***/ "./src/environments/environment.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return environment; });
// The file contents for the current environment will overwrite these during build.
// The build system defaults to the dev environment which uses `environment.ts`, but if you do
// `ng build --env=prod` then `environment.prod.ts` will be used instead.
// The list of which env maps to which file can be found in `.angular-cli.json`.
var environment = {
    production: false
};


/***/ }),

/***/ "./src/main.ts":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__("./node_modules/@angular/core/esm5/core.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser_dynamic__ = __webpack_require__("./node_modules/@angular/platform-browser-dynamic/esm5/platform-browser-dynamic.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_app_module__ = __webpack_require__("./src/app/app.module.ts");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__environments_environment__ = __webpack_require__("./src/environments/environment.ts");




if (__WEBPACK_IMPORTED_MODULE_3__environments_environment__["a" /* environment */].production) {
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["_17" /* enableProdMode */])();
}
Object(__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser_dynamic__["a" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_2__app_app_module__["a" /* AppModule */])
    .catch(function (err) { return console.log(err); });


/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./src/main.ts");


/***/ })

},[0]);
//# sourceMappingURL=main.bundle.js.map